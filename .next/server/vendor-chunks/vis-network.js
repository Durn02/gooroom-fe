"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/vis-network";
exports.ids = ["vendor-chunks/vis-network"];
exports.modules = {

/***/ "(ssr)/./node_modules/vis-network/peer/esm/vis-network.js":
/*!**********************************************************!*\
  !*** ./node_modules/vis-network/peer/esm/vis-network.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Network: () => (/* binding */ Network),\n/* harmony export */   NetworkImages: () => (/* binding */ Images),\n/* harmony export */   networkDOTParser: () => (/* binding */ dotparser),\n/* harmony export */   networkGephiParser: () => (/* binding */ gephiParser),\n/* harmony export */   networkOptions: () => (/* binding */ options),\n/* harmony export */   parseDOTNetwork: () => (/* binding */ parseDOTNetwork),\n/* harmony export */   parseGephiNetwork: () => (/* binding */ parseGephi)\n/* harmony export */ });\n/* harmony import */ var vis_data_peer_esm_vis_data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vis-data/peer/esm/vis-data.js */ \"(ssr)/./node_modules/vis-data/peer/esm/vis-data.js\");\n/**\n * vis-network\n * https://visjs.github.io/vis-network/\n *\n * A dynamic, browser-based visualization library.\n *\n * @version 9.1.9\n * @date    2023-11-03T01:42:27.418Z\n *\n * @copyright (c) 2011-2017 Almende B.V, http://almende.com\n * @copyright (c) 2017-2019 visjs contributors, https://github.com/visjs\n *\n * @license\n * vis.js is dual licensed under both\n *\n *   1. The Apache 2.0 License\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *   and\n *\n *   2. The MIT License\n *      http://opensource.org/licenses/MIT\n *\n * vis.js may be distributed under either license.\n */\n\n\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar check = function (it) {\n  return it && it.Math === Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global$n =\n  // eslint-disable-next-line es/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || commonjsGlobal || Function('return this')();\n\nvar fails$w = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\nvar fails$v = fails$w;\n\nvar functionBindNative = !fails$v(function () {\n  // eslint-disable-next-line es/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n\nvar NATIVE_BIND$4 = functionBindNative;\n\nvar FunctionPrototype$4 = Function.prototype;\nvar apply$5 = FunctionPrototype$4.apply;\nvar call$f = FunctionPrototype$4.call;\n\n// eslint-disable-next-line es/no-reflect -- safe\nvar functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND$4 ? call$f.bind(apply$5) : function () {\n  return call$f.apply(apply$5, arguments);\n});\n\nvar NATIVE_BIND$3 = functionBindNative;\n\nvar FunctionPrototype$3 = Function.prototype;\nvar call$e = FunctionPrototype$3.call;\nvar uncurryThisWithBind = NATIVE_BIND$3 && FunctionPrototype$3.bind.bind(call$e, call$e);\n\nvar functionUncurryThis = NATIVE_BIND$3 ? uncurryThisWithBind : function (fn) {\n  return function () {\n    return call$e.apply(fn, arguments);\n  };\n};\n\nvar uncurryThis$x = functionUncurryThis;\n\nvar toString$c = uncurryThis$x({}.toString);\nvar stringSlice$1 = uncurryThis$x(''.slice);\n\nvar classofRaw$2 = function (it) {\n  return stringSlice$1(toString$c(it), 8, -1);\n};\n\nvar classofRaw$1 = classofRaw$2;\nvar uncurryThis$w = functionUncurryThis;\n\nvar functionUncurryThisClause = function (fn) {\n  // Nashorn bug:\n  //   https://github.com/zloirock/core-js/issues/1128\n  //   https://github.com/zloirock/core-js/issues/1130\n  if (classofRaw$1(fn) === 'Function') return uncurryThis$w(fn);\n};\n\nvar documentAll$2 = typeof document == 'object' && document.all;\n\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing\nvar IS_HTMLDDA = typeof documentAll$2 == 'undefined' && documentAll$2 !== undefined;\n\nvar documentAll_1 = {\n  all: documentAll$2,\n  IS_HTMLDDA: IS_HTMLDDA\n};\n\nvar $documentAll$1 = documentAll_1;\n\nvar documentAll$1 = $documentAll$1.all;\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nvar isCallable$i = $documentAll$1.IS_HTMLDDA ? function (argument) {\n  return typeof argument == 'function' || argument === documentAll$1;\n} : function (argument) {\n  return typeof argument == 'function';\n};\n\nvar objectGetOwnPropertyDescriptor = {};\n\nvar fails$u = fails$w;\n\n// Detect IE8's incomplete defineProperty implementation\nvar descriptors = !fails$u(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;\n});\n\nvar NATIVE_BIND$2 = functionBindNative;\n\nvar call$d = Function.prototype.call;\n\nvar functionCall = NATIVE_BIND$2 ? call$d.bind(call$d) : function () {\n  return call$d.apply(call$d, arguments);\n};\n\nvar objectPropertyIsEnumerable = {};\n\nvar $propertyIsEnumerable$1 = {}.propertyIsEnumerable;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor$9 = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor$9 && !$propertyIsEnumerable$1.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nobjectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor$9(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable$1;\n\nvar createPropertyDescriptor$5 = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\nvar uncurryThis$v = functionUncurryThis;\nvar fails$t = fails$w;\nvar classof$e = classofRaw$2;\n\nvar $Object$5 = Object;\nvar split = uncurryThis$v(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar indexedObject = fails$t(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object$5('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof$e(it) === 'String' ? split(it, '') : $Object$5(it);\n} : $Object$5;\n\n// we can't use just `it == null` since of `document.all` special case\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec\nvar isNullOrUndefined$6 = function (it) {\n  return it === null || it === undefined;\n};\n\nvar isNullOrUndefined$5 = isNullOrUndefined$6;\n\nvar $TypeError$g = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nvar requireObjectCoercible$5 = function (it) {\n  if (isNullOrUndefined$5(it)) throw new $TypeError$g(\"Can't call method on \" + it);\n  return it;\n};\n\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject$3 = indexedObject;\nvar requireObjectCoercible$4 = requireObjectCoercible$5;\n\nvar toIndexedObject$a = function (it) {\n  return IndexedObject$3(requireObjectCoercible$4(it));\n};\n\nvar isCallable$h = isCallable$i;\nvar $documentAll = documentAll_1;\n\nvar documentAll = $documentAll.all;\n\nvar isObject$j = $documentAll.IS_HTMLDDA ? function (it) {\n  return typeof it == 'object' ? it !== null : isCallable$h(it) || it === documentAll;\n} : function (it) {\n  return typeof it == 'object' ? it !== null : isCallable$h(it);\n};\n\nvar path$w = {};\n\nvar path$v = path$w;\nvar global$m = global$n;\nvar isCallable$g = isCallable$i;\n\nvar aFunction = function (variable) {\n  return isCallable$g(variable) ? variable : undefined;\n};\n\nvar getBuiltIn$c = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(path$v[namespace]) || aFunction(global$m[namespace])\n    : path$v[namespace] && path$v[namespace][method] || global$m[namespace] && global$m[namespace][method];\n};\n\nvar uncurryThis$u = functionUncurryThis;\n\nvar objectIsPrototypeOf = uncurryThis$u({}.isPrototypeOf);\n\nvar engineUserAgent = typeof navigator != 'undefined' && String(navigator.userAgent) || '';\n\nvar global$l = global$n;\nvar userAgent$2 = engineUserAgent;\n\nvar process = global$l.process;\nvar Deno = global$l.Deno;\nvar versions = process && process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent$2) {\n  match = userAgent$2.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent$2.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nvar engineV8Version = version;\n\n/* eslint-disable es/no-symbol -- required for testing */\nvar V8_VERSION$2 = engineV8Version;\nvar fails$s = fails$w;\nvar global$k = global$n;\n\nvar $String$5 = global$k.String;\n\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing\nvar symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$s(function () {\n  var symbol = Symbol('symbol detection');\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,\n  // of course, fail.\n  return !$String$5(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION$2 && V8_VERSION$2 < 41;\n});\n\n/* eslint-disable es/no-symbol -- required for testing */\nvar NATIVE_SYMBOL$5 = symbolConstructorDetection;\n\nvar useSymbolAsUid = NATIVE_SYMBOL$5\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n\nvar getBuiltIn$b = getBuiltIn$c;\nvar isCallable$f = isCallable$i;\nvar isPrototypeOf$k = objectIsPrototypeOf;\nvar USE_SYMBOL_AS_UID$1 = useSymbolAsUid;\n\nvar $Object$4 = Object;\n\nvar isSymbol$5 = USE_SYMBOL_AS_UID$1 ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn$b('Symbol');\n  return isCallable$f($Symbol) && isPrototypeOf$k($Symbol.prototype, $Object$4(it));\n};\n\nvar $String$4 = String;\n\nvar tryToString$6 = function (argument) {\n  try {\n    return $String$4(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n\nvar isCallable$e = isCallable$i;\nvar tryToString$5 = tryToString$6;\n\nvar $TypeError$f = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nvar aCallable$7 = function (argument) {\n  if (isCallable$e(argument)) return argument;\n  throw new $TypeError$f(tryToString$5(argument) + ' is not a function');\n};\n\nvar aCallable$6 = aCallable$7;\nvar isNullOrUndefined$4 = isNullOrUndefined$6;\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nvar getMethod$3 = function (V, P) {\n  var func = V[P];\n  return isNullOrUndefined$4(func) ? undefined : aCallable$6(func);\n};\n\nvar call$c = functionCall;\nvar isCallable$d = isCallable$i;\nvar isObject$i = isObject$j;\n\nvar $TypeError$e = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nvar ordinaryToPrimitive$1 = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable$d(fn = input.toString) && !isObject$i(val = call$c(fn, input))) return val;\n  if (isCallable$d(fn = input.valueOf) && !isObject$i(val = call$c(fn, input))) return val;\n  if (pref !== 'string' && isCallable$d(fn = input.toString) && !isObject$i(val = call$c(fn, input))) return val;\n  throw new $TypeError$e(\"Can't convert object to primitive value\");\n};\n\nvar shared$7 = {exports: {}};\n\nvar global$j = global$n;\n\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar defineProperty$f = Object.defineProperty;\n\nvar defineGlobalProperty$1 = function (key, value) {\n  try {\n    defineProperty$f(global$j, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global$j[key] = value;\n  } return value;\n};\n\nvar global$i = global$n;\nvar defineGlobalProperty = defineGlobalProperty$1;\n\nvar SHARED = '__core-js_shared__';\nvar store$3 = global$i[SHARED] || defineGlobalProperty(SHARED, {});\n\nvar sharedStore = store$3;\n\nvar store$2 = sharedStore;\n\n(shared$7.exports = function (key, value) {\n  return store$2[key] || (store$2[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.33.0',\n  mode: 'pure' ,\n  copyright: 'Â© 2014-2023 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.33.0/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n\nvar sharedExports = shared$7.exports;\n\nvar requireObjectCoercible$3 = requireObjectCoercible$5;\n\nvar $Object$3 = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nvar toObject$e = function (argument) {\n  return $Object$3(requireObjectCoercible$3(argument));\n};\n\nvar uncurryThis$t = functionUncurryThis;\nvar toObject$d = toObject$e;\n\nvar hasOwnProperty = uncurryThis$t({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es/no-object-hasown -- safe\nvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject$d(it), key);\n};\n\nvar uncurryThis$s = functionUncurryThis;\n\nvar id$2 = 0;\nvar postfix = Math.random();\nvar toString$b = uncurryThis$s(1.0.toString);\n\nvar uid$4 = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$b(++id$2 + postfix, 36);\n};\n\nvar global$h = global$n;\nvar shared$6 = sharedExports;\nvar hasOwn$h = hasOwnProperty_1;\nvar uid$3 = uid$4;\nvar NATIVE_SYMBOL$4 = symbolConstructorDetection;\nvar USE_SYMBOL_AS_UID = useSymbolAsUid;\n\nvar Symbol$5 = global$h.Symbol;\nvar WellKnownSymbolsStore$2 = shared$6('wks');\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$5['for'] || Symbol$5 : Symbol$5 && Symbol$5.withoutSetter || uid$3;\n\nvar wellKnownSymbol$m = function (name) {\n  if (!hasOwn$h(WellKnownSymbolsStore$2, name)) {\n    WellKnownSymbolsStore$2[name] = NATIVE_SYMBOL$4 && hasOwn$h(Symbol$5, name)\n      ? Symbol$5[name]\n      : createWellKnownSymbol('Symbol.' + name);\n  } return WellKnownSymbolsStore$2[name];\n};\n\nvar call$b = functionCall;\nvar isObject$h = isObject$j;\nvar isSymbol$4 = isSymbol$5;\nvar getMethod$2 = getMethod$3;\nvar ordinaryToPrimitive = ordinaryToPrimitive$1;\nvar wellKnownSymbol$l = wellKnownSymbol$m;\n\nvar $TypeError$d = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol$l('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nvar toPrimitive$6 = function (input, pref) {\n  if (!isObject$h(input) || isSymbol$4(input)) return input;\n  var exoticToPrim = getMethod$2(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call$b(exoticToPrim, input, pref);\n    if (!isObject$h(result) || isSymbol$4(result)) return result;\n    throw new $TypeError$d(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n\nvar toPrimitive$5 = toPrimitive$6;\nvar isSymbol$3 = isSymbol$5;\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nvar toPropertyKey$4 = function (argument) {\n  var key = toPrimitive$5(argument, 'string');\n  return isSymbol$3(key) ? key : key + '';\n};\n\nvar global$g = global$n;\nvar isObject$g = isObject$j;\n\nvar document$1 = global$g.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS$1 = isObject$g(document$1) && isObject$g(document$1.createElement);\n\nvar documentCreateElement$1 = function (it) {\n  return EXISTS$1 ? document$1.createElement(it) : {};\n};\n\nvar DESCRIPTORS$h = descriptors;\nvar fails$r = fails$w;\nvar createElement = documentCreateElement$1;\n\n// Thanks to IE8 for its funny defineProperty\nvar ie8DomDefine = !DESCRIPTORS$h && !fails$r(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () { return 7; }\n  }).a !== 7;\n});\n\nvar DESCRIPTORS$g = descriptors;\nvar call$a = functionCall;\nvar propertyIsEnumerableModule$2 = objectPropertyIsEnumerable;\nvar createPropertyDescriptor$4 = createPropertyDescriptor$5;\nvar toIndexedObject$9 = toIndexedObject$a;\nvar toPropertyKey$3 = toPropertyKey$4;\nvar hasOwn$g = hasOwnProperty_1;\nvar IE8_DOM_DEFINE$1 = ie8DomDefine;\n\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nobjectGetOwnPropertyDescriptor.f = DESCRIPTORS$g ? $getOwnPropertyDescriptor$2 : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject$9(O);\n  P = toPropertyKey$3(P);\n  if (IE8_DOM_DEFINE$1) try {\n    return $getOwnPropertyDescriptor$2(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn$g(O, P)) return createPropertyDescriptor$4(!call$a(propertyIsEnumerableModule$2.f, O, P), O[P]);\n};\n\nvar fails$q = fails$w;\nvar isCallable$c = isCallable$i;\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced$1 = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value === POLYFILL ? true\n    : value === NATIVE ? false\n    : isCallable$c(detection) ? fails$q(detection)\n    : !!detection;\n};\n\nvar normalize = isForced$1.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced$1.data = {};\nvar NATIVE = isForced$1.NATIVE = 'N';\nvar POLYFILL = isForced$1.POLYFILL = 'P';\n\nvar isForced_1 = isForced$1;\n\nvar uncurryThis$r = functionUncurryThisClause;\nvar aCallable$5 = aCallable$7;\nvar NATIVE_BIND$1 = functionBindNative;\n\nvar bind$e = uncurryThis$r(uncurryThis$r.bind);\n\n// optional / simple context binding\nvar functionBindContext = function (fn, that) {\n  aCallable$5(fn);\n  return that === undefined ? fn : NATIVE_BIND$1 ? bind$e(fn, that) : function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\nvar objectDefineProperty = {};\n\nvar DESCRIPTORS$f = descriptors;\nvar fails$p = fails$w;\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nvar v8PrototypeDefineBug = DESCRIPTORS$f && fails$p(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype !== 42;\n});\n\nvar isObject$f = isObject$j;\n\nvar $String$3 = String;\nvar $TypeError$c = TypeError;\n\n// `Assert: Type(argument) is Object`\nvar anObject$d = function (argument) {\n  if (isObject$f(argument)) return argument;\n  throw new $TypeError$c($String$3(argument) + ' is not an object');\n};\n\nvar DESCRIPTORS$e = descriptors;\nvar IE8_DOM_DEFINE = ie8DomDefine;\nvar V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;\nvar anObject$c = anObject$d;\nvar toPropertyKey$2 = toPropertyKey$4;\n\nvar $TypeError$b = TypeError;\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar $defineProperty$1 = Object.defineProperty;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE$1 = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nobjectDefineProperty.f = DESCRIPTORS$e ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {\n  anObject$c(O);\n  P = toPropertyKey$2(P);\n  anObject$c(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor$1(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty$1(O, P, Attributes);\n} : $defineProperty$1 : function defineProperty(O, P, Attributes) {\n  anObject$c(O);\n  P = toPropertyKey$2(P);\n  anObject$c(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty$1(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError$b('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\nvar DESCRIPTORS$d = descriptors;\nvar definePropertyModule$3 = objectDefineProperty;\nvar createPropertyDescriptor$3 = createPropertyDescriptor$5;\n\nvar createNonEnumerableProperty$6 = DESCRIPTORS$d ? function (object, key, value) {\n  return definePropertyModule$3.f(object, key, createPropertyDescriptor$3(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\nvar global$f = global$n;\nvar apply$4 = functionApply;\nvar uncurryThis$q = functionUncurryThisClause;\nvar isCallable$b = isCallable$i;\nvar getOwnPropertyDescriptor$8 = objectGetOwnPropertyDescriptor.f;\nvar isForced = isForced_1;\nvar path$u = path$w;\nvar bind$d = functionBindContext;\nvar createNonEnumerableProperty$5 = createNonEnumerableProperty$6;\nvar hasOwn$f = hasOwnProperty_1;\n\nvar wrapConstructor = function (NativeConstructor) {\n  var Wrapper = function (a, b, c) {\n    if (this instanceof Wrapper) {\n      switch (arguments.length) {\n        case 0: return new NativeConstructor();\n        case 1: return new NativeConstructor(a);\n        case 2: return new NativeConstructor(a, b);\n      } return new NativeConstructor(a, b, c);\n    } return apply$4(NativeConstructor, this, arguments);\n  };\n  Wrapper.prototype = NativeConstructor.prototype;\n  return Wrapper;\n};\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nvar _export = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var PROTO = options.proto;\n\n  var nativeSource = GLOBAL ? global$f : STATIC ? global$f[TARGET] : (global$f[TARGET] || {}).prototype;\n\n  var target = GLOBAL ? path$u : path$u[TARGET] || createNonEnumerableProperty$5(path$u, TARGET, {})[TARGET];\n  var targetPrototype = target.prototype;\n\n  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;\n  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;\n\n  for (key in source) {\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contains in native\n    USE_NATIVE = !FORCED && nativeSource && hasOwn$f(nativeSource, key);\n\n    targetProperty = target[key];\n\n    if (USE_NATIVE) if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor$8(nativeSource, key);\n      nativeProperty = descriptor && descriptor.value;\n    } else nativeProperty = nativeSource[key];\n\n    // export native or implementation\n    sourceProperty = (USE_NATIVE && nativeProperty) ? nativeProperty : source[key];\n\n    if (USE_NATIVE && typeof targetProperty == typeof sourceProperty) continue;\n\n    // bind methods to global for calling from export context\n    if (options.bind && USE_NATIVE) resultProperty = bind$d(sourceProperty, global$f);\n    // wrap global constructors for prevent changes in this version\n    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);\n    // make static versions for prototype methods\n    else if (PROTO && isCallable$b(sourceProperty)) resultProperty = uncurryThis$q(sourceProperty);\n    // default case\n    else resultProperty = sourceProperty;\n\n    // add a flag to not completely full polyfills\n    if (options.sham || (sourceProperty && sourceProperty.sham) || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty$5(resultProperty, 'sham', true);\n    }\n\n    createNonEnumerableProperty$5(target, key, resultProperty);\n\n    if (PROTO) {\n      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';\n      if (!hasOwn$f(path$u, VIRTUAL_PROTOTYPE)) {\n        createNonEnumerableProperty$5(path$u, VIRTUAL_PROTOTYPE, {});\n      }\n      // export virtual prototype methods\n      createNonEnumerableProperty$5(path$u[VIRTUAL_PROTOTYPE], key, sourceProperty);\n      // export real prototype methods\n      if (options.real && targetPrototype && (FORCED || !targetPrototype[key])) {\n        createNonEnumerableProperty$5(targetPrototype, key, sourceProperty);\n      }\n    }\n  }\n};\n\nvar ceil = Math.ceil;\nvar floor$1 = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es/no-math-trunc -- safe\nvar mathTrunc = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor$1 : ceil)(n);\n};\n\nvar trunc = mathTrunc;\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nvar toIntegerOrInfinity$4 = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n\nvar toIntegerOrInfinity$3 = toIntegerOrInfinity$4;\n\nvar max$3 = Math.max;\nvar min$2 = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nvar toAbsoluteIndex$5 = function (index, length) {\n  var integer = toIntegerOrInfinity$3(index);\n  return integer < 0 ? max$3(integer + length, 0) : min$2(integer, length);\n};\n\nvar toIntegerOrInfinity$2 = toIntegerOrInfinity$4;\n\nvar min$1 = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nvar toLength$1 = function (argument) {\n  return argument > 0 ? min$1(toIntegerOrInfinity$2(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\nvar toLength = toLength$1;\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nvar lengthOfArrayLike$c = function (obj) {\n  return toLength(obj.length);\n};\n\nvar toIndexedObject$8 = toIndexedObject$a;\nvar toAbsoluteIndex$4 = toAbsoluteIndex$5;\nvar lengthOfArrayLike$b = lengthOfArrayLike$c;\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod$4 = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject$8($this);\n    var length = lengthOfArrayLike$b(O);\n    var index = toAbsoluteIndex$4(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el !== el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value !== value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nvar arrayIncludes = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod$4(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod$4(false)\n};\n\nvar hiddenKeys$6 = {};\n\nvar uncurryThis$p = functionUncurryThis;\nvar hasOwn$e = hasOwnProperty_1;\nvar toIndexedObject$7 = toIndexedObject$a;\nvar indexOf$4 = arrayIncludes.indexOf;\nvar hiddenKeys$5 = hiddenKeys$6;\n\nvar push$b = uncurryThis$p([].push);\n\nvar objectKeysInternal = function (object, names) {\n  var O = toIndexedObject$7(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn$e(hiddenKeys$5, key) && hasOwn$e(O, key) && push$b(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn$e(O, key = names[i++])) {\n    ~indexOf$4(result, key) || push$b(result, key);\n  }\n  return result;\n};\n\n// IE8- don't enum bug keys\nvar enumBugKeys$3 = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\nvar internalObjectKeys$1 = objectKeysInternal;\nvar enumBugKeys$2 = enumBugKeys$3;\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es/no-object-keys -- safe\nvar objectKeys$3 = Object.keys || function keys(O) {\n  return internalObjectKeys$1(O, enumBugKeys$2);\n};\n\nvar objectGetOwnPropertySymbols = {};\n\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe\nobjectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;\n\nvar DESCRIPTORS$c = descriptors;\nvar uncurryThis$o = functionUncurryThis;\nvar call$9 = functionCall;\nvar fails$o = fails$w;\nvar objectKeys$2 = objectKeys$3;\nvar getOwnPropertySymbolsModule$3 = objectGetOwnPropertySymbols;\nvar propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;\nvar toObject$c = toObject$e;\nvar IndexedObject$2 = indexedObject;\n\n// eslint-disable-next-line es/no-object-assign -- safe\nvar $assign = Object.assign;\n// eslint-disable-next-line es/no-object-defineproperty -- required for testing\nvar defineProperty$e = Object.defineProperty;\nvar concat$6 = uncurryThis$o([].concat);\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nvar objectAssign = !$assign || fails$o(function () {\n  // should have correct order of operations (Edge bug)\n  if (DESCRIPTORS$c && $assign({ b: 1 }, $assign(defineProperty$e({}, 'a', {\n    enumerable: true,\n    get: function () {\n      defineProperty$e(this, 'b', {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), { b: 2 })).b !== 1) return true;\n  // should work with symbols and should have deterministic property order (V8 bug)\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line es/no-symbol -- safe\n  var symbol = Symbol('assign detection');\n  var alphabet = 'abcdefghijklmnopqrst';\n  A[symbol] = 7;\n  alphabet.split('').forEach(function (chr) { B[chr] = chr; });\n  return $assign({}, A)[symbol] !== 7 || objectKeys$2($assign({}, B)).join('') !== alphabet;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`\n  var T = toObject$c(target);\n  var argumentsLength = arguments.length;\n  var index = 1;\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule$3.f;\n  var propertyIsEnumerable = propertyIsEnumerableModule$1.f;\n  while (argumentsLength > index) {\n    var S = IndexedObject$2(arguments[index++]);\n    var keys = getOwnPropertySymbols ? concat$6(objectKeys$2(S), getOwnPropertySymbols(S)) : objectKeys$2(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) {\n      key = keys[j++];\n      if (!DESCRIPTORS$c || call$9(propertyIsEnumerable, S, key)) T[key] = S[key];\n    }\n  } return T;\n} : $assign;\n\nvar $$O = _export;\nvar assign$5 = objectAssign;\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\n// eslint-disable-next-line es/no-object-assign -- required for testing\n$$O({ target: 'Object', stat: true, arity: 2, forced: Object.assign !== assign$5 }, {\n  assign: assign$5\n});\n\nvar path$t = path$w;\n\nvar assign$4 = path$t.Object.assign;\n\nvar parent$1b = assign$4;\n\nvar assign$3 = parent$1b;\n\nvar assign$2 = assign$3;\n\nvar _Object$assign = /*@__PURE__*/getDefaultExportFromCjs(assign$2);\n\nvar uncurryThis$n = functionUncurryThis;\n\nvar arraySlice$5 = uncurryThis$n([].slice);\n\nvar uncurryThis$m = functionUncurryThis;\nvar aCallable$4 = aCallable$7;\nvar isObject$e = isObject$j;\nvar hasOwn$d = hasOwnProperty_1;\nvar arraySlice$4 = arraySlice$5;\nvar NATIVE_BIND = functionBindNative;\n\nvar $Function = Function;\nvar concat$5 = uncurryThis$m([].concat);\nvar join = uncurryThis$m([].join);\nvar factories = {};\n\nvar construct$4 = function (C, argsLength, args) {\n  if (!hasOwn$d(factories, argsLength)) {\n    var list = [];\n    var i = 0;\n    for (; i < argsLength; i++) list[i] = 'a[' + i + ']';\n    factories[argsLength] = $Function('C,a', 'return new C(' + join(list, ',') + ')');\n  } return factories[argsLength](C, args);\n};\n\n// `Function.prototype.bind` method implementation\n// https://tc39.es/ecma262/#sec-function.prototype.bind\n// eslint-disable-next-line es/no-function-prototype-bind -- detection\nvar functionBind = NATIVE_BIND ? $Function.bind : function bind(that /* , ...args */) {\n  var F = aCallable$4(this);\n  var Prototype = F.prototype;\n  var partArgs = arraySlice$4(arguments, 1);\n  var boundFunction = function bound(/* args... */) {\n    var args = concat$5(partArgs, arraySlice$4(arguments));\n    return this instanceof boundFunction ? construct$4(F, args.length, args) : F.apply(that, args);\n  };\n  if (isObject$e(Prototype)) boundFunction.prototype = Prototype;\n  return boundFunction;\n};\n\n// TODO: Remove from `core-js@4`\nvar $$N = _export;\nvar bind$c = functionBind;\n\n// `Function.prototype.bind` method\n// https://tc39.es/ecma262/#sec-function.prototype.bind\n// eslint-disable-next-line es/no-function-prototype-bind -- detection\n$$N({ target: 'Function', proto: true, forced: Function.bind !== bind$c }, {\n  bind: bind$c\n});\n\nvar path$s = path$w;\n\nvar entryVirtual$i = function (CONSTRUCTOR) {\n  return path$s[CONSTRUCTOR + 'Prototype'];\n};\n\nvar entryVirtual$h = entryVirtual$i;\n\nvar bind$b = entryVirtual$h('Function').bind;\n\nvar isPrototypeOf$j = objectIsPrototypeOf;\nvar method$f = bind$b;\n\nvar FunctionPrototype$2 = Function.prototype;\n\nvar bind$a = function (it) {\n  var own = it.bind;\n  return it === FunctionPrototype$2 || (isPrototypeOf$j(FunctionPrototype$2, it) && own === FunctionPrototype$2.bind) ? method$f : own;\n};\n\nvar parent$1a = bind$a;\n\nvar bind$9 = parent$1a;\n\nvar bind$8 = bind$9;\n\nvar _bindInstanceProperty$1 = /*@__PURE__*/getDefaultExportFromCjs(bind$8);\n\n/**\r\n * Draw a circle.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param r - The radius of the circle.\r\n */\nfunction drawCircle(ctx, x, y, r) {\n  ctx.beginPath();\n  ctx.arc(x, y, r, 0, 2 * Math.PI, false);\n  ctx.closePath();\n}\n/**\r\n * Draw a square.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param r - Half of the width and height of the square.\r\n */\nfunction drawSquare(ctx, x, y, r) {\n  ctx.beginPath();\n  ctx.rect(x - r, y - r, r * 2, r * 2);\n  ctx.closePath();\n}\n/**\r\n * Draw an equilateral triangle standing on a side.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param r - Half of the length of the sides.\r\n * @remarks\r\n * http://en.wikipedia.org/wiki/Equilateral_triangle\r\n */\nfunction drawTriangle(ctx, x, y, r) {\n  ctx.beginPath();\n  // the change in radius and the offset is here to center the shape\n  r *= 1.15;\n  y += 0.275 * r;\n  var s = r * 2;\n  var s2 = s / 2;\n  var ir = Math.sqrt(3) / 6 * s; // radius of inner circle\n  var h = Math.sqrt(s * s - s2 * s2); // height\n  ctx.moveTo(x, y - (h - ir));\n  ctx.lineTo(x + s2, y + ir);\n  ctx.lineTo(x - s2, y + ir);\n  ctx.lineTo(x, y - (h - ir));\n  ctx.closePath();\n}\n/**\r\n * Draw an equilateral triangle standing on a vertex.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param r - Half of the length of the sides.\r\n * @remarks\r\n * http://en.wikipedia.org/wiki/Equilateral_triangle\r\n */\nfunction drawTriangleDown(ctx, x, y, r) {\n  ctx.beginPath();\n  // the change in radius and the offset is here to center the shape\n  r *= 1.15;\n  y -= 0.275 * r;\n  var s = r * 2;\n  var s2 = s / 2;\n  var ir = Math.sqrt(3) / 6 * s; // radius of inner circle\n  var h = Math.sqrt(s * s - s2 * s2); // height\n  ctx.moveTo(x, y + (h - ir));\n  ctx.lineTo(x + s2, y - ir);\n  ctx.lineTo(x - s2, y - ir);\n  ctx.lineTo(x, y + (h - ir));\n  ctx.closePath();\n}\n/**\r\n * Draw a star.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param r - The outer radius of the star.\r\n */\nfunction drawStar(ctx, x, y, r) {\n  // http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/\n  ctx.beginPath();\n  // the change in radius and the offset is here to center the shape\n  r *= 0.82;\n  y += 0.1 * r;\n  for (var n = 0; n < 10; n++) {\n    var radius = n % 2 === 0 ? r * 1.3 : r * 0.5;\n    ctx.lineTo(x + radius * Math.sin(n * 2 * Math.PI / 10), y - radius * Math.cos(n * 2 * Math.PI / 10));\n  }\n  ctx.closePath();\n}\n/**\r\n * Draw a diamond.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param r - Half of the width and height of the diamond.\r\n * @remarks\r\n * http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/\r\n */\nfunction drawDiamond(ctx, x, y, r) {\n  ctx.beginPath();\n  ctx.lineTo(x, y + r);\n  ctx.lineTo(x + r, y);\n  ctx.lineTo(x, y - r);\n  ctx.lineTo(x - r, y);\n  ctx.closePath();\n}\n/**\r\n * Draw a rectangle with rounded corners.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param w - The width of the rectangle.\r\n * @param h - The height of the rectangle.\r\n * @param r - The radius of the corners.\r\n * @remarks\r\n * http://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas\r\n */\nfunction drawRoundRect(ctx, x, y, w, h, r) {\n  var r2d = Math.PI / 180;\n  if (w - 2 * r < 0) {\n    r = w / 2;\n  } //ensure that the radius isn't too large for x\n  if (h - 2 * r < 0) {\n    r = h / 2;\n  } //ensure that the radius isn't too large for y\n  ctx.beginPath();\n  ctx.moveTo(x + r, y);\n  ctx.lineTo(x + w - r, y);\n  ctx.arc(x + w - r, y + r, r, r2d * 270, r2d * 360, false);\n  ctx.lineTo(x + w, y + h - r);\n  ctx.arc(x + w - r, y + h - r, r, 0, r2d * 90, false);\n  ctx.lineTo(x + r, y + h);\n  ctx.arc(x + r, y + h - r, r, r2d * 90, r2d * 180, false);\n  ctx.lineTo(x, y + r);\n  ctx.arc(x + r, y + r, r, r2d * 180, r2d * 270, false);\n  ctx.closePath();\n}\n/**\r\n * Draw an ellipse.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param w - The width of the ellipse.\r\n * @param h - The height of the ellipse.\r\n * @remarks\r\n * http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\r\n *\r\n * Postfix '_vis' added to discern it from standard method ellipse().\r\n */\nfunction drawEllipse(ctx, x, y, w, h) {\n  var kappa = 0.5522848,\n    ox = w / 2 * kappa,\n    // control point offset horizontal\n    oy = h / 2 * kappa,\n    // control point offset vertical\n    xe = x + w,\n    // x-end\n    ye = y + h,\n    // y-end\n    xm = x + w / 2,\n    // x-middle\n    ym = y + h / 2; // y-middle\n  ctx.beginPath();\n  ctx.moveTo(x, ym);\n  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n  ctx.closePath();\n}\n/**\r\n * Draw an isometric cylinder.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param w - The width of the database.\r\n * @param h - The height of the database.\r\n * @remarks\r\n * http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\r\n */\nfunction drawDatabase(ctx, x, y, w, h) {\n  var f = 1 / 3;\n  var wEllipse = w;\n  var hEllipse = h * f;\n  var kappa = 0.5522848,\n    ox = wEllipse / 2 * kappa,\n    // control point offset horizontal\n    oy = hEllipse / 2 * kappa,\n    // control point offset vertical\n    xe = x + wEllipse,\n    // x-end\n    ye = y + hEllipse,\n    // y-end\n    xm = x + wEllipse / 2,\n    // x-middle\n    ym = y + hEllipse / 2,\n    // y-middle\n    ymb = y + (h - hEllipse / 2),\n    // y-midlle, bottom ellipse\n    yeb = y + h; // y-end, bottom ellipse\n  ctx.beginPath();\n  ctx.moveTo(xe, ym);\n  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n  ctx.lineTo(xe, ymb);\n  ctx.bezierCurveTo(xe, ymb + oy, xm + ox, yeb, xm, yeb);\n  ctx.bezierCurveTo(xm - ox, yeb, x, ymb + oy, x, ymb);\n  ctx.lineTo(x, ym);\n}\n/**\r\n * Draw a dashed line.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The start position on the x axis.\r\n * @param y - The start position on the y axis.\r\n * @param x2 - The end position on the x axis.\r\n * @param y2 - The end position on the y axis.\r\n * @param pattern - List of lengths starting with line and then alternating between space and line.\r\n * @author David Jordan\r\n * @remarks\r\n * date 2012-08-08\r\n * http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas\r\n */\nfunction drawDashedLine(ctx, x, y, x2, y2, pattern) {\n  ctx.beginPath();\n  ctx.moveTo(x, y);\n  var patternLength = pattern.length;\n  var dx = x2 - x;\n  var dy = y2 - y;\n  var slope = dy / dx;\n  var distRemaining = Math.sqrt(dx * dx + dy * dy);\n  var patternIndex = 0;\n  var draw = true;\n  var xStep = 0;\n  var dashLength = +pattern[0];\n  while (distRemaining >= 0.1) {\n    dashLength = +pattern[patternIndex++ % patternLength];\n    if (dashLength > distRemaining) {\n      dashLength = distRemaining;\n    }\n    xStep = Math.sqrt(dashLength * dashLength / (1 + slope * slope));\n    xStep = dx < 0 ? -xStep : xStep;\n    x += xStep;\n    y += slope * xStep;\n    if (draw === true) {\n      ctx.lineTo(x, y);\n    } else {\n      ctx.moveTo(x, y);\n    }\n    distRemaining -= dashLength;\n    draw = !draw;\n  }\n}\n/**\r\n * Draw a hexagon.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param r - The radius of the hexagon.\r\n */\nfunction drawHexagon(ctx, x, y, r) {\n  ctx.beginPath();\n  var sides = 6;\n  var a = Math.PI * 2 / sides;\n  ctx.moveTo(x + r, y);\n  for (var i = 1; i < sides; i++) {\n    ctx.lineTo(x + r * Math.cos(a * i), y + r * Math.sin(a * i));\n  }\n  ctx.closePath();\n}\nvar shapeMap = {\n  circle: drawCircle,\n  dashedLine: drawDashedLine,\n  database: drawDatabase,\n  diamond: drawDiamond,\n  ellipse: drawEllipse,\n  ellipse_vis: drawEllipse,\n  hexagon: drawHexagon,\n  roundRect: drawRoundRect,\n  square: drawSquare,\n  star: drawStar,\n  triangle: drawTriangle,\n  triangleDown: drawTriangleDown\n};\n/**\r\n * Returns either custom or native drawing function base on supplied name.\r\n *\r\n * @param name - The name of the function. Either the name of a\r\n * CanvasRenderingContext2D property or an export from shapes.ts without the\r\n * draw prefix.\r\n * @returns The function that can be used for rendering. In case of native\r\n * CanvasRenderingContext2D function the API is normalized to\r\n * `(ctx: CanvasRenderingContext2D, ...originalArgs) => void`.\r\n */\nfunction getShape(name) {\n  if (Object.prototype.hasOwnProperty.call(shapeMap, name)) {\n    return shapeMap[name];\n  } else {\n    return function (ctx) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      CanvasRenderingContext2D.prototype[name].call(ctx, args);\n    };\n  }\n}\n\nvar componentEmitter = {exports: {}};\n\n(function (module) {\n\t/**\r\n\t * Expose `Emitter`.\r\n\t */\r\n\r\n\t{\r\n\t  module.exports = Emitter;\r\n\t}\r\n\r\n\t/**\r\n\t * Initialize a new `Emitter`.\r\n\t *\r\n\t * @api public\r\n\t */\r\n\r\n\tfunction Emitter(obj) {\r\n\t  if (obj) return mixin(obj);\r\n\t}\r\n\t/**\r\n\t * Mixin the emitter properties.\r\n\t *\r\n\t * @param {Object} obj\r\n\t * @return {Object}\r\n\t * @api private\r\n\t */\r\n\r\n\tfunction mixin(obj) {\r\n\t  for (var key in Emitter.prototype) {\r\n\t    obj[key] = Emitter.prototype[key];\r\n\t  }\r\n\t  return obj;\r\n\t}\r\n\r\n\t/**\r\n\t * Listen on the given `event` with `fn`.\r\n\t *\r\n\t * @param {String} event\r\n\t * @param {Function} fn\r\n\t * @return {Emitter}\r\n\t * @api public\r\n\t */\r\n\r\n\tEmitter.prototype.on =\r\n\tEmitter.prototype.addEventListener = function(event, fn){\r\n\t  this._callbacks = this._callbacks || {};\r\n\t  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\r\n\t    .push(fn);\r\n\t  return this;\r\n\t};\r\n\r\n\t/**\r\n\t * Adds an `event` listener that will be invoked a single\r\n\t * time then automatically removed.\r\n\t *\r\n\t * @param {String} event\r\n\t * @param {Function} fn\r\n\t * @return {Emitter}\r\n\t * @api public\r\n\t */\r\n\r\n\tEmitter.prototype.once = function(event, fn){\r\n\t  function on() {\r\n\t    this.off(event, on);\r\n\t    fn.apply(this, arguments);\r\n\t  }\r\n\r\n\t  on.fn = fn;\r\n\t  this.on(event, on);\r\n\t  return this;\r\n\t};\r\n\r\n\t/**\r\n\t * Remove the given callback for `event` or all\r\n\t * registered callbacks.\r\n\t *\r\n\t * @param {String} event\r\n\t * @param {Function} fn\r\n\t * @return {Emitter}\r\n\t * @api public\r\n\t */\r\n\r\n\tEmitter.prototype.off =\r\n\tEmitter.prototype.removeListener =\r\n\tEmitter.prototype.removeAllListeners =\r\n\tEmitter.prototype.removeEventListener = function(event, fn){\r\n\t  this._callbacks = this._callbacks || {};\r\n\r\n\t  // all\r\n\t  if (0 == arguments.length) {\r\n\t    this._callbacks = {};\r\n\t    return this;\r\n\t  }\r\n\r\n\t  // specific event\r\n\t  var callbacks = this._callbacks['$' + event];\r\n\t  if (!callbacks) return this;\r\n\r\n\t  // remove all handlers\r\n\t  if (1 == arguments.length) {\r\n\t    delete this._callbacks['$' + event];\r\n\t    return this;\r\n\t  }\r\n\r\n\t  // remove specific handler\r\n\t  var cb;\r\n\t  for (var i = 0; i < callbacks.length; i++) {\r\n\t    cb = callbacks[i];\r\n\t    if (cb === fn || cb.fn === fn) {\r\n\t      callbacks.splice(i, 1);\r\n\t      break;\r\n\t    }\r\n\t  }\r\n\r\n\t  // Remove event specific arrays for event types that no\r\n\t  // one is subscribed for to avoid memory leak.\r\n\t  if (callbacks.length === 0) {\r\n\t    delete this._callbacks['$' + event];\r\n\t  }\r\n\r\n\t  return this;\r\n\t};\r\n\r\n\t/**\r\n\t * Emit `event` with the given args.\r\n\t *\r\n\t * @param {String} event\r\n\t * @param {Mixed} ...\r\n\t * @return {Emitter}\r\n\t */\r\n\r\n\tEmitter.prototype.emit = function(event){\r\n\t  this._callbacks = this._callbacks || {};\r\n\r\n\t  var args = new Array(arguments.length - 1)\r\n\t    , callbacks = this._callbacks['$' + event];\r\n\r\n\t  for (var i = 1; i < arguments.length; i++) {\r\n\t    args[i - 1] = arguments[i];\r\n\t  }\r\n\r\n\t  if (callbacks) {\r\n\t    callbacks = callbacks.slice(0);\r\n\t    for (var i = 0, len = callbacks.length; i < len; ++i) {\r\n\t      callbacks[i].apply(this, args);\r\n\t    }\r\n\t  }\r\n\r\n\t  return this;\r\n\t};\r\n\r\n\t/**\r\n\t * Return array of callbacks for `event`.\r\n\t *\r\n\t * @param {String} event\r\n\t * @return {Array}\r\n\t * @api public\r\n\t */\r\n\r\n\tEmitter.prototype.listeners = function(event){\r\n\t  this._callbacks = this._callbacks || {};\r\n\t  return this._callbacks['$' + event] || [];\r\n\t};\r\n\r\n\t/**\r\n\t * Check if this emitter has `event` handlers.\r\n\t *\r\n\t * @param {String} event\r\n\t * @return {Boolean}\r\n\t * @api public\r\n\t */\r\n\r\n\tEmitter.prototype.hasListeners = function(event){\r\n\t  return !! this.listeners(event).length;\r\n\t}; \n} (componentEmitter));\n\nvar componentEmitterExports = componentEmitter.exports;\nvar Emitter = /*@__PURE__*/getDefaultExportFromCjs(componentEmitterExports);\n\nvar wellKnownSymbol$k = wellKnownSymbol$m;\n\nvar TO_STRING_TAG$3 = wellKnownSymbol$k('toStringTag');\nvar test$2 = {};\n\ntest$2[TO_STRING_TAG$3] = 'z';\n\nvar toStringTagSupport = String(test$2) === '[object z]';\n\nvar TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;\nvar isCallable$a = isCallable$i;\nvar classofRaw = classofRaw$2;\nvar wellKnownSymbol$j = wellKnownSymbol$m;\n\nvar TO_STRING_TAG$2 = wellKnownSymbol$j('toStringTag');\nvar $Object$2 = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) === 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nvar classof$d = TO_STRING_TAG_SUPPORT$2 ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = $Object$2(it), TO_STRING_TAG$2)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) === 'Object' && isCallable$a(O.callee) ? 'Arguments' : result;\n};\n\nvar classof$c = classof$d;\n\nvar $String$2 = String;\n\nvar toString$a = function (argument) {\n  if (classof$c(argument) === 'Symbol') throw new TypeError('Cannot convert a Symbol value to a string');\n  return $String$2(argument);\n};\n\nvar uncurryThis$l = functionUncurryThis;\nvar toIntegerOrInfinity$1 = toIntegerOrInfinity$4;\nvar toString$9 = toString$a;\nvar requireObjectCoercible$2 = requireObjectCoercible$5;\n\nvar charAt$3 = uncurryThis$l(''.charAt);\nvar charCodeAt$1 = uncurryThis$l(''.charCodeAt);\nvar stringSlice = uncurryThis$l(''.slice);\n\nvar createMethod$3 = function (CONVERT_TO_STRING) {\n  return function ($this, pos) {\n    var S = toString$9(requireObjectCoercible$2($this));\n    var position = toIntegerOrInfinity$1(pos);\n    var size = S.length;\n    var first, second;\n    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;\n    first = charCodeAt$1(S, position);\n    return first < 0xD800 || first > 0xDBFF || position + 1 === size\n      || (second = charCodeAt$1(S, position + 1)) < 0xDC00 || second > 0xDFFF\n        ? CONVERT_TO_STRING\n          ? charAt$3(S, position)\n          : first\n        : CONVERT_TO_STRING\n          ? stringSlice(S, position, position + 2)\n          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  };\n};\n\nvar stringMultibyte = {\n  // `String.prototype.codePointAt` method\n  // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n  codeAt: createMethod$3(false),\n  // `String.prototype.at` method\n  // https://github.com/mathiasbynens/String.prototype.at\n  charAt: createMethod$3(true)\n};\n\nvar global$e = global$n;\nvar isCallable$9 = isCallable$i;\n\nvar WeakMap$1 = global$e.WeakMap;\n\nvar weakMapBasicDetection = isCallable$9(WeakMap$1) && /native code/.test(String(WeakMap$1));\n\nvar shared$5 = sharedExports;\nvar uid$2 = uid$4;\n\nvar keys$3 = shared$5('keys');\n\nvar sharedKey$4 = function (key) {\n  return keys$3[key] || (keys$3[key] = uid$2(key));\n};\n\nvar NATIVE_WEAK_MAP$1 = weakMapBasicDetection;\nvar global$d = global$n;\nvar isObject$d = isObject$j;\nvar createNonEnumerableProperty$4 = createNonEnumerableProperty$6;\nvar hasOwn$c = hasOwnProperty_1;\nvar shared$4 = sharedStore;\nvar sharedKey$3 = sharedKey$4;\nvar hiddenKeys$4 = hiddenKeys$6;\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError$2 = global$d.TypeError;\nvar WeakMap = global$d.WeakMap;\nvar set$3, get$6, has;\n\nvar enforce = function (it) {\n  return has(it) ? get$6(it) : set$3(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject$d(it) || (state = get$6(it)).type !== TYPE) {\n      throw new TypeError$2('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP$1 || shared$4.state) {\n  var store$1 = shared$4.state || (shared$4.state = new WeakMap());\n  /* eslint-disable no-self-assign -- prototype methods protection */\n  store$1.get = store$1.get;\n  store$1.has = store$1.has;\n  store$1.set = store$1.set;\n  /* eslint-enable no-self-assign -- prototype methods protection */\n  set$3 = function (it, metadata) {\n    if (store$1.has(it)) throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    store$1.set(it, metadata);\n    return metadata;\n  };\n  get$6 = function (it) {\n    return store$1.get(it) || {};\n  };\n  has = function (it) {\n    return store$1.has(it);\n  };\n} else {\n  var STATE = sharedKey$3('state');\n  hiddenKeys$4[STATE] = true;\n  set$3 = function (it, metadata) {\n    if (hasOwn$c(it, STATE)) throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty$4(it, STATE, metadata);\n    return metadata;\n  };\n  get$6 = function (it) {\n    return hasOwn$c(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn$c(it, STATE);\n  };\n}\n\nvar internalState = {\n  set: set$3,\n  get: get$6,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\nvar DESCRIPTORS$b = descriptors;\nvar hasOwn$b = hasOwnProperty_1;\n\nvar FunctionPrototype$1 = Function.prototype;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS$b && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn$b(FunctionPrototype$1, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS$b || (DESCRIPTORS$b && getDescriptor(FunctionPrototype$1, 'name').configurable));\n\nvar functionName = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n\nvar objectDefineProperties = {};\n\nvar DESCRIPTORS$a = descriptors;\nvar V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;\nvar definePropertyModule$2 = objectDefineProperty;\nvar anObject$b = anObject$d;\nvar toIndexedObject$6 = toIndexedObject$a;\nvar objectKeys$1 = objectKeys$3;\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es/no-object-defineproperties -- safe\nobjectDefineProperties.f = DESCRIPTORS$a && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject$b(O);\n  var props = toIndexedObject$6(Properties);\n  var keys = objectKeys$1(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule$2.f(O, key = keys[index++], props[key]);\n  return O;\n};\n\nvar getBuiltIn$a = getBuiltIn$c;\n\nvar html$1 = getBuiltIn$a('document', 'documentElement');\n\n/* global ActiveXObject -- old IE, WSH */\nvar anObject$a = anObject$d;\nvar definePropertiesModule$1 = objectDefineProperties;\nvar enumBugKeys$1 = enumBugKeys$3;\nvar hiddenKeys$3 = hiddenKeys$6;\nvar html = html$1;\nvar documentCreateElement = documentCreateElement$1;\nvar sharedKey$2 = sharedKey$4;\n\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE$1 = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO$1 = sharedKey$2('IE_PROTO');\n\nvar EmptyConstructor = function () { /* empty */ };\n\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\n\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n  return temp;\n};\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html.appendChild(iframe);\n  // https://github.com/zloirock/core-js/issues/475\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\n\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function () {\n  try {\n    activeXDocument = new ActiveXObject('htmlfile');\n  } catch (error) { /* ignore */ }\n  NullProtoObject = typeof document != 'undefined'\n    ? document.domain && activeXDocument\n      ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n      : NullProtoObjectViaIFrame()\n    : NullProtoObjectViaActiveX(activeXDocument); // WSH\n  var length = enumBugKeys$1.length;\n  while (length--) delete NullProtoObject[PROTOTYPE$1][enumBugKeys$1[length]];\n  return NullProtoObject();\n};\n\nhiddenKeys$3[IE_PROTO$1] = true;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\n// eslint-disable-next-line es/no-object-create -- safe\nvar objectCreate = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE$1] = anObject$a(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE$1] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO$1] = O;\n  } else result = NullProtoObject();\n  return Properties === undefined ? result : definePropertiesModule$1.f(result, Properties);\n};\n\nvar fails$n = fails$w;\n\nvar correctPrototypeGetter = !fails$n(function () {\n  function F() { /* empty */ }\n  F.prototype.constructor = null;\n  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\nvar hasOwn$a = hasOwnProperty_1;\nvar isCallable$8 = isCallable$i;\nvar toObject$b = toObject$e;\nvar sharedKey$1 = sharedKey$4;\nvar CORRECT_PROTOTYPE_GETTER$1 = correctPrototypeGetter;\n\nvar IE_PROTO = sharedKey$1('IE_PROTO');\nvar $Object$1 = Object;\nvar ObjectPrototype$2 = $Object$1.prototype;\n\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\n// eslint-disable-next-line es/no-object-getprototypeof -- safe\nvar objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER$1 ? $Object$1.getPrototypeOf : function (O) {\n  var object = toObject$b(O);\n  if (hasOwn$a(object, IE_PROTO)) return object[IE_PROTO];\n  var constructor = object.constructor;\n  if (isCallable$8(constructor) && object instanceof constructor) {\n    return constructor.prototype;\n  } return object instanceof $Object$1 ? ObjectPrototype$2 : null;\n};\n\nvar createNonEnumerableProperty$3 = createNonEnumerableProperty$6;\n\nvar defineBuiltIn$5 = function (target, key, value, options) {\n  if (options && options.enumerable) target[key] = value;\n  else createNonEnumerableProperty$3(target, key, value);\n  return target;\n};\n\nvar fails$m = fails$w;\nvar isCallable$7 = isCallable$i;\nvar isObject$c = isObject$j;\nvar create$a = objectCreate;\nvar getPrototypeOf$8 = objectGetPrototypeOf;\nvar defineBuiltIn$4 = defineBuiltIn$5;\nvar wellKnownSymbol$i = wellKnownSymbol$m;\n\nvar ITERATOR$6 = wellKnownSymbol$i('iterator');\nvar BUGGY_SAFARI_ITERATORS$1 = false;\n\n// `%IteratorPrototype%` object\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype$1, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\n/* eslint-disable es/no-array-prototype-keys -- safe */\nif ([].keys) {\n  arrayIterator = [].keys();\n  // Safari 8 has buggy iterators w/o `next`\n  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;\n  else {\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf$8(getPrototypeOf$8(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$1 = PrototypeOfArrayIteratorPrototype;\n  }\n}\n\nvar NEW_ITERATOR_PROTOTYPE = !isObject$c(IteratorPrototype$1) || fails$m(function () {\n  var test = {};\n  // FF44- legacy iterators case\n  return IteratorPrototype$1[ITERATOR$6].call(test) !== test;\n});\n\nif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$1 = {};\nelse IteratorPrototype$1 = create$a(IteratorPrototype$1);\n\n// `%IteratorPrototype%[@@iterator]()` method\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\nif (!isCallable$7(IteratorPrototype$1[ITERATOR$6])) {\n  defineBuiltIn$4(IteratorPrototype$1, ITERATOR$6, function () {\n    return this;\n  });\n}\n\nvar iteratorsCore = {\n  IteratorPrototype: IteratorPrototype$1,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1\n};\n\nvar TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;\nvar classof$b = classof$d;\n\n// `Object.prototype.toString` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.tostring\nvar objectToString = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString() {\n  return '[object ' + classof$b(this) + ']';\n};\n\nvar TO_STRING_TAG_SUPPORT = toStringTagSupport;\nvar defineProperty$d = objectDefineProperty.f;\nvar createNonEnumerableProperty$2 = createNonEnumerableProperty$6;\nvar hasOwn$9 = hasOwnProperty_1;\nvar toString$8 = objectToString;\nvar wellKnownSymbol$h = wellKnownSymbol$m;\n\nvar TO_STRING_TAG$1 = wellKnownSymbol$h('toStringTag');\n\nvar setToStringTag$6 = function (it, TAG, STATIC, SET_METHOD) {\n  if (it) {\n    var target = STATIC ? it : it.prototype;\n    if (!hasOwn$9(target, TO_STRING_TAG$1)) {\n      defineProperty$d(target, TO_STRING_TAG$1, { configurable: true, value: TAG });\n    }\n    if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {\n      createNonEnumerableProperty$2(target, 'toString', toString$8);\n    }\n  }\n};\n\nvar iterators = {};\n\nvar IteratorPrototype = iteratorsCore.IteratorPrototype;\nvar create$9 = objectCreate;\nvar createPropertyDescriptor$2 = createPropertyDescriptor$5;\nvar setToStringTag$5 = setToStringTag$6;\nvar Iterators$5 = iterators;\n\nvar returnThis$1 = function () { return this; };\n\nvar iteratorCreateConstructor = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {\n  var TO_STRING_TAG = NAME + ' Iterator';\n  IteratorConstructor.prototype = create$9(IteratorPrototype, { next: createPropertyDescriptor$2(+!ENUMERABLE_NEXT, next) });\n  setToStringTag$5(IteratorConstructor, TO_STRING_TAG, false, true);\n  Iterators$5[TO_STRING_TAG] = returnThis$1;\n  return IteratorConstructor;\n};\n\nvar uncurryThis$k = functionUncurryThis;\nvar aCallable$3 = aCallable$7;\n\nvar functionUncurryThisAccessor = function (object, key, method) {\n  try {\n    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n    return uncurryThis$k(aCallable$3(Object.getOwnPropertyDescriptor(object, key)[method]));\n  } catch (error) { /* empty */ }\n};\n\nvar isCallable$6 = isCallable$i;\n\nvar $String$1 = String;\nvar $TypeError$a = TypeError;\n\nvar aPossiblePrototype$1 = function (argument) {\n  if (typeof argument == 'object' || isCallable$6(argument)) return argument;\n  throw new $TypeError$a(\"Can't set \" + $String$1(argument) + ' as a prototype');\n};\n\n/* eslint-disable no-proto -- safe */\nvar uncurryThisAccessor = functionUncurryThisAccessor;\nvar anObject$9 = anObject$d;\nvar aPossiblePrototype = aPossiblePrototype$1;\n\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n// eslint-disable-next-line es/no-object-setprototypeof -- safe\nvar objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');\n    setter(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject$9(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n\nvar $$M = _export;\nvar call$8 = functionCall;\nvar FunctionName = functionName;\nvar createIteratorConstructor = iteratorCreateConstructor;\nvar getPrototypeOf$7 = objectGetPrototypeOf;\nvar setToStringTag$4 = setToStringTag$6;\nvar defineBuiltIn$3 = defineBuiltIn$5;\nvar wellKnownSymbol$g = wellKnownSymbol$m;\nvar Iterators$4 = iterators;\nvar IteratorsCore = iteratorsCore;\n\nvar PROPER_FUNCTION_NAME = FunctionName.PROPER;\nFunctionName.CONFIGURABLE;\nIteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR$5 = wellKnownSymbol$g('iterator');\nvar KEYS = 'keys';\nvar VALUES = 'values';\nvar ENTRIES = 'entries';\n\nvar returnThis = function () { return this; };\n\nvar iteratorDefine = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n  var getIterationMethod = function (KIND) {\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];\n\n    switch (KIND) {\n      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n    }\n\n    return function () { return new IteratorConstructor(this); };\n  };\n\n  var TO_STRING_TAG = NAME + ' Iterator';\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR$5]\n    || IterablePrototype['@@iterator']\n    || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME === 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n\n  // fix native\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf$7(anyNativeIterator.call(new Iterable()));\n    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag$4(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\n      Iterators$4[TO_STRING_TAG] = returnThis;\n    }\n  }\n\n  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF\n  if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    {\n      INCORRECT_VALUES_NAME = true;\n      defaultIterator = function values() { return call$8(nativeIterator, this); };\n    }\n  }\n\n  // export additional methods\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED) for (KEY in methods) {\n      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n        defineBuiltIn$3(IterablePrototype, KEY, methods[KEY]);\n      }\n    } else $$M({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n  }\n\n  // define iterator\n  if ((FORCED) && IterablePrototype[ITERATOR$5] !== defaultIterator) {\n    defineBuiltIn$3(IterablePrototype, ITERATOR$5, defaultIterator, { name: DEFAULT });\n  }\n  Iterators$4[NAME] = defaultIterator;\n\n  return methods;\n};\n\n// `CreateIterResultObject` abstract operation\n// https://tc39.es/ecma262/#sec-createiterresultobject\nvar createIterResultObject$3 = function (value, done) {\n  return { value: value, done: done };\n};\n\nvar charAt$2 = stringMultibyte.charAt;\nvar toString$7 = toString$a;\nvar InternalStateModule$5 = internalState;\nvar defineIterator$2 = iteratorDefine;\nvar createIterResultObject$2 = createIterResultObject$3;\n\nvar STRING_ITERATOR = 'String Iterator';\nvar setInternalState$5 = InternalStateModule$5.set;\nvar getInternalState$2 = InternalStateModule$5.getterFor(STRING_ITERATOR);\n\n// `String.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-string.prototype-@@iterator\ndefineIterator$2(String, 'String', function (iterated) {\n  setInternalState$5(this, {\n    type: STRING_ITERATOR,\n    string: toString$7(iterated),\n    index: 0\n  });\n// `%StringIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next\n}, function next() {\n  var state = getInternalState$2(this);\n  var string = state.string;\n  var index = state.index;\n  var point;\n  if (index >= string.length) return createIterResultObject$2(undefined, true);\n  point = charAt$2(string, index);\n  state.index += point.length;\n  return createIterResultObject$2(point, false);\n});\n\nvar call$7 = functionCall;\nvar anObject$8 = anObject$d;\nvar getMethod$1 = getMethod$3;\n\nvar iteratorClose$2 = function (iterator, kind, value) {\n  var innerResult, innerError;\n  anObject$8(iterator);\n  try {\n    innerResult = getMethod$1(iterator, 'return');\n    if (!innerResult) {\n      if (kind === 'throw') throw value;\n      return value;\n    }\n    innerResult = call$7(innerResult, iterator);\n  } catch (error) {\n    innerError = true;\n    innerResult = error;\n  }\n  if (kind === 'throw') throw value;\n  if (innerError) throw innerResult;\n  anObject$8(innerResult);\n  return value;\n};\n\nvar anObject$7 = anObject$d;\nvar iteratorClose$1 = iteratorClose$2;\n\n// call something on iterator step with safe closing on error\nvar callWithSafeIterationClosing$1 = function (iterator, fn, value, ENTRIES) {\n  try {\n    return ENTRIES ? fn(anObject$7(value)[0], value[1]) : fn(value);\n  } catch (error) {\n    iteratorClose$1(iterator, 'throw', error);\n  }\n};\n\nvar wellKnownSymbol$f = wellKnownSymbol$m;\nvar Iterators$3 = iterators;\n\nvar ITERATOR$4 = wellKnownSymbol$f('iterator');\nvar ArrayPrototype$g = Array.prototype;\n\n// check on default Array iterator\nvar isArrayIteratorMethod$2 = function (it) {\n  return it !== undefined && (Iterators$3.Array === it || ArrayPrototype$g[ITERATOR$4] === it);\n};\n\nvar uncurryThis$j = functionUncurryThis;\nvar isCallable$5 = isCallable$i;\nvar store = sharedStore;\n\nvar functionToString = uncurryThis$j(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable$5(store.inspectSource)) {\n  store.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nvar inspectSource$1 = store.inspectSource;\n\nvar uncurryThis$i = functionUncurryThis;\nvar fails$l = fails$w;\nvar isCallable$4 = isCallable$i;\nvar classof$a = classof$d;\nvar getBuiltIn$9 = getBuiltIn$c;\nvar inspectSource = inspectSource$1;\n\nvar noop = function () { /* empty */ };\nvar empty = [];\nvar construct$3 = getBuiltIn$9('Reflect', 'construct');\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec$2 = uncurryThis$i(constructorRegExp.exec);\nvar INCORRECT_TO_STRING = !constructorRegExp.test(noop);\n\nvar isConstructorModern = function isConstructor(argument) {\n  if (!isCallable$4(argument)) return false;\n  try {\n    construct$3(noop, empty, argument);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\nvar isConstructorLegacy = function isConstructor(argument) {\n  if (!isCallable$4(argument)) return false;\n  switch (classof$a(argument)) {\n    case 'AsyncFunction':\n    case 'GeneratorFunction':\n    case 'AsyncGeneratorFunction': return false;\n  }\n  try {\n    // we can't check .prototype since constructors produced by .bind haven't it\n    // `Function#toString` throws on some built-it function in some legacy engines\n    // (for example, `DOMQuad` and similar in FF41-)\n    return INCORRECT_TO_STRING || !!exec$2(constructorRegExp, inspectSource(argument));\n  } catch (error) {\n    return true;\n  }\n};\n\nisConstructorLegacy.sham = true;\n\n// `IsConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-isconstructor\nvar isConstructor$4 = !construct$3 || fails$l(function () {\n  var called;\n  return isConstructorModern(isConstructorModern.call)\n    || !isConstructorModern(Object)\n    || !isConstructorModern(function () { called = true; })\n    || called;\n}) ? isConstructorLegacy : isConstructorModern;\n\nvar toPropertyKey$1 = toPropertyKey$4;\nvar definePropertyModule$1 = objectDefineProperty;\nvar createPropertyDescriptor$1 = createPropertyDescriptor$5;\n\nvar createProperty$6 = function (object, key, value) {\n  var propertyKey = toPropertyKey$1(key);\n  if (propertyKey in object) definePropertyModule$1.f(object, propertyKey, createPropertyDescriptor$1(0, value));\n  else object[propertyKey] = value;\n};\n\nvar classof$9 = classof$d;\nvar getMethod = getMethod$3;\nvar isNullOrUndefined$3 = isNullOrUndefined$6;\nvar Iterators$2 = iterators;\nvar wellKnownSymbol$e = wellKnownSymbol$m;\n\nvar ITERATOR$3 = wellKnownSymbol$e('iterator');\n\nvar getIteratorMethod$9 = function (it) {\n  if (!isNullOrUndefined$3(it)) return getMethod(it, ITERATOR$3)\n    || getMethod(it, '@@iterator')\n    || Iterators$2[classof$9(it)];\n};\n\nvar call$6 = functionCall;\nvar aCallable$2 = aCallable$7;\nvar anObject$6 = anObject$d;\nvar tryToString$4 = tryToString$6;\nvar getIteratorMethod$8 = getIteratorMethod$9;\n\nvar $TypeError$9 = TypeError;\n\nvar getIterator$2 = function (argument, usingIterator) {\n  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$8(argument) : usingIterator;\n  if (aCallable$2(iteratorMethod)) return anObject$6(call$6(iteratorMethod, argument));\n  throw new $TypeError$9(tryToString$4(argument) + ' is not iterable');\n};\n\nvar bind$7 = functionBindContext;\nvar call$5 = functionCall;\nvar toObject$a = toObject$e;\nvar callWithSafeIterationClosing = callWithSafeIterationClosing$1;\nvar isArrayIteratorMethod$1 = isArrayIteratorMethod$2;\nvar isConstructor$3 = isConstructor$4;\nvar lengthOfArrayLike$a = lengthOfArrayLike$c;\nvar createProperty$5 = createProperty$6;\nvar getIterator$1 = getIterator$2;\nvar getIteratorMethod$7 = getIteratorMethod$9;\n\nvar $Array$3 = Array;\n\n// `Array.from` method implementation\n// https://tc39.es/ecma262/#sec-array.from\nvar arrayFrom = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n  var O = toObject$a(arrayLike);\n  var IS_CONSTRUCTOR = isConstructor$3(this);\n  var argumentsLength = arguments.length;\n  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n  var mapping = mapfn !== undefined;\n  if (mapping) mapfn = bind$7(mapfn, argumentsLength > 2 ? arguments[2] : undefined);\n  var iteratorMethod = getIteratorMethod$7(O);\n  var index = 0;\n  var length, result, step, iterator, next, value;\n  // if the target is not iterable or it's an array with the default iterator - use a simple case\n  if (iteratorMethod && !(this === $Array$3 && isArrayIteratorMethod$1(iteratorMethod))) {\n    iterator = getIterator$1(O, iteratorMethod);\n    next = iterator.next;\n    result = IS_CONSTRUCTOR ? new this() : [];\n    for (;!(step = call$5(next, iterator)).done; index++) {\n      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;\n      createProperty$5(result, index, value);\n    }\n  } else {\n    length = lengthOfArrayLike$a(O);\n    result = IS_CONSTRUCTOR ? new this(length) : $Array$3(length);\n    for (;length > index; index++) {\n      value = mapping ? mapfn(O[index], index) : O[index];\n      createProperty$5(result, index, value);\n    }\n  }\n  result.length = index;\n  return result;\n};\n\nvar wellKnownSymbol$d = wellKnownSymbol$m;\n\nvar ITERATOR$2 = wellKnownSymbol$d('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var called = 0;\n  var iteratorWithReturn = {\n    next: function () {\n      return { done: !!called++ };\n    },\n    'return': function () {\n      SAFE_CLOSING = true;\n    }\n  };\n  iteratorWithReturn[ITERATOR$2] = function () {\n    return this;\n  };\n  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing\n  Array.from(iteratorWithReturn, function () { throw 2; });\n} catch (error) { /* empty */ }\n\nvar checkCorrectnessOfIteration$1 = function (exec, SKIP_CLOSING) {\n  try {\n    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n  } catch (error) { return false; } // workaround of old WebKit + `eval` bug\n  var ITERATION_SUPPORT = false;\n  try {\n    var object = {};\n    object[ITERATOR$2] = function () {\n      return {\n        next: function () {\n          return { done: ITERATION_SUPPORT = true };\n        }\n      };\n    };\n    exec(object);\n  } catch (error) { /* empty */ }\n  return ITERATION_SUPPORT;\n};\n\nvar $$L = _export;\nvar from$6 = arrayFrom;\nvar checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;\n\nvar INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {\n  // eslint-disable-next-line es/no-array-from -- required for testing\n  Array.from(iterable);\n});\n\n// `Array.from` method\n// https://tc39.es/ecma262/#sec-array.from\n$$L({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {\n  from: from$6\n});\n\nvar path$r = path$w;\n\nvar from$5 = path$r.Array.from;\n\nvar parent$19 = from$5;\n\nvar from$4 = parent$19;\n\nvar from$3 = from$4;\n\nvar _Array$from$1 = /*@__PURE__*/getDefaultExportFromCjs(from$3);\n\nvar toIndexedObject$5 = toIndexedObject$a;\nvar Iterators$1 = iterators;\nvar InternalStateModule$4 = internalState;\nobjectDefineProperty.f;\nvar defineIterator$1 = iteratorDefine;\nvar createIterResultObject$1 = createIterResultObject$3;\n\nvar ARRAY_ITERATOR = 'Array Iterator';\nvar setInternalState$4 = InternalStateModule$4.set;\nvar getInternalState$1 = InternalStateModule$4.getterFor(ARRAY_ITERATOR);\n\n// `Array.prototype.entries` method\n// https://tc39.es/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.es/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.es/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.es/ecma262/#sec-createarrayiterator\ndefineIterator$1(Array, 'Array', function (iterated, kind) {\n  setInternalState$4(this, {\n    type: ARRAY_ITERATOR,\n    target: toIndexedObject$5(iterated), // target\n    index: 0,                          // next index\n    kind: kind                         // kind\n  });\n// `%ArrayIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\n}, function () {\n  var state = getInternalState$1(this);\n  var target = state.target;\n  var kind = state.kind;\n  var index = state.index++;\n  if (!target || index >= target.length) {\n    state.target = undefined;\n    return createIterResultObject$1(undefined, true);\n  }\n  switch (kind) {\n    case 'keys': return createIterResultObject$1(index, false);\n    case 'values': return createIterResultObject$1(target[index], false);\n  } return createIterResultObject$1([index, target[index]], false);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.es/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.es/ecma262/#sec-createmappedargumentsobject\nIterators$1.Arguments = Iterators$1.Array;\n\nvar getIteratorMethod$6 = getIteratorMethod$9;\n\nvar getIteratorMethod_1 = getIteratorMethod$6;\n\n// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\nvar domIterables = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\n\nvar DOMIterables$2 = domIterables;\nvar global$c = global$n;\nvar classof$8 = classof$d;\nvar createNonEnumerableProperty$1 = createNonEnumerableProperty$6;\nvar Iterators = iterators;\nvar wellKnownSymbol$c = wellKnownSymbol$m;\n\nvar TO_STRING_TAG = wellKnownSymbol$c('toStringTag');\n\nfor (var COLLECTION_NAME in DOMIterables$2) {\n  var Collection = global$c[COLLECTION_NAME];\n  var CollectionPrototype = Collection && Collection.prototype;\n  if (CollectionPrototype && classof$8(CollectionPrototype) !== TO_STRING_TAG) {\n    createNonEnumerableProperty$1(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);\n  }\n  Iterators[COLLECTION_NAME] = Iterators.Array;\n}\n\nvar parent$18 = getIteratorMethod_1;\n\n\nvar getIteratorMethod$5 = parent$18;\n\nvar parent$17 = getIteratorMethod$5;\n\nvar getIteratorMethod$4 = parent$17;\n\nvar parent$16 = getIteratorMethod$4;\n\nvar getIteratorMethod$3 = parent$16;\n\nvar getIteratorMethod$2 = getIteratorMethod$3;\n\nvar _getIteratorMethod$1 = /*@__PURE__*/getDefaultExportFromCjs(getIteratorMethod$2);\n\nvar getIteratorMethod$1 = getIteratorMethod$2;\n\nvar _getIteratorMethod = /*@__PURE__*/getDefaultExportFromCjs(getIteratorMethod$1);\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar defineProperty$c = {exports: {}};\n\nvar $$K = _export;\nvar DESCRIPTORS$9 = descriptors;\nvar defineProperty$b = objectDefineProperty.f;\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\n// eslint-disable-next-line es/no-object-defineproperty -- safe\n$$K({ target: 'Object', stat: true, forced: Object.defineProperty !== defineProperty$b, sham: !DESCRIPTORS$9 }, {\n  defineProperty: defineProperty$b\n});\n\nvar path$q = path$w;\n\nvar Object$5 = path$q.Object;\n\nvar defineProperty$a = defineProperty$c.exports = function defineProperty(it, key, desc) {\n  return Object$5.defineProperty(it, key, desc);\n};\n\nif (Object$5.defineProperty.sham) defineProperty$a.sham = true;\n\nvar definePropertyExports = defineProperty$c.exports;\n\nvar parent$15 = definePropertyExports;\n\nvar defineProperty$9 = parent$15;\n\nvar parent$14 = defineProperty$9;\n\nvar defineProperty$8 = parent$14;\n\nvar parent$13 = defineProperty$8;\n\nvar defineProperty$7 = parent$13;\n\nvar defineProperty$6 = defineProperty$7;\n\nvar _Object$defineProperty$1 = /*@__PURE__*/getDefaultExportFromCjs(defineProperty$6);\n\nvar classof$7 = classofRaw$2;\n\n// `IsArray` abstract operation\n// https://tc39.es/ecma262/#sec-isarray\n// eslint-disable-next-line es/no-array-isarray -- safe\nvar isArray$e = Array.isArray || function isArray(argument) {\n  return classof$7(argument) === 'Array';\n};\n\nvar $TypeError$8 = TypeError;\nvar MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991\n\nvar doesNotExceedSafeInteger$3 = function (it) {\n  if (it > MAX_SAFE_INTEGER) throw $TypeError$8('Maximum allowed index exceeded');\n  return it;\n};\n\nvar isArray$d = isArray$e;\nvar isConstructor$2 = isConstructor$4;\nvar isObject$b = isObject$j;\nvar wellKnownSymbol$b = wellKnownSymbol$m;\n\nvar SPECIES$3 = wellKnownSymbol$b('species');\nvar $Array$2 = Array;\n\n// a part of `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nvar arraySpeciesConstructor$1 = function (originalArray) {\n  var C;\n  if (isArray$d(originalArray)) {\n    C = originalArray.constructor;\n    // cross-realm fallback\n    if (isConstructor$2(C) && (C === $Array$2 || isArray$d(C.prototype))) C = undefined;\n    else if (isObject$b(C)) {\n      C = C[SPECIES$3];\n      if (C === null) C = undefined;\n    }\n  } return C === undefined ? $Array$2 : C;\n};\n\nvar arraySpeciesConstructor = arraySpeciesConstructor$1;\n\n// `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nvar arraySpeciesCreate$3 = function (originalArray, length) {\n  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);\n};\n\nvar fails$k = fails$w;\nvar wellKnownSymbol$a = wellKnownSymbol$m;\nvar V8_VERSION$1 = engineV8Version;\n\nvar SPECIES$2 = wellKnownSymbol$a('species');\n\nvar arrayMethodHasSpeciesSupport$5 = function (METHOD_NAME) {\n  // We can't use this feature detection in V8 since it causes\n  // deoptimization and serious performance degradation\n  // https://github.com/zloirock/core-js/issues/677\n  return V8_VERSION$1 >= 51 || !fails$k(function () {\n    var array = [];\n    var constructor = array.constructor = {};\n    constructor[SPECIES$2] = function () {\n      return { foo: 1 };\n    };\n    return array[METHOD_NAME](Boolean).foo !== 1;\n  });\n};\n\nvar $$J = _export;\nvar fails$j = fails$w;\nvar isArray$c = isArray$e;\nvar isObject$a = isObject$j;\nvar toObject$9 = toObject$e;\nvar lengthOfArrayLike$9 = lengthOfArrayLike$c;\nvar doesNotExceedSafeInteger$2 = doesNotExceedSafeInteger$3;\nvar createProperty$4 = createProperty$6;\nvar arraySpeciesCreate$2 = arraySpeciesCreate$3;\nvar arrayMethodHasSpeciesSupport$4 = arrayMethodHasSpeciesSupport$5;\nvar wellKnownSymbol$9 = wellKnownSymbol$m;\nvar V8_VERSION = engineV8Version;\n\nvar IS_CONCAT_SPREADABLE = wellKnownSymbol$9('isConcatSpreadable');\n\n// We can't use this feature detection in V8 since it causes\n// deoptimization and serious performance degradation\n// https://github.com/zloirock/core-js/issues/679\nvar IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails$j(function () {\n  var array = [];\n  array[IS_CONCAT_SPREADABLE] = false;\n  return array.concat()[0] !== array;\n});\n\nvar isConcatSpreadable = function (O) {\n  if (!isObject$a(O)) return false;\n  var spreadable = O[IS_CONCAT_SPREADABLE];\n  return spreadable !== undefined ? !!spreadable : isArray$c(O);\n};\n\nvar FORCED$a = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport$4('concat');\n\n// `Array.prototype.concat` method\n// https://tc39.es/ecma262/#sec-array.prototype.concat\n// with adding support of @@isConcatSpreadable and @@species\n$$J({ target: 'Array', proto: true, arity: 1, forced: FORCED$a }, {\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  concat: function concat(arg) {\n    var O = toObject$9(this);\n    var A = arraySpeciesCreate$2(O, 0);\n    var n = 0;\n    var i, k, length, len, E;\n    for (i = -1, length = arguments.length; i < length; i++) {\n      E = i === -1 ? O : arguments[i];\n      if (isConcatSpreadable(E)) {\n        len = lengthOfArrayLike$9(E);\n        doesNotExceedSafeInteger$2(n + len);\n        for (k = 0; k < len; k++, n++) if (k in E) createProperty$4(A, n, E[k]);\n      } else {\n        doesNotExceedSafeInteger$2(n + 1);\n        createProperty$4(A, n++, E);\n      }\n    }\n    A.length = n;\n    return A;\n  }\n});\n\nvar objectGetOwnPropertyNames = {};\n\nvar internalObjectKeys = objectKeysInternal;\nvar enumBugKeys = enumBugKeys$3;\n\nvar hiddenKeys$2 = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es/no-object-getownpropertynames -- safe\nobjectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys$2);\n};\n\nvar objectGetOwnPropertyNamesExternal = {};\n\nvar toAbsoluteIndex$3 = toAbsoluteIndex$5;\nvar lengthOfArrayLike$8 = lengthOfArrayLike$c;\nvar createProperty$3 = createProperty$6;\n\nvar $Array$1 = Array;\nvar max$2 = Math.max;\n\nvar arraySliceSimple = function (O, start, end) {\n  var length = lengthOfArrayLike$8(O);\n  var k = toAbsoluteIndex$3(start, length);\n  var fin = toAbsoluteIndex$3(end === undefined ? length : end, length);\n  var result = $Array$1(max$2(fin - k, 0));\n  var n = 0;\n  for (; k < fin; k++, n++) createProperty$3(result, n, O[k]);\n  result.length = n;\n  return result;\n};\n\n/* eslint-disable es/no-object-getownpropertynames -- safe */\nvar classof$6 = classofRaw$2;\nvar toIndexedObject$4 = toIndexedObject$a;\nvar $getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;\nvar arraySlice$3 = arraySliceSimple;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function (it) {\n  try {\n    return $getOwnPropertyNames$1(it);\n  } catch (error) {\n    return arraySlice$3(windowNames);\n  }\n};\n\n// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nobjectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames(it) {\n  return windowNames && classof$6(it) === 'Window'\n    ? getWindowNames(it)\n    : $getOwnPropertyNames$1(toIndexedObject$4(it));\n};\n\nvar defineProperty$5 = objectDefineProperty;\n\nvar defineBuiltInAccessor$3 = function (target, name, descriptor) {\n  return defineProperty$5.f(target, name, descriptor);\n};\n\nvar wellKnownSymbolWrapped = {};\n\nvar wellKnownSymbol$8 = wellKnownSymbol$m;\n\nwellKnownSymbolWrapped.f = wellKnownSymbol$8;\n\nvar path$p = path$w;\nvar hasOwn$8 = hasOwnProperty_1;\nvar wrappedWellKnownSymbolModule$1 = wellKnownSymbolWrapped;\nvar defineProperty$4 = objectDefineProperty.f;\n\nvar wellKnownSymbolDefine = function (NAME) {\n  var Symbol = path$p.Symbol || (path$p.Symbol = {});\n  if (!hasOwn$8(Symbol, NAME)) defineProperty$4(Symbol, NAME, {\n    value: wrappedWellKnownSymbolModule$1.f(NAME)\n  });\n};\n\nvar call$4 = functionCall;\nvar getBuiltIn$8 = getBuiltIn$c;\nvar wellKnownSymbol$7 = wellKnownSymbol$m;\nvar defineBuiltIn$2 = defineBuiltIn$5;\n\nvar symbolDefineToPrimitive = function () {\n  var Symbol = getBuiltIn$8('Symbol');\n  var SymbolPrototype = Symbol && Symbol.prototype;\n  var valueOf = SymbolPrototype && SymbolPrototype.valueOf;\n  var TO_PRIMITIVE = wellKnownSymbol$7('toPrimitive');\n\n  if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {\n    // `Symbol.prototype[@@toPrimitive]` method\n    // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive\n    // eslint-disable-next-line no-unused-vars -- required for .length\n    defineBuiltIn$2(SymbolPrototype, TO_PRIMITIVE, function (hint) {\n      return call$4(valueOf, this);\n    }, { arity: 1 });\n  }\n};\n\nvar bind$6 = functionBindContext;\nvar uncurryThis$h = functionUncurryThis;\nvar IndexedObject$1 = indexedObject;\nvar toObject$8 = toObject$e;\nvar lengthOfArrayLike$7 = lengthOfArrayLike$c;\nvar arraySpeciesCreate$1 = arraySpeciesCreate$3;\n\nvar push$a = uncurryThis$h([].push);\n\n// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation\nvar createMethod$2 = function (TYPE) {\n  var IS_MAP = TYPE === 1;\n  var IS_FILTER = TYPE === 2;\n  var IS_SOME = TYPE === 3;\n  var IS_EVERY = TYPE === 4;\n  var IS_FIND_INDEX = TYPE === 6;\n  var IS_FILTER_REJECT = TYPE === 7;\n  var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;\n  return function ($this, callbackfn, that, specificCreate) {\n    var O = toObject$8($this);\n    var self = IndexedObject$1(O);\n    var boundFunction = bind$6(callbackfn, that);\n    var length = lengthOfArrayLike$7(self);\n    var index = 0;\n    var create = specificCreate || arraySpeciesCreate$1;\n    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;\n    var value, result;\n    for (;length > index; index++) if (NO_HOLES || index in self) {\n      value = self[index];\n      result = boundFunction(value, index, O);\n      if (TYPE) {\n        if (IS_MAP) target[index] = result; // map\n        else if (result) switch (TYPE) {\n          case 3: return true;              // some\n          case 5: return value;             // find\n          case 6: return index;             // findIndex\n          case 2: push$a(target, value);      // filter\n        } else switch (TYPE) {\n          case 4: return false;             // every\n          case 7: push$a(target, value);      // filterReject\n        }\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n  };\n};\n\nvar arrayIteration = {\n  // `Array.prototype.forEach` method\n  // https://tc39.es/ecma262/#sec-array.prototype.foreach\n  forEach: createMethod$2(0),\n  // `Array.prototype.map` method\n  // https://tc39.es/ecma262/#sec-array.prototype.map\n  map: createMethod$2(1),\n  // `Array.prototype.filter` method\n  // https://tc39.es/ecma262/#sec-array.prototype.filter\n  filter: createMethod$2(2),\n  // `Array.prototype.some` method\n  // https://tc39.es/ecma262/#sec-array.prototype.some\n  some: createMethod$2(3),\n  // `Array.prototype.every` method\n  // https://tc39.es/ecma262/#sec-array.prototype.every\n  every: createMethod$2(4),\n  // `Array.prototype.find` method\n  // https://tc39.es/ecma262/#sec-array.prototype.find\n  find: createMethod$2(5),\n  // `Array.prototype.findIndex` method\n  // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n  findIndex: createMethod$2(6),\n  // `Array.prototype.filterReject` method\n  // https://github.com/tc39/proposal-array-filtering\n  filterReject: createMethod$2(7)\n};\n\nvar $$I = _export;\nvar global$b = global$n;\nvar call$3 = functionCall;\nvar uncurryThis$g = functionUncurryThis;\nvar DESCRIPTORS$8 = descriptors;\nvar NATIVE_SYMBOL$3 = symbolConstructorDetection;\nvar fails$i = fails$w;\nvar hasOwn$7 = hasOwnProperty_1;\nvar isPrototypeOf$i = objectIsPrototypeOf;\nvar anObject$5 = anObject$d;\nvar toIndexedObject$3 = toIndexedObject$a;\nvar toPropertyKey = toPropertyKey$4;\nvar $toString = toString$a;\nvar createPropertyDescriptor = createPropertyDescriptor$5;\nvar nativeObjectCreate = objectCreate;\nvar objectKeys = objectKeys$3;\nvar getOwnPropertyNamesModule$2 = objectGetOwnPropertyNames;\nvar getOwnPropertyNamesExternal = objectGetOwnPropertyNamesExternal;\nvar getOwnPropertySymbolsModule$2 = objectGetOwnPropertySymbols;\nvar getOwnPropertyDescriptorModule$2 = objectGetOwnPropertyDescriptor;\nvar definePropertyModule = objectDefineProperty;\nvar definePropertiesModule = objectDefineProperties;\nvar propertyIsEnumerableModule = objectPropertyIsEnumerable;\nvar defineBuiltIn$1 = defineBuiltIn$5;\nvar defineBuiltInAccessor$2 = defineBuiltInAccessor$3;\nvar shared$3 = sharedExports;\nvar sharedKey = sharedKey$4;\nvar hiddenKeys$1 = hiddenKeys$6;\nvar uid$1 = uid$4;\nvar wellKnownSymbol$6 = wellKnownSymbol$m;\nvar wrappedWellKnownSymbolModule = wellKnownSymbolWrapped;\nvar defineWellKnownSymbol$l = wellKnownSymbolDefine;\nvar defineSymbolToPrimitive$1 = symbolDefineToPrimitive;\nvar setToStringTag$3 = setToStringTag$6;\nvar InternalStateModule$3 = internalState;\nvar $forEach$1 = arrayIteration.forEach;\n\nvar HIDDEN = sharedKey('hidden');\nvar SYMBOL = 'Symbol';\nvar PROTOTYPE = 'prototype';\n\nvar setInternalState$3 = InternalStateModule$3.set;\nvar getInternalState = InternalStateModule$3.getterFor(SYMBOL);\n\nvar ObjectPrototype$1 = Object[PROTOTYPE];\nvar $Symbol = global$b.Symbol;\nvar SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];\nvar RangeError$1 = global$b.RangeError;\nvar TypeError$1 = global$b.TypeError;\nvar QObject = global$b.QObject;\nvar nativeGetOwnPropertyDescriptor$1 = getOwnPropertyDescriptorModule$2.f;\nvar nativeDefineProperty = definePropertyModule.f;\nvar nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;\nvar nativePropertyIsEnumerable = propertyIsEnumerableModule.f;\nvar push$9 = uncurryThis$g([].push);\n\nvar AllSymbols = shared$3('symbols');\nvar ObjectPrototypeSymbols = shared$3('op-symbols');\nvar WellKnownSymbolsStore$1 = shared$3('wks');\n\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar fallbackDefineProperty = function (O, P, Attributes) {\n  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype$1, P);\n  if (ObjectPrototypeDescriptor) delete ObjectPrototype$1[P];\n  nativeDefineProperty(O, P, Attributes);\n  if (ObjectPrototypeDescriptor && O !== ObjectPrototype$1) {\n    nativeDefineProperty(ObjectPrototype$1, P, ObjectPrototypeDescriptor);\n  }\n};\n\nvar setSymbolDescriptor = DESCRIPTORS$8 && fails$i(function () {\n  return nativeObjectCreate(nativeDefineProperty({}, 'a', {\n    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }\n  })).a !== 7;\n}) ? fallbackDefineProperty : nativeDefineProperty;\n\nvar wrap = function (tag, description) {\n  var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);\n  setInternalState$3(symbol, {\n    type: SYMBOL,\n    tag: tag,\n    description: description\n  });\n  if (!DESCRIPTORS$8) symbol.description = description;\n  return symbol;\n};\n\nvar $defineProperty = function defineProperty(O, P, Attributes) {\n  if (O === ObjectPrototype$1) $defineProperty(ObjectPrototypeSymbols, P, Attributes);\n  anObject$5(O);\n  var key = toPropertyKey(P);\n  anObject$5(Attributes);\n  if (hasOwn$7(AllSymbols, key)) {\n    if (!Attributes.enumerable) {\n      if (!hasOwn$7(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));\n      O[HIDDEN][key] = true;\n    } else {\n      if (hasOwn$7(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;\n      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });\n    } return setSymbolDescriptor(O, key, Attributes);\n  } return nativeDefineProperty(O, key, Attributes);\n};\n\nvar $defineProperties = function defineProperties(O, Properties) {\n  anObject$5(O);\n  var properties = toIndexedObject$3(Properties);\n  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));\n  $forEach$1(keys, function (key) {\n    if (!DESCRIPTORS$8 || call$3($propertyIsEnumerable, properties, key)) $defineProperty(O, key, properties[key]);\n  });\n  return O;\n};\n\nvar $create = function create(O, Properties) {\n  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);\n};\n\nvar $propertyIsEnumerable = function propertyIsEnumerable(V) {\n  var P = toPropertyKey(V);\n  var enumerable = call$3(nativePropertyIsEnumerable, this, P);\n  if (this === ObjectPrototype$1 && hasOwn$7(AllSymbols, P) && !hasOwn$7(ObjectPrototypeSymbols, P)) return false;\n  return enumerable || !hasOwn$7(this, P) || !hasOwn$7(AllSymbols, P) || hasOwn$7(this, HIDDEN) && this[HIDDEN][P]\n    ? enumerable : true;\n};\n\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {\n  var it = toIndexedObject$3(O);\n  var key = toPropertyKey(P);\n  if (it === ObjectPrototype$1 && hasOwn$7(AllSymbols, key) && !hasOwn$7(ObjectPrototypeSymbols, key)) return;\n  var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);\n  if (descriptor && hasOwn$7(AllSymbols, key) && !(hasOwn$7(it, HIDDEN) && it[HIDDEN][key])) {\n    descriptor.enumerable = true;\n  }\n  return descriptor;\n};\n\nvar $getOwnPropertyNames = function getOwnPropertyNames(O) {\n  var names = nativeGetOwnPropertyNames(toIndexedObject$3(O));\n  var result = [];\n  $forEach$1(names, function (key) {\n    if (!hasOwn$7(AllSymbols, key) && !hasOwn$7(hiddenKeys$1, key)) push$9(result, key);\n  });\n  return result;\n};\n\nvar $getOwnPropertySymbols = function (O) {\n  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype$1;\n  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject$3(O));\n  var result = [];\n  $forEach$1(names, function (key) {\n    if (hasOwn$7(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn$7(ObjectPrototype$1, key))) {\n      push$9(result, AllSymbols[key]);\n    }\n  });\n  return result;\n};\n\n// `Symbol` constructor\n// https://tc39.es/ecma262/#sec-symbol-constructor\nif (!NATIVE_SYMBOL$3) {\n  $Symbol = function Symbol() {\n    if (isPrototypeOf$i(SymbolPrototype, this)) throw new TypeError$1('Symbol is not a constructor');\n    var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);\n    var tag = uid$1(description);\n    var setter = function (value) {\n      if (this === ObjectPrototype$1) call$3(setter, ObjectPrototypeSymbols, value);\n      if (hasOwn$7(this, HIDDEN) && hasOwn$7(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n      var descriptor = createPropertyDescriptor(1, value);\n      try {\n        setSymbolDescriptor(this, tag, descriptor);\n      } catch (error) {\n        if (!(error instanceof RangeError$1)) throw error;\n        fallbackDefineProperty(this, tag, descriptor);\n      }\n    };\n    if (DESCRIPTORS$8 && USE_SETTER) setSymbolDescriptor(ObjectPrototype$1, tag, { configurable: true, set: setter });\n    return wrap(tag, description);\n  };\n\n  SymbolPrototype = $Symbol[PROTOTYPE];\n\n  defineBuiltIn$1(SymbolPrototype, 'toString', function toString() {\n    return getInternalState(this).tag;\n  });\n\n  defineBuiltIn$1($Symbol, 'withoutSetter', function (description) {\n    return wrap(uid$1(description), description);\n  });\n\n  propertyIsEnumerableModule.f = $propertyIsEnumerable;\n  definePropertyModule.f = $defineProperty;\n  definePropertiesModule.f = $defineProperties;\n  getOwnPropertyDescriptorModule$2.f = $getOwnPropertyDescriptor;\n  getOwnPropertyNamesModule$2.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;\n  getOwnPropertySymbolsModule$2.f = $getOwnPropertySymbols;\n\n  wrappedWellKnownSymbolModule.f = function (name) {\n    return wrap(wellKnownSymbol$6(name), name);\n  };\n\n  if (DESCRIPTORS$8) {\n    // https://github.com/tc39/proposal-Symbol-description\n    defineBuiltInAccessor$2(SymbolPrototype, 'description', {\n      configurable: true,\n      get: function description() {\n        return getInternalState(this).description;\n      }\n    });\n  }\n}\n\n$$I({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL$3, sham: !NATIVE_SYMBOL$3 }, {\n  Symbol: $Symbol\n});\n\n$forEach$1(objectKeys(WellKnownSymbolsStore$1), function (name) {\n  defineWellKnownSymbol$l(name);\n});\n\n$$I({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL$3 }, {\n  useSetter: function () { USE_SETTER = true; },\n  useSimple: function () { USE_SETTER = false; }\n});\n\n$$I({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL$3, sham: !DESCRIPTORS$8 }, {\n  // `Object.create` method\n  // https://tc39.es/ecma262/#sec-object.create\n  create: $create,\n  // `Object.defineProperty` method\n  // https://tc39.es/ecma262/#sec-object.defineproperty\n  defineProperty: $defineProperty,\n  // `Object.defineProperties` method\n  // https://tc39.es/ecma262/#sec-object.defineproperties\n  defineProperties: $defineProperties,\n  // `Object.getOwnPropertyDescriptor` method\n  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor\n});\n\n$$I({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL$3 }, {\n  // `Object.getOwnPropertyNames` method\n  // https://tc39.es/ecma262/#sec-object.getownpropertynames\n  getOwnPropertyNames: $getOwnPropertyNames\n});\n\n// `Symbol.prototype[@@toPrimitive]` method\n// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive\ndefineSymbolToPrimitive$1();\n\n// `Symbol.prototype[@@toStringTag]` property\n// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag\nsetToStringTag$3($Symbol, SYMBOL);\n\nhiddenKeys$1[HIDDEN] = true;\n\nvar NATIVE_SYMBOL$2 = symbolConstructorDetection;\n\n/* eslint-disable es/no-symbol -- safe */\nvar symbolRegistryDetection = NATIVE_SYMBOL$2 && !!Symbol['for'] && !!Symbol.keyFor;\n\nvar $$H = _export;\nvar getBuiltIn$7 = getBuiltIn$c;\nvar hasOwn$6 = hasOwnProperty_1;\nvar toString$6 = toString$a;\nvar shared$2 = sharedExports;\nvar NATIVE_SYMBOL_REGISTRY$1 = symbolRegistryDetection;\n\nvar StringToSymbolRegistry = shared$2('string-to-symbol-registry');\nvar SymbolToStringRegistry$1 = shared$2('symbol-to-string-registry');\n\n// `Symbol.for` method\n// https://tc39.es/ecma262/#sec-symbol.for\n$$H({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY$1 }, {\n  'for': function (key) {\n    var string = toString$6(key);\n    if (hasOwn$6(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];\n    var symbol = getBuiltIn$7('Symbol')(string);\n    StringToSymbolRegistry[string] = symbol;\n    SymbolToStringRegistry$1[symbol] = string;\n    return symbol;\n  }\n});\n\nvar $$G = _export;\nvar hasOwn$5 = hasOwnProperty_1;\nvar isSymbol$2 = isSymbol$5;\nvar tryToString$3 = tryToString$6;\nvar shared$1 = sharedExports;\nvar NATIVE_SYMBOL_REGISTRY = symbolRegistryDetection;\n\nvar SymbolToStringRegistry = shared$1('symbol-to-string-registry');\n\n// `Symbol.keyFor` method\n// https://tc39.es/ecma262/#sec-symbol.keyfor\n$$G({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {\n  keyFor: function keyFor(sym) {\n    if (!isSymbol$2(sym)) throw new TypeError(tryToString$3(sym) + ' is not a symbol');\n    if (hasOwn$5(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];\n  }\n});\n\nvar uncurryThis$f = functionUncurryThis;\nvar isArray$b = isArray$e;\nvar isCallable$3 = isCallable$i;\nvar classof$5 = classofRaw$2;\nvar toString$5 = toString$a;\n\nvar push$8 = uncurryThis$f([].push);\n\nvar getJsonReplacerFunction = function (replacer) {\n  if (isCallable$3(replacer)) return replacer;\n  if (!isArray$b(replacer)) return;\n  var rawLength = replacer.length;\n  var keys = [];\n  for (var i = 0; i < rawLength; i++) {\n    var element = replacer[i];\n    if (typeof element == 'string') push$8(keys, element);\n    else if (typeof element == 'number' || classof$5(element) === 'Number' || classof$5(element) === 'String') push$8(keys, toString$5(element));\n  }\n  var keysLength = keys.length;\n  var root = true;\n  return function (key, value) {\n    if (root) {\n      root = false;\n      return value;\n    }\n    if (isArray$b(this)) return value;\n    for (var j = 0; j < keysLength; j++) if (keys[j] === key) return value;\n  };\n};\n\nvar $$F = _export;\nvar getBuiltIn$6 = getBuiltIn$c;\nvar apply$3 = functionApply;\nvar call$2 = functionCall;\nvar uncurryThis$e = functionUncurryThis;\nvar fails$h = fails$w;\nvar isCallable$2 = isCallable$i;\nvar isSymbol$1 = isSymbol$5;\nvar arraySlice$2 = arraySlice$5;\nvar getReplacerFunction = getJsonReplacerFunction;\nvar NATIVE_SYMBOL$1 = symbolConstructorDetection;\n\nvar $String = String;\nvar $stringify = getBuiltIn$6('JSON', 'stringify');\nvar exec$1 = uncurryThis$e(/./.exec);\nvar charAt$1 = uncurryThis$e(''.charAt);\nvar charCodeAt = uncurryThis$e(''.charCodeAt);\nvar replace$1 = uncurryThis$e(''.replace);\nvar numberToString = uncurryThis$e(1.0.toString);\n\nvar tester = /[\\uD800-\\uDFFF]/g;\nvar low = /^[\\uD800-\\uDBFF]$/;\nvar hi = /^[\\uDC00-\\uDFFF]$/;\n\nvar WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL$1 || fails$h(function () {\n  var symbol = getBuiltIn$6('Symbol')('stringify detection');\n  // MS Edge converts symbol values to JSON as {}\n  return $stringify([symbol]) !== '[null]'\n    // WebKit converts symbol values to JSON as null\n    || $stringify({ a: symbol }) !== '{}'\n    // V8 throws on boxed symbols\n    || $stringify(Object(symbol)) !== '{}';\n});\n\n// https://github.com/tc39/proposal-well-formed-stringify\nvar ILL_FORMED_UNICODE = fails$h(function () {\n  return $stringify('\\uDF06\\uD834') !== '\"\\\\udf06\\\\ud834\"'\n    || $stringify('\\uDEAD') !== '\"\\\\udead\"';\n});\n\nvar stringifyWithSymbolsFix = function (it, replacer) {\n  var args = arraySlice$2(arguments);\n  var $replacer = getReplacerFunction(replacer);\n  if (!isCallable$2($replacer) && (it === undefined || isSymbol$1(it))) return; // IE8 returns string on undefined\n  args[1] = function (key, value) {\n    // some old implementations (like WebKit) could pass numbers as keys\n    if (isCallable$2($replacer)) value = call$2($replacer, this, $String(key), value);\n    if (!isSymbol$1(value)) return value;\n  };\n  return apply$3($stringify, null, args);\n};\n\nvar fixIllFormed = function (match, offset, string) {\n  var prev = charAt$1(string, offset - 1);\n  var next = charAt$1(string, offset + 1);\n  if ((exec$1(low, match) && !exec$1(hi, next)) || (exec$1(hi, match) && !exec$1(low, prev))) {\n    return '\\\\u' + numberToString(charCodeAt(match, 0), 16);\n  } return match;\n};\n\nif ($stringify) {\n  // `JSON.stringify` method\n  // https://tc39.es/ecma262/#sec-json.stringify\n  $$F({ target: 'JSON', stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {\n    // eslint-disable-next-line no-unused-vars -- required for `.length`\n    stringify: function stringify(it, replacer, space) {\n      var args = arraySlice$2(arguments);\n      var result = apply$3(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);\n      return ILL_FORMED_UNICODE && typeof result == 'string' ? replace$1(result, tester, fixIllFormed) : result;\n    }\n  });\n}\n\nvar $$E = _export;\nvar NATIVE_SYMBOL = symbolConstructorDetection;\nvar fails$g = fails$w;\nvar getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;\nvar toObject$7 = toObject$e;\n\n// V8 ~ Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives\n// https://bugs.chromium.org/p/v8/issues/detail?id=3443\nvar FORCED$9 = !NATIVE_SYMBOL || fails$g(function () { getOwnPropertySymbolsModule$1.f(1); });\n\n// `Object.getOwnPropertySymbols` method\n// https://tc39.es/ecma262/#sec-object.getownpropertysymbols\n$$E({ target: 'Object', stat: true, forced: FORCED$9 }, {\n  getOwnPropertySymbols: function getOwnPropertySymbols(it) {\n    var $getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;\n    return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject$7(it)) : [];\n  }\n});\n\nvar defineWellKnownSymbol$k = wellKnownSymbolDefine;\n\n// `Symbol.asyncIterator` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.asynciterator\ndefineWellKnownSymbol$k('asyncIterator');\n\nvar defineWellKnownSymbol$j = wellKnownSymbolDefine;\n\n// `Symbol.hasInstance` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.hasinstance\ndefineWellKnownSymbol$j('hasInstance');\n\nvar defineWellKnownSymbol$i = wellKnownSymbolDefine;\n\n// `Symbol.isConcatSpreadable` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.isconcatspreadable\ndefineWellKnownSymbol$i('isConcatSpreadable');\n\nvar defineWellKnownSymbol$h = wellKnownSymbolDefine;\n\n// `Symbol.iterator` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.iterator\ndefineWellKnownSymbol$h('iterator');\n\nvar defineWellKnownSymbol$g = wellKnownSymbolDefine;\n\n// `Symbol.match` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.match\ndefineWellKnownSymbol$g('match');\n\nvar defineWellKnownSymbol$f = wellKnownSymbolDefine;\n\n// `Symbol.matchAll` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.matchall\ndefineWellKnownSymbol$f('matchAll');\n\nvar defineWellKnownSymbol$e = wellKnownSymbolDefine;\n\n// `Symbol.replace` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.replace\ndefineWellKnownSymbol$e('replace');\n\nvar defineWellKnownSymbol$d = wellKnownSymbolDefine;\n\n// `Symbol.search` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.search\ndefineWellKnownSymbol$d('search');\n\nvar defineWellKnownSymbol$c = wellKnownSymbolDefine;\n\n// `Symbol.species` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.species\ndefineWellKnownSymbol$c('species');\n\nvar defineWellKnownSymbol$b = wellKnownSymbolDefine;\n\n// `Symbol.split` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.split\ndefineWellKnownSymbol$b('split');\n\nvar defineWellKnownSymbol$a = wellKnownSymbolDefine;\nvar defineSymbolToPrimitive = symbolDefineToPrimitive;\n\n// `Symbol.toPrimitive` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.toprimitive\ndefineWellKnownSymbol$a('toPrimitive');\n\n// `Symbol.prototype[@@toPrimitive]` method\n// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive\ndefineSymbolToPrimitive();\n\nvar getBuiltIn$5 = getBuiltIn$c;\nvar defineWellKnownSymbol$9 = wellKnownSymbolDefine;\nvar setToStringTag$2 = setToStringTag$6;\n\n// `Symbol.toStringTag` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.tostringtag\ndefineWellKnownSymbol$9('toStringTag');\n\n// `Symbol.prototype[@@toStringTag]` property\n// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag\nsetToStringTag$2(getBuiltIn$5('Symbol'), 'Symbol');\n\nvar defineWellKnownSymbol$8 = wellKnownSymbolDefine;\n\n// `Symbol.unscopables` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.unscopables\ndefineWellKnownSymbol$8('unscopables');\n\nvar global$a = global$n;\nvar setToStringTag$1 = setToStringTag$6;\n\n// JSON[@@toStringTag] property\n// https://tc39.es/ecma262/#sec-json-@@tostringtag\nsetToStringTag$1(global$a.JSON, 'JSON', true);\n\nvar path$o = path$w;\n\nvar symbol$5 = path$o.Symbol;\n\nvar parent$12 = symbol$5;\n\n\nvar symbol$4 = parent$12;\n\nvar wellKnownSymbol$5 = wellKnownSymbol$m;\nvar defineProperty$3 = objectDefineProperty.f;\n\nvar METADATA$1 = wellKnownSymbol$5('metadata');\nvar FunctionPrototype = Function.prototype;\n\n// Function.prototype[@@metadata]\n// https://github.com/tc39/proposal-decorator-metadata\nif (FunctionPrototype[METADATA$1] === undefined) {\n  defineProperty$3(FunctionPrototype, METADATA$1, {\n    value: null\n  });\n}\n\nvar defineWellKnownSymbol$7 = wellKnownSymbolDefine;\n\n// `Symbol.asyncDispose` well-known symbol\n// https://github.com/tc39/proposal-async-explicit-resource-management\ndefineWellKnownSymbol$7('asyncDispose');\n\nvar defineWellKnownSymbol$6 = wellKnownSymbolDefine;\n\n// `Symbol.dispose` well-known symbol\n// https://github.com/tc39/proposal-explicit-resource-management\ndefineWellKnownSymbol$6('dispose');\n\n// TODO: Remove from `core-js@4`\nvar defineWellKnownSymbol$5 = wellKnownSymbolDefine;\n\n// `Symbol.metadata` well-known symbol\n// https://github.com/tc39/proposal-decorators\ndefineWellKnownSymbol$5('metadata');\n\nvar parent$11 = symbol$4;\n\n\n\n\n\n\nvar symbol$3 = parent$11;\n\nvar getBuiltIn$4 = getBuiltIn$c;\nvar uncurryThis$d = functionUncurryThis;\n\nvar Symbol$4 = getBuiltIn$4('Symbol');\nvar keyFor = Symbol$4.keyFor;\nvar thisSymbolValue$1 = uncurryThis$d(Symbol$4.prototype.valueOf);\n\n// `Symbol.isRegisteredSymbol` method\n// https://tc39.es/proposal-symbol-predicates/#sec-symbol-isregisteredsymbol\nvar symbolIsRegistered = Symbol$4.isRegisteredSymbol || function isRegisteredSymbol(value) {\n  try {\n    return keyFor(thisSymbolValue$1(value)) !== undefined;\n  } catch (error) {\n    return false;\n  }\n};\n\nvar $$D = _export;\nvar isRegisteredSymbol$1 = symbolIsRegistered;\n\n// `Symbol.isRegisteredSymbol` method\n// https://tc39.es/proposal-symbol-predicates/#sec-symbol-isregisteredsymbol\n$$D({ target: 'Symbol', stat: true }, {\n  isRegisteredSymbol: isRegisteredSymbol$1\n});\n\nvar shared = sharedExports;\nvar getBuiltIn$3 = getBuiltIn$c;\nvar uncurryThis$c = functionUncurryThis;\nvar isSymbol = isSymbol$5;\nvar wellKnownSymbol$4 = wellKnownSymbol$m;\n\nvar Symbol$3 = getBuiltIn$3('Symbol');\nvar $isWellKnownSymbol = Symbol$3.isWellKnownSymbol;\nvar getOwnPropertyNames$4 = getBuiltIn$3('Object', 'getOwnPropertyNames');\nvar thisSymbolValue = uncurryThis$c(Symbol$3.prototype.valueOf);\nvar WellKnownSymbolsStore = shared('wks');\n\nfor (var i = 0, symbolKeys = getOwnPropertyNames$4(Symbol$3), symbolKeysLength = symbolKeys.length; i < symbolKeysLength; i++) {\n  // some old engines throws on access to some keys like `arguments` or `caller`\n  try {\n    var symbolKey = symbolKeys[i];\n    if (isSymbol(Symbol$3[symbolKey])) wellKnownSymbol$4(symbolKey);\n  } catch (error) { /* empty */ }\n}\n\n// `Symbol.isWellKnownSymbol` method\n// https://tc39.es/proposal-symbol-predicates/#sec-symbol-iswellknownsymbol\n// We should patch it for newly added well-known symbols. If it's not required, this module just will not be injected\nvar symbolIsWellKnown = function isWellKnownSymbol(value) {\n  if ($isWellKnownSymbol && $isWellKnownSymbol(value)) return true;\n  try {\n    var symbol = thisSymbolValue(value);\n    for (var j = 0, keys = getOwnPropertyNames$4(WellKnownSymbolsStore), keysLength = keys.length; j < keysLength; j++) {\n      // eslint-disable-next-line eqeqeq -- polyfilled symbols case\n      if (WellKnownSymbolsStore[keys[j]] == symbol) return true;\n    }\n  } catch (error) { /* empty */ }\n  return false;\n};\n\nvar $$C = _export;\nvar isWellKnownSymbol$1 = symbolIsWellKnown;\n\n// `Symbol.isWellKnownSymbol` method\n// https://tc39.es/proposal-symbol-predicates/#sec-symbol-iswellknownsymbol\n// We should patch it for newly added well-known symbols. If it's not required, this module just will not be injected\n$$C({ target: 'Symbol', stat: true, forced: true }, {\n  isWellKnownSymbol: isWellKnownSymbol$1\n});\n\nvar defineWellKnownSymbol$4 = wellKnownSymbolDefine;\n\n// `Symbol.matcher` well-known symbol\n// https://github.com/tc39/proposal-pattern-matching\ndefineWellKnownSymbol$4('matcher');\n\nvar defineWellKnownSymbol$3 = wellKnownSymbolDefine;\n\n// `Symbol.observable` well-known symbol\n// https://github.com/tc39/proposal-observable\ndefineWellKnownSymbol$3('observable');\n\nvar $$B = _export;\nvar isRegisteredSymbol = symbolIsRegistered;\n\n// `Symbol.isRegistered` method\n// obsolete version of https://tc39.es/proposal-symbol-predicates/#sec-symbol-isregisteredsymbol\n$$B({ target: 'Symbol', stat: true, name: 'isRegisteredSymbol' }, {\n  isRegistered: isRegisteredSymbol\n});\n\nvar $$A = _export;\nvar isWellKnownSymbol = symbolIsWellKnown;\n\n// `Symbol.isWellKnown` method\n// obsolete version of https://tc39.es/proposal-symbol-predicates/#sec-symbol-iswellknownsymbol\n// We should patch it for newly added well-known symbols. If it's not required, this module just will not be injected\n$$A({ target: 'Symbol', stat: true, name: 'isWellKnownSymbol', forced: true }, {\n  isWellKnown: isWellKnownSymbol\n});\n\nvar defineWellKnownSymbol$2 = wellKnownSymbolDefine;\n\n// `Symbol.metadataKey` well-known symbol\n// https://github.com/tc39/proposal-decorator-metadata\ndefineWellKnownSymbol$2('metadataKey');\n\n// TODO: remove from `core-js@4`\nvar defineWellKnownSymbol$1 = wellKnownSymbolDefine;\n\n// `Symbol.patternMatch` well-known symbol\n// https://github.com/tc39/proposal-pattern-matching\ndefineWellKnownSymbol$1('patternMatch');\n\n// TODO: remove from `core-js@4`\nvar defineWellKnownSymbol = wellKnownSymbolDefine;\n\ndefineWellKnownSymbol('replaceAll');\n\nvar parent$10 = symbol$3;\n\n\n\n\n// TODO: Remove from `core-js@4`\n\n\n\n\n\n\nvar symbol$2 = parent$10;\n\nvar symbol$1 = symbol$2;\n\nvar _Symbol$1 = /*@__PURE__*/getDefaultExportFromCjs(symbol$1);\n\nvar WrappedWellKnownSymbolModule$1 = wellKnownSymbolWrapped;\n\nvar iterator$4 = WrappedWellKnownSymbolModule$1.f('iterator');\n\nvar parent$$ = iterator$4;\n\n\nvar iterator$3 = parent$$;\n\nvar parent$_ = iterator$3;\n\nvar iterator$2 = parent$_;\n\nvar parent$Z = iterator$2;\n\nvar iterator$1 = parent$Z;\n\nvar iterator = iterator$1;\n\nvar _Symbol$iterator = /*@__PURE__*/getDefaultExportFromCjs(iterator);\n\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof _Symbol$1 && \"symbol\" == typeof _Symbol$iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof _Symbol$1 && o.constructor === _Symbol$1 && o !== _Symbol$1.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\nvar WrappedWellKnownSymbolModule = wellKnownSymbolWrapped;\n\nvar toPrimitive$4 = WrappedWellKnownSymbolModule.f('toPrimitive');\n\nvar parent$Y = toPrimitive$4;\n\nvar toPrimitive$3 = parent$Y;\n\nvar parent$X = toPrimitive$3;\n\nvar toPrimitive$2 = parent$X;\n\nvar parent$W = toPrimitive$2;\n\nvar toPrimitive$1 = parent$W;\n\nvar toPrimitive = toPrimitive$1;\n\nvar _Symbol$toPrimitive = /*@__PURE__*/getDefaultExportFromCjs(toPrimitive);\n\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[_Symbol$toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    _Object$defineProperty$1(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  _Object$defineProperty$1(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nvar $$z = _export;\nvar isArray$a = isArray$e;\n\n// `Array.isArray` method\n// https://tc39.es/ecma262/#sec-array.isarray\n$$z({ target: 'Array', stat: true }, {\n  isArray: isArray$a\n});\n\nvar path$n = path$w;\n\nvar isArray$9 = path$n.Array.isArray;\n\nvar parent$V = isArray$9;\n\nvar isArray$8 = parent$V;\n\nvar parent$U = isArray$8;\n\nvar isArray$7 = parent$U;\n\nvar parent$T = isArray$7;\n\nvar isArray$6 = parent$T;\n\nvar isArray$5 = isArray$6;\n\nvar _Array$isArray$1 = /*@__PURE__*/getDefaultExportFromCjs(isArray$5);\n\nfunction _arrayWithHoles(arr) {\n  if (_Array$isArray$1(arr)) return arr;\n}\n\nvar DESCRIPTORS$7 = descriptors;\nvar isArray$4 = isArray$e;\n\nvar $TypeError$7 = TypeError;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor$7 = Object.getOwnPropertyDescriptor;\n\n// Safari < 13 does not throw an error in this case\nvar SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS$7 && !function () {\n  // makes no sense without proper strict mode support\n  if (this !== undefined) return true;\n  try {\n    // eslint-disable-next-line es/no-object-defineproperty -- safe\n    Object.defineProperty([], 'length', { writable: false }).length = 1;\n  } catch (error) {\n    return error instanceof TypeError;\n  }\n}();\n\nvar arraySetLength = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {\n  if (isArray$4(O) && !getOwnPropertyDescriptor$7(O, 'length').writable) {\n    throw new $TypeError$7('Cannot set read only .length');\n  } return O.length = length;\n} : function (O, length) {\n  return O.length = length;\n};\n\nvar $$y = _export;\nvar toObject$6 = toObject$e;\nvar lengthOfArrayLike$6 = lengthOfArrayLike$c;\nvar setArrayLength$1 = arraySetLength;\nvar doesNotExceedSafeInteger$1 = doesNotExceedSafeInteger$3;\nvar fails$f = fails$w;\n\nvar INCORRECT_TO_LENGTH = fails$f(function () {\n  return [].push.call({ length: 0x100000000 }, 1) !== 4294967297;\n});\n\n// V8 and Safari <= 15.4, FF < 23 throws InternalError\n// https://bugs.chromium.org/p/v8/issues/detail?id=12681\nvar properErrorOnNonWritableLength = function () {\n  try {\n    // eslint-disable-next-line es/no-object-defineproperty -- safe\n    Object.defineProperty([], 'length', { writable: false }).push();\n  } catch (error) {\n    return error instanceof TypeError;\n  }\n};\n\nvar FORCED$8 = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();\n\n// `Array.prototype.push` method\n// https://tc39.es/ecma262/#sec-array.prototype.push\n$$y({ target: 'Array', proto: true, arity: 1, forced: FORCED$8 }, {\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  push: function push(item) {\n    var O = toObject$6(this);\n    var len = lengthOfArrayLike$6(O);\n    var argCount = arguments.length;\n    doesNotExceedSafeInteger$1(len + argCount);\n    for (var i = 0; i < argCount; i++) {\n      O[len] = arguments[i];\n      len++;\n    }\n    setArrayLength$1(O, len);\n    return len;\n  }\n});\n\nvar entryVirtual$g = entryVirtual$i;\n\nvar push$7 = entryVirtual$g('Array').push;\n\nvar isPrototypeOf$h = objectIsPrototypeOf;\nvar method$e = push$7;\n\nvar ArrayPrototype$f = Array.prototype;\n\nvar push$6 = function (it) {\n  var own = it.push;\n  return it === ArrayPrototype$f || (isPrototypeOf$h(ArrayPrototype$f, it) && own === ArrayPrototype$f.push) ? method$e : own;\n};\n\nvar parent$S = push$6;\n\nvar push$5 = parent$S;\n\nvar parent$R = push$5;\n\nvar push$4 = parent$R;\n\nvar parent$Q = push$4;\n\nvar push$3 = parent$Q;\n\nvar push$2 = push$3;\n\nvar _pushInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(push$2);\n\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof _Symbol$1 && _getIteratorMethod$1(r) || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (_pushInstanceProperty(a).call(a, e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\n\nvar $$x = _export;\nvar isArray$3 = isArray$e;\nvar isConstructor$1 = isConstructor$4;\nvar isObject$9 = isObject$j;\nvar toAbsoluteIndex$2 = toAbsoluteIndex$5;\nvar lengthOfArrayLike$5 = lengthOfArrayLike$c;\nvar toIndexedObject$2 = toIndexedObject$a;\nvar createProperty$2 = createProperty$6;\nvar wellKnownSymbol$3 = wellKnownSymbol$m;\nvar arrayMethodHasSpeciesSupport$3 = arrayMethodHasSpeciesSupport$5;\nvar nativeSlice = arraySlice$5;\n\nvar HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport$3('slice');\n\nvar SPECIES$1 = wellKnownSymbol$3('species');\nvar $Array = Array;\nvar max$1 = Math.max;\n\n// `Array.prototype.slice` method\n// https://tc39.es/ecma262/#sec-array.prototype.slice\n// fallback for not array-like ES3 strings and DOM objects\n$$x({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$3 }, {\n  slice: function slice(start, end) {\n    var O = toIndexedObject$2(this);\n    var length = lengthOfArrayLike$5(O);\n    var k = toAbsoluteIndex$2(start, length);\n    var fin = toAbsoluteIndex$2(end === undefined ? length : end, length);\n    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible\n    var Constructor, result, n;\n    if (isArray$3(O)) {\n      Constructor = O.constructor;\n      // cross-realm fallback\n      if (isConstructor$1(Constructor) && (Constructor === $Array || isArray$3(Constructor.prototype))) {\n        Constructor = undefined;\n      } else if (isObject$9(Constructor)) {\n        Constructor = Constructor[SPECIES$1];\n        if (Constructor === null) Constructor = undefined;\n      }\n      if (Constructor === $Array || Constructor === undefined) {\n        return nativeSlice(O, k, fin);\n      }\n    }\n    result = new (Constructor === undefined ? $Array : Constructor)(max$1(fin - k, 0));\n    for (n = 0; k < fin; k++, n++) if (k in O) createProperty$2(result, n, O[k]);\n    result.length = n;\n    return result;\n  }\n});\n\nvar entryVirtual$f = entryVirtual$i;\n\nvar slice$6 = entryVirtual$f('Array').slice;\n\nvar isPrototypeOf$g = objectIsPrototypeOf;\nvar method$d = slice$6;\n\nvar ArrayPrototype$e = Array.prototype;\n\nvar slice$5 = function (it) {\n  var own = it.slice;\n  return it === ArrayPrototype$e || (isPrototypeOf$g(ArrayPrototype$e, it) && own === ArrayPrototype$e.slice) ? method$d : own;\n};\n\nvar parent$P = slice$5;\n\nvar slice$4 = parent$P;\n\nvar parent$O = slice$4;\n\nvar slice$3 = parent$O;\n\nvar parent$N = slice$3;\n\nvar slice$2 = parent$N;\n\nvar slice$1 = slice$2;\n\nvar _sliceInstanceProperty$1 = /*@__PURE__*/getDefaultExportFromCjs(slice$1);\n\nvar parent$M = from$4;\n\nvar from$2 = parent$M;\n\nvar parent$L = from$2;\n\nvar from$1 = parent$L;\n\nvar from = from$1;\n\nvar _Array$from = /*@__PURE__*/getDefaultExportFromCjs(from);\n\nfunction _arrayLikeToArray$7(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\n\nfunction _unsupportedIterableToArray$7(o, minLen) {\n  var _context;\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray$7(o, minLen);\n  var n = _sliceInstanceProperty$1(_context = Object.prototype.toString.call(o)).call(_context, 8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return _Array$from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen);\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$7(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (_Array$isArray$1(arr)) return _arrayLikeToArray$7(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof _Symbol$1 !== \"undefined\" && _getIteratorMethod$1(iter) != null || iter[\"@@iterator\"] != null) return _Array$from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$7(arr) || _nonIterableSpread();\n}\n\nvar symbol = symbol$4;\n\nvar _Symbol = /*@__PURE__*/getDefaultExportFromCjs(symbol);\n\nvar entryVirtual$e = entryVirtual$i;\n\nvar concat$4 = entryVirtual$e('Array').concat;\n\nvar isPrototypeOf$f = objectIsPrototypeOf;\nvar method$c = concat$4;\n\nvar ArrayPrototype$d = Array.prototype;\n\nvar concat$3 = function (it) {\n  var own = it.concat;\n  return it === ArrayPrototype$d || (isPrototypeOf$f(ArrayPrototype$d, it) && own === ArrayPrototype$d.concat) ? method$c : own;\n};\n\nvar parent$K = concat$3;\n\nvar concat$2 = parent$K;\n\nvar concat$1 = concat$2;\n\nvar _concatInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(concat$1);\n\nvar slice = slice$4;\n\nvar _sliceInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(slice);\n\nvar getBuiltIn$2 = getBuiltIn$c;\nvar uncurryThis$b = functionUncurryThis;\nvar getOwnPropertyNamesModule$1 = objectGetOwnPropertyNames;\nvar getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;\nvar anObject$4 = anObject$d;\n\nvar concat = uncurryThis$b([].concat);\n\n// all object keys, includes non-enumerable and symbols\nvar ownKeys$5 = getBuiltIn$2('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule$1.f(anObject$4(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n};\n\nvar isArray$2 = isArray$8;\n\nvar _Array$isArray = /*@__PURE__*/getDefaultExportFromCjs(isArray$2);\n\nvar $$w = _export;\nvar $map = arrayIteration.map;\nvar arrayMethodHasSpeciesSupport$2 = arrayMethodHasSpeciesSupport$5;\n\nvar HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport$2('map');\n\n// `Array.prototype.map` method\n// https://tc39.es/ecma262/#sec-array.prototype.map\n// with adding support of @@species\n$$w({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$2 }, {\n  map: function map(callbackfn /* , thisArg */) {\n    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar entryVirtual$d = entryVirtual$i;\n\nvar map$6 = entryVirtual$d('Array').map;\n\nvar isPrototypeOf$e = objectIsPrototypeOf;\nvar method$b = map$6;\n\nvar ArrayPrototype$c = Array.prototype;\n\nvar map$5 = function (it) {\n  var own = it.map;\n  return it === ArrayPrototype$c || (isPrototypeOf$e(ArrayPrototype$c, it) && own === ArrayPrototype$c.map) ? method$b : own;\n};\n\nvar parent$J = map$5;\n\nvar map$4 = parent$J;\n\nvar map$3 = map$4;\n\nvar _mapInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(map$3);\n\nvar $$v = _export;\nvar toObject$5 = toObject$e;\nvar nativeKeys = objectKeys$3;\nvar fails$e = fails$w;\n\nvar FAILS_ON_PRIMITIVES$3 = fails$e(function () { nativeKeys(1); });\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n$$v({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$3 }, {\n  keys: function keys(it) {\n    return nativeKeys(toObject$5(it));\n  }\n});\n\nvar path$m = path$w;\n\nvar keys$2 = path$m.Object.keys;\n\nvar parent$I = keys$2;\n\nvar keys$1 = parent$I;\n\nvar keys = keys$1;\n\nvar _Object$keys = /*@__PURE__*/getDefaultExportFromCjs(keys);\n\n// TODO: Remove from `core-js@4`\nvar $$u = _export;\nvar uncurryThis$a = functionUncurryThis;\n\nvar $Date = Date;\nvar thisTimeValue = uncurryThis$a($Date.prototype.getTime);\n\n// `Date.now` method\n// https://tc39.es/ecma262/#sec-date.now\n$$u({ target: 'Date', stat: true }, {\n  now: function now() {\n    return thisTimeValue(new $Date());\n  }\n});\n\nvar path$l = path$w;\n\nvar now$3 = path$l.Date.now;\n\nvar parent$H = now$3;\n\nvar now$2 = parent$H;\n\nvar now$1 = now$2;\n\nvar _Date$now = /*@__PURE__*/getDefaultExportFromCjs(now$1);\n\nvar fails$d = fails$w;\n\nvar arrayMethodIsStrict$6 = function (METHOD_NAME, argument) {\n  var method = [][METHOD_NAME];\n  return !!method && fails$d(function () {\n    // eslint-disable-next-line no-useless-call -- required for testing\n    method.call(null, argument || function () { return 1; }, 1);\n  });\n};\n\nvar $forEach = arrayIteration.forEach;\nvar arrayMethodIsStrict$5 = arrayMethodIsStrict$6;\n\nvar STRICT_METHOD$3 = arrayMethodIsStrict$5('forEach');\n\n// `Array.prototype.forEach` method implementation\n// https://tc39.es/ecma262/#sec-array.prototype.foreach\nvar arrayForEach = !STRICT_METHOD$3 ? function forEach(callbackfn /* , thisArg */) {\n  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n// eslint-disable-next-line es/no-array-prototype-foreach -- safe\n} : [].forEach;\n\nvar $$t = _export;\nvar forEach$6 = arrayForEach;\n\n// `Array.prototype.forEach` method\n// https://tc39.es/ecma262/#sec-array.prototype.foreach\n// eslint-disable-next-line es/no-array-prototype-foreach -- safe\n$$t({ target: 'Array', proto: true, forced: [].forEach !== forEach$6 }, {\n  forEach: forEach$6\n});\n\nvar entryVirtual$c = entryVirtual$i;\n\nvar forEach$5 = entryVirtual$c('Array').forEach;\n\nvar parent$G = forEach$5;\n\nvar forEach$4 = parent$G;\n\nvar classof$4 = classof$d;\nvar hasOwn$4 = hasOwnProperty_1;\nvar isPrototypeOf$d = objectIsPrototypeOf;\nvar method$a = forEach$4;\n\nvar ArrayPrototype$b = Array.prototype;\n\nvar DOMIterables$1 = {\n  DOMTokenList: true,\n  NodeList: true\n};\n\nvar forEach$3 = function (it) {\n  var own = it.forEach;\n  return it === ArrayPrototype$b || (isPrototypeOf$d(ArrayPrototype$b, it) && own === ArrayPrototype$b.forEach)\n    || hasOwn$4(DOMIterables$1, classof$4(it)) ? method$a : own;\n};\n\nvar forEach$2 = forEach$3;\n\nvar _forEachInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(forEach$2);\n\nvar $$s = _export;\nvar uncurryThis$9 = functionUncurryThis;\nvar isArray$1 = isArray$e;\n\nvar nativeReverse = uncurryThis$9([].reverse);\nvar test$1 = [1, 2];\n\n// `Array.prototype.reverse` method\n// https://tc39.es/ecma262/#sec-array.prototype.reverse\n// fix for Safari 12.0 bug\n// https://bugs.webkit.org/show_bug.cgi?id=188794\n$$s({ target: 'Array', proto: true, forced: String(test$1) === String(test$1.reverse()) }, {\n  reverse: function reverse() {\n    // eslint-disable-next-line no-self-assign -- dirty hack\n    if (isArray$1(this)) this.length = this.length;\n    return nativeReverse(this);\n  }\n});\n\nvar entryVirtual$b = entryVirtual$i;\n\nvar reverse$3 = entryVirtual$b('Array').reverse;\n\nvar isPrototypeOf$c = objectIsPrototypeOf;\nvar method$9 = reverse$3;\n\nvar ArrayPrototype$a = Array.prototype;\n\nvar reverse$2 = function (it) {\n  var own = it.reverse;\n  return it === ArrayPrototype$a || (isPrototypeOf$c(ArrayPrototype$a, it) && own === ArrayPrototype$a.reverse) ? method$9 : own;\n};\n\nvar parent$F = reverse$2;\n\nvar reverse$1 = parent$F;\n\nvar reverse = reverse$1;\n\nvar _reverseInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(reverse);\n\nvar tryToString$2 = tryToString$6;\n\nvar $TypeError$6 = TypeError;\n\nvar deletePropertyOrThrow$2 = function (O, P) {\n  if (!delete O[P]) throw new $TypeError$6('Cannot delete property ' + tryToString$2(P) + ' of ' + tryToString$2(O));\n};\n\nvar $$r = _export;\nvar toObject$4 = toObject$e;\nvar toAbsoluteIndex$1 = toAbsoluteIndex$5;\nvar toIntegerOrInfinity = toIntegerOrInfinity$4;\nvar lengthOfArrayLike$4 = lengthOfArrayLike$c;\nvar setArrayLength = arraySetLength;\nvar doesNotExceedSafeInteger = doesNotExceedSafeInteger$3;\nvar arraySpeciesCreate = arraySpeciesCreate$3;\nvar createProperty$1 = createProperty$6;\nvar deletePropertyOrThrow$1 = deletePropertyOrThrow$2;\nvar arrayMethodHasSpeciesSupport$1 = arrayMethodHasSpeciesSupport$5;\n\nvar HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport$1('splice');\n\nvar max = Math.max;\nvar min = Math.min;\n\n// `Array.prototype.splice` method\n// https://tc39.es/ecma262/#sec-array.prototype.splice\n// with adding support of @@species\n$$r({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$1 }, {\n  splice: function splice(start, deleteCount /* , ...items */) {\n    var O = toObject$4(this);\n    var len = lengthOfArrayLike$4(O);\n    var actualStart = toAbsoluteIndex$1(start, len);\n    var argumentsLength = arguments.length;\n    var insertCount, actualDeleteCount, A, k, from, to;\n    if (argumentsLength === 0) {\n      insertCount = actualDeleteCount = 0;\n    } else if (argumentsLength === 1) {\n      insertCount = 0;\n      actualDeleteCount = len - actualStart;\n    } else {\n      insertCount = argumentsLength - 2;\n      actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);\n    }\n    doesNotExceedSafeInteger(len + insertCount - actualDeleteCount);\n    A = arraySpeciesCreate(O, actualDeleteCount);\n    for (k = 0; k < actualDeleteCount; k++) {\n      from = actualStart + k;\n      if (from in O) createProperty$1(A, k, O[from]);\n    }\n    A.length = actualDeleteCount;\n    if (insertCount < actualDeleteCount) {\n      for (k = actualStart; k < len - actualDeleteCount; k++) {\n        from = k + actualDeleteCount;\n        to = k + insertCount;\n        if (from in O) O[to] = O[from];\n        else deletePropertyOrThrow$1(O, to);\n      }\n      for (k = len; k > len - actualDeleteCount + insertCount; k--) deletePropertyOrThrow$1(O, k - 1);\n    } else if (insertCount > actualDeleteCount) {\n      for (k = len - actualDeleteCount; k > actualStart; k--) {\n        from = k + actualDeleteCount - 1;\n        to = k + insertCount - 1;\n        if (from in O) O[to] = O[from];\n        else deletePropertyOrThrow$1(O, to);\n      }\n    }\n    for (k = 0; k < insertCount; k++) {\n      O[k + actualStart] = arguments[k + 2];\n    }\n    setArrayLength(O, len - actualDeleteCount + insertCount);\n    return A;\n  }\n});\n\nvar entryVirtual$a = entryVirtual$i;\n\nvar splice$4 = entryVirtual$a('Array').splice;\n\nvar isPrototypeOf$b = objectIsPrototypeOf;\nvar method$8 = splice$4;\n\nvar ArrayPrototype$9 = Array.prototype;\n\nvar splice$3 = function (it) {\n  var own = it.splice;\n  return it === ArrayPrototype$9 || (isPrototypeOf$b(ArrayPrototype$9, it) && own === ArrayPrototype$9.splice) ? method$8 : own;\n};\n\nvar parent$E = splice$3;\n\nvar splice$2 = parent$E;\n\nvar splice$1 = splice$2;\n\nvar _spliceInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(splice$1);\n\nvar $$q = _export;\nvar $includes = arrayIncludes.includes;\nvar fails$c = fails$w;\n\n// FF99+ bug\nvar BROKEN_ON_SPARSE = fails$c(function () {\n  // eslint-disable-next-line es/no-array-prototype-includes -- detection\n  return !Array(1).includes();\n});\n\n// `Array.prototype.includes` method\n// https://tc39.es/ecma262/#sec-array.prototype.includes\n$$q({ target: 'Array', proto: true, forced: BROKEN_ON_SPARSE }, {\n  includes: function includes(el /* , fromIndex = 0 */) {\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar entryVirtual$9 = entryVirtual$i;\n\nvar includes$4 = entryVirtual$9('Array').includes;\n\nvar isObject$8 = isObject$j;\nvar classof$3 = classofRaw$2;\nvar wellKnownSymbol$2 = wellKnownSymbol$m;\n\nvar MATCH$1 = wellKnownSymbol$2('match');\n\n// `IsRegExp` abstract operation\n// https://tc39.es/ecma262/#sec-isregexp\nvar isRegexp = function (it) {\n  var isRegExp;\n  return isObject$8(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classof$3(it) === 'RegExp');\n};\n\nvar isRegExp = isRegexp;\n\nvar $TypeError$5 = TypeError;\n\nvar notARegexp = function (it) {\n  if (isRegExp(it)) {\n    throw new $TypeError$5(\"The method doesn't accept regular expressions\");\n  } return it;\n};\n\nvar wellKnownSymbol$1 = wellKnownSymbol$m;\n\nvar MATCH = wellKnownSymbol$1('match');\n\nvar correctIsRegexpLogic = function (METHOD_NAME) {\n  var regexp = /./;\n  try {\n    '/./'[METHOD_NAME](regexp);\n  } catch (error1) {\n    try {\n      regexp[MATCH] = false;\n      return '/./'[METHOD_NAME](regexp);\n    } catch (error2) { /* empty */ }\n  } return false;\n};\n\nvar $$p = _export;\nvar uncurryThis$8 = functionUncurryThis;\nvar notARegExp = notARegexp;\nvar requireObjectCoercible$1 = requireObjectCoercible$5;\nvar toString$4 = toString$a;\nvar correctIsRegExpLogic = correctIsRegexpLogic;\n\nvar stringIndexOf = uncurryThis$8(''.indexOf);\n\n// `String.prototype.includes` method\n// https://tc39.es/ecma262/#sec-string.prototype.includes\n$$p({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {\n  includes: function includes(searchString /* , position = 0 */) {\n    return !!~stringIndexOf(\n      toString$4(requireObjectCoercible$1(this)),\n      toString$4(notARegExp(searchString)),\n      arguments.length > 1 ? arguments[1] : undefined\n    );\n  }\n});\n\nvar entryVirtual$8 = entryVirtual$i;\n\nvar includes$3 = entryVirtual$8('String').includes;\n\nvar isPrototypeOf$a = objectIsPrototypeOf;\nvar arrayMethod = includes$4;\nvar stringMethod = includes$3;\n\nvar ArrayPrototype$8 = Array.prototype;\nvar StringPrototype = String.prototype;\n\nvar includes$2 = function (it) {\n  var own = it.includes;\n  if (it === ArrayPrototype$8 || (isPrototypeOf$a(ArrayPrototype$8, it) && own === ArrayPrototype$8.includes)) return arrayMethod;\n  if (typeof it == 'string' || it === StringPrototype || (isPrototypeOf$a(StringPrototype, it) && own === StringPrototype.includes)) {\n    return stringMethod;\n  } return own;\n};\n\nvar parent$D = includes$2;\n\nvar includes$1 = parent$D;\n\nvar includes = includes$1;\n\nvar _includesInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(includes);\n\nvar $$o = _export;\nvar fails$b = fails$w;\nvar toObject$3 = toObject$e;\nvar nativeGetPrototypeOf = objectGetPrototypeOf;\nvar CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;\n\nvar FAILS_ON_PRIMITIVES$2 = fails$b(function () { nativeGetPrototypeOf(1); });\n\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\n$$o({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$2, sham: !CORRECT_PROTOTYPE_GETTER }, {\n  getPrototypeOf: function getPrototypeOf(it) {\n    return nativeGetPrototypeOf(toObject$3(it));\n  }\n});\n\nvar path$k = path$w;\n\nvar getPrototypeOf$6 = path$k.Object.getPrototypeOf;\n\nvar parent$C = getPrototypeOf$6;\n\nvar getPrototypeOf$5 = parent$C;\n\nvar getPrototypeOf$4 = getPrototypeOf$5;\n\nvar _Object$getPrototypeOf$1 = /*@__PURE__*/getDefaultExportFromCjs(getPrototypeOf$4);\n\nvar $$n = _export;\nvar $filter = arrayIteration.filter;\nvar arrayMethodHasSpeciesSupport = arrayMethodHasSpeciesSupport$5;\n\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');\n\n// `Array.prototype.filter` method\n// https://tc39.es/ecma262/#sec-array.prototype.filter\n// with adding support of @@species\n$$n({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {\n  filter: function filter(callbackfn /* , thisArg */) {\n    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar entryVirtual$7 = entryVirtual$i;\n\nvar filter$3 = entryVirtual$7('Array').filter;\n\nvar isPrototypeOf$9 = objectIsPrototypeOf;\nvar method$7 = filter$3;\n\nvar ArrayPrototype$7 = Array.prototype;\n\nvar filter$2 = function (it) {\n  var own = it.filter;\n  return it === ArrayPrototype$7 || (isPrototypeOf$9(ArrayPrototype$7, it) && own === ArrayPrototype$7.filter) ? method$7 : own;\n};\n\nvar parent$B = filter$2;\n\nvar filter$1 = parent$B;\n\nvar filter = filter$1;\n\nvar _filterInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(filter);\n\n// a string of all valid unicode whitespaces\nvar whitespaces$3 = '\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u2000\\u2001\\u2002' +\n  '\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n\nvar uncurryThis$7 = functionUncurryThis;\nvar requireObjectCoercible = requireObjectCoercible$5;\nvar toString$3 = toString$a;\nvar whitespaces$2 = whitespaces$3;\n\nvar replace = uncurryThis$7(''.replace);\nvar ltrim = RegExp('^[' + whitespaces$2 + ']+');\nvar rtrim = RegExp('(^|[^' + whitespaces$2 + '])[' + whitespaces$2 + ']+$');\n\n// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\nvar createMethod$1 = function (TYPE) {\n  return function ($this) {\n    var string = toString$3(requireObjectCoercible($this));\n    if (TYPE & 1) string = replace(string, ltrim, '');\n    if (TYPE & 2) string = replace(string, rtrim, '$1');\n    return string;\n  };\n};\n\nvar stringTrim = {\n  // `String.prototype.{ trimLeft, trimStart }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimstart\n  start: createMethod$1(1),\n  // `String.prototype.{ trimRight, trimEnd }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimend\n  end: createMethod$1(2),\n  // `String.prototype.trim` method\n  // https://tc39.es/ecma262/#sec-string.prototype.trim\n  trim: createMethod$1(3)\n};\n\nvar global$9 = global$n;\nvar fails$a = fails$w;\nvar uncurryThis$6 = functionUncurryThis;\nvar toString$2 = toString$a;\nvar trim$1 = stringTrim.trim;\nvar whitespaces$1 = whitespaces$3;\n\nvar $parseInt$1 = global$9.parseInt;\nvar Symbol$2 = global$9.Symbol;\nvar ITERATOR$1 = Symbol$2 && Symbol$2.iterator;\nvar hex = /^[+-]?0x/i;\nvar exec = uncurryThis$6(hex.exec);\nvar FORCED$7 = $parseInt$1(whitespaces$1 + '08') !== 8 || $parseInt$1(whitespaces$1 + '0x16') !== 22\n  // MS Edge 18- broken with boxed symbols\n  || (ITERATOR$1 && !fails$a(function () { $parseInt$1(Object(ITERATOR$1)); }));\n\n// `parseInt` method\n// https://tc39.es/ecma262/#sec-parseint-string-radix\nvar numberParseInt = FORCED$7 ? function parseInt(string, radix) {\n  var S = trim$1(toString$2(string));\n  return $parseInt$1(S, (radix >>> 0) || (exec(hex, S) ? 16 : 10));\n} : $parseInt$1;\n\nvar $$m = _export;\nvar $parseInt = numberParseInt;\n\n// `parseInt` method\n// https://tc39.es/ecma262/#sec-parseint-string-radix\n$$m({ global: true, forced: parseInt !== $parseInt }, {\n  parseInt: $parseInt\n});\n\nvar path$j = path$w;\n\nvar _parseInt$3 = path$j.parseInt;\n\nvar parent$A = _parseInt$3;\n\nvar _parseInt$2 = parent$A;\n\nvar _parseInt = _parseInt$2;\n\nvar _parseInt$1 = /*@__PURE__*/getDefaultExportFromCjs(_parseInt);\n\n/* eslint-disable es/no-array-prototype-indexof -- required for testing */\nvar $$l = _export;\nvar uncurryThis$5 = functionUncurryThisClause;\nvar $indexOf = arrayIncludes.indexOf;\nvar arrayMethodIsStrict$4 = arrayMethodIsStrict$6;\n\nvar nativeIndexOf = uncurryThis$5([].indexOf);\n\nvar NEGATIVE_ZERO = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;\nvar FORCED$6 = NEGATIVE_ZERO || !arrayMethodIsStrict$4('indexOf');\n\n// `Array.prototype.indexOf` method\n// https://tc39.es/ecma262/#sec-array.prototype.indexof\n$$l({ target: 'Array', proto: true, forced: FORCED$6 }, {\n  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {\n    var fromIndex = arguments.length > 1 ? arguments[1] : undefined;\n    return NEGATIVE_ZERO\n      // convert -0 to +0\n      ? nativeIndexOf(this, searchElement, fromIndex) || 0\n      : $indexOf(this, searchElement, fromIndex);\n  }\n});\n\nvar entryVirtual$6 = entryVirtual$i;\n\nvar indexOf$3 = entryVirtual$6('Array').indexOf;\n\nvar isPrototypeOf$8 = objectIsPrototypeOf;\nvar method$6 = indexOf$3;\n\nvar ArrayPrototype$6 = Array.prototype;\n\nvar indexOf$2 = function (it) {\n  var own = it.indexOf;\n  return it === ArrayPrototype$6 || (isPrototypeOf$8(ArrayPrototype$6, it) && own === ArrayPrototype$6.indexOf) ? method$6 : own;\n};\n\nvar parent$z = indexOf$2;\n\nvar indexOf$1 = parent$z;\n\nvar indexOf = indexOf$1;\n\nvar _indexOfInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(indexOf);\n\n// TODO: Remove from `core-js@4`\nvar $$k = _export;\nvar DESCRIPTORS$6 = descriptors;\nvar create$8 = objectCreate;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\n$$k({ target: 'Object', stat: true, sham: !DESCRIPTORS$6 }, {\n  create: create$8\n});\n\nvar path$i = path$w;\n\nvar Object$4 = path$i.Object;\n\nvar create$7 = function create(P, D) {\n  return Object$4.create(P, D);\n};\n\nvar parent$y = create$7;\n\nvar create$6 = parent$y;\n\nvar create$5 = create$6;\n\nvar _Object$create$1 = /*@__PURE__*/getDefaultExportFromCjs(create$5);\n\nvar path$h = path$w;\nvar apply$2 = functionApply;\n\n// eslint-disable-next-line es/no-json -- safe\nif (!path$h.JSON) path$h.JSON = { stringify: JSON.stringify };\n\n// eslint-disable-next-line no-unused-vars -- required for `.length`\nvar stringify$2 = function stringify(it, replacer, space) {\n  return apply$2(path$h.JSON.stringify, null, arguments);\n};\n\nvar parent$x = stringify$2;\n\nvar stringify$1 = parent$x;\n\nvar stringify = stringify$1;\n\nvar _JSON$stringify = /*@__PURE__*/getDefaultExportFromCjs(stringify);\n\n/* global Bun -- Deno case */\nvar engineIsBun = typeof Bun == 'function' && Bun && typeof Bun.version == 'string';\n\nvar $TypeError$4 = TypeError;\n\nvar validateArgumentsLength$1 = function (passed, required) {\n  if (passed < required) throw new $TypeError$4('Not enough arguments');\n  return passed;\n};\n\nvar global$8 = global$n;\nvar apply$1 = functionApply;\nvar isCallable$1 = isCallable$i;\nvar ENGINE_IS_BUN = engineIsBun;\nvar USER_AGENT = engineUserAgent;\nvar arraySlice$1 = arraySlice$5;\nvar validateArgumentsLength = validateArgumentsLength$1;\n\nvar Function$1 = global$8.Function;\n// dirty IE9- and Bun 0.3.0- checks\nvar WRAP = /MSIE .\\./.test(USER_AGENT) || ENGINE_IS_BUN && (function () {\n  var version = global$8.Bun.version.split('.');\n  return version.length < 3 || version[0] === '0' && (version[1] < 3 || version[1] === '3' && version[2] === '0');\n})();\n\n// IE9- / Bun 0.3.0- setTimeout / setInterval / setImmediate additional parameters fix\n// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers\n// https://github.com/oven-sh/bun/issues/1633\nvar schedulersFix$2 = function (scheduler, hasTimeArg) {\n  var firstParamIndex = hasTimeArg ? 2 : 1;\n  return WRAP ? function (handler, timeout /* , ...arguments */) {\n    var boundArgs = validateArgumentsLength(arguments.length, 1) > firstParamIndex;\n    var fn = isCallable$1(handler) ? handler : Function$1(handler);\n    var params = boundArgs ? arraySlice$1(arguments, firstParamIndex) : [];\n    var callback = boundArgs ? function () {\n      apply$1(fn, this, params);\n    } : fn;\n    return hasTimeArg ? scheduler(callback, timeout) : scheduler(callback);\n  } : scheduler;\n};\n\nvar $$j = _export;\nvar global$7 = global$n;\nvar schedulersFix$1 = schedulersFix$2;\n\nvar setInterval$2 = schedulersFix$1(global$7.setInterval, true);\n\n// Bun / IE9- setInterval additional parameters fix\n// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval\n$$j({ global: true, bind: true, forced: global$7.setInterval !== setInterval$2 }, {\n  setInterval: setInterval$2\n});\n\nvar $$i = _export;\nvar global$6 = global$n;\nvar schedulersFix = schedulersFix$2;\n\nvar setTimeout$3 = schedulersFix(global$6.setTimeout, true);\n\n// Bun / IE9- setTimeout additional parameters fix\n// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout\n$$i({ global: true, bind: true, forced: global$6.setTimeout !== setTimeout$3 }, {\n  setTimeout: setTimeout$3\n});\n\nvar path$g = path$w;\n\nvar setTimeout$2 = path$g.setTimeout;\n\nvar setTimeout$1 = setTimeout$2;\n\nvar _setTimeout = /*@__PURE__*/getDefaultExportFromCjs(setTimeout$1);\n\nvar toObject$2 = toObject$e;\nvar toAbsoluteIndex = toAbsoluteIndex$5;\nvar lengthOfArrayLike$3 = lengthOfArrayLike$c;\n\n// `Array.prototype.fill` method implementation\n// https://tc39.es/ecma262/#sec-array.prototype.fill\nvar arrayFill = function fill(value /* , start = 0, end = @length */) {\n  var O = toObject$2(this);\n  var length = lengthOfArrayLike$3(O);\n  var argumentsLength = arguments.length;\n  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);\n  var end = argumentsLength > 2 ? arguments[2] : undefined;\n  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);\n  while (endPos > index) O[index++] = value;\n  return O;\n};\n\nvar $$h = _export;\nvar fill$4 = arrayFill;\n\n// `Array.prototype.fill` method\n// https://tc39.es/ecma262/#sec-array.prototype.fill\n$$h({ target: 'Array', proto: true }, {\n  fill: fill$4\n});\n\nvar entryVirtual$5 = entryVirtual$i;\n\nvar fill$3 = entryVirtual$5('Array').fill;\n\nvar isPrototypeOf$7 = objectIsPrototypeOf;\nvar method$5 = fill$3;\n\nvar ArrayPrototype$5 = Array.prototype;\n\nvar fill$2 = function (it) {\n  var own = it.fill;\n  return it === ArrayPrototype$5 || (isPrototypeOf$7(ArrayPrototype$5, it) && own === ArrayPrototype$5.fill) ? method$5 : own;\n};\n\nvar parent$w = fill$2;\n\nvar fill$1 = parent$w;\n\nvar fill = fill$1;\n\nvar _fillInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(fill);\n\n/*! Hammer.JS - v2.0.17-rc - 2019-12-16\n * http://naver.github.io/egjs\n *\n * Forked By Naver egjs\n * Copyright (c) hammerjs\n * Licensed under the MIT license */\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _assertThisInitialized$1(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\n\nif (typeof Object.assign !== 'function') {\n  assign = function assign(target) {\n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    var output = Object(target);\n\n    for (var index = 1; index < arguments.length; index++) {\n      var source = arguments[index];\n\n      if (source !== undefined && source !== null) {\n        for (var nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n\n    return output;\n  };\n} else {\n  assign = Object.assign;\n}\n\nvar assign$1 = assign;\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = typeof document === \"undefined\" ? {\n  style: {}\n} : document.createElement('div');\nvar TYPE_FUNCTION = 'function';\nvar round = Math.round,\n    abs$1 = Math.abs;\nvar now = Date.now;\n\n/**\n * @private\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\n\nfunction prefixed(obj, property) {\n  var prefix;\n  var prop;\n  var camelProp = property[0].toUpperCase() + property.slice(1);\n  var i = 0;\n\n  while (i < VENDOR_PREFIXES.length) {\n    prefix = VENDOR_PREFIXES[i];\n    prop = prefix ? prefix + camelProp : property;\n\n    if (prop in obj) {\n      return prop;\n    }\n\n    i++;\n  }\n\n  return undefined;\n}\n\n/* eslint-disable no-new-func, no-nested-ternary */\nvar win;\n\nif (typeof window === \"undefined\") {\n  // window is undefined in node.js\n  win = {};\n} else {\n  win = window;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\nfunction getTouchActionProps() {\n  if (!NATIVE_TOUCH_ACTION) {\n    return false;\n  }\n\n  var touchMap = {};\n  var cssSupports = win.CSS && win.CSS.supports;\n  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n    // If css.supports is not supported but there is native touch-action assume it supports\n    // all values. This is the case for IE 10 and 11.\n    return touchMap[val] = cssSupports ? win.CSS.supports('touch-action', val) : true;\n  });\n  return touchMap;\n}\n\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\nvar SUPPORT_TOUCH = 'ontouchstart' in win;\nvar SUPPORT_POINTER_EVENTS = prefixed(win, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\nvar COMPUTE_INTERVAL = 25;\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * @private\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n  var i;\n\n  if (!obj) {\n    return;\n  }\n\n  if (obj.forEach) {\n    obj.forEach(iterator, context);\n  } else if (obj.length !== undefined) {\n    i = 0;\n\n    while (i < obj.length) {\n      iterator.call(context, obj[i], i, obj);\n      i++;\n    }\n  } else {\n    for (i in obj) {\n      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n    }\n  }\n}\n\n/**\n * @private\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\n\nfunction boolOrFn(val, args) {\n  if (typeof val === TYPE_FUNCTION) {\n    return val.apply(args ? args[0] || undefined : undefined, args);\n  }\n\n  return val;\n}\n\n/**\n * @private\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n  return str.indexOf(find) > -1;\n}\n\n/**\n * @private\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\n\nfunction cleanTouchActions(actions) {\n  // none\n  if (inStr(actions, TOUCH_ACTION_NONE)) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers\n  // for different directions, e.g. horizontal pan but vertical swipe?)\n  // we need none (as otherwise with pan-x pan-y combined none of these\n  // recognizers will work, since the browser would handle all panning\n\n  if (hasPanX && hasPanY) {\n    return TOUCH_ACTION_NONE;\n  } // pan-x OR pan-y\n\n\n  if (hasPanX || hasPanY) {\n    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n  } // manipulation\n\n\n  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n    return TOUCH_ACTION_MANIPULATION;\n  }\n\n  return TOUCH_ACTION_AUTO;\n}\n\n/**\n * @private\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\n\nvar TouchAction =\n/*#__PURE__*/\nfunction () {\n  function TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n  /**\n   * @private\n   * set the touchAction value on the element or enable the polyfill\n   * @param {String} value\n   */\n\n\n  var _proto = TouchAction.prototype;\n\n  _proto.set = function set(value) {\n    // find out the touch-action by the event handlers\n    if (value === TOUCH_ACTION_COMPUTE) {\n      value = this.compute();\n    }\n\n    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n      this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n    }\n\n    this.actions = value.toLowerCase().trim();\n  };\n  /**\n   * @private\n   * just re-set the touchAction value\n   */\n\n\n  _proto.update = function update() {\n    this.set(this.manager.options.touchAction);\n  };\n  /**\n   * @private\n   * compute the value for the touchAction property based on the recognizer's settings\n   * @returns {String} value\n   */\n\n\n  _proto.compute = function compute() {\n    var actions = [];\n    each(this.manager.recognizers, function (recognizer) {\n      if (boolOrFn(recognizer.options.enable, [recognizer])) {\n        actions = actions.concat(recognizer.getTouchAction());\n      }\n    });\n    return cleanTouchActions(actions.join(' '));\n  };\n  /**\n   * @private\n   * this method is called on each input cycle and provides the preventing of the browser behavior\n   * @param {Object} input\n   */\n\n\n  _proto.preventDefaults = function preventDefaults(input) {\n    var srcEvent = input.srcEvent;\n    var direction = input.offsetDirection; // if the touch action did prevented once this session\n\n    if (this.manager.session.prevented) {\n      srcEvent.preventDefault();\n      return;\n    }\n\n    var actions = this.actions;\n    var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n    if (hasNone) {\n      // do not prevent defaults if this is a tap gesture\n      var isTapPointer = input.pointers.length === 1;\n      var isTapMovement = input.distance < 2;\n      var isTapTouchTime = input.deltaTime < 250;\n\n      if (isTapPointer && isTapMovement && isTapTouchTime) {\n        return;\n      }\n    }\n\n    if (hasPanX && hasPanY) {\n      // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n      return;\n    }\n\n    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n      return this.preventSrc(srcEvent);\n    }\n  };\n  /**\n   * @private\n   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n   * @param {Object} srcEvent\n   */\n\n\n  _proto.preventSrc = function preventSrc(srcEvent) {\n    this.manager.session.prevented = true;\n    srcEvent.preventDefault();\n  };\n\n  return TouchAction;\n}();\n\n/**\n * @private\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n  while (node) {\n    if (node === parent) {\n      return true;\n    }\n\n    node = node.parentNode;\n  }\n\n  return false;\n}\n\n/**\n * @private\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\n\nfunction getCenter(pointers) {\n  var pointersLength = pointers.length; // no need to loop when only one touch\n\n  if (pointersLength === 1) {\n    return {\n      x: round(pointers[0].clientX),\n      y: round(pointers[0].clientY)\n    };\n  }\n\n  var x = 0;\n  var y = 0;\n  var i = 0;\n\n  while (i < pointersLength) {\n    x += pointers[i].clientX;\n    y += pointers[i].clientY;\n    i++;\n  }\n\n  return {\n    x: round(x / pointersLength),\n    y: round(y / pointersLength)\n  };\n}\n\n/**\n * @private\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\n\nfunction simpleCloneInputData(input) {\n  // make a simple copy of the pointers because we will get a reference if we don't\n  // we only need clientXY for the calculations\n  var pointers = [];\n  var i = 0;\n\n  while (i < input.pointers.length) {\n    pointers[i] = {\n      clientX: round(input.pointers[i].clientX),\n      clientY: round(input.pointers[i].clientY)\n    };\n    i++;\n  }\n\n  return {\n    timeStamp: now(),\n    pointers: pointers,\n    center: getCenter(pointers),\n    deltaX: input.deltaX,\n    deltaY: input.deltaY\n  };\n}\n\n/**\n * @private\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\n\nfunction getDistance(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.sqrt(x * x + y * y);\n}\n\n/**\n * @private\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\n\nfunction getAngle(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * @private\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\n\nfunction getDirection(x, y) {\n  if (x === y) {\n    return DIRECTION_NONE;\n  }\n\n  if (abs$1(x) >= abs$1(y)) {\n    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n  }\n\n  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\nfunction computeDeltaXY(session, input) {\n  var center = input.center; // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;\n  // jscs throwing error on defalut destructured values and without defaults tests fail\n\n  var offset = session.offsetDelta || {};\n  var prevDelta = session.prevDelta || {};\n  var prevInput = session.prevInput || {};\n\n  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n    prevDelta = session.prevDelta = {\n      x: prevInput.deltaX || 0,\n      y: prevInput.deltaY || 0\n    };\n    offset = session.offsetDelta = {\n      x: center.x,\n      y: center.y\n    };\n  }\n\n  input.deltaX = prevDelta.x + (center.x - offset.x);\n  input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * @private\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n  return {\n    x: x / deltaTime || 0,\n    y: y / deltaTime || 0\n  };\n}\n\n/**\n * @private\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\n\nfunction getScale(start, end) {\n  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\n/**\n * @private\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\n\nfunction getRotation(start, end) {\n  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * @private\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\n\nfunction computeIntervalInputData(session, input) {\n  var last = session.lastInterval || input;\n  var deltaTime = input.timeStamp - last.timeStamp;\n  var velocity;\n  var velocityX;\n  var velocityY;\n  var direction;\n\n  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n    var deltaX = input.deltaX - last.deltaX;\n    var deltaY = input.deltaY - last.deltaY;\n    var v = getVelocity(deltaTime, deltaX, deltaY);\n    velocityX = v.x;\n    velocityY = v.y;\n    velocity = abs$1(v.x) > abs$1(v.y) ? v.x : v.y;\n    direction = getDirection(deltaX, deltaY);\n    session.lastInterval = input;\n  } else {\n    // use latest velocity info if it doesn't overtake a minimum period\n    velocity = last.velocity;\n    velocityX = last.velocityX;\n    velocityY = last.velocityY;\n    direction = last.direction;\n  }\n\n  input.velocity = velocity;\n  input.velocityX = velocityX;\n  input.velocityY = velocityY;\n  input.direction = direction;\n}\n\n/**\n* @private\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\n\nfunction computeInputData(manager, input) {\n  var session = manager.session;\n  var pointers = input.pointers;\n  var pointersLength = pointers.length; // store the first input to calculate the distance and direction\n\n  if (!session.firstInput) {\n    session.firstInput = simpleCloneInputData(input);\n  } // to compute scale and rotation we need to store the multiple touches\n\n\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = simpleCloneInputData(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n\n  var firstInput = session.firstInput,\n      firstMultiple = session.firstMultiple;\n  var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n  var center = input.center = getCenter(pointers);\n  input.timeStamp = now();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n  input.angle = getAngle(offsetCenter, center);\n  input.distance = getDistance(offsetCenter, center);\n  computeDeltaXY(session, input);\n  input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n  var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity = abs$1(overallVelocity.x) > abs$1(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n  computeIntervalInputData(session, input); // find the correct target\n\n  var target = manager.element;\n  var srcEvent = input.srcEvent;\n  var srcEventTarget;\n\n  if (srcEvent.composedPath) {\n    srcEventTarget = srcEvent.composedPath()[0];\n  } else if (srcEvent.path) {\n    srcEventTarget = srcEvent.path[0];\n  } else {\n    srcEventTarget = srcEvent.target;\n  }\n\n  if (hasParent(srcEventTarget, target)) {\n    target = srcEventTarget;\n  }\n\n  input.target = target;\n}\n\n/**\n * @private\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\n\nfunction inputHandler(manager, eventType, input) {\n  var pointersLen = input.pointers.length;\n  var changedPointersLen = input.changedPointers.length;\n  var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n  var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n  input.isFirst = !!isFirst;\n  input.isFinal = !!isFinal;\n\n  if (isFirst) {\n    manager.session = {};\n  } // source event is the normalized value of the domEvents\n  // like 'touchstart, mouseup, pointerdown'\n\n\n  input.eventType = eventType; // compute scale, rotation etc\n\n  computeInputData(manager, input); // emit secret event\n\n  manager.emit('hammer.input', input);\n  manager.recognize(input);\n  manager.session.prevInput = input;\n}\n\n/**\n * @private\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n  return str.trim().split(/\\s+/g);\n}\n\n/**\n * @private\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\n\nfunction addEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.addEventListener(type, handler, false);\n  });\n}\n\n/**\n * @private\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\n\nfunction removeEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.removeEventListener(type, handler, false);\n  });\n}\n\n/**\n * @private\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n  var doc = element.ownerDocument || element;\n  return doc.defaultView || doc.parentWindow || window;\n}\n\n/**\n * @private\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\n\nvar Input =\n/*#__PURE__*/\nfunction () {\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n\n    this.domHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n\n    this.init();\n  }\n  /**\n   * @private\n   * should handle the inputEvent data and trigger the callback\n   * @virtual\n   */\n\n\n  var _proto = Input.prototype;\n\n  _proto.handler = function handler() {};\n  /**\n   * @private\n   * bind the events\n   */\n\n\n  _proto.init = function init() {\n    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n  /**\n   * @private\n   * unbind the events\n   */\n\n\n  _proto.destroy = function destroy() {\n    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n\n  return Input;\n}();\n\n/**\n * @private\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n  if (src.indexOf && !findByKey) {\n    return src.indexOf(find);\n  } else {\n    var i = 0;\n\n    while (i < src.length) {\n      if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n        // do not use === here, test fails\n        return i;\n      }\n\n      i++;\n    }\n\n    return -1;\n  }\n}\n\nvar POINTER_INPUT_MAP = {\n  pointerdown: INPUT_START,\n  pointermove: INPUT_MOVE,\n  pointerup: INPUT_END,\n  pointercancel: INPUT_CANCEL,\n  pointerout: INPUT_CANCEL\n}; // in IE10 the pointer types is defined as an enum\n\nvar IE10_POINTER_TYPE_ENUM = {\n  2: INPUT_TYPE_TOUCH,\n  3: INPUT_TYPE_PEN,\n  4: INPUT_TYPE_MOUSE,\n  5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n\n};\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive\n\nif (win.MSPointerEvent && !win.PointerEvent) {\n  POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n  POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n/**\n * @private\n * Pointer events input\n * @constructor\n * @extends Input\n */\n\n\nvar PointerEventInput =\n/*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(PointerEventInput, _Input);\n\n  function PointerEventInput() {\n    var _this;\n\n    var proto = PointerEventInput.prototype;\n    proto.evEl = POINTER_ELEMENT_EVENTS;\n    proto.evWin = POINTER_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.store = _this.manager.session.pointerEvents = [];\n    return _this;\n  }\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n\n  var _proto = PointerEventInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var store = this.store;\n    var removePointer = false;\n    var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n    var isTouch = pointerType === INPUT_TYPE_TOUCH; // get index of the event in the store\n\n    var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down\n\n    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n      if (storeIndex < 0) {\n        store.push(ev);\n        storeIndex = store.length - 1;\n      }\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      removePointer = true;\n    } // it not found, so the pointer hasn't been down (so it's probably a hover)\n\n\n    if (storeIndex < 0) {\n      return;\n    } // update the event in the store\n\n\n    store[storeIndex] = ev;\n    this.callback(this.manager, eventType, {\n      pointers: store,\n      changedPointers: [ev],\n      pointerType: pointerType,\n      srcEvent: ev\n    });\n\n    if (removePointer) {\n      // remove from the store\n      store.splice(storeIndex, 1);\n    }\n  };\n\n  return PointerEventInput;\n}(Input);\n\n/**\n * @private\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n  return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * @private\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\n\nfunction uniqueArray(src, key, sort) {\n  var results = [];\n  var values = [];\n  var i = 0;\n\n  while (i < src.length) {\n    var val = key ? src[i][key] : src[i];\n\n    if (inArray(values, val) < 0) {\n      results.push(src[i]);\n    }\n\n    values[i] = val;\n    i++;\n  }\n\n  if (sort) {\n    if (!key) {\n      results = results.sort();\n    } else {\n      results = results.sort(function (a, b) {\n        return a[key] > b[key];\n      });\n    }\n  }\n\n  return results;\n}\n\nvar TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n/**\n * @private\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\n\nvar TouchInput =\n/*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(TouchInput, _Input);\n\n  function TouchInput() {\n    var _this;\n\n    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.targetIds = {}; // this.evTarget = TOUCH_TARGET_EVENTS;\n\n    return _this;\n  }\n\n  var _proto = TouchInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var type = TOUCH_INPUT_MAP[ev.type];\n    var touches = getTouches.call(this, ev, type);\n\n    if (!touches) {\n      return;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n\n  return TouchInput;\n}(Input);\n\nfunction getTouches(ev, type) {\n  var allTouches = toArray(ev.touches);\n  var targetIds = this.targetIds; // when there is only one touch, the process can be simplified\n\n  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n    targetIds[allTouches[0].identifier] = true;\n    return [allTouches, allTouches];\n  }\n\n  var i;\n  var targetTouches;\n  var changedTouches = toArray(ev.changedTouches);\n  var changedTargetTouches = [];\n  var target = this.target; // get target touches from touches\n\n  targetTouches = allTouches.filter(function (touch) {\n    return hasParent(touch.target, target);\n  }); // collect touches\n\n  if (type === INPUT_START) {\n    i = 0;\n\n    while (i < targetTouches.length) {\n      targetIds[targetTouches[i].identifier] = true;\n      i++;\n    }\n  } // filter changed touches to only contain touches that exist in the collected target ids\n\n\n  i = 0;\n\n  while (i < changedTouches.length) {\n    if (targetIds[changedTouches[i].identifier]) {\n      changedTargetTouches.push(changedTouches[i]);\n    } // cleanup removed touches\n\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      delete targetIds[changedTouches[i].identifier];\n    }\n\n    i++;\n  }\n\n  if (!changedTargetTouches.length) {\n    return;\n  }\n\n  return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n  uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n}\n\nvar MOUSE_INPUT_MAP = {\n  mousedown: INPUT_START,\n  mousemove: INPUT_MOVE,\n  mouseup: INPUT_END\n};\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n/**\n * @private\n * Mouse events input\n * @constructor\n * @extends Input\n */\n\nvar MouseInput =\n/*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(MouseInput, _Input);\n\n  function MouseInput() {\n    var _this;\n\n    var proto = MouseInput.prototype;\n    proto.evEl = MOUSE_ELEMENT_EVENTS;\n    proto.evWin = MOUSE_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.pressed = false; // mousedown state\n\n    return _this;\n  }\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n\n  var _proto = MouseInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down\n\n    if (eventType & INPUT_START && ev.button === 0) {\n      this.pressed = true;\n    }\n\n    if (eventType & INPUT_MOVE && ev.which !== 1) {\n      eventType = INPUT_END;\n    } // mouse must be down\n\n\n    if (!this.pressed) {\n      return;\n    }\n\n    if (eventType & INPUT_END) {\n      this.pressed = false;\n    }\n\n    this.callback(this.manager, eventType, {\n      pointers: [ev],\n      changedPointers: [ev],\n      pointerType: INPUT_TYPE_MOUSE,\n      srcEvent: ev\n    });\n  };\n\n  return MouseInput;\n}(Input);\n\n/**\n * @private\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction setLastTouch(eventData) {\n  var _eventData$changedPoi = eventData.changedPointers,\n      touch = _eventData$changedPoi[0];\n\n  if (touch.identifier === this.primaryTouch) {\n    var lastTouch = {\n      x: touch.clientX,\n      y: touch.clientY\n    };\n    var lts = this.lastTouches;\n    this.lastTouches.push(lastTouch);\n\n    var removeLastTouch = function removeLastTouch() {\n      var i = lts.indexOf(lastTouch);\n\n      if (i > -1) {\n        lts.splice(i, 1);\n      }\n    };\n\n    setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n  }\n}\n\nfunction recordTouches(eventType, eventData) {\n  if (eventType & INPUT_START) {\n    this.primaryTouch = eventData.changedPointers[0].identifier;\n    setLastTouch.call(this, eventData);\n  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n    setLastTouch.call(this, eventData);\n  }\n}\n\nfunction isSyntheticEvent(eventData) {\n  var x = eventData.srcEvent.clientX;\n  var y = eventData.srcEvent.clientY;\n\n  for (var i = 0; i < this.lastTouches.length; i++) {\n    var t = this.lastTouches[i];\n    var dx = Math.abs(x - t.x);\n    var dy = Math.abs(y - t.y);\n\n    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar TouchMouseInput =\n/*#__PURE__*/\nfunction () {\n  var TouchMouseInput =\n  /*#__PURE__*/\n  function (_Input) {\n    _inheritsLoose(TouchMouseInput, _Input);\n\n    function TouchMouseInput(_manager, callback) {\n      var _this;\n\n      _this = _Input.call(this, _manager, callback) || this;\n\n      _this.handler = function (manager, inputEvent, inputData) {\n        var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;\n        var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n          return;\n        } // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n\n\n        if (isTouch) {\n          recordTouches.call(_assertThisInitialized$1(_assertThisInitialized$1(_this)), inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(_assertThisInitialized$1(_assertThisInitialized$1(_this)), inputData)) {\n          return;\n        }\n\n        _this.callback(manager, inputEvent, inputData);\n      };\n\n      _this.touch = new TouchInput(_this.manager, _this.handler);\n      _this.mouse = new MouseInput(_this.manager, _this.handler);\n      _this.primaryTouch = null;\n      _this.lastTouches = [];\n      return _this;\n    }\n    /**\n     * @private\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n\n\n    var _proto = TouchMouseInput.prototype;\n\n    /**\n     * @private\n     * remove the event listeners\n     */\n    _proto.destroy = function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    };\n\n    return TouchMouseInput;\n  }(Input);\n\n  return TouchMouseInput;\n}();\n\n/**\n * @private\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\n\nfunction createInputInstance(manager) {\n  var Type; // let inputClass = manager.options.inputClass;\n\n  var inputClass = manager.options.inputClass;\n\n  if (inputClass) {\n    Type = inputClass;\n  } else if (SUPPORT_POINTER_EVENTS) {\n    Type = PointerEventInput;\n  } else if (SUPPORT_ONLY_TOUCH) {\n    Type = TouchInput;\n  } else if (!SUPPORT_TOUCH) {\n    Type = MouseInput;\n  } else {\n    Type = TouchMouseInput;\n  }\n\n  return new Type(manager, inputHandler);\n}\n\n/**\n * @private\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\n\nfunction invokeArrayArg(arg, fn, context) {\n  if (Array.isArray(arg)) {\n    each(arg, context[fn], context);\n    return true;\n  }\n\n  return false;\n}\n\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * @private\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n  return _uniqueId++;\n}\n\n/**\n * @private\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n  var manager = recognizer.manager;\n\n  if (manager) {\n    return manager.get(otherRecognizer);\n  }\n\n  return otherRecognizer;\n}\n\n/**\n * @private\n * get a usable string, used as event postfix\n * @param {constant} state\n * @returns {String} state\n */\n\nfunction stateStr(state) {\n  if (state & STATE_CANCELLED) {\n    return 'cancel';\n  } else if (state & STATE_ENDED) {\n    return 'end';\n  } else if (state & STATE_CHANGED) {\n    return 'move';\n  } else if (state & STATE_BEGAN) {\n    return 'start';\n  }\n\n  return '';\n}\n\n/**\n * @private\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\n\n/**\n * @private\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\n\nvar Recognizer =\n/*#__PURE__*/\nfunction () {\n  function Recognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.options = _extends({\n      enable: true\n    }, options);\n    this.id = uniqueId();\n    this.manager = null; // default is enable true\n\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @return {Recognizer}\n   */\n\n\n  var _proto = Recognizer.prototype;\n\n  _proto.set = function set(options) {\n    assign$1(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state\n\n    this.manager && this.manager.touchAction.update();\n    return this;\n  };\n  /**\n   * @private\n   * recognize simultaneous with an other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.recognizeWith = function recognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n      return this;\n    }\n\n    var simultaneous = this.simultaneous;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.dropRecognizeWith = function dropRecognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    delete this.simultaneous[otherRecognizer.id];\n    return this;\n  };\n  /**\n   * @private\n   * recognizer can only run when an other is failing\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.requireFailure = function requireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n      return this;\n    }\n\n    var requireFail = this.requireFail;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n    if (inArray(requireFail, otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * drop the requireFailure link. it does not remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.dropRequireFailure = function dropRequireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    var index = inArray(this.requireFail, otherRecognizer);\n\n    if (index > -1) {\n      this.requireFail.splice(index, 1);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * has require failures boolean\n   * @returns {boolean}\n   */\n\n\n  _proto.hasRequireFailures = function hasRequireFailures() {\n    return this.requireFail.length > 0;\n  };\n  /**\n   * @private\n   * if the recognizer can recognize simultaneous with an other recognizer\n   * @param {Recognizer} otherRecognizer\n   * @returns {Boolean}\n   */\n\n\n  _proto.canRecognizeWith = function canRecognizeWith(otherRecognizer) {\n    return !!this.simultaneous[otherRecognizer.id];\n  };\n  /**\n   * @private\n   * You should use `tryEmit` instead of `emit` directly to check\n   * that all the needed recognizers has failed before emitting.\n   * @param {Object} input\n   */\n\n\n  _proto.emit = function emit(input) {\n    var self = this;\n    var state = this.state;\n\n    function emit(event) {\n      self.manager.emit(event, input);\n    } // 'panstart' and 'panmove'\n\n\n    if (state < STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n\n    emit(self.options.event); // simple 'eventName' events\n\n    if (input.additionalEvent) {\n      // additional event(panleft, panright, pinchin, pinchout...)\n      emit(input.additionalEvent);\n    } // panend and pancancel\n\n\n    if (state >= STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n  };\n  /**\n   * @private\n   * Check that all the require failure recognizers has failed,\n   * if true, it emits a gesture event,\n   * otherwise, setup the state to FAILED.\n   * @param {Object} input\n   */\n\n\n  _proto.tryEmit = function tryEmit(input) {\n    if (this.canEmit()) {\n      return this.emit(input);\n    } // it's failing anyway\n\n\n    this.state = STATE_FAILED;\n  };\n  /**\n   * @private\n   * can we emit?\n   * @returns {boolean}\n   */\n\n\n  _proto.canEmit = function canEmit() {\n    var i = 0;\n\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n        return false;\n      }\n\n      i++;\n    }\n\n    return true;\n  };\n  /**\n   * @private\n   * update the recognizer\n   * @param {Object} inputData\n   */\n\n\n  _proto.recognize = function recognize(inputData) {\n    // make a new copy of the inputData\n    // so we can change the inputData without messing up the other recognizers\n    var inputDataClone = assign$1({}, inputData); // is is enabled and allow recognizing?\n\n    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n      this.reset();\n      this.state = STATE_FAILED;\n      return;\n    } // reset when we've reached the end\n\n\n    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n      this.state = STATE_POSSIBLE;\n    }\n\n    this.state = this.process(inputDataClone); // the recognizer has recognized a gesture\n    // so trigger an event\n\n    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n      this.tryEmit(inputDataClone);\n    }\n  };\n  /**\n   * @private\n   * return the state of the recognizer\n   * the actual recognizing happens in this method\n   * @virtual\n   * @param {Object} inputData\n   * @returns {constant} STATE\n   */\n\n  /* jshint ignore:start */\n\n\n  _proto.process = function process(inputData) {};\n  /* jshint ignore:end */\n\n  /**\n   * @private\n   * return the preferred touch-action\n   * @virtual\n   * @returns {Array}\n   */\n\n\n  _proto.getTouchAction = function getTouchAction() {};\n  /**\n   * @private\n   * called when the gesture isn't allowed to recognize\n   * like when another is being recognized or it is disabled\n   * @virtual\n   */\n\n\n  _proto.reset = function reset() {};\n\n  return Recognizer;\n}();\n\n/**\n * @private\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\n\nvar TapRecognizer =\n/*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(TapRecognizer, _Recognizer);\n\n  function TapRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _Recognizer.call(this, _extends({\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      // max time between the multi-tap taps\n      time: 250,\n      // max time of the pointer to be down (like finger on the screen)\n      threshold: 9,\n      // a minimal movement is ok, but keep it low\n      posThreshold: 10\n    }, options)) || this; // previous time and center,\n    // used for tap counting\n\n    _this.pTime = false;\n    _this.pCenter = false;\n    _this._timer = null;\n    _this._input = null;\n    _this.count = 0;\n    return _this;\n  }\n\n  var _proto = TapRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_MANIPULATION];\n  };\n\n  _proto.process = function process(input) {\n    var _this2 = this;\n\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTouchTime = input.deltaTime < options.time;\n    this.reset();\n\n    if (input.eventType & INPUT_START && this.count === 0) {\n      return this.failTimeout();\n    } // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n\n\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== INPUT_END) {\n        return this.failTimeout();\n      }\n\n      var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n      var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n\n      this._input = input; // if tap count matches we have recognized it,\n      // else it has began recognizing...\n\n      var tapCount = this.count % options.taps;\n\n      if (tapCount === 0) {\n        // no failing requirements, immediately trigger the tap event\n        // or wait as long as the multitap interval to trigger\n        if (!this.hasRequireFailures()) {\n          return STATE_RECOGNIZED;\n        } else {\n          this._timer = setTimeout(function () {\n            _this2.state = STATE_RECOGNIZED;\n\n            _this2.tryEmit();\n          }, options.interval);\n          return STATE_BEGAN;\n        }\n      }\n    }\n\n    return STATE_FAILED;\n  };\n\n  _proto.failTimeout = function failTimeout() {\n    var _this3 = this;\n\n    this._timer = setTimeout(function () {\n      _this3.state = STATE_FAILED;\n    }, this.options.interval);\n    return STATE_FAILED;\n  };\n\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n\n  _proto.emit = function emit() {\n    if (this.state === STATE_RECOGNIZED) {\n      this._input.tapCount = this.count;\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n\n  return TapRecognizer;\n}(Recognizer);\n\n/**\n * @private\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\n\nvar AttrRecognizer =\n/*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(AttrRecognizer, _Recognizer);\n\n  function AttrRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _Recognizer.call(this, _extends({\n      pointers: 1\n    }, options)) || this;\n  }\n  /**\n   * @private\n   * Used to check if it the recognizer receives valid input, like input.distance > 10.\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {Boolean} recognized\n   */\n\n\n  var _proto = AttrRecognizer.prototype;\n\n  _proto.attrTest = function attrTest(input) {\n    var optionPointers = this.options.pointers;\n    return optionPointers === 0 || input.pointers.length === optionPointers;\n  };\n  /**\n   * @private\n   * Process the input and return the state for the recognizer\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {*} State\n   */\n\n\n  _proto.process = function process(input) {\n    var state = this.state;\n    var eventType = input.eventType;\n    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n    var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED\n\n    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n      return state | STATE_CANCELLED;\n    } else if (isRecognized || isValid) {\n      if (eventType & INPUT_END) {\n        return state | STATE_ENDED;\n      } else if (!(state & STATE_BEGAN)) {\n        return STATE_BEGAN;\n      }\n\n      return state | STATE_CHANGED;\n    }\n\n    return STATE_FAILED;\n  };\n\n  return AttrRecognizer;\n}(Recognizer);\n\n/**\n * @private\n * direction cons to string\n * @param {constant} direction\n * @returns {String}\n */\n\nfunction directionStr(direction) {\n  if (direction === DIRECTION_DOWN) {\n    return 'down';\n  } else if (direction === DIRECTION_UP) {\n    return 'up';\n  } else if (direction === DIRECTION_LEFT) {\n    return 'left';\n  } else if (direction === DIRECTION_RIGHT) {\n    return 'right';\n  }\n\n  return '';\n}\n\n/**\n * @private\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar PanRecognizer =\n/*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(PanRecognizer, _AttrRecognizer);\n\n  function PanRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _AttrRecognizer.call(this, _extends({\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    }, options)) || this;\n    _this.pX = null;\n    _this.pY = null;\n    return _this;\n  }\n\n  var _proto = PanRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    var direction = this.options.direction;\n    var actions = [];\n\n    if (direction & DIRECTION_HORIZONTAL) {\n      actions.push(TOUCH_ACTION_PAN_Y);\n    }\n\n    if (direction & DIRECTION_VERTICAL) {\n      actions.push(TOUCH_ACTION_PAN_X);\n    }\n\n    return actions;\n  };\n\n  _proto.directionTest = function directionTest(input) {\n    var options = this.options;\n    var hasMoved = true;\n    var distance = input.distance;\n    var direction = input.direction;\n    var x = input.deltaX;\n    var y = input.deltaY; // lock to axis?\n\n    if (!(direction & options.direction)) {\n      if (options.direction & DIRECTION_HORIZONTAL) {\n        direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        hasMoved = x !== this.pX;\n        distance = Math.abs(input.deltaX);\n      } else {\n        direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n        hasMoved = y !== this.pY;\n        distance = Math.abs(input.deltaY);\n      }\n    }\n\n    input.direction = direction;\n    return hasMoved && distance > options.threshold && direction & options.direction;\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return AttrRecognizer.prototype.attrTest.call(this, input) && ( // replace with a super call\n    this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n  };\n\n  _proto.emit = function emit(input) {\n    this.pX = input.deltaX;\n    this.pY = input.deltaY;\n    var direction = directionStr(input.direction);\n\n    if (direction) {\n      input.additionalEvent = this.options.event + direction;\n    }\n\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n\n  return PanRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar SwipeRecognizer =\n/*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(SwipeRecognizer, _AttrRecognizer);\n\n  function SwipeRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    }, options)) || this;\n  }\n\n  var _proto = SwipeRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return PanRecognizer.prototype.getTouchAction.call(this);\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    var direction = this.options.direction;\n    var velocity;\n\n    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n      velocity = input.overallVelocity;\n    } else if (direction & DIRECTION_HORIZONTAL) {\n      velocity = input.overallVelocityX;\n    } else if (direction & DIRECTION_VERTICAL) {\n      velocity = input.overallVelocityY;\n    }\n\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs$1(velocity) > this.options.velocity && input.eventType & INPUT_END;\n  };\n\n  _proto.emit = function emit(input) {\n    var direction = directionStr(input.offsetDirection);\n\n    if (direction) {\n      this.manager.emit(this.options.event + direction, input);\n    }\n\n    this.manager.emit(this.options.event, input);\n  };\n\n  return SwipeRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar PinchRecognizer =\n/*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(PinchRecognizer, _AttrRecognizer);\n\n  function PinchRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n\n  var _proto = PinchRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n\n  _proto.emit = function emit(input) {\n    if (input.scale !== 1) {\n      var inOut = input.scale < 1 ? 'in' : 'out';\n      input.additionalEvent = this.options.event + inOut;\n    }\n\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n\n  return PinchRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar RotateRecognizer =\n/*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(RotateRecognizer, _AttrRecognizer);\n\n  function RotateRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n\n  var _proto = RotateRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n\n  return RotateRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\n\nvar PressRecognizer =\n/*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(PressRecognizer, _Recognizer);\n\n  function PressRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _Recognizer.call(this, _extends({\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      // minimal time of the pointer to be pressed\n      threshold: 9\n    }, options)) || this;\n    _this._timer = null;\n    _this._input = null;\n    return _this;\n  }\n\n  var _proto = PressRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_AUTO];\n  };\n\n  _proto.process = function process(input) {\n    var _this2 = this;\n\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTime = input.deltaTime > options.time;\n    this._input = input; // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n\n    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n      this.reset();\n    } else if (input.eventType & INPUT_START) {\n      this.reset();\n      this._timer = setTimeout(function () {\n        _this2.state = STATE_RECOGNIZED;\n\n        _this2.tryEmit();\n      }, options.time);\n    } else if (input.eventType & INPUT_END) {\n      return STATE_RECOGNIZED;\n    }\n\n    return STATE_FAILED;\n  };\n\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n\n  _proto.emit = function emit(input) {\n    if (this.state !== STATE_RECOGNIZED) {\n      return;\n    }\n\n    if (input && input.eventType & INPUT_END) {\n      this.manager.emit(this.options.event + \"up\", input);\n    } else {\n      this._input.timeStamp = now();\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n\n  return PressRecognizer;\n}(Recognizer);\n\nvar defaults = {\n  /**\n   * @private\n   * set if DOM events are being triggered.\n   * But this is slower and unused by simple implementations, so disabled by default.\n   * @type {Boolean}\n   * @default false\n   */\n  domEvents: false,\n\n  /**\n   * @private\n   * The value for the touchAction property/fallback.\n   * When set to `compute` it will magically set the correct value based on the added recognizers.\n   * @type {String}\n   * @default compute\n   */\n  touchAction: TOUCH_ACTION_COMPUTE,\n\n  /**\n   * @private\n   * @type {Boolean}\n   * @default true\n   */\n  enable: true,\n\n  /**\n   * @private\n   * EXPERIMENTAL FEATURE -- can be removed/changed\n   * Change the parent input target element.\n   * If Null, then it is being set the to main element.\n   * @type {Null|EventTarget}\n   * @default null\n   */\n  inputTarget: null,\n\n  /**\n   * @private\n   * force an input class\n   * @type {Null|Function}\n   * @default null\n   */\n  inputClass: null,\n\n  /**\n   * @private\n   * Some CSS properties can be used to improve the working of Hammer.\n   * Add them to this method and they will be set when creating a new Manager.\n   * @namespace\n   */\n  cssProps: {\n    /**\n     * @private\n     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userSelect: \"none\",\n\n    /**\n     * @private\n     * Disable the Windows Phone grippers when pressing an element.\n     * @type {String}\n     * @default 'none'\n     */\n    touchSelect: \"none\",\n\n    /**\n     * @private\n     * Disables the default callout shown when you touch and hold a touch target.\n     * On iOS, when you touch and hold a touch target such as a link, Safari displays\n     * a callout containing information about the link. This property allows you to disable that callout.\n     * @type {String}\n     * @default 'none'\n     */\n    touchCallout: \"none\",\n\n    /**\n     * @private\n     * Specifies whether zooming is enabled. Used by IE10>\n     * @type {String}\n     * @default 'none'\n     */\n    contentZooming: \"none\",\n\n    /**\n     * @private\n     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userDrag: \"none\",\n\n    /**\n     * @private\n     * Overrides the highlight color shown when the user taps a link or a JavaScript\n     * clickable element in iOS. This property obeys the alpha value, if specified.\n     * @type {String}\n     * @default 'rgba(0,0,0,0)'\n     */\n    tapHighlightColor: \"rgba(0,0,0,0)\"\n  }\n};\n/**\n * @private\n * Default recognizer setup when calling `Hammer()`\n * When creating a new Manager these will be skipped.\n * This is separated with other defaults because of tree-shaking.\n * @type {Array}\n */\n\nvar preset = [[RotateRecognizer, {\n  enable: false\n}], [PinchRecognizer, {\n  enable: false\n}, ['rotate']], [SwipeRecognizer, {\n  direction: DIRECTION_HORIZONTAL\n}], [PanRecognizer, {\n  direction: DIRECTION_HORIZONTAL\n}, ['swipe']], [TapRecognizer], [TapRecognizer, {\n  event: 'doubletap',\n  taps: 2\n}, ['tap']], [PressRecognizer]];\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n/**\n * @private\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\n\nfunction toggleCssProps(manager, add) {\n  var element = manager.element;\n\n  if (!element.style) {\n    return;\n  }\n\n  var prop;\n  each(manager.options.cssProps, function (value, name) {\n    prop = prefixed(element.style, name);\n\n    if (add) {\n      manager.oldCssProps[prop] = element.style[prop];\n      element.style[prop] = value;\n    } else {\n      element.style[prop] = manager.oldCssProps[prop] || \"\";\n    }\n  });\n\n  if (!add) {\n    manager.oldCssProps = {};\n  }\n}\n/**\n * @private\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\n\n\nfunction triggerDomEvent(event, data) {\n  var gestureEvent = document.createEvent(\"Event\");\n  gestureEvent.initEvent(event, true, true);\n  gestureEvent.gesture = data;\n  data.target.dispatchEvent(gestureEvent);\n}\n/**\n* @private\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\n\n\nvar Manager =\n/*#__PURE__*/\nfunction () {\n  function Manager(element, options) {\n    var _this = this;\n\n    this.options = assign$1({}, defaults, options || {});\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    toggleCssProps(this, true);\n    each(this.options.recognizers, function (item) {\n      var recognizer = _this.add(new item[0](item[1]));\n\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @returns {Manager}\n   */\n\n\n  var _proto = Manager.prototype;\n\n  _proto.set = function set(options) {\n    assign$1(this.options, options); // Options that need a little more setup\n\n    if (options.touchAction) {\n      this.touchAction.update();\n    }\n\n    if (options.inputTarget) {\n      // Clean up existing event listeners and reinitialize\n      this.input.destroy();\n      this.input.target = options.inputTarget;\n      this.input.init();\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * stop recognizing for this session.\n   * This session will be discarded, when a new [input]start event is fired.\n   * When forced, the recognizer cycle is stopped immediately.\n   * @param {Boolean} [force]\n   */\n\n\n  _proto.stop = function stop(force) {\n    this.session.stopped = force ? FORCED_STOP : STOP;\n  };\n  /**\n   * @private\n   * run the recognizers!\n   * called by the inputHandler function on every movement of the pointers (touches)\n   * it walks through all the recognizers and tries to detect the gesture that is being made\n   * @param {Object} inputData\n   */\n\n\n  _proto.recognize = function recognize(inputData) {\n    var session = this.session;\n\n    if (session.stopped) {\n      return;\n    } // run the touch-action polyfill\n\n\n    this.touchAction.preventDefaults(inputData);\n    var recognizer;\n    var recognizers = this.recognizers; // this holds the recognizer that is being recognized.\n    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n    // if no recognizer is detecting a thing, it is set to `null`\n\n    var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized\n    // or when we're in a new session\n\n    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n      session.curRecognizer = null;\n      curRecognizer = null;\n    }\n\n    var i = 0;\n\n    while (i < recognizers.length) {\n      recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.\n      // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n      //      that is being recognized.\n      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n      //      this can be setup with the `recognizeWith()` method on the recognizer.\n\n      if (session.stopped !== FORCED_STOP && ( // 1\n      !curRecognizer || recognizer === curRecognizer || // 2\n      recognizer.canRecognizeWith(curRecognizer))) {\n        // 3\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n      // current active recognizer. but only if we don't already have an active recognizer\n\n\n      if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n        session.curRecognizer = recognizer;\n        curRecognizer = recognizer;\n      }\n\n      i++;\n    }\n  };\n  /**\n   * @private\n   * get a recognizer by its event name.\n   * @param {Recognizer|String} recognizer\n   * @returns {Recognizer|Null}\n   */\n\n\n  _proto.get = function get(recognizer) {\n    if (recognizer instanceof Recognizer) {\n      return recognizer;\n    }\n\n    var recognizers = this.recognizers;\n\n    for (var i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizer) {\n        return recognizers[i];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * @private add a recognizer to the manager\n   * existing recognizers with the same event name will be removed\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer|Manager}\n   */\n\n\n  _proto.add = function add(recognizer) {\n    if (invokeArrayArg(recognizer, \"add\", this)) {\n      return this;\n    } // remove existing\n\n\n    var existing = this.get(recognizer.options.event);\n\n    if (existing) {\n      this.remove(existing);\n    }\n\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n    this.touchAction.update();\n    return recognizer;\n  };\n  /**\n   * @private\n   * remove a recognizer by name or instance\n   * @param {Recognizer|String} recognizer\n   * @returns {Manager}\n   */\n\n\n  _proto.remove = function remove(recognizer) {\n    if (invokeArrayArg(recognizer, \"remove\", this)) {\n      return this;\n    }\n\n    var targetRecognizer = this.get(recognizer); // let's make sure this recognizer exists\n\n    if (recognizer) {\n      var recognizers = this.recognizers;\n      var index = inArray(recognizers, targetRecognizer);\n\n      if (index !== -1) {\n        recognizers.splice(index, 1);\n        this.touchAction.update();\n      }\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * bind event\n   * @param {String} events\n   * @param {Function} handler\n   * @returns {EventEmitter} this\n   */\n\n\n  _proto.on = function on(events, handler) {\n    if (events === undefined || handler === undefined) {\n      return this;\n    }\n\n    var handlers = this.handlers;\n    each(splitStr(events), function (event) {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    });\n    return this;\n  };\n  /**\n   * @private unbind event, leave emit blank to remove all handlers\n   * @param {String} events\n   * @param {Function} [handler]\n   * @returns {EventEmitter} this\n   */\n\n\n  _proto.off = function off(events, handler) {\n    if (events === undefined) {\n      return this;\n    }\n\n    var handlers = this.handlers;\n    each(splitStr(events), function (event) {\n      if (!handler) {\n        delete handlers[event];\n      } else {\n        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n      }\n    });\n    return this;\n  };\n  /**\n   * @private emit event to the listeners\n   * @param {String} event\n   * @param {Object} data\n   */\n\n\n  _proto.emit = function emit(event, data) {\n    // we also want to trigger dom events\n    if (this.options.domEvents) {\n      triggerDomEvent(event, data);\n    } // no handlers, so skip it all\n\n\n    var handlers = this.handlers[event] && this.handlers[event].slice();\n\n    if (!handlers || !handlers.length) {\n      return;\n    }\n\n    data.type = event;\n\n    data.preventDefault = function () {\n      data.srcEvent.preventDefault();\n    };\n\n    var i = 0;\n\n    while (i < handlers.length) {\n      handlers[i](data);\n      i++;\n    }\n  };\n  /**\n   * @private\n   * destroy the manager and unbinds all events\n   * it doesn't unbind dom events, that is the user own responsibility\n   */\n\n\n  _proto.destroy = function destroy() {\n    this.element && toggleCssProps(this, false);\n    this.handlers = {};\n    this.session = {};\n    this.input.destroy();\n    this.element = null;\n  };\n\n  return Manager;\n}();\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n/**\n * @private\n * Touch events input\n * @constructor\n * @extends Input\n */\n\nvar SingleTouchInput =\n/*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(SingleTouchInput, _Input);\n\n  function SingleTouchInput() {\n    var _this;\n\n    var proto = SingleTouchInput.prototype;\n    proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.started = false;\n    return _this;\n  }\n\n  var _proto = SingleTouchInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?\n\n    if (type === INPUT_START) {\n      this.started = true;\n    }\n\n    if (!this.started) {\n      return;\n    }\n\n    var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state\n\n    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n      this.started = false;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n\n  return SingleTouchInput;\n}(Input);\n\nfunction normalizeSingleTouches(ev, type) {\n  var all = toArray(ev.touches);\n  var changed = toArray(ev.changedTouches);\n\n  if (type & (INPUT_END | INPUT_CANCEL)) {\n    all = uniqueArray(all.concat(changed), 'identifier', true);\n  }\n\n  return [all, changed];\n}\n\n/**\n * @private\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n  var deprecationMessage = \"DEPRECATED METHOD: \" + name + \"\\n\" + message + \" AT \\n\";\n  return function () {\n    var e = new Error('get-stack-trace');\n    var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n    var log = window.console && (window.console.warn || window.console.log);\n\n    if (log) {\n      log.call(window.console, deprecationMessage, stack);\n    }\n\n    return method.apply(this, arguments);\n  };\n}\n\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\n\nvar extend = deprecate(function (dest, src, merge) {\n  var keys = Object.keys(src);\n  var i = 0;\n\n  while (i < keys.length) {\n    if (!merge || merge && dest[keys[i]] === undefined) {\n      dest[keys[i]] = src[keys[i]];\n    }\n\n    i++;\n  }\n\n  return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * @private\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\n\nvar merge$2 = deprecate(function (dest, src) {\n  return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * @private\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\n\nfunction inherit(child, base, properties) {\n  var baseP = base.prototype;\n  var childP;\n  childP = child.prototype = Object.create(baseP);\n  childP.constructor = child;\n  childP._super = baseP;\n\n  if (properties) {\n    assign$1(childP, properties);\n  }\n}\n\n/**\n * @private\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n  return function boundFn() {\n    return fn.apply(context, arguments);\n  };\n}\n\n/**\n * @private\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\n\nvar Hammer$2 =\n/*#__PURE__*/\nfunction () {\n  var Hammer =\n  /**\n    * @private\n    * @const {string}\n    */\n  function Hammer(element, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return new Manager(element, _extends({\n      recognizers: preset.concat()\n    }, options));\n  };\n\n  Hammer.VERSION = \"2.0.17-rc\";\n  Hammer.DIRECTION_ALL = DIRECTION_ALL;\n  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer.DIRECTION_LEFT = DIRECTION_LEFT;\n  Hammer.DIRECTION_RIGHT = DIRECTION_RIGHT;\n  Hammer.DIRECTION_UP = DIRECTION_UP;\n  Hammer.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;\n  Hammer.DIRECTION_VERTICAL = DIRECTION_VERTICAL;\n  Hammer.DIRECTION_NONE = DIRECTION_NONE;\n  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer.INPUT_START = INPUT_START;\n  Hammer.INPUT_MOVE = INPUT_MOVE;\n  Hammer.INPUT_END = INPUT_END;\n  Hammer.INPUT_CANCEL = INPUT_CANCEL;\n  Hammer.STATE_POSSIBLE = STATE_POSSIBLE;\n  Hammer.STATE_BEGAN = STATE_BEGAN;\n  Hammer.STATE_CHANGED = STATE_CHANGED;\n  Hammer.STATE_ENDED = STATE_ENDED;\n  Hammer.STATE_RECOGNIZED = STATE_RECOGNIZED;\n  Hammer.STATE_CANCELLED = STATE_CANCELLED;\n  Hammer.STATE_FAILED = STATE_FAILED;\n  Hammer.Manager = Manager;\n  Hammer.Input = Input;\n  Hammer.TouchAction = TouchAction;\n  Hammer.TouchInput = TouchInput;\n  Hammer.MouseInput = MouseInput;\n  Hammer.PointerEventInput = PointerEventInput;\n  Hammer.TouchMouseInput = TouchMouseInput;\n  Hammer.SingleTouchInput = SingleTouchInput;\n  Hammer.Recognizer = Recognizer;\n  Hammer.AttrRecognizer = AttrRecognizer;\n  Hammer.Tap = TapRecognizer;\n  Hammer.Pan = PanRecognizer;\n  Hammer.Swipe = SwipeRecognizer;\n  Hammer.Pinch = PinchRecognizer;\n  Hammer.Rotate = RotateRecognizer;\n  Hammer.Press = PressRecognizer;\n  Hammer.on = addEventListeners;\n  Hammer.off = removeEventListeners;\n  Hammer.each = each;\n  Hammer.merge = merge$2;\n  Hammer.extend = extend;\n  Hammer.bindFn = bindFn;\n  Hammer.assign = assign$1;\n  Hammer.inherit = inherit;\n  Hammer.bindFn = bindFn;\n  Hammer.prefixed = prefixed;\n  Hammer.toArray = toArray;\n  Hammer.inArray = inArray;\n  Hammer.uniqueArray = uniqueArray;\n  Hammer.splitStr = splitStr;\n  Hammer.boolOrFn = boolOrFn;\n  Hammer.hasParent = hasParent;\n  Hammer.addEventListeners = addEventListeners;\n  Hammer.removeEventListeners = removeEventListeners;\n  Hammer.defaults = assign$1({}, defaults, {\n    preset: preset\n  });\n  return Hammer;\n}();\n\n//  style loader but by script tag, not by the loader.\n\nHammer$2.defaults;\n\nvar RealHammer = Hammer$2;\n\nfunction _createForOfIteratorHelper$6(o, allowArrayLike) { var it = typeof _Symbol !== \"undefined\" && _getIteratorMethod(o) || o[\"@@iterator\"]; if (!it) { if (_Array$isArray(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$6(o, minLen) { var _context17; if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$6(o, minLen); var n = _sliceInstanceProperty(_context17 = Object.prototype.toString.call(o)).call(_context17, 8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return _Array$from$1(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen); }\nfunction _arrayLikeToArray$6(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n/**\r\n * Use this symbol to delete properies in deepObjectAssign.\r\n */\n_Symbol(\"DELETE\");\n\n/**\r\n * Seedable, fast and reasonably good (not crypto but more than okay for our\r\n * needs) random number generator.\r\n *\r\n * @remarks\r\n * Adapted from {@link https://web.archive.org/web/20110429100736/http://baagoe.com:80/en/RandomMusings/javascript}.\r\n * Original algorithm created by Johannes BaagÃ¸e \\<baagoe\\@baagoe.com\\> in 2010.\r\n */\n/**\r\n * Create a seeded pseudo random generator based on Alea by Johannes BaagÃ¸e.\r\n *\r\n * @param seed - All supplied arguments will be used as a seed. In case nothing\r\n * is supplied the current time will be used to seed the generator.\r\n * @returns A ready to use seeded generator.\r\n */\nfunction Alea() {\n  for (var _len3 = arguments.length, seed = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    seed[_key3] = arguments[_key3];\n  }\n  return AleaImplementation(seed.length ? seed : [_Date$now()]);\n}\n/**\r\n * An implementation of [[Alea]] without user input validation.\r\n *\r\n * @param seed - The data that will be used to seed the generator.\r\n * @returns A ready to use seeded generator.\r\n */\nfunction AleaImplementation(seed) {\n  var _mashSeed = mashSeed(seed),\n    _mashSeed2 = _slicedToArray(_mashSeed, 3),\n    s0 = _mashSeed2[0],\n    s1 = _mashSeed2[1],\n    s2 = _mashSeed2[2];\n  var c = 1;\n  var random = function random() {\n    var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32\n    s0 = s1;\n    s1 = s2;\n    return s2 = t - (c = t | 0);\n  };\n  random.uint32 = function () {\n    return random() * 0x100000000;\n  }; // 2^32\n  random.fract53 = function () {\n    return random() + (random() * 0x200000 | 0) * 1.1102230246251565e-16;\n  }; // 2^-53\n  random.algorithm = \"Alea\";\n  random.seed = seed;\n  random.version = \"0.9\";\n  return random;\n}\n/**\r\n * Turn arbitrary data into values [[AleaImplementation]] can use to generate\r\n * random numbers.\r\n *\r\n * @param seed - Arbitrary data that will be used as the seed.\r\n * @returns Three numbers to use as initial values for [[AleaImplementation]].\r\n */\nfunction mashSeed() {\n  var mash = Mash();\n  var s0 = mash(\" \");\n  var s1 = mash(\" \");\n  var s2 = mash(\" \");\n  for (var i = 0; i < arguments.length; i++) {\n    s0 -= mash(i < 0 || arguments.length <= i ? undefined : arguments[i]);\n    if (s0 < 0) {\n      s0 += 1;\n    }\n    s1 -= mash(i < 0 || arguments.length <= i ? undefined : arguments[i]);\n    if (s1 < 0) {\n      s1 += 1;\n    }\n    s2 -= mash(i < 0 || arguments.length <= i ? undefined : arguments[i]);\n    if (s2 < 0) {\n      s2 += 1;\n    }\n  }\n  return [s0, s1, s2];\n}\n/**\r\n * Create a new mash function.\r\n *\r\n * @returns A nonpure function that takes arbitrary [[Mashable]] data and turns\r\n * them into numbers.\r\n */\nfunction Mash() {\n  var n = 0xefc8249d;\n  return function (data) {\n    var string = data.toString();\n    for (var i = 0; i < string.length; i++) {\n      n += string.charCodeAt(i);\n      var h = 0.02519603282416938 * n;\n      n = h >>> 0;\n      h -= n;\n      h *= n;\n      n = h >>> 0;\n      h -= n;\n      n += h * 0x100000000; // 2^32\n    }\n\n    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32\n  };\n}\n\n/**\n * Setup a mock hammer.js object, for unit testing.\n *\n * Inspiration: https://github.com/uber/deck.gl/pull/658\n *\n * @returns {{on: noop, off: noop, destroy: noop, emit: noop, get: get}}\n */\nfunction hammerMock() {\n  var noop = function noop() {};\n  return {\n    on: noop,\n    off: noop,\n    destroy: noop,\n    emit: noop,\n    get: function get() {\n      return {\n        set: noop\n      };\n    }\n  };\n}\nvar Hammer$1 = typeof window !== \"undefined\" ? window.Hammer || RealHammer : function () {\n  // hammer.js is only available in a browser, not in node.js. Replacing it with a mock object.\n  return hammerMock();\n};\n\n/**\n * Turn an element into an clickToUse element.\n * When not active, the element has a transparent overlay. When the overlay is\n * clicked, the mode is changed to active.\n * When active, the element is displayed with a blue border around it, and\n * the interactive contents of the element can be used. When clicked outside\n * the element, the elements mode is changed to inactive.\n *\n * @param {Element} container\n * @class Activator\n */\nfunction Activator$1(container) {\n  var _this = this,\n    _context3;\n  this._cleanupQueue = [];\n  this.active = false;\n  this._dom = {\n    container: container,\n    overlay: document.createElement(\"div\")\n  };\n  this._dom.overlay.classList.add(\"vis-overlay\");\n  this._dom.container.appendChild(this._dom.overlay);\n  this._cleanupQueue.push(function () {\n    _this._dom.overlay.parentNode.removeChild(_this._dom.overlay);\n  });\n  var hammer = Hammer$1(this._dom.overlay);\n  hammer.on(\"tap\", _bindInstanceProperty$1(_context3 = this._onTapOverlay).call(_context3, this));\n  this._cleanupQueue.push(function () {\n    hammer.destroy();\n    // FIXME: cleaning up hammer instances doesn't work (Timeline not removed\n    // from memory)\n  });\n\n  // block all touch events (except tap)\n  var events = [\"tap\", \"doubletap\", \"press\", \"pinch\", \"pan\", \"panstart\", \"panmove\", \"panend\"];\n  _forEachInstanceProperty(events).call(events, function (event) {\n    hammer.on(event, function (event) {\n      event.srcEvent.stopPropagation();\n    });\n  });\n\n  // attach a click event to the window, in order to deactivate when clicking outside the timeline\n  if (document && document.body) {\n    this._onClick = function (event) {\n      if (!_hasParent(event.target, container)) {\n        _this.deactivate();\n      }\n    };\n    document.body.addEventListener(\"click\", this._onClick);\n    this._cleanupQueue.push(function () {\n      document.body.removeEventListener(\"click\", _this._onClick);\n    });\n  }\n\n  // prepare escape key listener for deactivating when active\n  this._escListener = function (event) {\n    if (\"key\" in event ? event.key === \"Escape\" : event.keyCode === 27 /* the keyCode is for IE11 */) {\n      _this.deactivate();\n    }\n  };\n}\n\n// turn into an event emitter\nEmitter(Activator$1.prototype);\n\n// The currently active activator\nActivator$1.current = null;\n\n/**\n * Destroy the activator. Cleans up all created DOM and event listeners\n */\nActivator$1.prototype.destroy = function () {\n  var _context4, _context5;\n  this.deactivate();\n  var _iterator2 = _createForOfIteratorHelper$6(_reverseInstanceProperty(_context4 = _spliceInstanceProperty(_context5 = this._cleanupQueue).call(_context5, 0)).call(_context4)),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var callback = _step2.value;\n      callback();\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n};\n\n/**\n * Activate the element\n * Overlay is hidden, element is decorated with a blue shadow border\n */\nActivator$1.prototype.activate = function () {\n  // we allow only one active activator at a time\n  if (Activator$1.current) {\n    Activator$1.current.deactivate();\n  }\n  Activator$1.current = this;\n  this.active = true;\n  this._dom.overlay.style.display = \"none\";\n  this._dom.container.classList.add(\"vis-active\");\n  this.emit(\"change\");\n  this.emit(\"activate\");\n\n  // ugly hack: bind ESC after emitting the events, as the Network rebinds all\n  // keyboard events on a 'change' event\n  document.body.addEventListener(\"keydown\", this._escListener);\n};\n\n/**\n * Deactivate the element\n * Overlay is displayed on top of the element\n */\nActivator$1.prototype.deactivate = function () {\n  this.active = false;\n  this._dom.overlay.style.display = \"block\";\n  this._dom.container.classList.remove(\"vis-active\");\n  document.body.removeEventListener(\"keydown\", this._escListener);\n  this.emit(\"change\");\n  this.emit(\"deactivate\");\n};\n\n/**\n * Handle a tap event: activate the container\n *\n * @param {Event}  event   The event\n * @private\n */\nActivator$1.prototype._onTapOverlay = function (event) {\n  // activate the container\n  this.activate();\n  event.srcEvent.stopPropagation();\n};\n\n/**\n * Test whether the element has the requested parent element somewhere in\n * its chain of parent nodes.\n *\n * @param {HTMLElement} element\n * @param {HTMLElement} parent\n * @returns {boolean} Returns true when the parent is found somewhere in the\n *                    chain of parent nodes.\n * @private\n */\nfunction _hasParent(element, parent) {\n  while (element) {\n    if (element === parent) {\n      return true;\n    }\n    element = element.parentNode;\n  }\n  return false;\n}\n// Color REs\nvar fullHexRE = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i;\nvar shortHexRE = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\nvar rgbRE = /^rgb\\( *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *\\)$/i;\nvar rgbaRE = /^rgba\\( *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *([01]|0?\\.\\d+) *\\)$/i;\n/**\r\n * Remove everything in the DOM object.\r\n *\r\n * @param DOMobject - Node whose child nodes will be recursively deleted.\r\n */\nfunction recursiveDOMDelete(DOMobject) {\n  if (DOMobject) {\n    while (DOMobject.hasChildNodes() === true) {\n      var child = DOMobject.firstChild;\n      if (child) {\n        recursiveDOMDelete(child);\n        DOMobject.removeChild(child);\n      }\n    }\n  }\n}\n/**\r\n * Test whether given object is a string.\r\n *\r\n * @param value - Input value of unknown type.\r\n * @returns True if string, false otherwise.\r\n */\nfunction isString(value) {\n  return value instanceof String || typeof value === \"string\";\n}\n/**\r\n * Test whether given object is a object (not primitive or null).\r\n *\r\n * @param value - Input value of unknown type.\r\n * @returns True if not null object, false otherwise.\r\n */\nfunction isObject$7(value) {\n  return _typeof(value) === \"object\" && value !== null;\n}\n/**\r\n * Copy property from b to a if property present in a.\r\n * If property in b explicitly set to null, delete it if `allowDeletion` set.\r\n *\r\n * Internal helper routine, should not be exported. Not added to `exports` for that reason.\r\n *\r\n * @param a - Target object.\r\n * @param b - Source object.\r\n * @param prop - Name of property to copy from b to a.\r\n * @param allowDeletion - If true, delete property in a if explicitly set to null in b.\r\n */\nfunction copyOrDelete(a, b, prop, allowDeletion) {\n  var doDeletion = false;\n  if (allowDeletion === true) {\n    doDeletion = b[prop] === null && a[prop] !== undefined;\n  }\n  if (doDeletion) {\n    delete a[prop];\n  } else {\n    a[prop] = b[prop]; // Remember, this is a reference copy!\n  }\n}\n/**\r\n * Fill an object with a possibly partially defined other object.\r\n *\r\n * Only copies values for the properties already present in a.\r\n * That means an object is not created on a property if only the b object has it.\r\n *\r\n * @param a - The object that will have it's properties updated.\r\n * @param b - The object with property updates.\r\n * @param allowDeletion - If true, delete properties in a that are explicitly set to null in b.\r\n */\nfunction fillIfDefined(a, b) {\n  var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // NOTE: iteration of properties of a\n  // NOTE: prototype properties iterated over as well\n  for (var prop in a) {\n    if (b[prop] !== undefined) {\n      if (b[prop] === null || _typeof(b[prop]) !== \"object\") {\n        // Note: typeof null === 'object'\n        copyOrDelete(a, b, prop, allowDeletion);\n      } else {\n        var aProp = a[prop];\n        var bProp = b[prop];\n        if (isObject$7(aProp) && isObject$7(bProp)) {\n          fillIfDefined(aProp, bProp, allowDeletion);\n        }\n      }\n    }\n  }\n}\n/**\r\n * Extend object a with selected properties of object b.\r\n * Only properties with defined values are copied.\r\n *\r\n * @remarks\r\n * Previous version of this routine implied that multiple source objects could\r\n * be used; however, the implementation was **wrong**. Since multiple (\\>1)\r\n * sources weren't used anywhere in the `vis.js` code, this has been removed\r\n * @param props - Names of first-level properties to copy over.\r\n * @param a - Target object.\r\n * @param b - Source object.\r\n * @param allowDeletion - If true, delete property in a if explicitly set to null in b.\r\n * @returns Argument a.\r\n */\nfunction selectiveDeepExtend(props, a, b) {\n  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  // TODO: add support for Arrays to deepExtend\n  if (_Array$isArray(b)) {\n    throw new TypeError(\"Arrays are not supported by deepExtend\");\n  }\n  for (var p = 0; p < props.length; p++) {\n    var prop = props[p];\n    if (Object.prototype.hasOwnProperty.call(b, prop)) {\n      if (b[prop] && b[prop].constructor === Object) {\n        if (a[prop] === undefined) {\n          a[prop] = {};\n        }\n        if (a[prop].constructor === Object) {\n          deepExtend(a[prop], b[prop], false, allowDeletion);\n        } else {\n          copyOrDelete(a, b, prop, allowDeletion);\n        }\n      } else if (_Array$isArray(b[prop])) {\n        throw new TypeError(\"Arrays are not supported by deepExtend\");\n      } else {\n        copyOrDelete(a, b, prop, allowDeletion);\n      }\n    }\n  }\n  return a;\n}\n/**\r\n * Extend object `a` with properties of object `b`, ignoring properties which\r\n * are explicitly specified to be excluded.\r\n *\r\n * @remarks\r\n * The properties of `b` are considered for copying. Properties which are\r\n * themselves objects are are also extended. Only properties with defined\r\n * values are copied.\r\n * @param propsToExclude - Names of properties which should *not* be copied.\r\n * @param a - Object to extend.\r\n * @param b - Object to take properties from for extension.\r\n * @param allowDeletion - If true, delete properties in a that are explicitly\r\n * set to null in b.\r\n * @returns Argument a.\r\n */\nfunction selectiveNotDeepExtend(propsToExclude, a, b) {\n  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  // TODO: add support for Arrays to deepExtend\n  // NOTE: array properties have an else-below; apparently, there is a problem here.\n  if (_Array$isArray(b)) {\n    throw new TypeError(\"Arrays are not supported by deepExtend\");\n  }\n  for (var prop in b) {\n    if (!Object.prototype.hasOwnProperty.call(b, prop)) {\n      continue;\n    } // Handle local properties only\n    if (_includesInstanceProperty(propsToExclude).call(propsToExclude, prop)) {\n      continue;\n    } // In exclusion list, skip\n    if (b[prop] && b[prop].constructor === Object) {\n      if (a[prop] === undefined) {\n        a[prop] = {};\n      }\n      if (a[prop].constructor === Object) {\n        deepExtend(a[prop], b[prop]); // NOTE: allowDeletion not propagated!\n      } else {\n        copyOrDelete(a, b, prop, allowDeletion);\n      }\n    } else if (_Array$isArray(b[prop])) {\n      a[prop] = [];\n      for (var i = 0; i < b[prop].length; i++) {\n        a[prop].push(b[prop][i]);\n      }\n    } else {\n      copyOrDelete(a, b, prop, allowDeletion);\n    }\n  }\n  return a;\n}\n/**\r\n * Deep extend an object a with the properties of object b.\r\n *\r\n * @param a - Target object.\r\n * @param b - Source object.\r\n * @param protoExtend - If true, the prototype values will also be extended.\r\n * (That is the options objects that inherit from others will also get the\r\n * inherited options).\r\n * @param allowDeletion - If true, the values of fields that are null will be deleted.\r\n * @returns Argument a.\r\n */\nfunction deepExtend(a, b) {\n  var protoExtend = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  for (var prop in b) {\n    if (Object.prototype.hasOwnProperty.call(b, prop) || protoExtend === true) {\n      if (_typeof(b[prop]) === \"object\" && b[prop] !== null && _Object$getPrototypeOf$1(b[prop]) === Object.prototype) {\n        if (a[prop] === undefined) {\n          a[prop] = deepExtend({}, b[prop], protoExtend); // NOTE: allowDeletion not propagated!\n        } else if (_typeof(a[prop]) === \"object\" && a[prop] !== null && _Object$getPrototypeOf$1(a[prop]) === Object.prototype) {\n          deepExtend(a[prop], b[prop], protoExtend); // NOTE: allowDeletion not propagated!\n        } else {\n          copyOrDelete(a, b, prop, allowDeletion);\n        }\n      } else if (_Array$isArray(b[prop])) {\n        var _context6;\n        a[prop] = _sliceInstanceProperty(_context6 = b[prop]).call(_context6);\n      } else {\n        copyOrDelete(a, b, prop, allowDeletion);\n      }\n    }\n  }\n  return a;\n}\n/**\r\n * Used to extend an array and copy it. This is used to propagate paths recursively.\r\n *\r\n * @param arr - First part.\r\n * @param newValue - The value to be aadded into the array.\r\n * @returns A new array with all items from arr and newValue (which is last).\r\n */\nfunction copyAndExtendArray(arr, newValue) {\n  var _context7;\n  return _concatInstanceProperty(_context7 = []).call(_context7, _toConsumableArray(arr), [newValue]);\n}\n/**\r\n * Used to extend an array and copy it. This is used to propagate paths recursively.\r\n *\r\n * @param arr - The array to be copied.\r\n * @returns Shallow copy of arr.\r\n */\nfunction copyArray(arr) {\n  return _sliceInstanceProperty(arr).call(arr);\n}\n/**\r\n * Retrieve the absolute left value of a DOM element.\r\n *\r\n * @param elem - A dom element, for example a div.\r\n * @returns The absolute left position of this element in the browser page.\r\n */\nfunction getAbsoluteLeft(elem) {\n  return elem.getBoundingClientRect().left;\n}\n/**\r\n * Retrieve the absolute top value of a DOM element.\r\n *\r\n * @param elem - A dom element, for example a div.\r\n * @returns The absolute top position of this element in the browser page.\r\n */\nfunction getAbsoluteTop(elem) {\n  return elem.getBoundingClientRect().top;\n}\n/**\r\n * For each method for both arrays and objects.\r\n * In case of an array, the built-in Array.forEach() is applied (**No, it's not!**).\r\n * In case of an Object, the method loops over all properties of the object.\r\n *\r\n * @param object - An Object or Array to be iterated over.\r\n * @param callback - Array.forEach-like callback.\r\n */\nfunction forEach$1(object, callback) {\n  if (_Array$isArray(object)) {\n    // array\n    var len = object.length;\n    for (var i = 0; i < len; i++) {\n      callback(object[i], i, object);\n    }\n  } else {\n    // object\n    for (var key in object) {\n      if (Object.prototype.hasOwnProperty.call(object, key)) {\n        callback(object[key], key, object);\n      }\n    }\n  }\n}\n/**\r\n * Convert hex color string into RGB color object.\r\n *\r\n * @remarks\r\n * {@link http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb}\r\n * @param hex - Hex color string (3 or 6 digits, with or without #).\r\n * @returns RGB color object.\r\n */\nfunction hexToRGB(hex) {\n  var result;\n  switch (hex.length) {\n    case 3:\n    case 4:\n      result = shortHexRE.exec(hex);\n      return result ? {\n        r: _parseInt$1(result[1] + result[1], 16),\n        g: _parseInt$1(result[2] + result[2], 16),\n        b: _parseInt$1(result[3] + result[3], 16)\n      } : null;\n    case 6:\n    case 7:\n      result = fullHexRE.exec(hex);\n      return result ? {\n        r: _parseInt$1(result[1], 16),\n        g: _parseInt$1(result[2], 16),\n        b: _parseInt$1(result[3], 16)\n      } : null;\n    default:\n      return null;\n  }\n}\n/**\r\n * This function takes string color in hex or RGB format and adds the opacity, RGBA is passed through unchanged.\r\n *\r\n * @param color - The color string (hex, RGB, RGBA).\r\n * @param opacity - The new opacity.\r\n * @returns RGBA string, for example 'rgba(255, 0, 127, 0.3)'.\r\n */\nfunction overrideOpacity(color, opacity) {\n  if (_includesInstanceProperty(color).call(color, \"rgba\")) {\n    return color;\n  } else if (_includesInstanceProperty(color).call(color, \"rgb\")) {\n    var rgb = color.substr(_indexOfInstanceProperty(color).call(color, \"(\") + 1).replace(\")\", \"\").split(\",\");\n    return \"rgba(\" + rgb[0] + \",\" + rgb[1] + \",\" + rgb[2] + \",\" + opacity + \")\";\n  } else {\n    var _rgb = hexToRGB(color);\n    if (_rgb == null) {\n      return color;\n    } else {\n      return \"rgba(\" + _rgb.r + \",\" + _rgb.g + \",\" + _rgb.b + \",\" + opacity + \")\";\n    }\n  }\n}\n/**\r\n * Convert RGB \\<0, 255\\> into hex color string.\r\n *\r\n * @param red - Red channel.\r\n * @param green - Green channel.\r\n * @param blue - Blue channel.\r\n * @returns Hex color string (for example: '#0acdc0').\r\n */\nfunction RGBToHex(red, green, blue) {\n  var _context10;\n  return \"#\" + _sliceInstanceProperty(_context10 = ((1 << 24) + (red << 16) + (green << 8) + blue).toString(16)).call(_context10, 1);\n}\n/**\r\n * Parse a color property into an object with border, background, and highlight colors.\r\n *\r\n * @param inputColor - Shorthand color string or input color object.\r\n * @param defaultColor - Full color object to fill in missing values in inputColor.\r\n * @returns Color object.\r\n */\nfunction parseColor(inputColor, defaultColor) {\n  if (isString(inputColor)) {\n    var colorStr = inputColor;\n    if (isValidRGB(colorStr)) {\n      var _context11;\n      var rgb = _mapInstanceProperty(_context11 = colorStr.substr(4).substr(0, colorStr.length - 5).split(\",\")).call(_context11, function (value) {\n        return _parseInt$1(value);\n      });\n      colorStr = RGBToHex(rgb[0], rgb[1], rgb[2]);\n    }\n    if (isValidHex(colorStr) === true) {\n      var hsv = hexToHSV(colorStr);\n      var lighterColorHSV = {\n        h: hsv.h,\n        s: hsv.s * 0.8,\n        v: Math.min(1, hsv.v * 1.02)\n      };\n      var darkerColorHSV = {\n        h: hsv.h,\n        s: Math.min(1, hsv.s * 1.25),\n        v: hsv.v * 0.8\n      };\n      var darkerColorHex = HSVToHex(darkerColorHSV.h, darkerColorHSV.s, darkerColorHSV.v);\n      var lighterColorHex = HSVToHex(lighterColorHSV.h, lighterColorHSV.s, lighterColorHSV.v);\n      return {\n        background: colorStr,\n        border: darkerColorHex,\n        highlight: {\n          background: lighterColorHex,\n          border: darkerColorHex\n        },\n        hover: {\n          background: lighterColorHex,\n          border: darkerColorHex\n        }\n      };\n    } else {\n      return {\n        background: colorStr,\n        border: colorStr,\n        highlight: {\n          background: colorStr,\n          border: colorStr\n        },\n        hover: {\n          background: colorStr,\n          border: colorStr\n        }\n      };\n    }\n  } else {\n    if (defaultColor) {\n      var color = {\n        background: inputColor.background || defaultColor.background,\n        border: inputColor.border || defaultColor.border,\n        highlight: isString(inputColor.highlight) ? {\n          border: inputColor.highlight,\n          background: inputColor.highlight\n        } : {\n          background: inputColor.highlight && inputColor.highlight.background || defaultColor.highlight.background,\n          border: inputColor.highlight && inputColor.highlight.border || defaultColor.highlight.border\n        },\n        hover: isString(inputColor.hover) ? {\n          border: inputColor.hover,\n          background: inputColor.hover\n        } : {\n          border: inputColor.hover && inputColor.hover.border || defaultColor.hover.border,\n          background: inputColor.hover && inputColor.hover.background || defaultColor.hover.background\n        }\n      };\n      return color;\n    } else {\n      var _color = {\n        background: inputColor.background || undefined,\n        border: inputColor.border || undefined,\n        highlight: isString(inputColor.highlight) ? {\n          border: inputColor.highlight,\n          background: inputColor.highlight\n        } : {\n          background: inputColor.highlight && inputColor.highlight.background || undefined,\n          border: inputColor.highlight && inputColor.highlight.border || undefined\n        },\n        hover: isString(inputColor.hover) ? {\n          border: inputColor.hover,\n          background: inputColor.hover\n        } : {\n          border: inputColor.hover && inputColor.hover.border || undefined,\n          background: inputColor.hover && inputColor.hover.background || undefined\n        }\n      };\n      return _color;\n    }\n  }\n}\n/**\r\n * Convert RGB \\<0, 255\\> into HSV object.\r\n *\r\n * @remarks\r\n * {@link http://www.javascripter.net/faq/rgb2hsv.htm}\r\n * @param red - Red channel.\r\n * @param green - Green channel.\r\n * @param blue - Blue channel.\r\n * @returns HSV color object.\r\n */\nfunction RGBToHSV(red, green, blue) {\n  red = red / 255;\n  green = green / 255;\n  blue = blue / 255;\n  var minRGB = Math.min(red, Math.min(green, blue));\n  var maxRGB = Math.max(red, Math.max(green, blue));\n  // Black-gray-white\n  if (minRGB === maxRGB) {\n    return {\n      h: 0,\n      s: 0,\n      v: minRGB\n    };\n  }\n  // Colors other than black-gray-white:\n  var d = red === minRGB ? green - blue : blue === minRGB ? red - green : blue - red;\n  var h = red === minRGB ? 3 : blue === minRGB ? 1 : 5;\n  var hue = 60 * (h - d / (maxRGB - minRGB)) / 360;\n  var saturation = (maxRGB - minRGB) / maxRGB;\n  var value = maxRGB;\n  return {\n    h: hue,\n    s: saturation,\n    v: value\n  };\n}\n/**\r\n * Convert HSV \\<0, 1\\> into RGB color object.\r\n *\r\n * @remarks\r\n * {@link https://gist.github.com/mjijackson/5311256}\r\n * @param h - Hue.\r\n * @param s - Saturation.\r\n * @param v - Value.\r\n * @returns RGB color object.\r\n */\nfunction HSVToRGB(h, s, v) {\n  var r;\n  var g;\n  var b;\n  var i = Math.floor(h * 6);\n  var f = h * 6 - i;\n  var p = v * (1 - s);\n  var q = v * (1 - f * s);\n  var t = v * (1 - (1 - f) * s);\n  switch (i % 6) {\n    case 0:\n      r = v, g = t, b = p;\n      break;\n    case 1:\n      r = q, g = v, b = p;\n      break;\n    case 2:\n      r = p, g = v, b = t;\n      break;\n    case 3:\n      r = p, g = q, b = v;\n      break;\n    case 4:\n      r = t, g = p, b = v;\n      break;\n    case 5:\n      r = v, g = p, b = q;\n      break;\n  }\n  return {\n    r: Math.floor(r * 255),\n    g: Math.floor(g * 255),\n    b: Math.floor(b * 255)\n  };\n}\n/**\r\n * Convert HSV \\<0, 1\\> into hex color string.\r\n *\r\n * @param h - Hue.\r\n * @param s - Saturation.\r\n * @param v - Value.\r\n * @returns Hex color string.\r\n */\nfunction HSVToHex(h, s, v) {\n  var rgb = HSVToRGB(h, s, v);\n  return RGBToHex(rgb.r, rgb.g, rgb.b);\n}\n/**\r\n * Convert hex color string into HSV \\<0, 1\\>.\r\n *\r\n * @param hex - Hex color string.\r\n * @returns HSV color object.\r\n */\nfunction hexToHSV(hex) {\n  var rgb = hexToRGB(hex);\n  if (!rgb) {\n    throw new TypeError(\"'\".concat(hex, \"' is not a valid color.\"));\n  }\n  return RGBToHSV(rgb.r, rgb.g, rgb.b);\n}\n/**\r\n * Validate hex color string.\r\n *\r\n * @param hex - Unknown string that may contain a color.\r\n * @returns True if the string is valid, false otherwise.\r\n */\nfunction isValidHex(hex) {\n  var isOk = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);\n  return isOk;\n}\n/**\r\n * Validate RGB color string.\r\n *\r\n * @param rgb - Unknown string that may contain a color.\r\n * @returns True if the string is valid, false otherwise.\r\n */\nfunction isValidRGB(rgb) {\n  return rgbRE.test(rgb);\n}\n/**\r\n * Validate RGBA color string.\r\n *\r\n * @param rgba - Unknown string that may contain a color.\r\n * @returns True if the string is valid, false otherwise.\r\n */\nfunction isValidRGBA(rgba) {\n  return rgbaRE.test(rgba);\n}\n/**\r\n * This recursively redirects the prototype of JSON objects to the referenceObject.\r\n * This is used for default options.\r\n *\r\n * @param referenceObject - The original object.\r\n * @returns The Element if the referenceObject is an Element, or a new object inheriting from the referenceObject.\r\n */\nfunction bridgeObject(referenceObject) {\n  if (referenceObject === null || _typeof(referenceObject) !== \"object\") {\n    return null;\n  }\n  if (referenceObject instanceof Element) {\n    // Avoid bridging DOM objects\n    return referenceObject;\n  }\n  var objectTo = _Object$create$1(referenceObject);\n  for (var i in referenceObject) {\n    if (Object.prototype.hasOwnProperty.call(referenceObject, i)) {\n      if (_typeof(referenceObject[i]) == \"object\") {\n        objectTo[i] = bridgeObject(referenceObject[i]);\n      }\n    }\n  }\n  return objectTo;\n}\n/**\r\n * This is used to set the options of subobjects in the options object.\r\n *\r\n * A requirement of these subobjects is that they have an 'enabled' element\r\n * which is optional for the user but mandatory for the program.\r\n *\r\n * The added value here of the merge is that option 'enabled' is set as required.\r\n *\r\n * @param mergeTarget - Either this.options or the options used for the groups.\r\n * @param options - Options.\r\n * @param option - Option key in the options argument.\r\n * @param globalOptions - Global options, passed in to determine value of option 'enabled'.\r\n */\nfunction mergeOptions(mergeTarget, options, option) {\n  var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  // Local helpers\n  var isPresent = function isPresent(obj) {\n    return obj !== null && obj !== undefined;\n  };\n  var isObject = function isObject(obj) {\n    return obj !== null && _typeof(obj) === \"object\";\n  };\n  // https://stackoverflow.com/a/34491287/1223531\n  var isEmpty = function isEmpty(obj) {\n    for (var x in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, x)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  // Guards\n  if (!isObject(mergeTarget)) {\n    throw new Error(\"Parameter mergeTarget must be an object\");\n  }\n  if (!isObject(options)) {\n    throw new Error(\"Parameter options must be an object\");\n  }\n  if (!isPresent(option)) {\n    throw new Error(\"Parameter option must have a value\");\n  }\n  if (!isObject(globalOptions)) {\n    throw new Error(\"Parameter globalOptions must be an object\");\n  }\n  //\n  // Actual merge routine, separated from main logic\n  // Only a single level of options is merged. Deeper levels are ref'd. This may actually be an issue.\n  //\n  var doMerge = function doMerge(target, options, option) {\n    if (!isObject(target[option])) {\n      target[option] = {};\n    }\n    var src = options[option];\n    var dst = target[option];\n    for (var prop in src) {\n      if (Object.prototype.hasOwnProperty.call(src, prop)) {\n        dst[prop] = src[prop];\n      }\n    }\n  };\n  // Local initialization\n  var srcOption = options[option];\n  var globalPassed = isObject(globalOptions) && !isEmpty(globalOptions);\n  var globalOption = globalPassed ? globalOptions[option] : undefined;\n  var globalEnabled = globalOption ? globalOption.enabled : undefined;\n  /////////////////////////////////////////\n  // Main routine\n  /////////////////////////////////////////\n  if (srcOption === undefined) {\n    return; // Nothing to do\n  }\n\n  if (typeof srcOption === \"boolean\") {\n    if (!isObject(mergeTarget[option])) {\n      mergeTarget[option] = {};\n    }\n    mergeTarget[option].enabled = srcOption;\n    return;\n  }\n  if (srcOption === null && !isObject(mergeTarget[option])) {\n    // If possible, explicit copy from globals\n    if (isPresent(globalOption)) {\n      mergeTarget[option] = _Object$create$1(globalOption);\n    } else {\n      return; // Nothing to do\n    }\n  }\n\n  if (!isObject(srcOption)) {\n    return;\n  }\n  //\n  // Ensure that 'enabled' is properly set. It is required internally\n  // Note that the value from options will always overwrite the existing value\n  //\n  var enabled = true; // default value\n  if (srcOption.enabled !== undefined) {\n    enabled = srcOption.enabled;\n  } else {\n    // Take from globals, if present\n    if (globalEnabled !== undefined) {\n      enabled = globalOption.enabled;\n    }\n  }\n  doMerge(mergeTarget, options, option);\n  mergeTarget[option].enabled = enabled;\n}\n/*\r\n * Easing Functions.\r\n * Only considering the t value for the range [0, 1] => [0, 1].\r\n *\r\n * Inspiration: from http://gizma.com/easing/\r\n * https://gist.github.com/gre/1650294\r\n */\nvar easingFunctions = {\n  /**\r\n   * Provides no easing and no acceleration.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  linear: function linear(t) {\n    return t;\n  },\n  /**\r\n   * Accelerate from zero velocity.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  easeInQuad: function easeInQuad(t) {\n    return t * t;\n  },\n  /**\r\n   * Decelerate to zero velocity.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  easeOutQuad: function easeOutQuad(t) {\n    return t * (2 - t);\n  },\n  /**\r\n   * Accelerate until halfway, then decelerate.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  easeInOutQuad: function easeInOutQuad(t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n  },\n  /**\r\n   * Accelerate from zero velocity.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  easeInCubic: function easeInCubic(t) {\n    return t * t * t;\n  },\n  /**\r\n   * Decelerate to zero velocity.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  easeOutCubic: function easeOutCubic(t) {\n    return --t * t * t + 1;\n  },\n  /**\r\n   * Accelerate until halfway, then decelerate.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  easeInOutCubic: function easeInOutCubic(t) {\n    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n  },\n  /**\r\n   * Accelerate from zero velocity.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  easeInQuart: function easeInQuart(t) {\n    return t * t * t * t;\n  },\n  /**\r\n   * Decelerate to zero velocity.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  easeOutQuart: function easeOutQuart(t) {\n    return 1 - --t * t * t * t;\n  },\n  /**\r\n   * Accelerate until halfway, then decelerate.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  easeInOutQuart: function easeInOutQuart(t) {\n    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n  },\n  /**\r\n   * Accelerate from zero velocity.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  easeInQuint: function easeInQuint(t) {\n    return t * t * t * t * t;\n  },\n  /**\r\n   * Decelerate to zero velocity.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  easeOutQuint: function easeOutQuint(t) {\n    return 1 + --t * t * t * t * t;\n  },\n  /**\r\n   * Accelerate until halfway, then decelerate.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  easeInOutQuint: function easeInOutQuint(t) {\n    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n  }\n};\n// @TODO: This doesn't work properly.\n// It works only for single property objects,\n// otherwise it combines all of the types in a union.\n// export function topMost<K1 extends string, V1> (\n//   pile: Record<K1, undefined | V1>[],\n//   accessors: K1 | [K1]\n// ): undefined | V1\n// export function topMost<K1 extends string, K2 extends string, V1, V2> (\n//   pile: Record<K1, undefined | V1 | Record<K2, undefined | V2>>[],\n//   accessors: [K1, K2]\n// ): undefined | V1 | V2\n// export function topMost<K1 extends string, K2 extends string, K3 extends string, V1, V2, V3> (\n//   pile: Record<K1, undefined | V1 | Record<K2, undefined | V2 | Record<K3, undefined | V3>>>[],\n//   accessors: [K1, K2, K3]\n// ): undefined | V1 | V2 | V3\n/**\r\n * Get the top most property value from a pile of objects.\r\n *\r\n * @param pile - Array of objects, no required format.\r\n * @param accessors - Array of property names.\r\n * For example `object['foo']['bar']` â `['foo', 'bar']`.\r\n * @returns Value of the property with given accessors path from the first pile item where it's not undefined.\r\n */\nfunction topMost(pile, accessors) {\n  var candidate;\n  if (!_Array$isArray(accessors)) {\n    accessors = [accessors];\n  }\n  var _iterator3 = _createForOfIteratorHelper$6(pile),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var member = _step3.value;\n      if (member) {\n        candidate = member[accessors[0]];\n        for (var i = 1; i < accessors.length; i++) {\n          if (candidate) {\n            candidate = candidate[accessors[i]];\n          }\n        }\n        if (typeof candidate !== \"undefined\") {\n          break;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return candidate;\n}\nvar htmlColors = {\n  black: \"#000000\",\n  navy: \"#000080\",\n  darkblue: \"#00008B\",\n  mediumblue: \"#0000CD\",\n  blue: \"#0000FF\",\n  darkgreen: \"#006400\",\n  green: \"#008000\",\n  teal: \"#008080\",\n  darkcyan: \"#008B8B\",\n  deepskyblue: \"#00BFFF\",\n  darkturquoise: \"#00CED1\",\n  mediumspringgreen: \"#00FA9A\",\n  lime: \"#00FF00\",\n  springgreen: \"#00FF7F\",\n  aqua: \"#00FFFF\",\n  cyan: \"#00FFFF\",\n  midnightblue: \"#191970\",\n  dodgerblue: \"#1E90FF\",\n  lightseagreen: \"#20B2AA\",\n  forestgreen: \"#228B22\",\n  seagreen: \"#2E8B57\",\n  darkslategray: \"#2F4F4F\",\n  limegreen: \"#32CD32\",\n  mediumseagreen: \"#3CB371\",\n  turquoise: \"#40E0D0\",\n  royalblue: \"#4169E1\",\n  steelblue: \"#4682B4\",\n  darkslateblue: \"#483D8B\",\n  mediumturquoise: \"#48D1CC\",\n  indigo: \"#4B0082\",\n  darkolivegreen: \"#556B2F\",\n  cadetblue: \"#5F9EA0\",\n  cornflowerblue: \"#6495ED\",\n  mediumaquamarine: \"#66CDAA\",\n  dimgray: \"#696969\",\n  slateblue: \"#6A5ACD\",\n  olivedrab: \"#6B8E23\",\n  slategray: \"#708090\",\n  lightslategray: \"#778899\",\n  mediumslateblue: \"#7B68EE\",\n  lawngreen: \"#7CFC00\",\n  chartreuse: \"#7FFF00\",\n  aquamarine: \"#7FFFD4\",\n  maroon: \"#800000\",\n  purple: \"#800080\",\n  olive: \"#808000\",\n  gray: \"#808080\",\n  skyblue: \"#87CEEB\",\n  lightskyblue: \"#87CEFA\",\n  blueviolet: \"#8A2BE2\",\n  darkred: \"#8B0000\",\n  darkmagenta: \"#8B008B\",\n  saddlebrown: \"#8B4513\",\n  darkseagreen: \"#8FBC8F\",\n  lightgreen: \"#90EE90\",\n  mediumpurple: \"#9370D8\",\n  darkviolet: \"#9400D3\",\n  palegreen: \"#98FB98\",\n  darkorchid: \"#9932CC\",\n  yellowgreen: \"#9ACD32\",\n  sienna: \"#A0522D\",\n  brown: \"#A52A2A\",\n  darkgray: \"#A9A9A9\",\n  lightblue: \"#ADD8E6\",\n  greenyellow: \"#ADFF2F\",\n  paleturquoise: \"#AFEEEE\",\n  lightsteelblue: \"#B0C4DE\",\n  powderblue: \"#B0E0E6\",\n  firebrick: \"#B22222\",\n  darkgoldenrod: \"#B8860B\",\n  mediumorchid: \"#BA55D3\",\n  rosybrown: \"#BC8F8F\",\n  darkkhaki: \"#BDB76B\",\n  silver: \"#C0C0C0\",\n  mediumvioletred: \"#C71585\",\n  indianred: \"#CD5C5C\",\n  peru: \"#CD853F\",\n  chocolate: \"#D2691E\",\n  tan: \"#D2B48C\",\n  lightgrey: \"#D3D3D3\",\n  palevioletred: \"#D87093\",\n  thistle: \"#D8BFD8\",\n  orchid: \"#DA70D6\",\n  goldenrod: \"#DAA520\",\n  crimson: \"#DC143C\",\n  gainsboro: \"#DCDCDC\",\n  plum: \"#DDA0DD\",\n  burlywood: \"#DEB887\",\n  lightcyan: \"#E0FFFF\",\n  lavender: \"#E6E6FA\",\n  darksalmon: \"#E9967A\",\n  violet: \"#EE82EE\",\n  palegoldenrod: \"#EEE8AA\",\n  lightcoral: \"#F08080\",\n  khaki: \"#F0E68C\",\n  aliceblue: \"#F0F8FF\",\n  honeydew: \"#F0FFF0\",\n  azure: \"#F0FFFF\",\n  sandybrown: \"#F4A460\",\n  wheat: \"#F5DEB3\",\n  beige: \"#F5F5DC\",\n  whitesmoke: \"#F5F5F5\",\n  mintcream: \"#F5FFFA\",\n  ghostwhite: \"#F8F8FF\",\n  salmon: \"#FA8072\",\n  antiquewhite: \"#FAEBD7\",\n  linen: \"#FAF0E6\",\n  lightgoldenrodyellow: \"#FAFAD2\",\n  oldlace: \"#FDF5E6\",\n  red: \"#FF0000\",\n  fuchsia: \"#FF00FF\",\n  magenta: \"#FF00FF\",\n  deeppink: \"#FF1493\",\n  orangered: \"#FF4500\",\n  tomato: \"#FF6347\",\n  hotpink: \"#FF69B4\",\n  coral: \"#FF7F50\",\n  darkorange: \"#FF8C00\",\n  lightsalmon: \"#FFA07A\",\n  orange: \"#FFA500\",\n  lightpink: \"#FFB6C1\",\n  pink: \"#FFC0CB\",\n  gold: \"#FFD700\",\n  peachpuff: \"#FFDAB9\",\n  navajowhite: \"#FFDEAD\",\n  moccasin: \"#FFE4B5\",\n  bisque: \"#FFE4C4\",\n  mistyrose: \"#FFE4E1\",\n  blanchedalmond: \"#FFEBCD\",\n  papayawhip: \"#FFEFD5\",\n  lavenderblush: \"#FFF0F5\",\n  seashell: \"#FFF5EE\",\n  cornsilk: \"#FFF8DC\",\n  lemonchiffon: \"#FFFACD\",\n  floralwhite: \"#FFFAF0\",\n  snow: \"#FFFAFA\",\n  yellow: \"#FFFF00\",\n  lightyellow: \"#FFFFE0\",\n  ivory: \"#FFFFF0\",\n  white: \"#FFFFFF\"\n};\n\n/**\n * @param {number} [pixelRatio=1]\n */\nvar ColorPicker$1 = /*#__PURE__*/function () {\n  /**\n   * @param {number} [pixelRatio=1]\n   */\n  function ColorPicker() {\n    var pixelRatio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    _classCallCheck(this, ColorPicker);\n    this.pixelRatio = pixelRatio;\n    this.generated = false;\n    this.centerCoordinates = {\n      x: 289 / 2,\n      y: 289 / 2\n    };\n    this.r = 289 * 0.49;\n    this.color = {\n      r: 255,\n      g: 255,\n      b: 255,\n      a: 1.0\n    };\n    this.hueCircle = undefined;\n    this.initialColor = {\n      r: 255,\n      g: 255,\n      b: 255,\n      a: 1.0\n    };\n    this.previousColor = undefined;\n    this.applied = false;\n\n    // bound by\n    this.updateCallback = function () {};\n    this.closeCallback = function () {};\n\n    // create all DOM elements\n    this._create();\n  }\n\n  /**\n   * this inserts the colorPicker into a div from the DOM\n   *\n   * @param {Element} container\n   */\n  _createClass(ColorPicker, [{\n    key: \"insertTo\",\n    value: function insertTo(container) {\n      if (this.hammer !== undefined) {\n        this.hammer.destroy();\n        this.hammer = undefined;\n      }\n      this.container = container;\n      this.container.appendChild(this.frame);\n      this._bindHammer();\n      this._setSize();\n    }\n\n    /**\n     * the callback is executed on apply and save. Bind it to the application\n     *\n     * @param {Function} callback\n     */\n  }, {\n    key: \"setUpdateCallback\",\n    value: function setUpdateCallback(callback) {\n      if (typeof callback === \"function\") {\n        this.updateCallback = callback;\n      } else {\n        throw new Error(\"Function attempted to set as colorPicker update callback is not a function.\");\n      }\n    }\n\n    /**\n     * the callback is executed on apply and save. Bind it to the application\n     *\n     * @param {Function} callback\n     */\n  }, {\n    key: \"setCloseCallback\",\n    value: function setCloseCallback(callback) {\n      if (typeof callback === \"function\") {\n        this.closeCallback = callback;\n      } else {\n        throw new Error(\"Function attempted to set as colorPicker closing callback is not a function.\");\n      }\n    }\n\n    /**\n     *\n     * @param {string} color\n     * @returns {string}\n     * @private\n     */\n  }, {\n    key: \"_isColorString\",\n    value: function _isColorString(color) {\n      if (typeof color === \"string\") {\n        return htmlColors[color];\n      }\n    }\n\n    /**\n     * Set the color of the colorPicker\n     * Supported formats:\n     * 'red'                   --> HTML color string\n     * '#ffffff'               --> hex string\n     * 'rgb(255,255,255)'      --> rgb string\n     * 'rgba(255,255,255,1.0)' --> rgba string\n     * {r:255,g:255,b:255}     --> rgb object\n     * {r:255,g:255,b:255,a:1.0} --> rgba object\n     *\n     * @param {string | object} color\n     * @param {boolean} [setInitial=true]\n     */\n  }, {\n    key: \"setColor\",\n    value: function setColor(color) {\n      var setInitial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (color === \"none\") {\n        return;\n      }\n      var rgba;\n\n      // if a html color shorthand is used, convert to hex\n      var htmlColor = this._isColorString(color);\n      if (htmlColor !== undefined) {\n        color = htmlColor;\n      }\n\n      // check format\n      if (isString(color) === true) {\n        if (isValidRGB(color) === true) {\n          var rgbaArray = color.substr(4).substr(0, color.length - 5).split(\",\");\n          rgba = {\n            r: rgbaArray[0],\n            g: rgbaArray[1],\n            b: rgbaArray[2],\n            a: 1.0\n          };\n        } else if (isValidRGBA(color) === true) {\n          var _rgbaArray = color.substr(5).substr(0, color.length - 6).split(\",\");\n          rgba = {\n            r: _rgbaArray[0],\n            g: _rgbaArray[1],\n            b: _rgbaArray[2],\n            a: _rgbaArray[3]\n          };\n        } else if (isValidHex(color) === true) {\n          var rgbObj = hexToRGB(color);\n          rgba = {\n            r: rgbObj.r,\n            g: rgbObj.g,\n            b: rgbObj.b,\n            a: 1.0\n          };\n        }\n      } else {\n        if (color instanceof Object) {\n          if (color.r !== undefined && color.g !== undefined && color.b !== undefined) {\n            var alpha = color.a !== undefined ? color.a : \"1.0\";\n            rgba = {\n              r: color.r,\n              g: color.g,\n              b: color.b,\n              a: alpha\n            };\n          }\n        }\n      }\n\n      // set color\n      if (rgba === undefined) {\n        throw new Error(\"Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: \" + _JSON$stringify(color));\n      } else {\n        this._setColor(rgba, setInitial);\n      }\n    }\n\n    /**\n     * this shows the color picker.\n     * The hue circle is constructed once and stored.\n     */\n  }, {\n    key: \"show\",\n    value: function show() {\n      if (this.closeCallback !== undefined) {\n        this.closeCallback();\n        this.closeCallback = undefined;\n      }\n      this.applied = false;\n      this.frame.style.display = \"block\";\n      this._generateHueCircle();\n    }\n\n    // ------------------------------------------ PRIVATE ----------------------------- //\n\n    /**\n     * Hide the picker. Is called by the cancel button.\n     * Optional boolean to store the previous color for easy access later on.\n     *\n     * @param {boolean} [storePrevious=true]\n     * @private\n     */\n  }, {\n    key: \"_hide\",\n    value: function _hide() {\n      var _this2 = this;\n      var storePrevious = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      // store the previous color for next time;\n      if (storePrevious === true) {\n        this.previousColor = _Object$assign({}, this.color);\n      }\n      if (this.applied === true) {\n        this.updateCallback(this.initialColor);\n      }\n      this.frame.style.display = \"none\";\n\n      // call the closing callback, restoring the onclick method.\n      // this is in a setTimeout because it will trigger the show again before the click is done.\n      _setTimeout(function () {\n        if (_this2.closeCallback !== undefined) {\n          _this2.closeCallback();\n          _this2.closeCallback = undefined;\n        }\n      }, 0);\n    }\n\n    /**\n     * bound to the save button. Saves and hides.\n     *\n     * @private\n     */\n  }, {\n    key: \"_save\",\n    value: function _save() {\n      this.updateCallback(this.color);\n      this.applied = false;\n      this._hide();\n    }\n\n    /**\n     * Bound to apply button. Saves but does not close. Is undone by the cancel button.\n     *\n     * @private\n     */\n  }, {\n    key: \"_apply\",\n    value: function _apply() {\n      this.applied = true;\n      this.updateCallback(this.color);\n      this._updatePicker(this.color);\n    }\n\n    /**\n     * load the color from the previous session.\n     *\n     * @private\n     */\n  }, {\n    key: \"_loadLast\",\n    value: function _loadLast() {\n      if (this.previousColor !== undefined) {\n        this.setColor(this.previousColor, false);\n      } else {\n        alert(\"There is no last color to load...\");\n      }\n    }\n\n    /**\n     * set the color, place the picker\n     *\n     * @param {object} rgba\n     * @param {boolean} [setInitial=true]\n     * @private\n     */\n  }, {\n    key: \"_setColor\",\n    value: function _setColor(rgba) {\n      var setInitial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      // store the initial color\n      if (setInitial === true) {\n        this.initialColor = _Object$assign({}, rgba);\n      }\n      this.color = rgba;\n      var hsv = RGBToHSV(rgba.r, rgba.g, rgba.b);\n      var angleConvert = 2 * Math.PI;\n      var radius = this.r * hsv.s;\n      var x = this.centerCoordinates.x + radius * Math.sin(angleConvert * hsv.h);\n      var y = this.centerCoordinates.y + radius * Math.cos(angleConvert * hsv.h);\n      this.colorPickerSelector.style.left = x - 0.5 * this.colorPickerSelector.clientWidth + \"px\";\n      this.colorPickerSelector.style.top = y - 0.5 * this.colorPickerSelector.clientHeight + \"px\";\n      this._updatePicker(rgba);\n    }\n\n    /**\n     * bound to opacity control\n     *\n     * @param {number} value\n     * @private\n     */\n  }, {\n    key: \"_setOpacity\",\n    value: function _setOpacity(value) {\n      this.color.a = value / 100;\n      this._updatePicker(this.color);\n    }\n\n    /**\n     * bound to brightness control\n     *\n     * @param {number} value\n     * @private\n     */\n  }, {\n    key: \"_setBrightness\",\n    value: function _setBrightness(value) {\n      var hsv = RGBToHSV(this.color.r, this.color.g, this.color.b);\n      hsv.v = value / 100;\n      var rgba = HSVToRGB(hsv.h, hsv.s, hsv.v);\n      rgba[\"a\"] = this.color.a;\n      this.color = rgba;\n      this._updatePicker();\n    }\n\n    /**\n     * update the color picker. A black circle overlays the hue circle to mimic the brightness decreasing.\n     *\n     * @param {object} rgba\n     * @private\n     */\n  }, {\n    key: \"_updatePicker\",\n    value: function _updatePicker() {\n      var rgba = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.color;\n      var hsv = RGBToHSV(rgba.r, rgba.g, rgba.b);\n      var ctx = this.colorPickerCanvas.getContext(\"2d\");\n      if (this.pixelRation === undefined) {\n        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);\n      }\n      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n\n      // clear the canvas\n      var w = this.colorPickerCanvas.clientWidth;\n      var h = this.colorPickerCanvas.clientHeight;\n      ctx.clearRect(0, 0, w, h);\n      ctx.putImageData(this.hueCircle, 0, 0);\n      ctx.fillStyle = \"rgba(0,0,0,\" + (1 - hsv.v) + \")\";\n      ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);\n      _fillInstanceProperty(ctx).call(ctx);\n      this.brightnessRange.value = 100 * hsv.v;\n      this.opacityRange.value = 100 * rgba.a;\n      this.initialColorDiv.style.backgroundColor = \"rgba(\" + this.initialColor.r + \",\" + this.initialColor.g + \",\" + this.initialColor.b + \",\" + this.initialColor.a + \")\";\n      this.newColorDiv.style.backgroundColor = \"rgba(\" + this.color.r + \",\" + this.color.g + \",\" + this.color.b + \",\" + this.color.a + \")\";\n    }\n\n    /**\n     * used by create to set the size of the canvas.\n     *\n     * @private\n     */\n  }, {\n    key: \"_setSize\",\n    value: function _setSize() {\n      this.colorPickerCanvas.style.width = \"100%\";\n      this.colorPickerCanvas.style.height = \"100%\";\n      this.colorPickerCanvas.width = 289 * this.pixelRatio;\n      this.colorPickerCanvas.height = 289 * this.pixelRatio;\n    }\n\n    /**\n     * create all dom elements\n     * TODO: cleanup, lots of similar dom elements\n     *\n     * @private\n     */\n  }, {\n    key: \"_create\",\n    value: function _create() {\n      var _context12, _context13, _context14, _context15;\n      this.frame = document.createElement(\"div\");\n      this.frame.className = \"vis-color-picker\";\n      this.colorPickerDiv = document.createElement(\"div\");\n      this.colorPickerSelector = document.createElement(\"div\");\n      this.colorPickerSelector.className = \"vis-selector\";\n      this.colorPickerDiv.appendChild(this.colorPickerSelector);\n      this.colorPickerCanvas = document.createElement(\"canvas\");\n      this.colorPickerDiv.appendChild(this.colorPickerCanvas);\n      if (!this.colorPickerCanvas.getContext) {\n        var noCanvas = document.createElement(\"DIV\");\n        noCanvas.style.color = \"red\";\n        noCanvas.style.fontWeight = \"bold\";\n        noCanvas.style.padding = \"10px\";\n        noCanvas.innerText = \"Error: your browser does not support HTML canvas\";\n        this.colorPickerCanvas.appendChild(noCanvas);\n      } else {\n        var ctx = this.colorPickerCanvas.getContext(\"2d\");\n        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);\n        this.colorPickerCanvas.getContext(\"2d\").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n      }\n      this.colorPickerDiv.className = \"vis-color\";\n      this.opacityDiv = document.createElement(\"div\");\n      this.opacityDiv.className = \"vis-opacity\";\n      this.brightnessDiv = document.createElement(\"div\");\n      this.brightnessDiv.className = \"vis-brightness\";\n      this.arrowDiv = document.createElement(\"div\");\n      this.arrowDiv.className = \"vis-arrow\";\n      this.opacityRange = document.createElement(\"input\");\n      try {\n        this.opacityRange.type = \"range\"; // Not supported on IE9\n        this.opacityRange.min = \"0\";\n        this.opacityRange.max = \"100\";\n      } catch (err) {\n        // TODO: Add some error handling.\n      }\n      this.opacityRange.value = \"100\";\n      this.opacityRange.className = \"vis-range\";\n      this.brightnessRange = document.createElement(\"input\");\n      try {\n        this.brightnessRange.type = \"range\"; // Not supported on IE9\n        this.brightnessRange.min = \"0\";\n        this.brightnessRange.max = \"100\";\n      } catch (err) {\n        // TODO: Add some error handling.\n      }\n      this.brightnessRange.value = \"100\";\n      this.brightnessRange.className = \"vis-range\";\n      this.opacityDiv.appendChild(this.opacityRange);\n      this.brightnessDiv.appendChild(this.brightnessRange);\n      var me = this;\n      this.opacityRange.onchange = function () {\n        me._setOpacity(this.value);\n      };\n      this.opacityRange.oninput = function () {\n        me._setOpacity(this.value);\n      };\n      this.brightnessRange.onchange = function () {\n        me._setBrightness(this.value);\n      };\n      this.brightnessRange.oninput = function () {\n        me._setBrightness(this.value);\n      };\n      this.brightnessLabel = document.createElement(\"div\");\n      this.brightnessLabel.className = \"vis-label vis-brightness\";\n      this.brightnessLabel.innerText = \"brightness:\";\n      this.opacityLabel = document.createElement(\"div\");\n      this.opacityLabel.className = \"vis-label vis-opacity\";\n      this.opacityLabel.innerText = \"opacity:\";\n      this.newColorDiv = document.createElement(\"div\");\n      this.newColorDiv.className = \"vis-new-color\";\n      this.newColorDiv.innerText = \"new\";\n      this.initialColorDiv = document.createElement(\"div\");\n      this.initialColorDiv.className = \"vis-initial-color\";\n      this.initialColorDiv.innerText = \"initial\";\n      this.cancelButton = document.createElement(\"div\");\n      this.cancelButton.className = \"vis-button vis-cancel\";\n      this.cancelButton.innerText = \"cancel\";\n      this.cancelButton.onclick = _bindInstanceProperty$1(_context12 = this._hide).call(_context12, this, false);\n      this.applyButton = document.createElement(\"div\");\n      this.applyButton.className = \"vis-button vis-apply\";\n      this.applyButton.innerText = \"apply\";\n      this.applyButton.onclick = _bindInstanceProperty$1(_context13 = this._apply).call(_context13, this);\n      this.saveButton = document.createElement(\"div\");\n      this.saveButton.className = \"vis-button vis-save\";\n      this.saveButton.innerText = \"save\";\n      this.saveButton.onclick = _bindInstanceProperty$1(_context14 = this._save).call(_context14, this);\n      this.loadButton = document.createElement(\"div\");\n      this.loadButton.className = \"vis-button vis-load\";\n      this.loadButton.innerText = \"load last\";\n      this.loadButton.onclick = _bindInstanceProperty$1(_context15 = this._loadLast).call(_context15, this);\n      this.frame.appendChild(this.colorPickerDiv);\n      this.frame.appendChild(this.arrowDiv);\n      this.frame.appendChild(this.brightnessLabel);\n      this.frame.appendChild(this.brightnessDiv);\n      this.frame.appendChild(this.opacityLabel);\n      this.frame.appendChild(this.opacityDiv);\n      this.frame.appendChild(this.newColorDiv);\n      this.frame.appendChild(this.initialColorDiv);\n      this.frame.appendChild(this.cancelButton);\n      this.frame.appendChild(this.applyButton);\n      this.frame.appendChild(this.saveButton);\n      this.frame.appendChild(this.loadButton);\n    }\n\n    /**\n     * bind hammer to the color picker\n     *\n     * @private\n     */\n  }, {\n    key: \"_bindHammer\",\n    value: function _bindHammer() {\n      var _this3 = this;\n      this.drag = {};\n      this.pinch = {};\n      this.hammer = new Hammer$1(this.colorPickerCanvas);\n      this.hammer.get(\"pinch\").set({\n        enable: true\n      });\n      this.hammer.on(\"hammer.input\", function (event) {\n        if (event.isFirst) {\n          _this3._moveSelector(event);\n        }\n      });\n      this.hammer.on(\"tap\", function (event) {\n        _this3._moveSelector(event);\n      });\n      this.hammer.on(\"panstart\", function (event) {\n        _this3._moveSelector(event);\n      });\n      this.hammer.on(\"panmove\", function (event) {\n        _this3._moveSelector(event);\n      });\n      this.hammer.on(\"panend\", function (event) {\n        _this3._moveSelector(event);\n      });\n    }\n\n    /**\n     * generate the hue circle. This is relatively heavy (200ms) and is done only once on the first time it is shown.\n     *\n     * @private\n     */\n  }, {\n    key: \"_generateHueCircle\",\n    value: function _generateHueCircle() {\n      if (this.generated === false) {\n        var ctx = this.colorPickerCanvas.getContext(\"2d\");\n        if (this.pixelRation === undefined) {\n          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);\n        }\n        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n\n        // clear the canvas\n        var w = this.colorPickerCanvas.clientWidth;\n        var h = this.colorPickerCanvas.clientHeight;\n        ctx.clearRect(0, 0, w, h);\n\n        // draw hue circle\n        var x, y, hue, sat;\n        this.centerCoordinates = {\n          x: w * 0.5,\n          y: h * 0.5\n        };\n        this.r = 0.49 * w;\n        var angleConvert = 2 * Math.PI / 360;\n        var hfac = 1 / 360;\n        var sfac = 1 / this.r;\n        var rgb;\n        for (hue = 0; hue < 360; hue++) {\n          for (sat = 0; sat < this.r; sat++) {\n            x = this.centerCoordinates.x + sat * Math.sin(angleConvert * hue);\n            y = this.centerCoordinates.y + sat * Math.cos(angleConvert * hue);\n            rgb = HSVToRGB(hue * hfac, sat * sfac, 1);\n            ctx.fillStyle = \"rgb(\" + rgb.r + \",\" + rgb.g + \",\" + rgb.b + \")\";\n            ctx.fillRect(x - 0.5, y - 0.5, 2, 2);\n          }\n        }\n        ctx.strokeStyle = \"rgba(0,0,0,1)\";\n        ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);\n        ctx.stroke();\n        this.hueCircle = ctx.getImageData(0, 0, w, h);\n      }\n      this.generated = true;\n    }\n\n    /**\n     * move the selector. This is called by hammer functions.\n     *\n     * @param {Event}  event   The event\n     * @private\n     */\n  }, {\n    key: \"_moveSelector\",\n    value: function _moveSelector(event) {\n      var rect = this.colorPickerDiv.getBoundingClientRect();\n      var left = event.center.x - rect.left;\n      var top = event.center.y - rect.top;\n      var centerY = 0.5 * this.colorPickerDiv.clientHeight;\n      var centerX = 0.5 * this.colorPickerDiv.clientWidth;\n      var x = left - centerX;\n      var y = top - centerY;\n      var angle = Math.atan2(x, y);\n      var radius = 0.98 * Math.min(Math.sqrt(x * x + y * y), centerX);\n      var newTop = Math.cos(angle) * radius + centerY;\n      var newLeft = Math.sin(angle) * radius + centerX;\n      this.colorPickerSelector.style.top = newTop - 0.5 * this.colorPickerSelector.clientHeight + \"px\";\n      this.colorPickerSelector.style.left = newLeft - 0.5 * this.colorPickerSelector.clientWidth + \"px\";\n\n      // set color\n      var h = angle / (2 * Math.PI);\n      h = h < 0 ? h + 1 : h;\n      var s = radius / this.r;\n      var hsv = RGBToHSV(this.color.r, this.color.g, this.color.b);\n      hsv.h = h;\n      hsv.s = s;\n      var rgba = HSVToRGB(hsv.h, hsv.s, hsv.v);\n      rgba[\"a\"] = this.color.a;\n      this.color = rgba;\n\n      // update previews\n      this.initialColorDiv.style.backgroundColor = \"rgba(\" + this.initialColor.r + \",\" + this.initialColor.g + \",\" + this.initialColor.b + \",\" + this.initialColor.a + \")\";\n      this.newColorDiv.style.backgroundColor = \"rgba(\" + this.color.r + \",\" + this.color.g + \",\" + this.color.b + \",\" + this.color.a + \")\";\n    }\n  }]);\n  return ColorPicker;\n}();\n\n/**\n * Wrap given text (last argument) in HTML elements (all preceding arguments).\n *\n * @param {...any} rest - List of tag names followed by inner text.\n * @returns An element or a text node.\n */\nfunction wrapInTag() {\n  for (var _len5 = arguments.length, rest = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    rest[_key5] = arguments[_key5];\n  }\n  if (rest.length < 1) {\n    throw new TypeError(\"Invalid arguments.\");\n  } else if (rest.length === 1) {\n    return document.createTextNode(rest[0]);\n  } else {\n    var element = document.createElement(rest[0]);\n    element.appendChild(wrapInTag.apply(void 0, _toConsumableArray(_sliceInstanceProperty(rest).call(rest, 1))));\n    return element;\n  }\n}\n\n/**\n * The way this works is for all properties of this.possible options, you can supply the property name in any form to list the options.\n * Boolean options are recognised as Boolean\n * Number options should be written as array: [default value, min value, max value, stepsize]\n * Colors should be written as array: ['color', '#ffffff']\n * Strings with should be written as array: [option1, option2, option3, ..]\n *\n * The options are matched with their counterparts in each of the modules and the values used in the configuration are\n */\nvar Configurator$1 = /*#__PURE__*/function () {\n  /**\n   * @param {object} parentModule        | the location where parentModule.setOptions() can be called\n   * @param {object} defaultContainer    | the default container of the module\n   * @param {object} configureOptions    | the fully configured and predefined options set found in allOptions.js\n   * @param {number} pixelRatio          | canvas pixel ratio\n   * @param {Function} hideOption        | custom logic to dynamically hide options\n   */\n  function Configurator(parentModule, defaultContainer, configureOptions) {\n    var pixelRatio = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    var hideOption = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {\n      return false;\n    };\n    _classCallCheck(this, Configurator);\n    this.parent = parentModule;\n    this.changedOptions = [];\n    this.container = defaultContainer;\n    this.allowCreation = false;\n    this.hideOption = hideOption;\n    this.options = {};\n    this.initialized = false;\n    this.popupCounter = 0;\n    this.defaultOptions = {\n      enabled: false,\n      filter: true,\n      container: undefined,\n      showButton: true\n    };\n    _Object$assign(this.options, this.defaultOptions);\n    this.configureOptions = configureOptions;\n    this.moduleOptions = {};\n    this.domElements = [];\n    this.popupDiv = {};\n    this.popupLimit = 5;\n    this.popupHistory = {};\n    this.colorPicker = new ColorPicker$1(pixelRatio);\n    this.wrapper = undefined;\n  }\n\n  /**\n   * refresh all options.\n   * Because all modules parse their options by themselves, we just use their options. We copy them here.\n   *\n   * @param {object} options\n   */\n  _createClass(Configurator, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        // reset the popup history because the indices may have been changed.\n        this.popupHistory = {};\n        this._removePopup();\n        var enabled = true;\n        if (typeof options === \"string\") {\n          this.options.filter = options;\n        } else if (_Array$isArray(options)) {\n          this.options.filter = options.join();\n        } else if (_typeof(options) === \"object\") {\n          if (options == null) {\n            throw new TypeError(\"options cannot be null\");\n          }\n          if (options.container !== undefined) {\n            this.options.container = options.container;\n          }\n          if (_filterInstanceProperty(options) !== undefined) {\n            this.options.filter = _filterInstanceProperty(options);\n          }\n          if (options.showButton !== undefined) {\n            this.options.showButton = options.showButton;\n          }\n          if (options.enabled !== undefined) {\n            enabled = options.enabled;\n          }\n        } else if (typeof options === \"boolean\") {\n          this.options.filter = true;\n          enabled = options;\n        } else if (typeof options === \"function\") {\n          this.options.filter = options;\n          enabled = true;\n        }\n        if (_filterInstanceProperty(this.options) === false) {\n          enabled = false;\n        }\n        this.options.enabled = enabled;\n      }\n      this._clean();\n    }\n\n    /**\n     *\n     * @param {object} moduleOptions\n     */\n  }, {\n    key: \"setModuleOptions\",\n    value: function setModuleOptions(moduleOptions) {\n      this.moduleOptions = moduleOptions;\n      if (this.options.enabled === true) {\n        this._clean();\n        if (this.options.container !== undefined) {\n          this.container = this.options.container;\n        }\n        this._create();\n      }\n    }\n\n    /**\n     * Create all DOM elements\n     *\n     * @private\n     */\n  }, {\n    key: \"_create\",\n    value: function _create() {\n      this._clean();\n      this.changedOptions = [];\n      var filter = _filterInstanceProperty(this.options);\n      var counter = 0;\n      var show = false;\n      for (var _option in this.configureOptions) {\n        if (Object.prototype.hasOwnProperty.call(this.configureOptions, _option)) {\n          this.allowCreation = false;\n          show = false;\n          if (typeof filter === \"function\") {\n            show = filter(_option, []);\n            show = show || this._handleObject(this.configureOptions[_option], [_option], true);\n          } else if (filter === true || _indexOfInstanceProperty(filter).call(filter, _option) !== -1) {\n            show = true;\n          }\n          if (show !== false) {\n            this.allowCreation = true;\n\n            // linebreak between categories\n            if (counter > 0) {\n              this._makeItem([]);\n            }\n            // a header for the category\n            this._makeHeader(_option);\n\n            // get the sub options\n            this._handleObject(this.configureOptions[_option], [_option]);\n          }\n          counter++;\n        }\n      }\n      this._makeButton();\n      this._push();\n      //~ this.colorPicker.insertTo(this.container);\n    }\n\n    /**\n     * draw all DOM elements on the screen\n     *\n     * @private\n     */\n  }, {\n    key: \"_push\",\n    value: function _push() {\n      this.wrapper = document.createElement(\"div\");\n      this.wrapper.className = \"vis-configuration-wrapper\";\n      this.container.appendChild(this.wrapper);\n      for (var i = 0; i < this.domElements.length; i++) {\n        this.wrapper.appendChild(this.domElements[i]);\n      }\n      this._showPopupIfNeeded();\n    }\n\n    /**\n     * delete all DOM elements\n     *\n     * @private\n     */\n  }, {\n    key: \"_clean\",\n    value: function _clean() {\n      for (var i = 0; i < this.domElements.length; i++) {\n        this.wrapper.removeChild(this.domElements[i]);\n      }\n      if (this.wrapper !== undefined) {\n        this.container.removeChild(this.wrapper);\n        this.wrapper = undefined;\n      }\n      this.domElements = [];\n      this._removePopup();\n    }\n\n    /**\n     * get the value from the actualOptions if it exists\n     *\n     * @param {Array} path    | where to look for the actual option\n     * @returns {*}\n     * @private\n     */\n  }, {\n    key: \"_getValue\",\n    value: function _getValue(path) {\n      var base = this.moduleOptions;\n      for (var i = 0; i < path.length; i++) {\n        if (base[path[i]] !== undefined) {\n          base = base[path[i]];\n        } else {\n          base = undefined;\n          break;\n        }\n      }\n      return base;\n    }\n\n    /**\n     * all option elements are wrapped in an item\n     *\n     * @param {Array} path    | where to look for the actual option\n     * @param {Array.<Element>} domElements\n     * @returns {number}\n     * @private\n     */\n  }, {\n    key: \"_makeItem\",\n    value: function _makeItem(path) {\n      if (this.allowCreation === true) {\n        var item = document.createElement(\"div\");\n        item.className = \"vis-configuration vis-config-item vis-config-s\" + path.length;\n        for (var _len6 = arguments.length, domElements = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n          domElements[_key6 - 1] = arguments[_key6];\n        }\n        _forEachInstanceProperty(domElements).call(domElements, function (element) {\n          item.appendChild(element);\n        });\n        this.domElements.push(item);\n        return this.domElements.length;\n      }\n      return 0;\n    }\n\n    /**\n     * header for major subjects\n     *\n     * @param {string} name\n     * @private\n     */\n  }, {\n    key: \"_makeHeader\",\n    value: function _makeHeader(name) {\n      var div = document.createElement(\"div\");\n      div.className = \"vis-configuration vis-config-header\";\n      div.innerText = name;\n      this._makeItem([], div);\n    }\n\n    /**\n     * make a label, if it is an object label, it gets different styling.\n     *\n     * @param {string} name\n     * @param {Array} path    | where to look for the actual option\n     * @param {string} objectLabel\n     * @returns {HTMLElement}\n     * @private\n     */\n  }, {\n    key: \"_makeLabel\",\n    value: function _makeLabel(name, path) {\n      var objectLabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var div = document.createElement(\"div\");\n      div.className = \"vis-configuration vis-config-label vis-config-s\" + path.length;\n      if (objectLabel === true) {\n        while (div.firstChild) {\n          div.removeChild(div.firstChild);\n        }\n        div.appendChild(wrapInTag(\"i\", \"b\", name));\n      } else {\n        div.innerText = name + \":\";\n      }\n      return div;\n    }\n\n    /**\n     * make a dropdown list for multiple possible string optoins\n     *\n     * @param {Array.<number>} arr\n     * @param {number} value\n     * @param {Array} path    | where to look for the actual option\n     * @private\n     */\n  }, {\n    key: \"_makeDropdown\",\n    value: function _makeDropdown(arr, value, path) {\n      var select = document.createElement(\"select\");\n      select.className = \"vis-configuration vis-config-select\";\n      var selectedValue = 0;\n      if (value !== undefined) {\n        if (_indexOfInstanceProperty(arr).call(arr, value) !== -1) {\n          selectedValue = _indexOfInstanceProperty(arr).call(arr, value);\n        }\n      }\n      for (var i = 0; i < arr.length; i++) {\n        var _option2 = document.createElement(\"option\");\n        _option2.value = arr[i];\n        if (i === selectedValue) {\n          _option2.selected = \"selected\";\n        }\n        _option2.innerText = arr[i];\n        select.appendChild(_option2);\n      }\n      var me = this;\n      select.onchange = function () {\n        me._update(this.value, path);\n      };\n      var label = this._makeLabel(path[path.length - 1], path);\n      this._makeItem(path, label, select);\n    }\n\n    /**\n     * make a range object for numeric options\n     *\n     * @param {Array.<number>} arr\n     * @param {number} value\n     * @param {Array} path    | where to look for the actual option\n     * @private\n     */\n  }, {\n    key: \"_makeRange\",\n    value: function _makeRange(arr, value, path) {\n      var defaultValue = arr[0];\n      var min = arr[1];\n      var max = arr[2];\n      var step = arr[3];\n      var range = document.createElement(\"input\");\n      range.className = \"vis-configuration vis-config-range\";\n      try {\n        range.type = \"range\"; // not supported on IE9\n        range.min = min;\n        range.max = max;\n      } catch (err) {\n        // TODO: Add some error handling.\n      }\n      range.step = step;\n\n      // set up the popup settings in case they are needed.\n      var popupString = \"\";\n      var popupValue = 0;\n      if (value !== undefined) {\n        var factor = 1.2;\n        if (value < 0 && value * factor < min) {\n          range.min = Math.ceil(value * factor);\n          popupValue = range.min;\n          popupString = \"range increased\";\n        } else if (value / factor < min) {\n          range.min = Math.ceil(value / factor);\n          popupValue = range.min;\n          popupString = \"range increased\";\n        }\n        if (value * factor > max && max !== 1) {\n          range.max = Math.ceil(value * factor);\n          popupValue = range.max;\n          popupString = \"range increased\";\n        }\n        range.value = value;\n      } else {\n        range.value = defaultValue;\n      }\n      var input = document.createElement(\"input\");\n      input.className = \"vis-configuration vis-config-rangeinput\";\n      input.value = range.value;\n      var me = this;\n      range.onchange = function () {\n        input.value = this.value;\n        me._update(Number(this.value), path);\n      };\n      range.oninput = function () {\n        input.value = this.value;\n      };\n      var label = this._makeLabel(path[path.length - 1], path);\n      var itemIndex = this._makeItem(path, label, range, input);\n\n      // if a popup is needed AND it has not been shown for this value, show it.\n      if (popupString !== \"\" && this.popupHistory[itemIndex] !== popupValue) {\n        this.popupHistory[itemIndex] = popupValue;\n        this._setupPopup(popupString, itemIndex);\n      }\n    }\n\n    /**\n     * make a button object\n     *\n     * @private\n     */\n  }, {\n    key: \"_makeButton\",\n    value: function _makeButton() {\n      var _this4 = this;\n      if (this.options.showButton === true) {\n        var generateButton = document.createElement(\"div\");\n        generateButton.className = \"vis-configuration vis-config-button\";\n        generateButton.innerText = \"generate options\";\n        generateButton.onclick = function () {\n          _this4._printOptions();\n        };\n        generateButton.onmouseover = function () {\n          generateButton.className = \"vis-configuration vis-config-button hover\";\n        };\n        generateButton.onmouseout = function () {\n          generateButton.className = \"vis-configuration vis-config-button\";\n        };\n        this.optionsContainer = document.createElement(\"div\");\n        this.optionsContainer.className = \"vis-configuration vis-config-option-container\";\n        this.domElements.push(this.optionsContainer);\n        this.domElements.push(generateButton);\n      }\n    }\n\n    /**\n     * prepare the popup\n     *\n     * @param {string} string\n     * @param {number} index\n     * @private\n     */\n  }, {\n    key: \"_setupPopup\",\n    value: function _setupPopup(string, index) {\n      var _this5 = this;\n      if (this.initialized === true && this.allowCreation === true && this.popupCounter < this.popupLimit) {\n        var div = document.createElement(\"div\");\n        div.id = \"vis-configuration-popup\";\n        div.className = \"vis-configuration-popup\";\n        div.innerText = string;\n        div.onclick = function () {\n          _this5._removePopup();\n        };\n        this.popupCounter += 1;\n        this.popupDiv = {\n          html: div,\n          index: index\n        };\n      }\n    }\n\n    /**\n     * remove the popup from the dom\n     *\n     * @private\n     */\n  }, {\n    key: \"_removePopup\",\n    value: function _removePopup() {\n      if (this.popupDiv.html !== undefined) {\n        this.popupDiv.html.parentNode.removeChild(this.popupDiv.html);\n        clearTimeout(this.popupDiv.hideTimeout);\n        clearTimeout(this.popupDiv.deleteTimeout);\n        this.popupDiv = {};\n      }\n    }\n\n    /**\n     * Show the popup if it is needed.\n     *\n     * @private\n     */\n  }, {\n    key: \"_showPopupIfNeeded\",\n    value: function _showPopupIfNeeded() {\n      var _this6 = this;\n      if (this.popupDiv.html !== undefined) {\n        var correspondingElement = this.domElements[this.popupDiv.index];\n        var rect = correspondingElement.getBoundingClientRect();\n        this.popupDiv.html.style.left = rect.left + \"px\";\n        this.popupDiv.html.style.top = rect.top - 30 + \"px\"; // 30 is the height;\n        document.body.appendChild(this.popupDiv.html);\n        this.popupDiv.hideTimeout = _setTimeout(function () {\n          _this6.popupDiv.html.style.opacity = 0;\n        }, 1500);\n        this.popupDiv.deleteTimeout = _setTimeout(function () {\n          _this6._removePopup();\n        }, 1800);\n      }\n    }\n\n    /**\n     * make a checkbox for boolean options.\n     *\n     * @param {number} defaultValue\n     * @param {number} value\n     * @param {Array} path    | where to look for the actual option\n     * @private\n     */\n  }, {\n    key: \"_makeCheckbox\",\n    value: function _makeCheckbox(defaultValue, value, path) {\n      var checkbox = document.createElement(\"input\");\n      checkbox.type = \"checkbox\";\n      checkbox.className = \"vis-configuration vis-config-checkbox\";\n      checkbox.checked = defaultValue;\n      if (value !== undefined) {\n        checkbox.checked = value;\n        if (value !== defaultValue) {\n          if (_typeof(defaultValue) === \"object\") {\n            if (value !== defaultValue.enabled) {\n              this.changedOptions.push({\n                path: path,\n                value: value\n              });\n            }\n          } else {\n            this.changedOptions.push({\n              path: path,\n              value: value\n            });\n          }\n        }\n      }\n      var me = this;\n      checkbox.onchange = function () {\n        me._update(this.checked, path);\n      };\n      var label = this._makeLabel(path[path.length - 1], path);\n      this._makeItem(path, label, checkbox);\n    }\n\n    /**\n     * make a text input field for string options.\n     *\n     * @param {number} defaultValue\n     * @param {number} value\n     * @param {Array} path    | where to look for the actual option\n     * @private\n     */\n  }, {\n    key: \"_makeTextInput\",\n    value: function _makeTextInput(defaultValue, value, path) {\n      var checkbox = document.createElement(\"input\");\n      checkbox.type = \"text\";\n      checkbox.className = \"vis-configuration vis-config-text\";\n      checkbox.value = value;\n      if (value !== defaultValue) {\n        this.changedOptions.push({\n          path: path,\n          value: value\n        });\n      }\n      var me = this;\n      checkbox.onchange = function () {\n        me._update(this.value, path);\n      };\n      var label = this._makeLabel(path[path.length - 1], path);\n      this._makeItem(path, label, checkbox);\n    }\n\n    /**\n     * make a color field with a color picker for color fields\n     *\n     * @param {Array.<number>} arr\n     * @param {number} value\n     * @param {Array} path    | where to look for the actual option\n     * @private\n     */\n  }, {\n    key: \"_makeColorField\",\n    value: function _makeColorField(arr, value, path) {\n      var _this7 = this;\n      var defaultColor = arr[1];\n      var div = document.createElement(\"div\");\n      value = value === undefined ? defaultColor : value;\n      if (value !== \"none\") {\n        div.className = \"vis-configuration vis-config-colorBlock\";\n        div.style.backgroundColor = value;\n      } else {\n        div.className = \"vis-configuration vis-config-colorBlock none\";\n      }\n      value = value === undefined ? defaultColor : value;\n      div.onclick = function () {\n        _this7._showColorPicker(value, div, path);\n      };\n      var label = this._makeLabel(path[path.length - 1], path);\n      this._makeItem(path, label, div);\n    }\n\n    /**\n     * used by the color buttons to call the color picker.\n     *\n     * @param {number} value\n     * @param {HTMLElement} div\n     * @param {Array} path    | where to look for the actual option\n     * @private\n     */\n  }, {\n    key: \"_showColorPicker\",\n    value: function _showColorPicker(value, div, path) {\n      var _this8 = this;\n      // clear the callback from this div\n      div.onclick = function () {};\n      this.colorPicker.insertTo(div);\n      this.colorPicker.show();\n      this.colorPicker.setColor(value);\n      this.colorPicker.setUpdateCallback(function (color) {\n        var colorString = \"rgba(\" + color.r + \",\" + color.g + \",\" + color.b + \",\" + color.a + \")\";\n        div.style.backgroundColor = colorString;\n        _this8._update(colorString, path);\n      });\n\n      // on close of the colorpicker, restore the callback.\n      this.colorPicker.setCloseCallback(function () {\n        div.onclick = function () {\n          _this8._showColorPicker(value, div, path);\n        };\n      });\n    }\n\n    /**\n     * parse an object and draw the correct items\n     *\n     * @param {object} obj\n     * @param {Array} [path=[]]    | where to look for the actual option\n     * @param {boolean} [checkOnly=false]\n     * @returns {boolean}\n     * @private\n     */\n  }, {\n    key: \"_handleObject\",\n    value: function _handleObject(obj) {\n      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var checkOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var show = false;\n      var filter = _filterInstanceProperty(this.options);\n      var visibleInSet = false;\n      for (var subObj in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, subObj)) {\n          show = true;\n          var item = obj[subObj];\n          var newPath = copyAndExtendArray(path, subObj);\n          if (typeof filter === \"function\") {\n            show = filter(subObj, path);\n\n            // if needed we must go deeper into the object.\n            if (show === false) {\n              if (!_Array$isArray(item) && typeof item !== \"string\" && typeof item !== \"boolean\" && item instanceof Object) {\n                this.allowCreation = false;\n                show = this._handleObject(item, newPath, true);\n                this.allowCreation = checkOnly === false;\n              }\n            }\n          }\n          if (show !== false) {\n            visibleInSet = true;\n            var value = this._getValue(newPath);\n            if (_Array$isArray(item)) {\n              this._handleArray(item, value, newPath);\n            } else if (typeof item === \"string\") {\n              this._makeTextInput(item, value, newPath);\n            } else if (typeof item === \"boolean\") {\n              this._makeCheckbox(item, value, newPath);\n            } else if (item instanceof Object) {\n              // skip the options that are not enabled\n              if (!this.hideOption(path, subObj, this.moduleOptions)) {\n                // initially collapse options with an disabled enabled option.\n                if (item.enabled !== undefined) {\n                  var enabledPath = copyAndExtendArray(newPath, \"enabled\");\n                  var enabledValue = this._getValue(enabledPath);\n                  if (enabledValue === true) {\n                    var label = this._makeLabel(subObj, newPath, true);\n                    this._makeItem(newPath, label);\n                    visibleInSet = this._handleObject(item, newPath) || visibleInSet;\n                  } else {\n                    this._makeCheckbox(item, enabledValue, newPath);\n                  }\n                } else {\n                  var _label = this._makeLabel(subObj, newPath, true);\n                  this._makeItem(newPath, _label);\n                  visibleInSet = this._handleObject(item, newPath) || visibleInSet;\n                }\n              }\n            } else {\n              console.error(\"dont know how to handle\", item, subObj, newPath);\n            }\n          }\n        }\n      }\n      return visibleInSet;\n    }\n\n    /**\n     * handle the array type of option\n     *\n     * @param {Array.<number>} arr\n     * @param {number} value\n     * @param {Array} path    | where to look for the actual option\n     * @private\n     */\n  }, {\n    key: \"_handleArray\",\n    value: function _handleArray(arr, value, path) {\n      if (typeof arr[0] === \"string\" && arr[0] === \"color\") {\n        this._makeColorField(arr, value, path);\n        if (arr[1] !== value) {\n          this.changedOptions.push({\n            path: path,\n            value: value\n          });\n        }\n      } else if (typeof arr[0] === \"string\") {\n        this._makeDropdown(arr, value, path);\n        if (arr[0] !== value) {\n          this.changedOptions.push({\n            path: path,\n            value: value\n          });\n        }\n      } else if (typeof arr[0] === \"number\") {\n        this._makeRange(arr, value, path);\n        if (arr[0] !== value) {\n          this.changedOptions.push({\n            path: path,\n            value: Number(value)\n          });\n        }\n      }\n    }\n\n    /**\n     * called to update the network with the new settings.\n     *\n     * @param {number} value\n     * @param {Array} path    | where to look for the actual option\n     * @private\n     */\n  }, {\n    key: \"_update\",\n    value: function _update(value, path) {\n      var options = this._constructOptions(value, path);\n      if (this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit) {\n        this.parent.body.emitter.emit(\"configChange\", options);\n      }\n      this.initialized = true;\n      this.parent.setOptions(options);\n    }\n\n    /**\n     *\n     * @param {string | boolean} value\n     * @param {Array.<string>} path\n     * @param {{}} optionsObj\n     * @returns {{}}\n     * @private\n     */\n  }, {\n    key: \"_constructOptions\",\n    value: function _constructOptions(value, path) {\n      var optionsObj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var pointer = optionsObj;\n\n      // when dropdown boxes can be string or boolean, we typecast it into correct types\n      value = value === \"true\" ? true : value;\n      value = value === \"false\" ? false : value;\n      for (var i = 0; i < path.length; i++) {\n        if (path[i] !== \"global\") {\n          if (pointer[path[i]] === undefined) {\n            pointer[path[i]] = {};\n          }\n          if (i !== path.length - 1) {\n            pointer = pointer[path[i]];\n          } else {\n            pointer[path[i]] = value;\n          }\n        }\n      }\n      return optionsObj;\n    }\n\n    /**\n     * @private\n     */\n  }, {\n    key: \"_printOptions\",\n    value: function _printOptions() {\n      var options = this.getOptions();\n      while (this.optionsContainer.firstChild) {\n        this.optionsContainer.removeChild(this.optionsContainer.firstChild);\n      }\n      this.optionsContainer.appendChild(wrapInTag(\"pre\", \"const options = \" + _JSON$stringify(options, null, 2)));\n    }\n\n    /**\n     *\n     * @returns {{}} options\n     */\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      var options = {};\n      for (var i = 0; i < this.changedOptions.length; i++) {\n        this._constructOptions(this.changedOptions[i].value, this.changedOptions[i].path, options);\n      }\n      return options;\n    }\n  }]);\n  return Configurator;\n}();\n\n/**\n * Popup is a class to create a popup window with some text\n */\nvar Popup$1 = /*#__PURE__*/function () {\n  /**\n   * @param {Element} container       The container object.\n   * @param {string}  overflowMethod  How the popup should act to overflowing ('flip' or 'cap')\n   */\n  function Popup(container, overflowMethod) {\n    _classCallCheck(this, Popup);\n    this.container = container;\n    this.overflowMethod = overflowMethod || \"cap\";\n    this.x = 0;\n    this.y = 0;\n    this.padding = 5;\n    this.hidden = false;\n\n    // create the frame\n    this.frame = document.createElement(\"div\");\n    this.frame.className = \"vis-tooltip\";\n    this.container.appendChild(this.frame);\n  }\n\n  /**\n   * @param {number} x   Horizontal position of the popup window\n   * @param {number} y   Vertical position of the popup window\n   */\n  _createClass(Popup, [{\n    key: \"setPosition\",\n    value: function setPosition(x, y) {\n      this.x = _parseInt$1(x);\n      this.y = _parseInt$1(y);\n    }\n\n    /**\n     * Set the content for the popup window. This can be HTML code or text.\n     *\n     * @param {string | Element} content\n     */\n  }, {\n    key: \"setText\",\n    value: function setText(content) {\n      if (content instanceof Element) {\n        while (this.frame.firstChild) {\n          this.frame.removeChild(this.frame.firstChild);\n        }\n        this.frame.appendChild(content);\n      } else {\n        // String containing literal text, element has to be used for HTML due to\n        // XSS risks associated with innerHTML (i.e. prevent XSS by accident).\n        this.frame.innerText = content;\n      }\n    }\n\n    /**\n     * Show the popup window\n     *\n     * @param {boolean} [doShow]    Show or hide the window\n     */\n  }, {\n    key: \"show\",\n    value: function show(doShow) {\n      if (doShow === undefined) {\n        doShow = true;\n      }\n      if (doShow === true) {\n        var height = this.frame.clientHeight;\n        var width = this.frame.clientWidth;\n        var maxHeight = this.frame.parentNode.clientHeight;\n        var maxWidth = this.frame.parentNode.clientWidth;\n        var left = 0,\n          top = 0;\n        if (this.overflowMethod == \"flip\") {\n          var isLeft = false,\n            isTop = true; // Where around the position it's located\n\n          if (this.y - height < this.padding) {\n            isTop = false;\n          }\n          if (this.x + width > maxWidth - this.padding) {\n            isLeft = true;\n          }\n          if (isLeft) {\n            left = this.x - width;\n          } else {\n            left = this.x;\n          }\n          if (isTop) {\n            top = this.y - height;\n          } else {\n            top = this.y;\n          }\n        } else {\n          top = this.y - height;\n          if (top + height + this.padding > maxHeight) {\n            top = maxHeight - height - this.padding;\n          }\n          if (top < this.padding) {\n            top = this.padding;\n          }\n          left = this.x;\n          if (left + width + this.padding > maxWidth) {\n            left = maxWidth - width - this.padding;\n          }\n          if (left < this.padding) {\n            left = this.padding;\n          }\n        }\n        this.frame.style.left = left + \"px\";\n        this.frame.style.top = top + \"px\";\n        this.frame.style.visibility = \"visible\";\n        this.hidden = false;\n      } else {\n        this.hide();\n      }\n    }\n\n    /**\n     * Hide the popup window\n     */\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      this.hidden = true;\n      this.frame.style.left = \"0\";\n      this.frame.style.top = \"0\";\n      this.frame.style.visibility = \"hidden\";\n    }\n\n    /**\n     * Remove the popup window\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.frame.parentNode.removeChild(this.frame); // Remove element from DOM\n    }\n  }]);\n  return Popup;\n}();\nvar errorFound = false;\nvar allOptions$1;\nvar VALIDATOR_PRINT_STYLE$1 = \"background: #FFeeee; color: #dd0000\";\n\n/**\n *  Used to validate options.\n */\nvar Validator$1 = /*#__PURE__*/function () {\n  function Validator() {\n    _classCallCheck(this, Validator);\n  }\n  _createClass(Validator, null, [{\n    key: \"validate\",\n    value:\n    /**\n     * Main function to be called\n     *\n     * @param {object} options\n     * @param {object} referenceOptions\n     * @param {object} subObject\n     * @returns {boolean}\n     * @static\n     */\n    function validate(options, referenceOptions, subObject) {\n      errorFound = false;\n      allOptions$1 = referenceOptions;\n      var usedOptions = referenceOptions;\n      if (subObject !== undefined) {\n        usedOptions = referenceOptions[subObject];\n      }\n      Validator.parse(options, usedOptions, []);\n      return errorFound;\n    }\n\n    /**\n     * Will traverse an object recursively and check every value\n     *\n     * @param {object} options\n     * @param {object} referenceOptions\n     * @param {Array} path    | where to look for the actual option\n     * @static\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(options, referenceOptions, path) {\n      for (var _option3 in options) {\n        if (Object.prototype.hasOwnProperty.call(options, _option3)) {\n          Validator.check(_option3, options, referenceOptions, path);\n        }\n      }\n    }\n\n    /**\n     * Check every value. If the value is an object, call the parse function on that object.\n     *\n     * @param {string} option\n     * @param {object} options\n     * @param {object} referenceOptions\n     * @param {Array} path    | where to look for the actual option\n     * @static\n     */\n  }, {\n    key: \"check\",\n    value: function check(option, options, referenceOptions, path) {\n      if (referenceOptions[option] === undefined && referenceOptions.__any__ === undefined) {\n        Validator.getSuggestion(option, referenceOptions, path);\n        return;\n      }\n      var referenceOption = option;\n      var is_object = true;\n      if (referenceOptions[option] === undefined && referenceOptions.__any__ !== undefined) {\n        // NOTE: This only triggers if the __any__ is in the top level of the options object.\n        //       THAT'S A REALLY BAD PLACE TO ALLOW IT!!!!\n        // TODO: Examine if needed, remove if possible\n\n        // __any__ is a wildcard. Any value is accepted and will be further analysed by reference.\n        referenceOption = \"__any__\";\n\n        // if the any-subgroup is not a predefined object in the configurator,\n        // we do not look deeper into the object.\n        is_object = Validator.getType(options[option]) === \"object\";\n      }\n      var refOptionObj = referenceOptions[referenceOption];\n      if (is_object && refOptionObj.__type__ !== undefined) {\n        refOptionObj = refOptionObj.__type__;\n      }\n      Validator.checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path);\n    }\n\n    /**\n     *\n     * @param {string}  option           | the option property\n     * @param {object}  options          | The supplied options object\n     * @param {object}  referenceOptions | The reference options containing all options and their allowed formats\n     * @param {string}  referenceOption  | Usually this is the same as option, except when handling an __any__ tag.\n     * @param {string}  refOptionObj     | This is the type object from the reference options\n     * @param {Array}   path             | where in the object is the option\n     * @static\n     */\n  }, {\n    key: \"checkFields\",\n    value: function checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path) {\n      var log = function log(message) {\n        console.error(\"%c\" + message + Validator.printLocation(path, option), VALIDATOR_PRINT_STYLE$1);\n      };\n      var optionType = Validator.getType(options[option]);\n      var refOptionType = refOptionObj[optionType];\n      if (refOptionType !== undefined) {\n        // if the type is correct, we check if it is supposed to be one of a few select values\n        if (Validator.getType(refOptionType) === \"array\" && _indexOfInstanceProperty(refOptionType).call(refOptionType, options[option]) === -1) {\n          log('Invalid option detected in \"' + option + '\".' + \" Allowed values are:\" + Validator.print(refOptionType) + ' not \"' + options[option] + '\". ');\n          errorFound = true;\n        } else if (optionType === \"object\" && referenceOption !== \"__any__\") {\n          path = copyAndExtendArray(path, option);\n          Validator.parse(options[option], referenceOptions[referenceOption], path);\n        }\n      } else if (refOptionObj[\"any\"] === undefined) {\n        // type of the field is incorrect and the field cannot be any\n        log('Invalid type received for \"' + option + '\". Expected: ' + Validator.print(_Object$keys(refOptionObj)) + \". Received [\" + optionType + '] \"' + options[option] + '\"');\n        errorFound = true;\n      }\n    }\n\n    /**\n     *\n     * @param {object | boolean | number | string | Array.<number> | Date | Node | Moment | undefined | null} object\n     * @returns {string}\n     * @static\n     */\n  }, {\n    key: \"getType\",\n    value: function getType(object) {\n      var type = _typeof(object);\n      if (type === \"object\") {\n        if (object === null) {\n          return \"null\";\n        }\n        if (object instanceof Boolean) {\n          return \"boolean\";\n        }\n        if (object instanceof Number) {\n          return \"number\";\n        }\n        if (object instanceof String) {\n          return \"string\";\n        }\n        if (_Array$isArray(object)) {\n          return \"array\";\n        }\n        if (object instanceof Date) {\n          return \"date\";\n        }\n        if (object.nodeType !== undefined) {\n          return \"dom\";\n        }\n        if (object._isAMomentObject === true) {\n          return \"moment\";\n        }\n        return \"object\";\n      } else if (type === \"number\") {\n        return \"number\";\n      } else if (type === \"boolean\") {\n        return \"boolean\";\n      } else if (type === \"string\") {\n        return \"string\";\n      } else if (type === undefined) {\n        return \"undefined\";\n      }\n      return type;\n    }\n\n    /**\n     * @param {string} option\n     * @param {object} options\n     * @param {Array.<string>} path\n     * @static\n     */\n  }, {\n    key: \"getSuggestion\",\n    value: function getSuggestion(option, options, path) {\n      var localSearch = Validator.findInOptions(option, options, path, false);\n      var globalSearch = Validator.findInOptions(option, allOptions$1, [], true);\n      var localSearchThreshold = 8;\n      var globalSearchThreshold = 4;\n      var msg;\n      if (localSearch.indexMatch !== undefined) {\n        msg = \" in \" + Validator.printLocation(localSearch.path, option, \"\") + 'Perhaps it was incomplete? Did you mean: \"' + localSearch.indexMatch + '\"?\\n\\n';\n      } else if (globalSearch.distance <= globalSearchThreshold && localSearch.distance > globalSearch.distance) {\n        msg = \" in \" + Validator.printLocation(localSearch.path, option, \"\") + \"Perhaps it was misplaced? Matching option found at: \" + Validator.printLocation(globalSearch.path, globalSearch.closestMatch, \"\");\n      } else if (localSearch.distance <= localSearchThreshold) {\n        msg = '. Did you mean \"' + localSearch.closestMatch + '\"?' + Validator.printLocation(localSearch.path, option);\n      } else {\n        msg = \". Did you mean one of these: \" + Validator.print(_Object$keys(options)) + Validator.printLocation(path, option);\n      }\n      console.error('%cUnknown option detected: \"' + option + '\"' + msg, VALIDATOR_PRINT_STYLE$1);\n      errorFound = true;\n    }\n\n    /**\n     * traverse the options in search for a match.\n     *\n     * @param {string} option\n     * @param {object} options\n     * @param {Array} path    | where to look for the actual option\n     * @param {boolean} [recursive=false]\n     * @returns {{closestMatch: string, path: Array, distance: number}}\n     * @static\n     */\n  }, {\n    key: \"findInOptions\",\n    value: function findInOptions(option, options, path) {\n      var recursive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var min = 1e9;\n      var closestMatch = \"\";\n      var closestMatchPath = [];\n      var lowerCaseOption = option.toLowerCase();\n      var indexMatch = undefined;\n      for (var op in options) {\n        var distance = void 0;\n        if (options[op].__type__ !== undefined && recursive === true) {\n          var result = Validator.findInOptions(option, options[op], copyAndExtendArray(path, op));\n          if (min > result.distance) {\n            closestMatch = result.closestMatch;\n            closestMatchPath = result.path;\n            min = result.distance;\n            indexMatch = result.indexMatch;\n          }\n        } else {\n          var _context16;\n          if (_indexOfInstanceProperty(_context16 = op.toLowerCase()).call(_context16, lowerCaseOption) !== -1) {\n            indexMatch = op;\n          }\n          distance = Validator.levenshteinDistance(option, op);\n          if (min > distance) {\n            closestMatch = op;\n            closestMatchPath = copyArray(path);\n            min = distance;\n          }\n        }\n      }\n      return {\n        closestMatch: closestMatch,\n        path: closestMatchPath,\n        distance: min,\n        indexMatch: indexMatch\n      };\n    }\n\n    /**\n     * @param {Array.<string>} path\n     * @param {object} option\n     * @param {string} prefix\n     * @returns {string}\n     * @static\n     */\n  }, {\n    key: \"printLocation\",\n    value: function printLocation(path, option) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Problem value found at: \\n\";\n      var str = \"\\n\\n\" + prefix + \"options = {\\n\";\n      for (var i = 0; i < path.length; i++) {\n        for (var j = 0; j < i + 1; j++) {\n          str += \"  \";\n        }\n        str += path[i] + \": {\\n\";\n      }\n      for (var _j = 0; _j < path.length + 1; _j++) {\n        str += \"  \";\n      }\n      str += option + \"\\n\";\n      for (var _i5 = 0; _i5 < path.length + 1; _i5++) {\n        for (var _j2 = 0; _j2 < path.length - _i5; _j2++) {\n          str += \"  \";\n        }\n        str += \"}\\n\";\n      }\n      return str + \"\\n\\n\";\n    }\n\n    /**\n     * @param {object} options\n     * @returns {string}\n     * @static\n     */\n  }, {\n    key: \"print\",\n    value: function print(options) {\n      return _JSON$stringify(options).replace(/(\")|(\\[)|(\\])|(,\"__type__\")/g, \"\").replace(/(,)/g, \", \");\n    }\n\n    /**\n     *  Compute the edit distance between the two given strings\n     * http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript\n     *\n     * Copyright (c) 2011 Andrei Mackenzie\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n     *\n     * @param {string} a\n     * @param {string} b\n     * @returns {Array.<Array.<number>>}}\n     * @static\n     */\n  }, {\n    key: \"levenshteinDistance\",\n    value: function levenshteinDistance(a, b) {\n      if (a.length === 0) return b.length;\n      if (b.length === 0) return a.length;\n      var matrix = [];\n\n      // increment along the first column of each row\n      var i;\n      for (i = 0; i <= b.length; i++) {\n        matrix[i] = [i];\n      }\n\n      // increment each column in the first row\n      var j;\n      for (j = 0; j <= a.length; j++) {\n        matrix[0][j] = j;\n      }\n\n      // Fill in the rest of the matrix\n      for (i = 1; i <= b.length; i++) {\n        for (j = 1; j <= a.length; j++) {\n          if (b.charAt(i - 1) == a.charAt(j - 1)) {\n            matrix[i][j] = matrix[i - 1][j - 1];\n          } else {\n            matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1,\n            // substitution\n            Math.min(matrix[i][j - 1] + 1,\n            // insertion\n            matrix[i - 1][j] + 1)); // deletion\n          }\n        }\n      }\n\n      return matrix[b.length][a.length];\n    }\n  }]);\n  return Validator;\n}();\nvar Activator = Activator$1;\nvar Configurator = Configurator$1;\nvar Hammer = Hammer$1;\nvar Popup = Popup$1;\nvar VALIDATOR_PRINT_STYLE = VALIDATOR_PRINT_STYLE$1;\nvar Validator = Validator$1;\n\n/* eslint-disable no-prototype-builtins */\n/* eslint-disable no-unused-vars */\n/* eslint-disable no-var */\n\n/**\n * Parse a text source containing data in DOT language into a JSON object.\n * The object contains two lists: one with nodes and one with edges.\n *\n * DOT language reference: http://www.graphviz.org/doc/info/lang.html\n *\n * DOT language attributes: http://graphviz.org/content/attrs\n *\n * @param {string} data     Text containing a graph in DOT-notation\n * @returns {object} graph   An object containing two parameters:\n *                          {Object[]} nodes\n *                          {Object[]} edges\n *\n * -------------------------------------------\n * TODO\n * ====\n *\n * For label handling, this is an incomplete implementation. From docs (quote #3015):\n *\n * > the escape sequences \"\\n\", \"\\l\" and \"\\r\" divide the label into lines, centered,\n * > left-justified, and right-justified, respectively.\n *\n * Source: http://www.graphviz.org/content/attrs#kescString\n *\n * > As another aid for readability, dot allows double-quoted strings to span multiple physical\n * > lines using the standard C convention of a backslash immediately preceding a newline\n * > character\n * > In addition, double-quoted strings can be concatenated using a '+' operator.\n * > As HTML strings can contain newline characters, which are used solely for formatting,\n * > the language does not allow escaped newlines or concatenation operators to be used\n * > within them.\n *\n * - Currently, only '\\\\n' is handled\n * - Note that text explicitly says 'labels'; the dot parser currently handles escape\n *   sequences in **all** strings.\n */\nfunction parseDOT(data) {\n  dot = data;\n  return parseGraph();\n}\n\n// mapping of attributes from DOT (the keys) to vis.js (the values)\nvar NODE_ATTR_MAPPING = {\n  fontsize: \"font.size\",\n  fontcolor: \"font.color\",\n  labelfontcolor: \"font.color\",\n  fontname: \"font.face\",\n  color: [\"color.border\", \"color.background\"],\n  fillcolor: \"color.background\",\n  tooltip: \"title\",\n  labeltooltip: \"title\"\n};\nvar EDGE_ATTR_MAPPING = _Object$create$1(NODE_ATTR_MAPPING);\nEDGE_ATTR_MAPPING.color = \"color.color\";\nEDGE_ATTR_MAPPING.style = \"dashes\";\n\n// token types enumeration\nvar TOKENTYPE = {\n  NULL: 0,\n  DELIMITER: 1,\n  IDENTIFIER: 2,\n  UNKNOWN: 3\n};\n\n// map with all delimiters\nvar DELIMITERS = {\n  \"{\": true,\n  \"}\": true,\n  \"[\": true,\n  \"]\": true,\n  \";\": true,\n  \"=\": true,\n  \",\": true,\n  \"->\": true,\n  \"--\": true\n};\nvar dot = \"\"; // current dot file\nvar index = 0; // current index in dot file\nvar c = \"\"; // current token character in expr\nvar token = \"\"; // current token\nvar tokenType = TOKENTYPE.NULL; // type of the token\n\n/**\n * Get the first character from the dot file.\n * The character is stored into the char c. If the end of the dot file is\n * reached, the function puts an empty string in c.\n */\nfunction first() {\n  index = 0;\n  c = dot.charAt(0);\n}\n\n/**\n * Get the next character from the dot file.\n * The character is stored into the char c. If the end of the dot file is\n * reached, the function puts an empty string in c.\n */\nfunction next() {\n  index++;\n  c = dot.charAt(index);\n}\n\n/**\n * Preview the next character from the dot file.\n *\n * @returns {string} cNext\n */\nfunction nextPreview() {\n  return dot.charAt(index + 1);\n}\n\n/**\n * Test whether given character is alphabetic or numeric ( a-zA-Z_0-9.:# )\n *\n * @param {string} c\n * @returns {boolean} isAlphaNumeric\n */\nfunction isAlphaNumeric(c) {\n  var charCode = c.charCodeAt(0);\n  if (charCode < 47) {\n    // #.\n    return charCode === 35 || charCode === 46;\n  }\n  if (charCode < 59) {\n    // 0-9 and :\n    return charCode > 47;\n  }\n  if (charCode < 91) {\n    // A-Z\n    return charCode > 64;\n  }\n  if (charCode < 96) {\n    // _\n    return charCode === 95;\n  }\n  if (charCode < 123) {\n    // a-z\n    return charCode > 96;\n  }\n  return false;\n}\n\n/**\n * Merge all options of object b into object b\n *\n * @param {object} a\n * @param {object} b\n * @returns {object} a\n */\nfunction merge$1(a, b) {\n  if (!a) {\n    a = {};\n  }\n  if (b) {\n    for (var name in b) {\n      if (b.hasOwnProperty(name)) {\n        a[name] = b[name];\n      }\n    }\n  }\n  return a;\n}\n\n/**\n * Set a value in an object, where the provided parameter name can be a\n * path with nested parameters. For example:\n *\n *     var obj = {a: 2};\n *     setValue(obj, 'b.c', 3);     // obj = {a: 2, b: {c: 3}}\n *\n * @param {object} obj\n * @param {string} path  A parameter name or dot-separated parameter path,\n *                      like \"color.highlight.border\".\n * @param {*} value\n */\nfunction setValue(obj, path, value) {\n  var keys = path.split(\".\");\n  var o = obj;\n  while (keys.length) {\n    var key = keys.shift();\n    if (keys.length) {\n      // this isn't the end point\n      if (!o[key]) {\n        o[key] = {};\n      }\n      o = o[key];\n    } else {\n      // this is the end point\n      o[key] = value;\n    }\n  }\n}\n\n/**\n * Add a node to a graph object. If there is already a node with\n * the same id, their attributes will be merged.\n *\n * @param {object} graph\n * @param {object} node\n */\nfunction addNode(graph, node) {\n  var i, len;\n  var current = null;\n\n  // find root graph (in case of subgraph)\n  var graphs = [graph]; // list with all graphs from current graph to root graph\n  var root = graph;\n  while (root.parent) {\n    graphs.push(root.parent);\n    root = root.parent;\n  }\n\n  // find existing node (at root level) by its id\n  if (root.nodes) {\n    for (i = 0, len = root.nodes.length; i < len; i++) {\n      if (node.id === root.nodes[i].id) {\n        current = root.nodes[i];\n        break;\n      }\n    }\n  }\n  if (!current) {\n    // this is a new node\n    current = {\n      id: node.id\n    };\n    if (graph.node) {\n      // clone default attributes\n      current.attr = merge$1(current.attr, graph.node);\n    }\n  }\n\n  // add node to this (sub)graph and all its parent graphs\n  for (i = graphs.length - 1; i >= 0; i--) {\n    var _context;\n    var g = graphs[i];\n    if (!g.nodes) {\n      g.nodes = [];\n    }\n    if (_indexOfInstanceProperty(_context = g.nodes).call(_context, current) === -1) {\n      g.nodes.push(current);\n    }\n  }\n\n  // merge attributes\n  if (node.attr) {\n    current.attr = merge$1(current.attr, node.attr);\n  }\n}\n\n/**\n * Add an edge to a graph object\n *\n * @param {object} graph\n * @param {object} edge\n */\nfunction addEdge(graph, edge) {\n  if (!graph.edges) {\n    graph.edges = [];\n  }\n  graph.edges.push(edge);\n  if (graph.edge) {\n    var attr = merge$1({}, graph.edge); // clone default attributes\n    edge.attr = merge$1(attr, edge.attr); // merge attributes\n  }\n}\n\n/**\n * Create an edge to a graph object\n *\n * @param {object} graph\n * @param {string | number | object} from\n * @param {string | number | object} to\n * @param {string} type\n * @param {object | null} attr\n * @returns {object} edge\n */\nfunction createEdge(graph, from, to, type, attr) {\n  var edge = {\n    from: from,\n    to: to,\n    type: type\n  };\n  if (graph.edge) {\n    edge.attr = merge$1({}, graph.edge); // clone default attributes\n  }\n\n  edge.attr = merge$1(edge.attr || {}, attr); // merge attributes\n\n  // Move arrows attribute from attr to edge temporally created in\n  // parseAttributeList().\n  if (attr != null) {\n    if (attr.hasOwnProperty(\"arrows\") && attr[\"arrows\"] != null) {\n      edge[\"arrows\"] = {\n        to: {\n          enabled: true,\n          type: attr.arrows.type\n        }\n      };\n      attr[\"arrows\"] = null;\n    }\n  }\n  return edge;\n}\n\n/**\n * Get next token in the current dot file.\n * The token and token type are available as token and tokenType\n */\nfunction getToken() {\n  tokenType = TOKENTYPE.NULL;\n  token = \"\";\n\n  // skip over whitespaces\n  while (c === \" \" || c === \"\\t\" || c === \"\\n\" || c === \"\\r\") {\n    // space, tab, enter\n    next();\n  }\n  do {\n    var isComment = false;\n\n    // skip comment\n    if (c === \"#\") {\n      // find the previous non-space character\n      var i = index - 1;\n      while (dot.charAt(i) === \" \" || dot.charAt(i) === \"\\t\") {\n        i--;\n      }\n      if (dot.charAt(i) === \"\\n\" || dot.charAt(i) === \"\") {\n        // the # is at the start of a line, this is indeed a line comment\n        while (c != \"\" && c != \"\\n\") {\n          next();\n        }\n        isComment = true;\n      }\n    }\n    if (c === \"/\" && nextPreview() === \"/\") {\n      // skip line comment\n      while (c != \"\" && c != \"\\n\") {\n        next();\n      }\n      isComment = true;\n    }\n    if (c === \"/\" && nextPreview() === \"*\") {\n      // skip block comment\n      while (c != \"\") {\n        if (c === \"*\" && nextPreview() === \"/\") {\n          // end of block comment found. skip these last two characters\n          next();\n          next();\n          break;\n        } else {\n          next();\n        }\n      }\n      isComment = true;\n    }\n\n    // skip over whitespaces\n    while (c === \" \" || c === \"\\t\" || c === \"\\n\" || c === \"\\r\") {\n      // space, tab, enter\n      next();\n    }\n  } while (isComment);\n\n  // check for end of dot file\n  if (c === \"\") {\n    // token is still empty\n    tokenType = TOKENTYPE.DELIMITER;\n    return;\n  }\n\n  // check for delimiters consisting of 2 characters\n  var c2 = c + nextPreview();\n  if (DELIMITERS[c2]) {\n    tokenType = TOKENTYPE.DELIMITER;\n    token = c2;\n    next();\n    next();\n    return;\n  }\n\n  // check for delimiters consisting of 1 character\n  if (DELIMITERS[c]) {\n    tokenType = TOKENTYPE.DELIMITER;\n    token = c;\n    next();\n    return;\n  }\n\n  // check for an identifier (number or string)\n  // TODO: more precise parsing of numbers/strings (and the port separator ':')\n  if (isAlphaNumeric(c) || c === \"-\") {\n    token += c;\n    next();\n    while (isAlphaNumeric(c)) {\n      token += c;\n      next();\n    }\n    if (token === \"false\") {\n      token = false; // convert to boolean\n    } else if (token === \"true\") {\n      token = true; // convert to boolean\n    } else if (!isNaN(Number(token))) {\n      token = Number(token); // convert to number\n    }\n\n    tokenType = TOKENTYPE.IDENTIFIER;\n    return;\n  }\n\n  // check for a string enclosed by double quotes\n  if (c === '\"') {\n    next();\n    while (c != \"\" && (c != '\"' || c === '\"' && nextPreview() === '\"')) {\n      if (c === '\"') {\n        // skip the escape character\n        token += c;\n        next();\n      } else if (c === \"\\\\\" && nextPreview() === \"n\") {\n        // Honor a newline escape sequence\n        token += \"\\n\";\n        next();\n      } else {\n        token += c;\n      }\n      next();\n    }\n    if (c != '\"') {\n      throw newSyntaxError('End of string \" expected');\n    }\n    next();\n    tokenType = TOKENTYPE.IDENTIFIER;\n    return;\n  }\n\n  // something unknown is found, wrong characters, a syntax error\n  tokenType = TOKENTYPE.UNKNOWN;\n  while (c != \"\") {\n    token += c;\n    next();\n  }\n  throw new SyntaxError('Syntax error in part \"' + chop(token, 30) + '\"');\n}\n\n/**\n * Parse a graph.\n *\n * @returns {object} graph\n */\nfunction parseGraph() {\n  var graph = {};\n  first();\n  getToken();\n\n  // optional strict keyword\n  if (token === \"strict\") {\n    graph.strict = true;\n    getToken();\n  }\n\n  // graph or digraph keyword\n  if (token === \"graph\" || token === \"digraph\") {\n    graph.type = token;\n    getToken();\n  }\n\n  // optional graph id\n  if (tokenType === TOKENTYPE.IDENTIFIER) {\n    graph.id = token;\n    getToken();\n  }\n\n  // open angle bracket\n  if (token != \"{\") {\n    throw newSyntaxError(\"Angle bracket { expected\");\n  }\n  getToken();\n\n  // statements\n  parseStatements(graph);\n\n  // close angle bracket\n  if (token != \"}\") {\n    throw newSyntaxError(\"Angle bracket } expected\");\n  }\n  getToken();\n\n  // end of file\n  if (token !== \"\") {\n    throw newSyntaxError(\"End of file expected\");\n  }\n  getToken();\n\n  // remove temporary default options\n  delete graph.node;\n  delete graph.edge;\n  delete graph.graph;\n  return graph;\n}\n\n/**\n * Parse a list with statements.\n *\n * @param {object} graph\n */\nfunction parseStatements(graph) {\n  while (token !== \"\" && token != \"}\") {\n    parseStatement(graph);\n    if (token === \";\") {\n      getToken();\n    }\n  }\n}\n\n/**\n * Parse a single statement. Can be a an attribute statement, node\n * statement, a series of node statements and edge statements, or a\n * parameter.\n *\n * @param {object} graph\n */\nfunction parseStatement(graph) {\n  // parse subgraph\n  var subgraph = parseSubgraph(graph);\n  if (subgraph) {\n    // edge statements\n    parseEdge(graph, subgraph);\n    return;\n  }\n\n  // parse an attribute statement\n  var attr = parseAttributeStatement(graph);\n  if (attr) {\n    return;\n  }\n\n  // parse node\n  if (tokenType != TOKENTYPE.IDENTIFIER) {\n    throw newSyntaxError(\"Identifier expected\");\n  }\n  var id = token; // id can be a string or a number\n  getToken();\n  if (token === \"=\") {\n    // id statement\n    getToken();\n    if (tokenType != TOKENTYPE.IDENTIFIER) {\n      throw newSyntaxError(\"Identifier expected\");\n    }\n    graph[id] = token;\n    getToken();\n    // TODO: implement comma separated list with \"a_list: ID=ID [','] [a_list] \"\n  } else {\n    parseNodeStatement(graph, id);\n  }\n}\n\n/**\n * Parse a subgraph\n *\n * @param {object} graph    parent graph object\n * @returns {object | null} subgraph\n */\nfunction parseSubgraph(graph) {\n  var subgraph = null;\n\n  // optional subgraph keyword\n  if (token === \"subgraph\") {\n    subgraph = {};\n    subgraph.type = \"subgraph\";\n    getToken();\n\n    // optional graph id\n    if (tokenType === TOKENTYPE.IDENTIFIER) {\n      subgraph.id = token;\n      getToken();\n    }\n  }\n\n  // open angle bracket\n  if (token === \"{\") {\n    getToken();\n    if (!subgraph) {\n      subgraph = {};\n    }\n    subgraph.parent = graph;\n    subgraph.node = graph.node;\n    subgraph.edge = graph.edge;\n    subgraph.graph = graph.graph;\n\n    // statements\n    parseStatements(subgraph);\n\n    // close angle bracket\n    if (token != \"}\") {\n      throw newSyntaxError(\"Angle bracket } expected\");\n    }\n    getToken();\n\n    // remove temporary default options\n    delete subgraph.node;\n    delete subgraph.edge;\n    delete subgraph.graph;\n    delete subgraph.parent;\n\n    // register at the parent graph\n    if (!graph.subgraphs) {\n      graph.subgraphs = [];\n    }\n    graph.subgraphs.push(subgraph);\n  }\n  return subgraph;\n}\n\n/**\n * parse an attribute statement like \"node [shape=circle fontSize=16]\".\n * Available keywords are 'node', 'edge', 'graph'.\n * The previous list with default attributes will be replaced\n *\n * @param {object} graph\n * @returns {string | null} keyword Returns the name of the parsed attribute\n *                                  (node, edge, graph), or null if nothing\n *                                  is parsed.\n */\nfunction parseAttributeStatement(graph) {\n  // attribute statements\n  if (token === \"node\") {\n    getToken();\n\n    // node attributes\n    graph.node = parseAttributeList();\n    return \"node\";\n  } else if (token === \"edge\") {\n    getToken();\n\n    // edge attributes\n    graph.edge = parseAttributeList();\n    return \"edge\";\n  } else if (token === \"graph\") {\n    getToken();\n\n    // graph attributes\n    graph.graph = parseAttributeList();\n    return \"graph\";\n  }\n  return null;\n}\n\n/**\n * parse a node statement\n *\n * @param {object} graph\n * @param {string | number} id\n */\nfunction parseNodeStatement(graph, id) {\n  // node statement\n  var node = {\n    id: id\n  };\n  var attr = parseAttributeList();\n  if (attr) {\n    node.attr = attr;\n  }\n  addNode(graph, node);\n\n  // edge statements\n  parseEdge(graph, id);\n}\n\n/**\n * Parse an edge or a series of edges\n *\n * @param {object} graph\n * @param {string | number} from        Id of the from node\n */\nfunction parseEdge(graph, from) {\n  while (token === \"->\" || token === \"--\") {\n    var to;\n    var type = token;\n    getToken();\n    var subgraph = parseSubgraph(graph);\n    if (subgraph) {\n      to = subgraph;\n    } else {\n      if (tokenType != TOKENTYPE.IDENTIFIER) {\n        throw newSyntaxError(\"Identifier or subgraph expected\");\n      }\n      to = token;\n      addNode(graph, {\n        id: to\n      });\n      getToken();\n    }\n\n    // parse edge attributes\n    var attr = parseAttributeList();\n\n    // create edge\n    var edge = createEdge(graph, from, to, type, attr);\n    addEdge(graph, edge);\n    from = to;\n  }\n}\n\n/**\n * Parse a set with attributes,\n * for example [label=\"1.000\", shape=solid]\n *\n * @returns {object | null} attr\n */\nfunction parseAttributeList() {\n  var i;\n  var attr = null;\n\n  // edge styles of dot and vis\n  var edgeStyles = {\n    dashed: true,\n    solid: false,\n    dotted: [1, 5]\n  };\n\n  /**\n   * Define arrow types.\n   * vis currently supports types defined in 'arrowTypes'.\n   * Details of arrow shapes are described in\n   * http://www.graphviz.org/content/arrow-shapes\n   */\n  var arrowTypes = {\n    dot: \"circle\",\n    box: \"box\",\n    crow: \"crow\",\n    curve: \"curve\",\n    icurve: \"inv_curve\",\n    normal: \"triangle\",\n    inv: \"inv_triangle\",\n    diamond: \"diamond\",\n    tee: \"bar\",\n    vee: \"vee\"\n  };\n\n  /**\n   * 'attr_list' contains attributes for checking if some of them are affected\n   * later. For instance, both of 'arrowhead' and 'dir' (edge style defined\n   * in DOT) make changes to 'arrows' attribute in vis.\n   */\n  var attr_list = new Array();\n  var attr_names = new Array(); // used for checking the case.\n\n  // parse attributes\n  while (token === \"[\") {\n    getToken();\n    attr = {};\n    while (token !== \"\" && token != \"]\") {\n      if (tokenType != TOKENTYPE.IDENTIFIER) {\n        throw newSyntaxError(\"Attribute name expected\");\n      }\n      var name = token;\n      getToken();\n      if (token != \"=\") {\n        throw newSyntaxError(\"Equal sign = expected\");\n      }\n      getToken();\n      if (tokenType != TOKENTYPE.IDENTIFIER) {\n        throw newSyntaxError(\"Attribute value expected\");\n      }\n      var value = token;\n\n      // convert from dot style to vis\n      if (name === \"style\") {\n        value = edgeStyles[value];\n      }\n      var arrowType;\n      if (name === \"arrowhead\") {\n        arrowType = arrowTypes[value];\n        name = \"arrows\";\n        value = {\n          to: {\n            enabled: true,\n            type: arrowType\n          }\n        };\n      }\n      if (name === \"arrowtail\") {\n        arrowType = arrowTypes[value];\n        name = \"arrows\";\n        value = {\n          from: {\n            enabled: true,\n            type: arrowType\n          }\n        };\n      }\n      attr_list.push({\n        attr: attr,\n        name: name,\n        value: value\n      });\n      attr_names.push(name);\n      getToken();\n      if (token == \",\") {\n        getToken();\n      }\n    }\n    if (token != \"]\") {\n      throw newSyntaxError(\"Bracket ] expected\");\n    }\n    getToken();\n  }\n\n  /**\n   * As explained in [1], graphviz has limitations for combination of\n   * arrow[head|tail] and dir. If attribute list includes 'dir',\n   * following cases just be supported.\n   *   1. both or none + arrowhead, arrowtail\n   *   2. forward + arrowhead (arrowtail is not affedted)\n   *   3. back + arrowtail (arrowhead is not affected)\n   * [1] https://www.graphviz.org/doc/info/attrs.html#h:undir_note\n   */\n  if (_includesInstanceProperty(attr_names).call(attr_names, \"dir\")) {\n    var idx = {}; // get index of 'arrows' and 'dir'\n    idx.arrows = {};\n    for (i = 0; i < attr_list.length; i++) {\n      if (attr_list[i].name === \"arrows\") {\n        if (attr_list[i].value.to != null) {\n          idx.arrows.to = i;\n        } else if (attr_list[i].value.from != null) {\n          idx.arrows.from = i;\n        } else {\n          throw newSyntaxError(\"Invalid value of arrows\");\n        }\n      } else if (attr_list[i].name === \"dir\") {\n        idx.dir = i;\n      }\n    }\n\n    // first, add default arrow shape if it is not assigned to avoid error\n    var dir_type = attr_list[idx.dir].value;\n    if (!_includesInstanceProperty(attr_names).call(attr_names, \"arrows\")) {\n      if (dir_type === \"both\") {\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: \"arrows\",\n          value: {\n            to: {\n              enabled: true\n            }\n          }\n        });\n        idx.arrows.to = attr_list.length - 1;\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: \"arrows\",\n          value: {\n            from: {\n              enabled: true\n            }\n          }\n        });\n        idx.arrows.from = attr_list.length - 1;\n      } else if (dir_type === \"forward\") {\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: \"arrows\",\n          value: {\n            to: {\n              enabled: true\n            }\n          }\n        });\n        idx.arrows.to = attr_list.length - 1;\n      } else if (dir_type === \"back\") {\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: \"arrows\",\n          value: {\n            from: {\n              enabled: true\n            }\n          }\n        });\n        idx.arrows.from = attr_list.length - 1;\n      } else if (dir_type === \"none\") {\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: \"arrows\",\n          value: \"\"\n        });\n        idx.arrows.to = attr_list.length - 1;\n      } else {\n        throw newSyntaxError('Invalid dir type \"' + dir_type + '\"');\n      }\n    }\n    var from_type;\n    var to_type;\n    // update 'arrows' attribute from 'dir'.\n    if (dir_type === \"both\") {\n      // both of shapes of 'from' and 'to' are given\n      if (idx.arrows.to && idx.arrows.from) {\n        to_type = attr_list[idx.arrows.to].value.to.type;\n        from_type = attr_list[idx.arrows.from].value.from.type;\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n        _spliceInstanceProperty(attr_list).call(attr_list, idx.arrows.from, 1);\n\n        // shape of 'to' is assigned and use default to 'from'\n      } else if (idx.arrows.to) {\n        to_type = attr_list[idx.arrows.to].value.to.type;\n        from_type = \"arrow\";\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n\n        // only shape of 'from' is assigned and use default for 'to'\n      } else if (idx.arrows.from) {\n        to_type = \"arrow\";\n        from_type = attr_list[idx.arrows.from].value.from.type;\n        attr_list[idx.arrows.from] = {\n          attr: attr_list[idx.arrows.from].attr,\n          name: attr_list[idx.arrows.from].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n      }\n    } else if (dir_type === \"back\") {\n      // given both of shapes, but use only 'from'\n      if (idx.arrows.to && idx.arrows.from) {\n        to_type = \"\";\n        from_type = attr_list[idx.arrows.from].value.from.type;\n        attr_list[idx.arrows.from] = {\n          attr: attr_list[idx.arrows.from].attr,\n          name: attr_list[idx.arrows.from].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n\n        // given shape of 'to', but does not use it\n      } else if (idx.arrows.to) {\n        to_type = \"\";\n        from_type = \"arrow\";\n        idx.arrows.from = idx.arrows.to;\n        attr_list[idx.arrows.from] = {\n          attr: attr_list[idx.arrows.from].attr,\n          name: attr_list[idx.arrows.from].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n\n        // assign given 'from' shape\n      } else if (idx.arrows.from) {\n        to_type = \"\";\n        from_type = attr_list[idx.arrows.from].value.from.type;\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.from].attr,\n          name: attr_list[idx.arrows.from].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n      }\n      attr_list[idx.arrows.from] = {\n        attr: attr_list[idx.arrows.from].attr,\n        name: attr_list[idx.arrows.from].name,\n        value: {\n          from: {\n            enabled: true,\n            type: attr_list[idx.arrows.from].value.from.type\n          }\n        }\n      };\n    } else if (dir_type === \"none\") {\n      var idx_arrow;\n      if (idx.arrows.to) {\n        idx_arrow = idx.arrows.to;\n      } else {\n        idx_arrow = idx.arrows.from;\n      }\n      attr_list[idx_arrow] = {\n        attr: attr_list[idx_arrow].attr,\n        name: attr_list[idx_arrow].name,\n        value: \"\"\n      };\n    } else if (dir_type === \"forward\") {\n      // given both of shapes, but use only 'to'\n      if (idx.arrows.to && idx.arrows.from) {\n        to_type = attr_list[idx.arrows.to].value.to.type;\n        from_type = \"\";\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n\n        // assign given 'to' shape\n      } else if (idx.arrows.to) {\n        to_type = attr_list[idx.arrows.to].value.to.type;\n        from_type = \"\";\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n\n        // given shape of 'from', but does not use it\n      } else if (idx.arrows.from) {\n        to_type = \"arrow\";\n        from_type = \"\";\n        idx.arrows.to = idx.arrows.from;\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n      }\n      attr_list[idx.arrows.to] = {\n        attr: attr_list[idx.arrows.to].attr,\n        name: attr_list[idx.arrows.to].name,\n        value: {\n          to: {\n            enabled: true,\n            type: attr_list[idx.arrows.to].value.to.type\n          }\n        }\n      };\n    } else {\n      throw newSyntaxError('Invalid dir type \"' + dir_type + '\"');\n    }\n\n    // remove 'dir' attribute no need anymore\n    _spliceInstanceProperty(attr_list).call(attr_list, idx.dir, 1);\n  }\n\n  // parse 'penwidth'\n  var nof_attr_list;\n  if (_includesInstanceProperty(attr_names).call(attr_names, \"penwidth\")) {\n    var tmp_attr_list = [];\n    nof_attr_list = attr_list.length;\n    for (i = 0; i < nof_attr_list; i++) {\n      // exclude 'width' from attr_list if 'penwidth' exists\n      if (attr_list[i].name !== \"width\") {\n        if (attr_list[i].name === \"penwidth\") {\n          attr_list[i].name = \"width\";\n        }\n        tmp_attr_list.push(attr_list[i]);\n      }\n    }\n    attr_list = tmp_attr_list;\n  }\n  nof_attr_list = attr_list.length;\n  for (i = 0; i < nof_attr_list; i++) {\n    setValue(attr_list[i].attr, attr_list[i].name, attr_list[i].value);\n  }\n  return attr;\n}\n\n/**\n * Create a syntax error with extra information on current token and index.\n *\n * @param {string} message\n * @returns {SyntaxError} err\n */\nfunction newSyntaxError(message) {\n  return new SyntaxError(message + ', got \"' + chop(token, 30) + '\" (char ' + index + \")\");\n}\n\n/**\n * Chop off text after a maximum length\n *\n * @param {string} text\n * @param {number} maxLength\n * @returns {string}\n */\nfunction chop(text, maxLength) {\n  return text.length <= maxLength ? text : text.substr(0, 27) + \"...\";\n}\n\n/**\n * Execute a function fn for each pair of elements in two arrays\n *\n * @param {Array | *} array1\n * @param {Array | *} array2\n * @param {Function} fn\n */\nfunction forEach2(array1, array2, fn) {\n  if (_Array$isArray(array1)) {\n    _forEachInstanceProperty(array1).call(array1, function (elem1) {\n      if (_Array$isArray(array2)) {\n        _forEachInstanceProperty(array2).call(array2, function (elem2) {\n          fn(elem1, elem2);\n        });\n      } else {\n        fn(elem1, array2);\n      }\n    });\n  } else {\n    if (_Array$isArray(array2)) {\n      _forEachInstanceProperty(array2).call(array2, function (elem2) {\n        fn(array1, elem2);\n      });\n    } else {\n      fn(array1, array2);\n    }\n  }\n}\n\n/**\n * Set a nested property on an object\n * When nested objects are missing, they will be created.\n * For example setProp({}, 'font.color', 'red') will return {font: {color: 'red'}}\n *\n * @param {object} object\n * @param {string} path   A dot separated string like 'font.color'\n * @param {*} value       Value for the property\n * @returns {object} Returns the original object, allows for chaining.\n */\nfunction setProp(object, path, value) {\n  var names = path.split(\".\");\n  var prop = names.pop();\n\n  // traverse over the nested objects\n  var obj = object;\n  for (var i = 0; i < names.length; i++) {\n    var name = names[i];\n    if (!(name in obj)) {\n      obj[name] = {};\n    }\n    obj = obj[name];\n  }\n\n  // set the property value\n  obj[prop] = value;\n  return object;\n}\n\n/**\n * Convert an object with DOT attributes to their vis.js equivalents.\n *\n * @param {object} attr     Object with DOT attributes\n * @param {object} mapping\n * @returns {object}         Returns an object with vis.js attributes\n */\nfunction convertAttr(attr, mapping) {\n  var converted = {};\n  for (var prop in attr) {\n    if (attr.hasOwnProperty(prop)) {\n      var visProp = mapping[prop];\n      if (_Array$isArray(visProp)) {\n        _forEachInstanceProperty(visProp).call(visProp, function (visPropI) {\n          setProp(converted, visPropI, attr[prop]);\n        });\n      } else if (typeof visProp === \"string\") {\n        setProp(converted, visProp, attr[prop]);\n      } else {\n        setProp(converted, prop, attr[prop]);\n      }\n    }\n  }\n  return converted;\n}\n\n/**\n * Convert a string containing a graph in DOT language into a map containing\n * with nodes and edges in the format of graph.\n *\n * @param {string} data         Text containing a graph in DOT-notation\n * @returns {object} graphData\n */\nfunction DOTToGraph(data) {\n  // parse the DOT file\n  var dotData = parseDOT(data);\n  var graphData = {\n    nodes: [],\n    edges: [],\n    options: {}\n  };\n\n  // copy the nodes\n  if (dotData.nodes) {\n    var _context2;\n    _forEachInstanceProperty(_context2 = dotData.nodes).call(_context2, function (dotNode) {\n      var graphNode = {\n        id: dotNode.id,\n        label: String(dotNode.label || dotNode.id)\n      };\n      merge$1(graphNode, convertAttr(dotNode.attr, NODE_ATTR_MAPPING));\n      if (graphNode.image) {\n        graphNode.shape = \"image\";\n      }\n      graphData.nodes.push(graphNode);\n    });\n  }\n\n  // copy the edges\n  if (dotData.edges) {\n    var _context3;\n    /**\n     * Convert an edge in DOT format to an edge with VisGraph format\n     *\n     * @param {object} dotEdge\n     * @returns {object} graphEdge\n     */\n    var convertEdge = function convertEdge(dotEdge) {\n      var graphEdge = {\n        from: dotEdge.from,\n        to: dotEdge.to\n      };\n      merge$1(graphEdge, convertAttr(dotEdge.attr, EDGE_ATTR_MAPPING));\n\n      // Add arrows attribute to default styled arrow.\n      // The reason why default style is not added in parseAttributeList() is\n      // because only default is cleared before here.\n      if (graphEdge.arrows == null && dotEdge.type === \"->\") {\n        graphEdge.arrows = \"to\";\n      }\n      return graphEdge;\n    };\n    _forEachInstanceProperty(_context3 = dotData.edges).call(_context3, function (dotEdge) {\n      var from, to;\n      if (dotEdge.from instanceof Object) {\n        from = dotEdge.from.nodes;\n      } else {\n        from = {\n          id: dotEdge.from\n        };\n      }\n      if (dotEdge.to instanceof Object) {\n        to = dotEdge.to.nodes;\n      } else {\n        to = {\n          id: dotEdge.to\n        };\n      }\n      if (dotEdge.from instanceof Object && dotEdge.from.edges) {\n        var _context4;\n        _forEachInstanceProperty(_context4 = dotEdge.from.edges).call(_context4, function (subEdge) {\n          var graphEdge = convertEdge(subEdge);\n          graphData.edges.push(graphEdge);\n        });\n      }\n      forEach2(from, to, function (from, to) {\n        var subEdge = createEdge(graphData, from.id, to.id, dotEdge.type, dotEdge.attr);\n        var graphEdge = convertEdge(subEdge);\n        graphData.edges.push(graphEdge);\n      });\n      if (dotEdge.to instanceof Object && dotEdge.to.edges) {\n        var _context5;\n        _forEachInstanceProperty(_context5 = dotEdge.to.edges).call(_context5, function (subEdge) {\n          var graphEdge = convertEdge(subEdge);\n          graphData.edges.push(graphEdge);\n        });\n      }\n    });\n  }\n\n  // copy the options\n  if (dotData.attr) {\n    graphData.options = dotData.attr;\n  }\n  return graphData;\n}\n\n/* eslint-enable no-var */\n/* eslint-enable no-unused-vars */\n/* eslint-enable no-prototype-builtins */\n\nvar dotparser = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tDOTToGraph: DOTToGraph,\n\tparseDOT: parseDOT\n});\n\n/**\r\n * Convert Gephi to Vis.\r\n *\r\n * @param gephiJSON - The parsed JSON data in Gephi format.\r\n * @param optionsObj - Additional options.\r\n * @returns The converted data ready to be used in Vis.\r\n */\nfunction parseGephi(gephiJSON, optionsObj) {\n  var _context;\n  var options = {\n    edges: {\n      inheritColor: false\n    },\n    nodes: {\n      fixed: false,\n      parseColor: false\n    }\n  };\n  if (optionsObj != null) {\n    if (optionsObj.fixed != null) {\n      options.nodes.fixed = optionsObj.fixed;\n    }\n    if (optionsObj.parseColor != null) {\n      options.nodes.parseColor = optionsObj.parseColor;\n    }\n    if (optionsObj.inheritColor != null) {\n      options.edges.inheritColor = optionsObj.inheritColor;\n    }\n  }\n  var gEdges = gephiJSON.edges;\n  var vEdges = _mapInstanceProperty(gEdges).call(gEdges, function (gEdge) {\n    var vEdge = {\n      from: gEdge.source,\n      id: gEdge.id,\n      to: gEdge.target\n    };\n    if (gEdge.attributes != null) {\n      vEdge.attributes = gEdge.attributes;\n    }\n    if (gEdge.label != null) {\n      vEdge.label = gEdge.label;\n    }\n    if (gEdge.attributes != null && gEdge.attributes.title != null) {\n      vEdge.title = gEdge.attributes.title;\n    }\n    if (gEdge.type === \"Directed\") {\n      vEdge.arrows = \"to\";\n    }\n    // edge['value'] = gEdge.attributes != null ? gEdge.attributes.Weight : undefined;\n    // edge['width'] = edge['value'] != null ? undefined : edgegEdge.size;\n    if (gEdge.color && options.edges.inheritColor === false) {\n      vEdge.color = gEdge.color;\n    }\n    return vEdge;\n  });\n  var vNodes = _mapInstanceProperty(_context = gephiJSON.nodes).call(_context, function (gNode) {\n    var vNode = {\n      id: gNode.id,\n      fixed: options.nodes.fixed && gNode.x != null && gNode.y != null\n    };\n    if (gNode.attributes != null) {\n      vNode.attributes = gNode.attributes;\n    }\n    if (gNode.label != null) {\n      vNode.label = gNode.label;\n    }\n    if (gNode.size != null) {\n      vNode.size = gNode.size;\n    }\n    if (gNode.attributes != null && gNode.attributes.title != null) {\n      vNode.title = gNode.attributes.title;\n    }\n    if (gNode.title != null) {\n      vNode.title = gNode.title;\n    }\n    if (gNode.x != null) {\n      vNode.x = gNode.x;\n    }\n    if (gNode.y != null) {\n      vNode.y = gNode.y;\n    }\n    if (gNode.color != null) {\n      if (options.nodes.parseColor === true) {\n        vNode.color = gNode.color;\n      } else {\n        vNode.color = {\n          background: gNode.color,\n          border: gNode.color,\n          highlight: {\n            background: gNode.color,\n            border: gNode.color\n          },\n          hover: {\n            background: gNode.color,\n            border: gNode.color\n          }\n        };\n      }\n    }\n    return vNode;\n  });\n  return {\n    nodes: vNodes,\n    edges: vEdges\n  };\n}\n\nvar gephiParser = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tparseGephi: parseGephi\n});\n\n// English\nvar en = {\n  addDescription: \"Click in an empty space to place a new node.\",\n  addEdge: \"Add Edge\",\n  addNode: \"Add Node\",\n  back: \"Back\",\n  close: \"Close\",\n  createEdgeError: \"Cannot link edges to a cluster.\",\n  del: \"Delete selected\",\n  deleteClusterError: \"Clusters cannot be deleted.\",\n  edgeDescription: \"Click on a node and drag the edge to another node to connect them.\",\n  edit: \"Edit\",\n  editClusterError: \"Clusters cannot be edited.\",\n  editEdge: \"Edit Edge\",\n  editEdgeDescription: \"Click on the control points and drag them to a node to connect to it.\",\n  editNode: \"Edit Node\"\n};\n// German\nvar de = {\n  addDescription: \"Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.\",\n  addEdge: \"Kante hinzuf\\xFCgen\",\n  addNode: \"Knoten hinzuf\\xFCgen\",\n  back: \"Zur\\xFCck\",\n  close: \"SchlieÃen\",\n  createEdgeError: \"Es ist nicht m\\xF6glich, Kanten mit Clustern zu verbinden.\",\n  del: \"L\\xF6sche Auswahl\",\n  deleteClusterError: \"Cluster k\\xF6nnen nicht gel\\xF6scht werden.\",\n  edgeDescription: \"Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.\",\n  edit: \"Editieren\",\n  editClusterError: \"Cluster k\\xF6nnen nicht editiert werden.\",\n  editEdge: \"Kante editieren\",\n  editEdgeDescription: \"Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.\",\n  editNode: \"Knoten editieren\"\n};\n// Spanish\nvar es = {\n  addDescription: \"Haga clic en un lugar vac\\xEDo para colocar un nuevo nodo.\",\n  addEdge: \"A\\xF1adir arista\",\n  addNode: \"A\\xF1adir nodo\",\n  back: \"Atr\\xE1s\",\n  close: \"Cerrar\",\n  createEdgeError: \"No se puede conectar una arista a un grupo.\",\n  del: \"Eliminar selecci\\xF3n\",\n  deleteClusterError: \"No es posible eliminar grupos.\",\n  edgeDescription: \"Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.\",\n  edit: \"Editar\",\n  editClusterError: \"No es posible editar grupos.\",\n  editEdge: \"Editar arista\",\n  editEdgeDescription: \"Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.\",\n  editNode: \"Editar nodo\"\n};\n//Italiano\nvar it = {\n  addDescription: \"Clicca per aggiungere un nuovo nodo\",\n  addEdge: \"Aggiungi un vertice\",\n  addNode: \"Aggiungi un nodo\",\n  back: \"Indietro\",\n  close: \"Chiudere\",\n  createEdgeError: \"Non si possono collegare vertici ad un cluster\",\n  del: \"Cancella la selezione\",\n  deleteClusterError: \"I cluster non possono essere cancellati\",\n  edgeDescription: \"Clicca su un nodo e trascinalo ad un altro nodo per connetterli.\",\n  edit: \"Modifica\",\n  editClusterError: \"I clusters non possono essere modificati.\",\n  editEdge: \"Modifica il vertice\",\n  editEdgeDescription: \"Clicca sui Punti di controllo e trascinali ad un nodo per connetterli.\",\n  editNode: \"Modifica il nodo\"\n};\n// Dutch\nvar nl = {\n  addDescription: \"Klik op een leeg gebied om een nieuwe node te maken.\",\n  addEdge: \"Link toevoegen\",\n  addNode: \"Node toevoegen\",\n  back: \"Terug\",\n  close: \"Sluiten\",\n  createEdgeError: \"Kan geen link maken naar een cluster.\",\n  del: \"Selectie verwijderen\",\n  deleteClusterError: \"Clusters kunnen niet worden verwijderd.\",\n  edgeDescription: \"Klik op een node en sleep de link naar een andere node om ze te verbinden.\",\n  edit: \"Wijzigen\",\n  editClusterError: \"Clusters kunnen niet worden aangepast.\",\n  editEdge: \"Link wijzigen\",\n  editEdgeDescription: \"Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.\",\n  editNode: \"Node wijzigen\"\n};\n// Portuguese Brazil\nvar pt = {\n  addDescription: \"Clique em um espaÃ§o em branco para adicionar um novo nÃ³\",\n  addEdge: \"Adicionar aresta\",\n  addNode: \"Adicionar nÃ³\",\n  back: \"Voltar\",\n  close: \"Fechar\",\n  createEdgeError: \"NÃ£o foi possÃ­vel linkar arestas a um cluster.\",\n  del: \"Remover selecionado\",\n  deleteClusterError: \"Clusters nÃ£o puderam ser removidos.\",\n  edgeDescription: \"Clique em um nÃ³ e arraste a aresta atÃ© outro nÃ³ para conectÃ¡-los\",\n  edit: \"Editar\",\n  editClusterError: \"Clusters nÃ£o puderam ser editados.\",\n  editEdge: \"Editar aresta\",\n  editEdgeDescription: \"Clique nos pontos de controle e os arraste para um nÃ³ para conectÃ¡-los\",\n  editNode: \"Editar nÃ³\"\n};\n// Russian\nvar ru = {\n  addDescription: \"ÐÐ»Ð¸ÐºÐ½Ð¸ÑÐµ Ð² ÑÐ²Ð¾Ð±Ð¾Ð´Ð½Ð¾Ðµ Ð¼ÐµÑÑÐ¾, ÑÑÐ¾Ð±Ñ Ð´Ð¾Ð±Ð°Ð²Ð¸ÑÑ Ð½Ð¾Ð²ÑÐ¹ ÑÐ·ÐµÐ».\",\n  addEdge: \"ÐÐ¾Ð±Ð°Ð²Ð¸ÑÑ ÑÐµÐ±ÑÐ¾\",\n  addNode: \"ÐÐ¾Ð±Ð°Ð²Ð¸ÑÑ ÑÐ·ÐµÐ»\",\n  back: \"ÐÐ°Ð·Ð°Ð´\",\n  close: \"ÐÐ°ÐºÑÑÐ²Ð°ÑÑ\",\n  createEdgeError: \"ÐÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾ÐµÐ´Ð¸Ð½Ð¸ÑÑ ÑÐµÐ±ÑÐ° Ð² ÐºÐ»Ð°ÑÑÐµÑ.\",\n  del: \"Ð£Ð´Ð°Ð»Ð¸ÑÑ Ð²ÑÐ±ÑÐ°Ð½Ð½Ð¾Ðµ\",\n  deleteClusterError: \"ÐÐ»Ð°ÑÑÐµÑÑ Ð½Ðµ Ð¼Ð¾Ð³ÑÑ Ð±ÑÑÑ ÑÐ´Ð°Ð»ÐµÐ½Ñ\",\n  edgeDescription: \"ÐÐ»Ð¸ÐºÐ½Ð¸ÑÐµ Ð½Ð° ÑÐ·ÐµÐ» Ð¸ Ð¿ÑÐ¾ÑÑÐ½Ð¸ÑÐµ ÑÐµÐ±ÑÐ¾ Ðº Ð´ÑÑÐ³Ð¾Ð¼Ñ ÑÐ·Ð»Ñ, ÑÑÐ¾Ð±Ñ ÑÐ¾ÐµÐ´Ð¸Ð½Ð¸ÑÑ Ð¸Ñ.\",\n  edit: \"Ð ÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°ÑÑ\",\n  editClusterError: \"ÐÐ»Ð°ÑÑÐµÑÑ Ð½ÐµÐ´Ð¾ÑÑÑÐ¿Ð½Ñ Ð´Ð»Ñ ÑÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ.\",\n  editEdge: \"Ð ÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÑÐµÐ±ÑÐ¾\",\n  editEdgeDescription: \"ÐÐ»Ð¸ÐºÐ½Ð¸ÑÐµ Ð½Ð° ÐºÐ¾Ð½ÑÑÐ¾Ð»ÑÐ½ÑÐµ ÑÐ¾ÑÐºÐ¸ Ð¸ Ð¿ÐµÑÐµÑÐ°ÑÐ¸ÑÐµ Ð¸Ñ Ð² ÑÐ·ÐµÐ», ÑÑÐ¾Ð±Ñ Ð¿Ð¾Ð´ÐºÐ»ÑÑÐ¸ÑÑÑÑ Ðº Ð½ÐµÐ¼Ñ.\",\n  editNode: \"Ð ÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÑÐ·ÐµÐ»\"\n};\n// Chinese\nvar cn = {\n  addDescription: \"åå»ç©ºç½å¤æ¾ç½®æ°èç¹ã\",\n  addEdge: \"æ·»å è¿æ¥çº¿\",\n  addNode: \"æ·»å èç¹\",\n  back: \"è¿å\",\n  close: \"éé\",\n  createEdgeError: \"æ æ³å°è¿æ¥çº¿è¿æ¥å°ç¾¤éã\",\n  del: \"å é¤éå®\",\n  deleteClusterError: \"æ æ³å é¤ç¾¤éã\",\n  edgeDescription: \"åå»æä¸ªèç¹å¹¶å°è¯¥è¿æ¥çº¿æå¨å°å¦ä¸ä¸ªèç¹ä»¥è¿æ¥å®ä»¬ã\",\n  edit: \"ç¼è¾\",\n  editClusterError: \"æ æ³ç¼è¾ç¾¤éã\",\n  editEdge: \"ç¼è¾è¿æ¥çº¿\",\n  editEdgeDescription: \"åå»æ§å¶èç¹å¹¶å°å®ä»¬æå°èç¹ä¸è¿æ¥ã\",\n  editNode: \"ç¼è¾èç¹\"\n};\n// Ukrainian\nvar uk = {\n  addDescription: \"KÐ»ÑÐºÐ½ÑÑÑ Ð½Ð° Ð²ÑÐ»ÑÐ½Ðµ Ð¼ÑÑÑÐµ, ÑÐ¾Ð± Ð´Ð¾Ð´Ð°ÑÐ¸ Ð½Ð¾Ð²Ð¸Ð¹ Ð²ÑÐ·Ð¾Ð».\",\n  addEdge: \"ÐÐ¾Ð´Ð°ÑÐ¸ ÐºÑÐ°Ð¹\",\n  addNode: \"ÐÐ¾Ð´Ð°ÑÐ¸ Ð²ÑÐ·Ð¾Ð»\",\n  back: \"ÐÐ°Ð·Ð°Ð´\",\n  close: \"ÐÐ°ÐºÑÐ¸ÑÐ¸\",\n  createEdgeError: \"ÐÐµ Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ Ð¾Ð±'ÑÐ´Ð½Ð°ÑÐ¸ ÐºÑÐ°Ñ Ð² Ð³ÑÑÐ¿Ñ.\",\n  del: \"ÐÐ¸Ð´Ð°Ð»Ð¸ÑÐ¸ Ð¾Ð±ÑÐ°Ð½Ðµ\",\n  deleteClusterError: \"ÐÑÑÐ¿Ð¸ Ð½Ðµ Ð¼Ð¾Ð¶ÑÑÑ Ð±ÑÑÐ¸ Ð²Ð¸Ð´Ð°Ð»ÐµÐ½Ñ.\",\n  edgeDescription: \"ÐÐ»ÑÐºÐ½ÑÑÑ Ð½Ð° Ð²ÑÐ·Ð¾Ð» Ñ Ð¿ÐµÑÐµÑÑÐ³Ð½ÑÑÑ ÐºÑÐ°Ð¹ Ð´Ð¾ ÑÐ½ÑÐ¾Ð³Ð¾ Ð²ÑÐ·Ð»Ð°, ÑÐ¾Ð± ÑÑ Ð·'ÑÐ´Ð½Ð°ÑÐ¸.\",\n  edit: \"Ð ÐµÐ´Ð°Ð³ÑÐ²Ð°ÑÐ¸\",\n  editClusterError: \"ÐÑÑÐ¿Ð¸ Ð½ÐµÐ´Ð¾ÑÑÑÐ¿Ð½Ñ Ð´Ð»Ñ ÑÐµÐ´Ð°Ð³ÑÐ²Ð°Ð½Ð½Ñ.\",\n  editEdge: \"Ð ÐµÐ´Ð°Ð³ÑÐ²Ð°ÑÐ¸ ÐºÑÐ°Ð¹\",\n  editEdgeDescription: \"ÐÐ»ÑÐºÐ½ÑÑÑ Ð½Ð° ÐºÐ¾Ð½ÑÑÐ¾Ð»ÑÐ½Ñ ÑÐ¾ÑÐºÐ¸ Ñ Ð¿ÐµÑÐµÑÑÐ³Ð½ÑÑÑ ÑÑ Ñ Ð²ÑÐ·Ð¾Ð», ÑÐ¾Ð± Ð¿ÑÐ´ÐºÐ»ÑÑÐ¸ÑÐ¸ÑÑ Ð´Ð¾ Ð½ÑÐ¾Ð³Ð¾.\",\n  editNode: \"Ð ÐµÐ´Ð°Ð³ÑÐ²Ð°ÑÐ¸ Ð²ÑÐ·Ð¾Ð»\"\n};\n// French\nvar fr = {\n  addDescription: \"Cliquez dans un endroit vide pour placer un nÅud.\",\n  addEdge: \"Ajouter un lien\",\n  addNode: \"Ajouter un nÅud\",\n  back: \"Retour\",\n  close: \"Fermer\",\n  createEdgeError: \"Impossible de crÃ©er un lien vers un cluster.\",\n  del: \"Effacer la sÃ©lection\",\n  deleteClusterError: \"Les clusters ne peuvent pas Ãªtre effacÃ©s.\",\n  edgeDescription: \"Cliquez sur un nÅud et glissez le lien vers un autre nÅud pour les connecter.\",\n  edit: \"Ãditer\",\n  editClusterError: \"Les clusters ne peuvent pas Ãªtre Ã©ditÃ©s.\",\n  editEdge: \"Ãditer le lien\",\n  editEdgeDescription: \"Cliquez sur les points de contrÃ´le et glissez-les pour connecter un nÅud.\",\n  editNode: \"Ãditer le nÅud\"\n};\n// Czech\nvar cs = {\n  addDescription: \"KluknutÃ­m do prÃ¡zdnÃ©ho prostoru mÅ¯Å¾ete pÅidat novÃ½ vrchol.\",\n  addEdge: \"PÅidat hranu\",\n  addNode: \"PÅidat vrchol\",\n  back: \"ZpÄt\",\n  close: \"ZavÅÃ­t\",\n  createEdgeError: \"Nelze pÅipojit hranu ke shluku.\",\n  del: \"Smazat vÃ½bÄr\",\n  deleteClusterError: \"Nelze mazat shluky.\",\n  edgeDescription: \"PÅetaÅ¾enÃ­m z jednoho vrcholu do druhÃ©ho mÅ¯Å¾ete spojit tyto vrcholy novou hranou.\",\n  edit: \"Upravit\",\n  editClusterError: \"Nelze upravovat shluky.\",\n  editEdge: \"Upravit hranu\",\n  editEdgeDescription: \"PÅetaÅ¾enÃ­m kontrolnÃ­ho vrcholu hrany ji mÅ¯Å¾ete pÅipojit k jinÃ©mu vrcholu.\",\n  editNode: \"Upravit vrchol\"\n};\n\nvar locales = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tcn: cn,\n\tcs: cs,\n\tde: de,\n\ten: en,\n\tes: es,\n\tfr: fr,\n\tit: it,\n\tnl: nl,\n\tpt: pt,\n\tru: ru,\n\tuk: uk\n});\n\n/**\r\n * Normalizes language code into the format used internally.\r\n *\r\n * @param locales - All the available locales.\r\n * @param rawCode - The original code as supplied by the user.\r\n * @returns Language code in the format language-COUNTRY or language, eventually\r\n * fallbacks to en.\r\n */\nfunction normalizeLanguageCode(locales, rawCode) {\n  try {\n    var _rawCode$split = rawCode.split(/[-_ /]/, 2),\n      _rawCode$split2 = _slicedToArray(_rawCode$split, 2),\n      rawLanguage = _rawCode$split2[0],\n      rawCountry = _rawCode$split2[1];\n    var language = rawLanguage != null ? rawLanguage.toLowerCase() : null;\n    var country = rawCountry != null ? rawCountry.toUpperCase() : null;\n    if (language && country) {\n      var code = language + \"-\" + country;\n      if (Object.prototype.hasOwnProperty.call(locales, code)) {\n        return code;\n      } else {\n        var _context;\n        console.warn(_concatInstanceProperty(_context = \"Unknown variant \".concat(country, \" of language \")).call(_context, language, \".\"));\n      }\n    }\n    if (language) {\n      var _code = language;\n      if (Object.prototype.hasOwnProperty.call(locales, _code)) {\n        return _code;\n      } else {\n        console.warn(\"Unknown language \".concat(language));\n      }\n    }\n    console.warn(\"Unknown locale \".concat(rawCode, \", falling back to English.\"));\n    return \"en\";\n  } catch (error) {\n    console.error(error);\n    console.warn(\"Unexpected error while normalizing locale \".concat(rawCode, \", falling back to English.\"));\n    return \"en\";\n  }\n}\n\n/**\n * Associates a canvas to a given image, containing a number of renderings\n * of the image at various sizes.\n *\n * This technique is known as 'mipmapping'.\n *\n * NOTE: Images can also be of type 'data:svg+xml`. This code also works\n *       for svg, but the mipmapping may not be necessary.\n *\n * @param {Image} image\n */\nvar CachedImage = /*#__PURE__*/function () {\n  /**\n   * @ignore\n   */\n  function CachedImage() {\n    _classCallCheck(this, CachedImage);\n    this.NUM_ITERATIONS = 4; // Number of items in the coordinates array\n\n    this.image = new Image();\n    this.canvas = document.createElement(\"canvas\");\n  }\n\n  /**\n   * Called when the image has been successfully loaded.\n   */\n  _createClass(CachedImage, [{\n    key: \"init\",\n    value: function init() {\n      if (this.initialized()) return;\n      this.src = this.image.src; // For same interface with Image\n      var w = this.image.width;\n      var h = this.image.height;\n\n      // Ease external access\n      this.width = w;\n      this.height = h;\n      var h2 = Math.floor(h / 2);\n      var h4 = Math.floor(h / 4);\n      var h8 = Math.floor(h / 8);\n      var h16 = Math.floor(h / 16);\n      var w2 = Math.floor(w / 2);\n      var w4 = Math.floor(w / 4);\n      var w8 = Math.floor(w / 8);\n      var w16 = Math.floor(w / 16);\n\n      // Make canvas as small as possible\n      this.canvas.width = 3 * w4;\n      this.canvas.height = h2;\n\n      // Coordinates and sizes of images contained in the canvas\n      // Values per row:  [top x, left y, width, height]\n\n      this.coordinates = [[0, 0, w2, h2], [w2, 0, w4, h4], [w2, h4, w8, h8], [5 * w8, h4, w16, h16]];\n      this._fillMipMap();\n    }\n\n    /**\n     * @returns {boolean} true if init() has been called, false otherwise.\n     */\n  }, {\n    key: \"initialized\",\n    value: function initialized() {\n      return this.coordinates !== undefined;\n    }\n\n    /**\n     * Redraw main image in various sizes to the context.\n     *\n     * The rationale behind this is to reduce artefacts due to interpolation\n     * at differing zoom levels.\n     *\n     * Source: http://stackoverflow.com/q/18761404/1223531\n     *\n     * This methods takes the resizing out of the drawing loop, in order to\n     * reduce performance overhead.\n     *\n     * TODO: The code assumes that a 2D context can always be gotten. This is\n     *       not necessarily true! OTOH, if not true then usage of this class\n     *       is senseless.\n     *\n     * @private\n     */\n  }, {\n    key: \"_fillMipMap\",\n    value: function _fillMipMap() {\n      var ctx = this.canvas.getContext(\"2d\");\n\n      // First zoom-level comes from the image\n      var to = this.coordinates[0];\n      ctx.drawImage(this.image, to[0], to[1], to[2], to[3]);\n\n      // The rest are copy actions internal to the canvas/context\n      for (var iterations = 1; iterations < this.NUM_ITERATIONS; iterations++) {\n        var from = this.coordinates[iterations - 1];\n        var _to = this.coordinates[iterations];\n        ctx.drawImage(this.canvas, from[0], from[1], from[2], from[3], _to[0], _to[1], _to[2], _to[3]);\n      }\n    }\n\n    /**\n     * Draw the image, using the mipmap if necessary.\n     *\n     * MipMap is only used if param factor > 2; otherwise, original bitmap\n     * is resized. This is also used to skip mipmap usage, e.g. by setting factor = 1\n     *\n     * Credits to 'Alex de Mulder' for original implementation.\n     *\n     * @param {CanvasRenderingContext2D} ctx  context on which to draw zoomed image\n     * @param {Float} factor scale factor at which to draw\n     * @param {number} left\n     * @param {number} top\n     * @param {number} width\n     * @param {number} height\n     */\n  }, {\n    key: \"drawImageAtPosition\",\n    value: function drawImageAtPosition(ctx, factor, left, top, width, height) {\n      if (!this.initialized()) return; //can't draw image yet not intialized\n\n      if (factor > 2) {\n        // Determine which zoomed image to use\n        factor *= 0.5;\n        var iterations = 0;\n        while (factor > 2 && iterations < this.NUM_ITERATIONS) {\n          factor *= 0.5;\n          iterations += 1;\n        }\n        if (iterations >= this.NUM_ITERATIONS) {\n          iterations = this.NUM_ITERATIONS - 1;\n        }\n        //console.log(\"iterations: \" + iterations);\n\n        var from = this.coordinates[iterations];\n        ctx.drawImage(this.canvas, from[0], from[1], from[2], from[3], left, top, width, height);\n      } else {\n        // Draw image directly\n        ctx.drawImage(this.image, left, top, width, height);\n      }\n    }\n  }]);\n  return CachedImage;\n}();\n\n/**\n * This callback is a callback that accepts an Image.\n *\n * @callback ImageCallback\n * @param {Image} image\n */\n\n/**\n * This class loads images and keeps them stored.\n *\n * @param {ImageCallback} callback\n */\nvar Images = /*#__PURE__*/function () {\n  /**\n   * @param {ImageCallback} callback\n   */\n  function Images(callback) {\n    _classCallCheck(this, Images);\n    this.images = {};\n    this.imageBroken = {};\n    this.callback = callback;\n  }\n\n  /**\n   * @param {string} url                      The original Url that failed to load, if the broken image is successfully loaded it will be added to the cache using this Url as the key so that subsequent requests for this Url will return the broken image\n   * @param {string} brokenUrl                Url the broken image to try and load\n   * @param {Image} imageToLoadBrokenUrlOn   The image object\n   */\n  _createClass(Images, [{\n    key: \"_tryloadBrokenUrl\",\n    value: function _tryloadBrokenUrl(url, brokenUrl, imageToLoadBrokenUrlOn) {\n      //If these parameters aren't specified then exit the function because nothing constructive can be done\n      if (url === undefined || imageToLoadBrokenUrlOn === undefined) return;\n      if (brokenUrl === undefined) {\n        console.warn(\"No broken url image defined\");\n        return;\n      }\n\n      //Clear the old subscription to the error event and put a new in place that only handle errors in loading the brokenImageUrl\n      imageToLoadBrokenUrlOn.image.onerror = function () {\n        console.error(\"Could not load brokenImage:\", brokenUrl);\n        // cache item will contain empty image, this should be OK for default\n      };\n\n      //Set the source of the image to the brokenUrl, this is actually what kicks off the loading of the broken image\n      imageToLoadBrokenUrlOn.image.src = brokenUrl;\n    }\n\n    /**\n     *\n     * @param {vis.Image} imageToRedrawWith\n     * @private\n     */\n  }, {\n    key: \"_redrawWithImage\",\n    value: function _redrawWithImage(imageToRedrawWith) {\n      if (this.callback) {\n        this.callback(imageToRedrawWith);\n      }\n    }\n\n    /**\n     * @param {string} url          Url of the image\n     * @param {string} brokenUrl    Url of an image to use if the url image is not found\n     * @returns {Image} img          The image object\n     */\n  }, {\n    key: \"load\",\n    value: function load(url, brokenUrl) {\n      var _this = this;\n      //Try and get the image from the cache, if successful then return the cached image\n      var cachedImage = this.images[url];\n      if (cachedImage) return cachedImage;\n\n      //Create a new image\n      var img = new CachedImage();\n\n      // Need to add to cache here, otherwise final return will spawn different copies of the same image,\n      // Also, there will be multiple loads of the same image.\n      this.images[url] = img;\n\n      //Subscribe to the event that is raised if the image loads successfully\n      img.image.onload = function () {\n        // Properly init the cached item and then request a redraw\n        _this._fixImageCoordinates(img.image);\n        img.init();\n        _this._redrawWithImage(img);\n      };\n\n      //Subscribe to the event that is raised if the image fails to load\n      img.image.onerror = function () {\n        console.error(\"Could not load image:\", url);\n        //Try and load the image specified by the brokenUrl using\n        _this._tryloadBrokenUrl(url, brokenUrl, img);\n      };\n\n      //Set the source of the image to the url, this is what actually kicks off the loading of the image\n      img.image.src = url;\n\n      //Return the new image\n      return img;\n    }\n\n    /**\n     * IE11 fix -- thanks dponch!\n     *\n     * Local helper function\n     *\n     * @param {vis.Image} imageToCache\n     * @private\n     */\n  }, {\n    key: \"_fixImageCoordinates\",\n    value: function _fixImageCoordinates(imageToCache) {\n      if (imageToCache.width === 0) {\n        document.body.appendChild(imageToCache);\n        imageToCache.width = imageToCache.offsetWidth;\n        imageToCache.height = imageToCache.offsetHeight;\n        document.body.removeChild(imageToCache);\n      }\n    }\n  }]);\n  return Images;\n}();\n\nvar internalMetadata = {exports: {}};\n\n// FF26- bug: ArrayBuffers are non-extensible, but Object.isExtensible does not report it\nvar fails$9 = fails$w;\n\nvar arrayBufferNonExtensible = fails$9(function () {\n  if (typeof ArrayBuffer == 'function') {\n    var buffer = new ArrayBuffer(8);\n    // eslint-disable-next-line es/no-object-isextensible, es/no-object-defineproperty -- safe\n    if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', { value: 8 });\n  }\n});\n\nvar fails$8 = fails$w;\nvar isObject$6 = isObject$j;\nvar classof$2 = classofRaw$2;\nvar ARRAY_BUFFER_NON_EXTENSIBLE = arrayBufferNonExtensible;\n\n// eslint-disable-next-line es/no-object-isextensible -- safe\nvar $isExtensible = Object.isExtensible;\nvar FAILS_ON_PRIMITIVES$1 = fails$8(function () { $isExtensible(1); });\n\n// `Object.isExtensible` method\n// https://tc39.es/ecma262/#sec-object.isextensible\nvar objectIsExtensible = (FAILS_ON_PRIMITIVES$1 || ARRAY_BUFFER_NON_EXTENSIBLE) ? function isExtensible(it) {\n  if (!isObject$6(it)) return false;\n  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof$2(it) === 'ArrayBuffer') return false;\n  return $isExtensible ? $isExtensible(it) : true;\n} : $isExtensible;\n\nvar fails$7 = fails$w;\n\nvar freezing = !fails$7(function () {\n  // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing\n  return Object.isExtensible(Object.preventExtensions({}));\n});\n\nvar $$g = _export;\nvar uncurryThis$4 = functionUncurryThis;\nvar hiddenKeys = hiddenKeys$6;\nvar isObject$5 = isObject$j;\nvar hasOwn$3 = hasOwnProperty_1;\nvar defineProperty$2 = objectDefineProperty.f;\nvar getOwnPropertyNamesModule = objectGetOwnPropertyNames;\nvar getOwnPropertyNamesExternalModule = objectGetOwnPropertyNamesExternal;\nvar isExtensible$1 = objectIsExtensible;\nvar uid = uid$4;\nvar FREEZING$1 = freezing;\n\nvar REQUIRED = false;\nvar METADATA = uid('meta');\nvar id$1 = 0;\n\nvar setMetadata = function (it) {\n  defineProperty$2(it, METADATA, { value: {\n    objectID: 'O' + id$1++, // object ID\n    weakData: {}          // weak collections IDs\n  } });\n};\n\nvar fastKey$1 = function (it, create) {\n  // return a primitive with prefix\n  if (!isObject$5(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if (!hasOwn$3(it, METADATA)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible$1(it)) return 'F';\n    // not necessary to add metadata\n    if (!create) return 'E';\n    // add missing metadata\n    setMetadata(it);\n  // return object ID\n  } return it[METADATA].objectID;\n};\n\nvar getWeakData$1 = function (it, create) {\n  if (!hasOwn$3(it, METADATA)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible$1(it)) return true;\n    // not necessary to add metadata\n    if (!create) return false;\n    // add missing metadata\n    setMetadata(it);\n  // return the store of weak collections IDs\n  } return it[METADATA].weakData;\n};\n\n// add metadata on freeze-family methods calling\nvar onFreeze = function (it) {\n  if (FREEZING$1 && REQUIRED && isExtensible$1(it) && !hasOwn$3(it, METADATA)) setMetadata(it);\n  return it;\n};\n\nvar enable = function () {\n  meta.enable = function () { /* empty */ };\n  REQUIRED = true;\n  var getOwnPropertyNames = getOwnPropertyNamesModule.f;\n  var splice = uncurryThis$4([].splice);\n  var test = {};\n  test[METADATA] = 1;\n\n  // prevent exposing of metadata key\n  if (getOwnPropertyNames(test).length) {\n    getOwnPropertyNamesModule.f = function (it) {\n      var result = getOwnPropertyNames(it);\n      for (var i = 0, length = result.length; i < length; i++) {\n        if (result[i] === METADATA) {\n          splice(result, i, 1);\n          break;\n        }\n      } return result;\n    };\n\n    $$g({ target: 'Object', stat: true, forced: true }, {\n      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f\n    });\n  }\n};\n\nvar meta = internalMetadata.exports = {\n  enable: enable,\n  fastKey: fastKey$1,\n  getWeakData: getWeakData$1,\n  onFreeze: onFreeze\n};\n\nhiddenKeys[METADATA] = true;\n\nvar internalMetadataExports = internalMetadata.exports;\n\nvar bind$5 = functionBindContext;\nvar call$1 = functionCall;\nvar anObject$3 = anObject$d;\nvar tryToString$1 = tryToString$6;\nvar isArrayIteratorMethod = isArrayIteratorMethod$2;\nvar lengthOfArrayLike$2 = lengthOfArrayLike$c;\nvar isPrototypeOf$6 = objectIsPrototypeOf;\nvar getIterator = getIterator$2;\nvar getIteratorMethod = getIteratorMethod$9;\nvar iteratorClose = iteratorClose$2;\n\nvar $TypeError$3 = TypeError;\n\nvar Result = function (stopped, result) {\n  this.stopped = stopped;\n  this.result = result;\n};\n\nvar ResultPrototype = Result.prototype;\n\nvar iterate$3 = function (iterable, unboundFunction, options) {\n  var that = options && options.that;\n  var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n  var IS_RECORD = !!(options && options.IS_RECORD);\n  var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n  var INTERRUPTED = !!(options && options.INTERRUPTED);\n  var fn = bind$5(unboundFunction, that);\n  var iterator, iterFn, index, length, result, next, step;\n\n  var stop = function (condition) {\n    if (iterator) iteratorClose(iterator, 'normal', condition);\n    return new Result(true, condition);\n  };\n\n  var callFn = function (value) {\n    if (AS_ENTRIES) {\n      anObject$3(value);\n      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n    } return INTERRUPTED ? fn(value, stop) : fn(value);\n  };\n\n  if (IS_RECORD) {\n    iterator = iterable.iterator;\n  } else if (IS_ITERATOR) {\n    iterator = iterable;\n  } else {\n    iterFn = getIteratorMethod(iterable);\n    if (!iterFn) throw new $TypeError$3(tryToString$1(iterable) + ' is not iterable');\n    // optimisation for array iterators\n    if (isArrayIteratorMethod(iterFn)) {\n      for (index = 0, length = lengthOfArrayLike$2(iterable); length > index; index++) {\n        result = callFn(iterable[index]);\n        if (result && isPrototypeOf$6(ResultPrototype, result)) return result;\n      } return new Result(false);\n    }\n    iterator = getIterator(iterable, iterFn);\n  }\n\n  next = IS_RECORD ? iterable.next : iterator.next;\n  while (!(step = call$1(next, iterator)).done) {\n    try {\n      result = callFn(step.value);\n    } catch (error) {\n      iteratorClose(iterator, 'throw', error);\n    }\n    if (typeof result == 'object' && result && isPrototypeOf$6(ResultPrototype, result)) return result;\n  } return new Result(false);\n};\n\nvar isPrototypeOf$5 = objectIsPrototypeOf;\n\nvar $TypeError$2 = TypeError;\n\nvar anInstance$3 = function (it, Prototype) {\n  if (isPrototypeOf$5(Prototype, it)) return it;\n  throw new $TypeError$2('Incorrect invocation');\n};\n\nvar $$f = _export;\nvar global$5 = global$n;\nvar InternalMetadataModule$1 = internalMetadataExports;\nvar fails$6 = fails$w;\nvar createNonEnumerableProperty = createNonEnumerableProperty$6;\nvar iterate$2 = iterate$3;\nvar anInstance$2 = anInstance$3;\nvar isCallable = isCallable$i;\nvar isObject$4 = isObject$j;\nvar isNullOrUndefined$2 = isNullOrUndefined$6;\nvar setToStringTag = setToStringTag$6;\nvar defineProperty$1 = objectDefineProperty.f;\nvar forEach = arrayIteration.forEach;\nvar DESCRIPTORS$5 = descriptors;\nvar InternalStateModule$2 = internalState;\n\nvar setInternalState$2 = InternalStateModule$2.set;\nvar internalStateGetterFor$2 = InternalStateModule$2.getterFor;\n\nvar collection$3 = function (CONSTRUCTOR_NAME, wrapper, common) {\n  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;\n  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;\n  var ADDER = IS_MAP ? 'set' : 'add';\n  var NativeConstructor = global$5[CONSTRUCTOR_NAME];\n  var NativePrototype = NativeConstructor && NativeConstructor.prototype;\n  var exported = {};\n  var Constructor;\n\n  if (!DESCRIPTORS$5 || !isCallable(NativeConstructor)\n    || !(IS_WEAK || NativePrototype.forEach && !fails$6(function () { new NativeConstructor().entries().next(); }))\n  ) {\n    // create collection constructor\n    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);\n    InternalMetadataModule$1.enable();\n  } else {\n    Constructor = wrapper(function (target, iterable) {\n      setInternalState$2(anInstance$2(target, Prototype), {\n        type: CONSTRUCTOR_NAME,\n        collection: new NativeConstructor()\n      });\n      if (!isNullOrUndefined$2(iterable)) iterate$2(iterable, target[ADDER], { that: target, AS_ENTRIES: IS_MAP });\n    });\n\n    var Prototype = Constructor.prototype;\n\n    var getInternalState = internalStateGetterFor$2(CONSTRUCTOR_NAME);\n\n    forEach(['add', 'clear', 'delete', 'forEach', 'get', 'has', 'set', 'keys', 'values', 'entries'], function (KEY) {\n      var IS_ADDER = KEY === 'add' || KEY === 'set';\n      if (KEY in NativePrototype && !(IS_WEAK && KEY === 'clear')) {\n        createNonEnumerableProperty(Prototype, KEY, function (a, b) {\n          var collection = getInternalState(this).collection;\n          if (!IS_ADDER && IS_WEAK && !isObject$4(a)) return KEY === 'get' ? undefined : false;\n          var result = collection[KEY](a === 0 ? 0 : a, b);\n          return IS_ADDER ? this : result;\n        });\n      }\n    });\n\n    IS_WEAK || defineProperty$1(Prototype, 'size', {\n      configurable: true,\n      get: function () {\n        return getInternalState(this).collection.size;\n      }\n    });\n  }\n\n  setToStringTag(Constructor, CONSTRUCTOR_NAME, false, true);\n\n  exported[CONSTRUCTOR_NAME] = Constructor;\n  $$f({ global: true, forced: true }, exported);\n\n  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);\n\n  return Constructor;\n};\n\nvar defineBuiltIn = defineBuiltIn$5;\n\nvar defineBuiltIns$3 = function (target, src, options) {\n  for (var key in src) {\n    if (options && options.unsafe && target[key]) target[key] = src[key];\n    else defineBuiltIn(target, key, src[key], options);\n  } return target;\n};\n\nvar getBuiltIn$1 = getBuiltIn$c;\nvar defineBuiltInAccessor$1 = defineBuiltInAccessor$3;\nvar wellKnownSymbol = wellKnownSymbol$m;\nvar DESCRIPTORS$4 = descriptors;\n\nvar SPECIES = wellKnownSymbol('species');\n\nvar setSpecies$1 = function (CONSTRUCTOR_NAME) {\n  var Constructor = getBuiltIn$1(CONSTRUCTOR_NAME);\n\n  if (DESCRIPTORS$4 && Constructor && !Constructor[SPECIES]) {\n    defineBuiltInAccessor$1(Constructor, SPECIES, {\n      configurable: true,\n      get: function () { return this; }\n    });\n  }\n};\n\nvar create$4 = objectCreate;\nvar defineBuiltInAccessor = defineBuiltInAccessor$3;\nvar defineBuiltIns$2 = defineBuiltIns$3;\nvar bind$4 = functionBindContext;\nvar anInstance$1 = anInstance$3;\nvar isNullOrUndefined$1 = isNullOrUndefined$6;\nvar iterate$1 = iterate$3;\nvar defineIterator = iteratorDefine;\nvar createIterResultObject = createIterResultObject$3;\nvar setSpecies = setSpecies$1;\nvar DESCRIPTORS$3 = descriptors;\nvar fastKey = internalMetadataExports.fastKey;\nvar InternalStateModule$1 = internalState;\n\nvar setInternalState$1 = InternalStateModule$1.set;\nvar internalStateGetterFor$1 = InternalStateModule$1.getterFor;\n\nvar collectionStrong$2 = {\n  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {\n    var Constructor = wrapper(function (that, iterable) {\n      anInstance$1(that, Prototype);\n      setInternalState$1(that, {\n        type: CONSTRUCTOR_NAME,\n        index: create$4(null),\n        first: undefined,\n        last: undefined,\n        size: 0\n      });\n      if (!DESCRIPTORS$3) that.size = 0;\n      if (!isNullOrUndefined$1(iterable)) iterate$1(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });\n    });\n\n    var Prototype = Constructor.prototype;\n\n    var getInternalState = internalStateGetterFor$1(CONSTRUCTOR_NAME);\n\n    var define = function (that, key, value) {\n      var state = getInternalState(that);\n      var entry = getEntry(that, key);\n      var previous, index;\n      // change existing entry\n      if (entry) {\n        entry.value = value;\n      // create new entry\n      } else {\n        state.last = entry = {\n          index: index = fastKey(key, true),\n          key: key,\n          value: value,\n          previous: previous = state.last,\n          next: undefined,\n          removed: false\n        };\n        if (!state.first) state.first = entry;\n        if (previous) previous.next = entry;\n        if (DESCRIPTORS$3) state.size++;\n        else that.size++;\n        // add to index\n        if (index !== 'F') state.index[index] = entry;\n      } return that;\n    };\n\n    var getEntry = function (that, key) {\n      var state = getInternalState(that);\n      // fast case\n      var index = fastKey(key);\n      var entry;\n      if (index !== 'F') return state.index[index];\n      // frozen object case\n      for (entry = state.first; entry; entry = entry.next) {\n        if (entry.key === key) return entry;\n      }\n    };\n\n    defineBuiltIns$2(Prototype, {\n      // `{ Map, Set }.prototype.clear()` methods\n      // https://tc39.es/ecma262/#sec-map.prototype.clear\n      // https://tc39.es/ecma262/#sec-set.prototype.clear\n      clear: function clear() {\n        var that = this;\n        var state = getInternalState(that);\n        var data = state.index;\n        var entry = state.first;\n        while (entry) {\n          entry.removed = true;\n          if (entry.previous) entry.previous = entry.previous.next = undefined;\n          delete data[entry.index];\n          entry = entry.next;\n        }\n        state.first = state.last = undefined;\n        if (DESCRIPTORS$3) state.size = 0;\n        else that.size = 0;\n      },\n      // `{ Map, Set }.prototype.delete(key)` methods\n      // https://tc39.es/ecma262/#sec-map.prototype.delete\n      // https://tc39.es/ecma262/#sec-set.prototype.delete\n      'delete': function (key) {\n        var that = this;\n        var state = getInternalState(that);\n        var entry = getEntry(that, key);\n        if (entry) {\n          var next = entry.next;\n          var prev = entry.previous;\n          delete state.index[entry.index];\n          entry.removed = true;\n          if (prev) prev.next = next;\n          if (next) next.previous = prev;\n          if (state.first === entry) state.first = next;\n          if (state.last === entry) state.last = prev;\n          if (DESCRIPTORS$3) state.size--;\n          else that.size--;\n        } return !!entry;\n      },\n      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods\n      // https://tc39.es/ecma262/#sec-map.prototype.foreach\n      // https://tc39.es/ecma262/#sec-set.prototype.foreach\n      forEach: function forEach(callbackfn /* , that = undefined */) {\n        var state = getInternalState(this);\n        var boundFunction = bind$4(callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n        var entry;\n        while (entry = entry ? entry.next : state.first) {\n          boundFunction(entry.value, entry.key, this);\n          // revert to the last existing entry\n          while (entry && entry.removed) entry = entry.previous;\n        }\n      },\n      // `{ Map, Set}.prototype.has(key)` methods\n      // https://tc39.es/ecma262/#sec-map.prototype.has\n      // https://tc39.es/ecma262/#sec-set.prototype.has\n      has: function has(key) {\n        return !!getEntry(this, key);\n      }\n    });\n\n    defineBuiltIns$2(Prototype, IS_MAP ? {\n      // `Map.prototype.get(key)` method\n      // https://tc39.es/ecma262/#sec-map.prototype.get\n      get: function get(key) {\n        var entry = getEntry(this, key);\n        return entry && entry.value;\n      },\n      // `Map.prototype.set(key, value)` method\n      // https://tc39.es/ecma262/#sec-map.prototype.set\n      set: function set(key, value) {\n        return define(this, key === 0 ? 0 : key, value);\n      }\n    } : {\n      // `Set.prototype.add(value)` method\n      // https://tc39.es/ecma262/#sec-set.prototype.add\n      add: function add(value) {\n        return define(this, value = value === 0 ? 0 : value, value);\n      }\n    });\n    if (DESCRIPTORS$3) defineBuiltInAccessor(Prototype, 'size', {\n      configurable: true,\n      get: function () {\n        return getInternalState(this).size;\n      }\n    });\n    return Constructor;\n  },\n  setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {\n    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';\n    var getInternalCollectionState = internalStateGetterFor$1(CONSTRUCTOR_NAME);\n    var getInternalIteratorState = internalStateGetterFor$1(ITERATOR_NAME);\n    // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods\n    // https://tc39.es/ecma262/#sec-map.prototype.entries\n    // https://tc39.es/ecma262/#sec-map.prototype.keys\n    // https://tc39.es/ecma262/#sec-map.prototype.values\n    // https://tc39.es/ecma262/#sec-map.prototype-@@iterator\n    // https://tc39.es/ecma262/#sec-set.prototype.entries\n    // https://tc39.es/ecma262/#sec-set.prototype.keys\n    // https://tc39.es/ecma262/#sec-set.prototype.values\n    // https://tc39.es/ecma262/#sec-set.prototype-@@iterator\n    defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {\n      setInternalState$1(this, {\n        type: ITERATOR_NAME,\n        target: iterated,\n        state: getInternalCollectionState(iterated),\n        kind: kind,\n        last: undefined\n      });\n    }, function () {\n      var state = getInternalIteratorState(this);\n      var kind = state.kind;\n      var entry = state.last;\n      // revert to the last existing entry\n      while (entry && entry.removed) entry = entry.previous;\n      // get next entry\n      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {\n        // or finish the iteration\n        state.target = undefined;\n        return createIterResultObject(undefined, true);\n      }\n      // return step by kind\n      if (kind === 'keys') return createIterResultObject(entry.key, false);\n      if (kind === 'values') return createIterResultObject(entry.value, false);\n      return createIterResultObject([entry.key, entry.value], false);\n    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);\n\n    // `{ Map, Set }.prototype[@@species]` accessors\n    // https://tc39.es/ecma262/#sec-get-map-@@species\n    // https://tc39.es/ecma262/#sec-get-set-@@species\n    setSpecies(CONSTRUCTOR_NAME);\n  }\n};\n\nvar collection$2 = collection$3;\nvar collectionStrong$1 = collectionStrong$2;\n\n// `Map` constructor\n// https://tc39.es/ecma262/#sec-map-objects\ncollection$2('Map', function (init) {\n  return function Map() { return init(this, arguments.length ? arguments[0] : undefined); };\n}, collectionStrong$1);\n\nvar path$f = path$w;\n\nvar map$2 = path$f.Map;\n\nvar parent$v = map$2;\n\n\nvar map$1 = parent$v;\n\nvar map = map$1;\n\nvar _Map = /*@__PURE__*/getDefaultExportFromCjs(map);\n\n/**\n * This class can store groups and options specific for groups.\n */\nvar Groups = /*#__PURE__*/function () {\n  /**\n   * @ignore\n   */\n  function Groups() {\n    _classCallCheck(this, Groups);\n    this.clear();\n    this._defaultIndex = 0;\n    this._groupIndex = 0;\n    this._defaultGroups = [{\n      border: \"#2B7CE9\",\n      background: \"#97C2FC\",\n      highlight: {\n        border: \"#2B7CE9\",\n        background: \"#D2E5FF\"\n      },\n      hover: {\n        border: \"#2B7CE9\",\n        background: \"#D2E5FF\"\n      }\n    },\n    // 0: blue\n    {\n      border: \"#FFA500\",\n      background: \"#FFFF00\",\n      highlight: {\n        border: \"#FFA500\",\n        background: \"#FFFFA3\"\n      },\n      hover: {\n        border: \"#FFA500\",\n        background: \"#FFFFA3\"\n      }\n    },\n    // 1: yellow\n    {\n      border: \"#FA0A10\",\n      background: \"#FB7E81\",\n      highlight: {\n        border: \"#FA0A10\",\n        background: \"#FFAFB1\"\n      },\n      hover: {\n        border: \"#FA0A10\",\n        background: \"#FFAFB1\"\n      }\n    },\n    // 2: red\n    {\n      border: \"#41A906\",\n      background: \"#7BE141\",\n      highlight: {\n        border: \"#41A906\",\n        background: \"#A1EC76\"\n      },\n      hover: {\n        border: \"#41A906\",\n        background: \"#A1EC76\"\n      }\n    },\n    // 3: green\n    {\n      border: \"#E129F0\",\n      background: \"#EB7DF4\",\n      highlight: {\n        border: \"#E129F0\",\n        background: \"#F0B3F5\"\n      },\n      hover: {\n        border: \"#E129F0\",\n        background: \"#F0B3F5\"\n      }\n    },\n    // 4: magenta\n    {\n      border: \"#7C29F0\",\n      background: \"#AD85E4\",\n      highlight: {\n        border: \"#7C29F0\",\n        background: \"#D3BDF0\"\n      },\n      hover: {\n        border: \"#7C29F0\",\n        background: \"#D3BDF0\"\n      }\n    },\n    // 5: purple\n    {\n      border: \"#C37F00\",\n      background: \"#FFA807\",\n      highlight: {\n        border: \"#C37F00\",\n        background: \"#FFCA66\"\n      },\n      hover: {\n        border: \"#C37F00\",\n        background: \"#FFCA66\"\n      }\n    },\n    // 6: orange\n    {\n      border: \"#4220FB\",\n      background: \"#6E6EFD\",\n      highlight: {\n        border: \"#4220FB\",\n        background: \"#9B9BFD\"\n      },\n      hover: {\n        border: \"#4220FB\",\n        background: \"#9B9BFD\"\n      }\n    },\n    // 7: darkblue\n    {\n      border: \"#FD5A77\",\n      background: \"#FFC0CB\",\n      highlight: {\n        border: \"#FD5A77\",\n        background: \"#FFD1D9\"\n      },\n      hover: {\n        border: \"#FD5A77\",\n        background: \"#FFD1D9\"\n      }\n    },\n    // 8: pink\n    {\n      border: \"#4AD63A\",\n      background: \"#C2FABC\",\n      highlight: {\n        border: \"#4AD63A\",\n        background: \"#E6FFE3\"\n      },\n      hover: {\n        border: \"#4AD63A\",\n        background: \"#E6FFE3\"\n      }\n    },\n    // 9: mint\n\n    {\n      border: \"#990000\",\n      background: \"#EE0000\",\n      highlight: {\n        border: \"#BB0000\",\n        background: \"#FF3333\"\n      },\n      hover: {\n        border: \"#BB0000\",\n        background: \"#FF3333\"\n      }\n    },\n    // 10:bright red\n\n    {\n      border: \"#FF6000\",\n      background: \"#FF6000\",\n      highlight: {\n        border: \"#FF6000\",\n        background: \"#FF6000\"\n      },\n      hover: {\n        border: \"#FF6000\",\n        background: \"#FF6000\"\n      }\n    },\n    // 12: real orange\n    {\n      border: \"#97C2FC\",\n      background: \"#2B7CE9\",\n      highlight: {\n        border: \"#D2E5FF\",\n        background: \"#2B7CE9\"\n      },\n      hover: {\n        border: \"#D2E5FF\",\n        background: \"#2B7CE9\"\n      }\n    },\n    // 13: blue\n    {\n      border: \"#399605\",\n      background: \"#255C03\",\n      highlight: {\n        border: \"#399605\",\n        background: \"#255C03\"\n      },\n      hover: {\n        border: \"#399605\",\n        background: \"#255C03\"\n      }\n    },\n    // 14: green\n    {\n      border: \"#B70054\",\n      background: \"#FF007E\",\n      highlight: {\n        border: \"#B70054\",\n        background: \"#FF007E\"\n      },\n      hover: {\n        border: \"#B70054\",\n        background: \"#FF007E\"\n      }\n    },\n    // 15: magenta\n    {\n      border: \"#AD85E4\",\n      background: \"#7C29F0\",\n      highlight: {\n        border: \"#D3BDF0\",\n        background: \"#7C29F0\"\n      },\n      hover: {\n        border: \"#D3BDF0\",\n        background: \"#7C29F0\"\n      }\n    },\n    // 16: purple\n    {\n      border: \"#4557FA\",\n      background: \"#000EA1\",\n      highlight: {\n        border: \"#6E6EFD\",\n        background: \"#000EA1\"\n      },\n      hover: {\n        border: \"#6E6EFD\",\n        background: \"#000EA1\"\n      }\n    },\n    // 17: darkblue\n    {\n      border: \"#FFC0CB\",\n      background: \"#FD5A77\",\n      highlight: {\n        border: \"#FFD1D9\",\n        background: \"#FD5A77\"\n      },\n      hover: {\n        border: \"#FFD1D9\",\n        background: \"#FD5A77\"\n      }\n    },\n    // 18: pink\n    {\n      border: \"#C2FABC\",\n      background: \"#74D66A\",\n      highlight: {\n        border: \"#E6FFE3\",\n        background: \"#74D66A\"\n      },\n      hover: {\n        border: \"#E6FFE3\",\n        background: \"#74D66A\"\n      }\n    },\n    // 19: mint\n\n    {\n      border: \"#EE0000\",\n      background: \"#990000\",\n      highlight: {\n        border: \"#FF3333\",\n        background: \"#BB0000\"\n      },\n      hover: {\n        border: \"#FF3333\",\n        background: \"#BB0000\"\n      }\n    } // 20:bright red\n    ];\n\n    this.options = {};\n    this.defaultOptions = {\n      useDefaultGroups: true\n    };\n    _Object$assign(this.options, this.defaultOptions);\n  }\n\n  /**\n   *\n   * @param {object} options\n   */\n  _createClass(Groups, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      var optionFields = [\"useDefaultGroups\"];\n      if (options !== undefined) {\n        for (var groupName in options) {\n          if (Object.prototype.hasOwnProperty.call(options, groupName)) {\n            if (_indexOfInstanceProperty(optionFields).call(optionFields, groupName) === -1) {\n              var group = options[groupName];\n              this.add(groupName, group);\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * Clear all groups\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._groups = new _Map();\n      this._groupNames = [];\n    }\n\n    /**\n     * Get group options of a groupname.\n     * If groupname is not found, a new group may be created.\n     *\n     * @param {*}       groupname     Can be a number, string, Date, etc.\n     * @param {boolean} [shouldCreate=true] If true, create a new group\n     * @returns {object} The found or created group\n     */\n  }, {\n    key: \"get\",\n    value: function get(groupname) {\n      var shouldCreate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var group = this._groups.get(groupname);\n      if (group === undefined && shouldCreate) {\n        if (this.options.useDefaultGroups === false && this._groupNames.length > 0) {\n          // create new group\n          var index = this._groupIndex % this._groupNames.length;\n          ++this._groupIndex;\n          group = {};\n          group.color = this._groups.get(this._groupNames[index]);\n          this._groups.set(groupname, group);\n        } else {\n          // create new group\n          var _index = this._defaultIndex % this._defaultGroups.length;\n          this._defaultIndex++;\n          group = {};\n          group.color = this._defaultGroups[_index];\n          this._groups.set(groupname, group);\n        }\n      }\n      return group;\n    }\n\n    /**\n     * Add custom group style.\n     *\n     * @param {string} groupName - The name of the group, a new group will be\n     * created if a group with the same name doesn't exist, otherwise the old\n     * groups style will be overwritten.\n     * @param {object} style - An object containing borderColor, backgroundColor,\n     * etc.\n     * @returns {object} The created group object.\n     */\n  }, {\n    key: \"add\",\n    value: function add(groupName, style) {\n      // Only push group name once to prevent duplicates which would consume more\n      // RAM and also skew the distribution towards more often updated groups,\n      // neither of which is desirable.\n      if (!this._groups.has(groupName)) {\n        this._groupNames.push(groupName);\n      }\n      this._groups.set(groupName, style);\n      return style;\n    }\n  }]);\n  return Groups;\n}();\n\nvar $$e = _export;\n\n// `Number.isNaN` method\n// https://tc39.es/ecma262/#sec-number.isnan\n$$e({ target: 'Number', stat: true }, {\n  isNaN: function isNaN(number) {\n    // eslint-disable-next-line no-self-compare -- NaN check\n    return number !== number;\n  }\n});\n\nvar path$e = path$w;\n\nvar isNan$2 = path$e.Number.isNaN;\n\nvar parent$u = isNan$2;\n\nvar isNan$1 = parent$u;\n\nvar isNan = isNan$1;\n\nvar _Number$isNaN = /*@__PURE__*/getDefaultExportFromCjs(isNan);\n\nvar global$4 = global$n;\n\nvar globalIsFinite = global$4.isFinite;\n\n// `Number.isFinite` method\n// https://tc39.es/ecma262/#sec-number.isfinite\n// eslint-disable-next-line es/no-number-isfinite -- safe\nvar numberIsFinite$1 = Number.isFinite || function isFinite(it) {\n  return typeof it == 'number' && globalIsFinite(it);\n};\n\nvar $$d = _export;\nvar numberIsFinite = numberIsFinite$1;\n\n// `Number.isFinite` method\n// https://tc39.es/ecma262/#sec-number.isfinite\n$$d({ target: 'Number', stat: true }, { isFinite: numberIsFinite });\n\nvar path$d = path$w;\n\nvar _isFinite$2 = path$d.Number.isFinite;\n\nvar parent$t = _isFinite$2;\n\nvar _isFinite$1 = parent$t;\n\nvar _isFinite = _isFinite$1;\n\nvar _Number$isFinite = /*@__PURE__*/getDefaultExportFromCjs(_isFinite);\n\nvar $$c = _export;\nvar $some = arrayIteration.some;\nvar arrayMethodIsStrict$3 = arrayMethodIsStrict$6;\n\nvar STRICT_METHOD$2 = arrayMethodIsStrict$3('some');\n\n// `Array.prototype.some` method\n// https://tc39.es/ecma262/#sec-array.prototype.some\n$$c({ target: 'Array', proto: true, forced: !STRICT_METHOD$2 }, {\n  some: function some(callbackfn /* , thisArg */) {\n    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar entryVirtual$4 = entryVirtual$i;\n\nvar some$3 = entryVirtual$4('Array').some;\n\nvar isPrototypeOf$4 = objectIsPrototypeOf;\nvar method$4 = some$3;\n\nvar ArrayPrototype$4 = Array.prototype;\n\nvar some$2 = function (it) {\n  var own = it.some;\n  return it === ArrayPrototype$4 || (isPrototypeOf$4(ArrayPrototype$4, it) && own === ArrayPrototype$4.some) ? method$4 : own;\n};\n\nvar parent$s = some$2;\n\nvar some$1 = parent$s;\n\nvar some = some$1;\n\nvar _someInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(some);\n\nvar path$c = path$w;\n\nvar getOwnPropertySymbols$2 = path$c.Object.getOwnPropertySymbols;\n\nvar parent$r = getOwnPropertySymbols$2;\n\nvar getOwnPropertySymbols$1 = parent$r;\n\nvar getOwnPropertySymbols = getOwnPropertySymbols$1;\n\nvar _Object$getOwnPropertySymbols = /*@__PURE__*/getDefaultExportFromCjs(getOwnPropertySymbols);\n\nvar getOwnPropertyDescriptor$6 = {exports: {}};\n\nvar $$b = _export;\nvar fails$5 = fails$w;\nvar toIndexedObject$1 = toIndexedObject$a;\nvar nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\nvar DESCRIPTORS$2 = descriptors;\n\nvar FORCED$5 = !DESCRIPTORS$2 || fails$5(function () { nativeGetOwnPropertyDescriptor(1); });\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\n$$b({ target: 'Object', stat: true, forced: FORCED$5, sham: !DESCRIPTORS$2 }, {\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {\n    return nativeGetOwnPropertyDescriptor(toIndexedObject$1(it), key);\n  }\n});\n\nvar path$b = path$w;\n\nvar Object$3 = path$b.Object;\n\nvar getOwnPropertyDescriptor$5 = getOwnPropertyDescriptor$6.exports = function getOwnPropertyDescriptor(it, key) {\n  return Object$3.getOwnPropertyDescriptor(it, key);\n};\n\nif (Object$3.getOwnPropertyDescriptor.sham) getOwnPropertyDescriptor$5.sham = true;\n\nvar getOwnPropertyDescriptorExports = getOwnPropertyDescriptor$6.exports;\n\nvar parent$q = getOwnPropertyDescriptorExports;\n\nvar getOwnPropertyDescriptor$4 = parent$q;\n\nvar getOwnPropertyDescriptor$3 = getOwnPropertyDescriptor$4;\n\nvar _Object$getOwnPropertyDescriptor$1 = /*@__PURE__*/getDefaultExportFromCjs(getOwnPropertyDescriptor$3);\n\nvar $$a = _export;\nvar DESCRIPTORS$1 = descriptors;\nvar ownKeys$4 = ownKeys$5;\nvar toIndexedObject = toIndexedObject$a;\nvar getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;\nvar createProperty = createProperty$6;\n\n// `Object.getOwnPropertyDescriptors` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors\n$$a({ target: 'Object', stat: true, sham: !DESCRIPTORS$1 }, {\n  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {\n    var O = toIndexedObject(object);\n    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule$1.f;\n    var keys = ownKeys$4(O);\n    var result = {};\n    var index = 0;\n    var key, descriptor;\n    while (keys.length > index) {\n      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);\n      if (descriptor !== undefined) createProperty(result, key, descriptor);\n    }\n    return result;\n  }\n});\n\nvar path$a = path$w;\n\nvar getOwnPropertyDescriptors$2 = path$a.Object.getOwnPropertyDescriptors;\n\nvar parent$p = getOwnPropertyDescriptors$2;\n\nvar getOwnPropertyDescriptors$1 = parent$p;\n\nvar getOwnPropertyDescriptors = getOwnPropertyDescriptors$1;\n\nvar _Object$getOwnPropertyDescriptors = /*@__PURE__*/getDefaultExportFromCjs(getOwnPropertyDescriptors);\n\nvar defineProperties$4 = {exports: {}};\n\nvar $$9 = _export;\nvar DESCRIPTORS = descriptors;\nvar defineProperties$3 = objectDefineProperties.f;\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es/no-object-defineproperties -- safe\n$$9({ target: 'Object', stat: true, forced: Object.defineProperties !== defineProperties$3, sham: !DESCRIPTORS }, {\n  defineProperties: defineProperties$3\n});\n\nvar path$9 = path$w;\n\nvar Object$2 = path$9.Object;\n\nvar defineProperties$2 = defineProperties$4.exports = function defineProperties(T, D) {\n  return Object$2.defineProperties(T, D);\n};\n\nif (Object$2.defineProperties.sham) defineProperties$2.sham = true;\n\nvar definePropertiesExports = defineProperties$4.exports;\n\nvar parent$o = definePropertiesExports;\n\nvar defineProperties$1 = parent$o;\n\nvar defineProperties = defineProperties$1;\n\nvar _Object$defineProperties = /*@__PURE__*/getDefaultExportFromCjs(defineProperties);\n\nvar defineProperty = defineProperty$9;\n\nvar _Object$defineProperty = /*@__PURE__*/getDefaultExportFromCjs(defineProperty);\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    _Object$defineProperty$1(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nvar global$3 = global$n;\nvar fails$4 = fails$w;\nvar uncurryThis$3 = functionUncurryThis;\nvar toString$1 = toString$a;\nvar trim = stringTrim.trim;\nvar whitespaces = whitespaces$3;\n\nvar charAt = uncurryThis$3(''.charAt);\nvar $parseFloat$1 = global$3.parseFloat;\nvar Symbol$1 = global$3.Symbol;\nvar ITERATOR = Symbol$1 && Symbol$1.iterator;\nvar FORCED$4 = 1 / $parseFloat$1(whitespaces + '-0') !== -Infinity\n  // MS Edge 18- broken with boxed symbols\n  || (ITERATOR && !fails$4(function () { $parseFloat$1(Object(ITERATOR)); }));\n\n// `parseFloat` method\n// https://tc39.es/ecma262/#sec-parsefloat-string\nvar numberParseFloat = FORCED$4 ? function parseFloat(string) {\n  var trimmedString = trim(toString$1(string));\n  var result = $parseFloat$1(trimmedString);\n  return result === 0 && charAt(trimmedString, 0) === '-' ? -0 : result;\n} : $parseFloat$1;\n\nvar $$8 = _export;\nvar $parseFloat = numberParseFloat;\n\n// `parseFloat` method\n// https://tc39.es/ecma262/#sec-parsefloat-string\n$$8({ global: true, forced: parseFloat !== $parseFloat }, {\n  parseFloat: $parseFloat\n});\n\nvar path$8 = path$w;\n\nvar _parseFloat$3 = path$8.parseFloat;\n\nvar parent$n = _parseFloat$3;\n\nvar _parseFloat$2 = parent$n;\n\nvar _parseFloat = _parseFloat$2;\n\nvar _parseFloat$1 = /*@__PURE__*/getDefaultExportFromCjs(_parseFloat);\n\nvar $$7 = _export;\nvar fails$3 = fails$w;\nvar getOwnPropertyNames$3 = objectGetOwnPropertyNamesExternal.f;\n\n// eslint-disable-next-line es/no-object-getownpropertynames -- required for testing\nvar FAILS_ON_PRIMITIVES = fails$3(function () { return !Object.getOwnPropertyNames(1); });\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n$$7({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {\n  getOwnPropertyNames: getOwnPropertyNames$3\n});\n\nvar path$7 = path$w;\n\nvar Object$1 = path$7.Object;\n\nvar getOwnPropertyNames$2 = function getOwnPropertyNames(it) {\n  return Object$1.getOwnPropertyNames(it);\n};\n\nvar parent$m = getOwnPropertyNames$2;\n\nvar getOwnPropertyNames$1 = parent$m;\n\nvar getOwnPropertyNames = getOwnPropertyNames$1;\n\nvar _Object$getOwnPropertyNames = /*@__PURE__*/getDefaultExportFromCjs(getOwnPropertyNames);\n\n/**\n * Helper functions for components\n */\n\n/**\n * Determine values to use for (sub)options of 'chosen'.\n *\n * This option is either a boolean or an object whose values should be examined further.\n * The relevant structures are:\n *\n * - chosen: <boolean value>\n * - chosen: { subOption: <boolean or function> }\n *\n * Where subOption is 'node', 'edge' or 'label'.\n *\n * The intention of this method appears to be to set a specific priority to the options;\n * Since most properties are either bridged or merged into the local options objects, there\n * is not much point in handling them separately.\n * TODO: examine if 'most' in previous sentence can be replaced with 'all'. In that case, we\n *       should be able to get rid of this method.\n *\n * @param {string}  subOption  option within object 'chosen' to consider; either 'node', 'edge' or 'label'\n * @param {object}  pile       array of options objects to consider\n * @returns {boolean | Function}  value for passed subOption of 'chosen' to use\n */\nfunction choosify(subOption, pile) {\n  // allowed values for subOption\n  var allowed = [\"node\", \"edge\", \"label\"];\n  var value = true;\n  var chosen = topMost(pile, \"chosen\");\n  if (typeof chosen === \"boolean\") {\n    value = chosen;\n  } else if (_typeof(chosen) === \"object\") {\n    if (_indexOfInstanceProperty(allowed).call(allowed, subOption) === -1) {\n      throw new Error(\"choosify: subOption '\" + subOption + \"' should be one of \" + \"'\" + allowed.join(\"', '\") + \"'\");\n    }\n    var chosenEdge = topMost(pile, [\"chosen\", subOption]);\n    if (typeof chosenEdge === \"boolean\" || typeof chosenEdge === \"function\") {\n      value = chosenEdge;\n    }\n  }\n  return value;\n}\n\n/**\n * Check if the point falls within the given rectangle.\n *\n * @param {rect} rect\n * @param {point} point\n * @param {rotationPoint} [rotationPoint] if specified, the rotation that applies to the rectangle.\n * @returns {boolean}  true if point within rectangle, false otherwise\n */\nfunction pointInRect(rect, point, rotationPoint) {\n  if (rect.width <= 0 || rect.height <= 0) {\n    return false; // early out\n  }\n\n  if (rotationPoint !== undefined) {\n    // Rotate the point the same amount as the rectangle\n    var tmp = {\n      x: point.x - rotationPoint.x,\n      y: point.y - rotationPoint.y\n    };\n    if (rotationPoint.angle !== 0) {\n      // In order to get the coordinates the same, you need to\n      // rotate in the reverse direction\n      var angle = -rotationPoint.angle;\n      var tmp2 = {\n        x: Math.cos(angle) * tmp.x - Math.sin(angle) * tmp.y,\n        y: Math.sin(angle) * tmp.x + Math.cos(angle) * tmp.y\n      };\n      point = tmp2;\n    } else {\n      point = tmp;\n    }\n\n    // Note that if a rotation is specified, the rectangle coordinates\n    // are **not* the full canvas coordinates. They are relative to the\n    // rotationPoint. Hence, the point coordinates need not be translated\n    // back in this case.\n  }\n\n  var right = rect.x + rect.width;\n  var bottom = rect.y + rect.width;\n  return rect.left < point.x && right > point.x && rect.top < point.y && bottom > point.y;\n}\n\n/**\n * Check if given value is acceptable as a label text.\n *\n * @param {*} text value to check; can be anything at this point\n * @returns {boolean} true if valid label value, false otherwise\n */\nfunction isValidLabel(text) {\n  // Note that this is quite strict: types that *might* be converted to string are disallowed\n  return typeof text === \"string\" && text !== \"\";\n}\n\n/**\n * Returns x, y of self reference circle based on provided angle\n *\n * @param {object} ctx\n * @param {number} angle\n * @param {number} radius\n * @param {VisNode} node\n * @returns {object} x and y coordinates\n */\nfunction getSelfRefCoordinates(ctx, angle, radius, node) {\n  var x = node.x;\n  var y = node.y;\n  if (typeof node.distanceToBorder === \"function\") {\n    //calculating opposite and adjacent\n    //distaneToBorder becomes Hypotenuse.\n    //Formulas sin(a) = Opposite / Hypotenuse and cos(a) = Adjacent / Hypotenuse\n    var toBorderDist = node.distanceToBorder(ctx, angle);\n    var yFromNodeCenter = Math.sin(angle) * toBorderDist;\n    var xFromNodeCenter = Math.cos(angle) * toBorderDist;\n    //xFromNodeCenter is basically x and if xFromNodeCenter equals to the distance to border then it means\n    //that y does not need calculation because it is equal node.height / 2 or node.y\n    //same thing with yFromNodeCenter and if yFromNodeCenter equals to the distance to border then it means\n    //that x is equal node.width / 2 or node.x\n    if (xFromNodeCenter === toBorderDist) {\n      x += toBorderDist;\n      y = node.y;\n    } else if (yFromNodeCenter === toBorderDist) {\n      x = node.x;\n      y -= toBorderDist;\n    } else {\n      x += xFromNodeCenter;\n      y -= yFromNodeCenter;\n    }\n  } else if (node.shape.width > node.shape.height) {\n    x = node.x + node.shape.width * 0.5;\n    y = node.y - radius;\n  } else {\n    x = node.x + radius;\n    y = node.y - node.shape.height * 0.5;\n  }\n  return {\n    x: x,\n    y: y\n  };\n}\n\nvar entryVirtual$3 = entryVirtual$i;\n\nvar values$3 = entryVirtual$3('Array').values;\n\nvar parent$l = values$3;\n\nvar values$2 = parent$l;\n\nvar classof$1 = classof$d;\nvar hasOwn$2 = hasOwnProperty_1;\nvar isPrototypeOf$3 = objectIsPrototypeOf;\nvar method$3 = values$2;\n\nvar ArrayPrototype$3 = Array.prototype;\n\nvar DOMIterables = {\n  DOMTokenList: true,\n  NodeList: true\n};\n\nvar values$1 = function (it) {\n  var own = it.values;\n  return it === ArrayPrototype$3 || (isPrototypeOf$3(ArrayPrototype$3, it) && own === ArrayPrototype$3.values)\n    || hasOwn$2(DOMIterables, classof$1(it)) ? method$3 : own;\n};\n\nvar values = values$1;\n\nvar _valuesInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(values);\n\n/**\n * Callback to determine text dimensions, using the parent label settings.\n *\n * @callback MeasureText\n * @param {text} text\n * @param {text} mod\n * @returns {object} { width, values} width in pixels and font attributes\n */\n/**\n * Helper class for Label which collects results of splitting labels into lines and blocks.\n *\n * @private\n */\nvar LabelAccumulator = /*#__PURE__*/function () {\n  /**\n   * @param {MeasureText} measureText\n   */\n  function LabelAccumulator(measureText) {\n    _classCallCheck(this, LabelAccumulator);\n    this.measureText = measureText;\n    this.current = 0;\n    this.width = 0;\n    this.height = 0;\n    this.lines = [];\n  }\n\n  /**\n   * Append given text to the given line.\n   *\n   * @param {number}  l    index of line to add to\n   * @param {string}  text string to append to line\n   * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']\n   * @private\n   */\n  _createClass(LabelAccumulator, [{\n    key: \"_add\",\n    value: function _add(l, text) {\n      var mod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"normal\";\n      if (this.lines[l] === undefined) {\n        this.lines[l] = {\n          width: 0,\n          height: 0,\n          blocks: []\n        };\n      }\n\n      // We still need to set a block for undefined and empty texts, hence return at this point\n      // This is necessary because we don't know at this point if we're at the\n      // start of an empty line or not.\n      // To compensate, empty blocks are removed in `finalize()`.\n      //\n      // Empty strings should still have a height\n      var tmpText = text;\n      if (text === undefined || text === \"\") tmpText = \" \";\n\n      // Determine width and get the font properties\n      var result = this.measureText(tmpText, mod);\n      var block = _Object$assign({}, _valuesInstanceProperty(result));\n      block.text = text;\n      block.width = result.width;\n      block.mod = mod;\n      if (text === undefined || text === \"\") {\n        block.width = 0;\n      }\n      this.lines[l].blocks.push(block);\n\n      // Update the line width. We need this for determining if a string goes over max width\n      this.lines[l].width += block.width;\n    }\n\n    /**\n     * Returns the width in pixels of the current line.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"curWidth\",\n    value: function curWidth() {\n      var line = this.lines[this.current];\n      if (line === undefined) return 0;\n      return line.width;\n    }\n\n    /**\n     * Add text in block to current line\n     *\n     * @param {string} text\n     * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']\n     */\n  }, {\n    key: \"append\",\n    value: function append(text) {\n      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"normal\";\n      this._add(this.current, text, mod);\n    }\n\n    /**\n     * Add text in block to current line and start a new line\n     *\n     * @param {string} text\n     * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']\n     */\n  }, {\n    key: \"newLine\",\n    value: function newLine(text) {\n      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"normal\";\n      this._add(this.current, text, mod);\n      this.current++;\n    }\n\n    /**\n     * Determine and set the heights of all the lines currently contained in this instance\n     *\n     * Note that width has already been set.\n     *\n     * @private\n     */\n  }, {\n    key: \"determineLineHeights\",\n    value: function determineLineHeights() {\n      for (var k = 0; k < this.lines.length; k++) {\n        var line = this.lines[k];\n\n        // Looking for max height of blocks in line\n        var height = 0;\n        if (line.blocks !== undefined) {\n          // Can happen if text contains e.g. '\\n '\n          for (var l = 0; l < line.blocks.length; l++) {\n            var block = line.blocks[l];\n            if (height < block.height) {\n              height = block.height;\n            }\n          }\n        }\n        line.height = height;\n      }\n    }\n\n    /**\n     * Determine the full size of the label text, as determined by current lines and blocks\n     *\n     * @private\n     */\n  }, {\n    key: \"determineLabelSize\",\n    value: function determineLabelSize() {\n      var width = 0;\n      var height = 0;\n      for (var k = 0; k < this.lines.length; k++) {\n        var line = this.lines[k];\n        if (line.width > width) {\n          width = line.width;\n        }\n        height += line.height;\n      }\n      this.width = width;\n      this.height = height;\n    }\n\n    /**\n     * Remove all empty blocks and empty lines we don't need\n     *\n     * This must be done after the width/height determination,\n     * so that these are set properly for processing here.\n     *\n     * @returns {Array<Line>} Lines with empty blocks (and some empty lines) removed\n     * @private\n     */\n  }, {\n    key: \"removeEmptyBlocks\",\n    value: function removeEmptyBlocks() {\n      var tmpLines = [];\n      for (var k = 0; k < this.lines.length; k++) {\n        var line = this.lines[k];\n\n        // Note: an empty line in between text has width zero but is still relevant to layout.\n        // So we can't use width for testing empty line here\n        if (line.blocks.length === 0) continue;\n\n        // Discard final empty line always\n        if (k === this.lines.length - 1) {\n          if (line.width === 0) continue;\n        }\n        var tmpLine = {};\n        _Object$assign(tmpLine, line);\n        tmpLine.blocks = [];\n        var firstEmptyBlock = void 0;\n        var tmpBlocks = [];\n        for (var l = 0; l < line.blocks.length; l++) {\n          var block = line.blocks[l];\n          if (block.width !== 0) {\n            tmpBlocks.push(block);\n          } else {\n            if (firstEmptyBlock === undefined) {\n              firstEmptyBlock = block;\n            }\n          }\n        }\n\n        // Ensure that there is *some* text present\n        if (tmpBlocks.length === 0 && firstEmptyBlock !== undefined) {\n          tmpBlocks.push(firstEmptyBlock);\n        }\n        tmpLine.blocks = tmpBlocks;\n        tmpLines.push(tmpLine);\n      }\n      return tmpLines;\n    }\n\n    /**\n     * Set the sizes for all lines and the whole thing.\n     *\n     * @returns {{width: (number|*), height: (number|*), lines: Array}}\n     */\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      //console.log(JSON.stringify(this.lines, null, 2));\n\n      this.determineLineHeights();\n      this.determineLabelSize();\n      var tmpLines = this.removeEmptyBlocks();\n\n      // Return a simple hash object for further processing.\n      return {\n        width: this.width,\n        height: this.height,\n        lines: tmpLines\n      };\n    }\n  }]);\n  return LabelAccumulator;\n}();\n\n// Hash of prepared regexp's for tags\nvar tagPattern = {\n  // HTML\n  \"<b>\": /<b>/,\n  \"<i>\": /<i>/,\n  \"<code>\": /<code>/,\n  \"</b>\": /<\\/b>/,\n  \"</i>\": /<\\/i>/,\n  \"</code>\": /<\\/code>/,\n  // Markdown\n  \"*\": /\\*/,\n  // bold\n  _: /_/,\n  // ital\n  \"`\": /`/,\n  // mono\n  afterBold: /[^*]/,\n  afterItal: /[^_]/,\n  afterMono: /[^`]/\n};\n\n/**\n * Internal helper class for parsing the markup tags for HTML and Markdown.\n *\n * NOTE: Sequences of tabs and spaces are reduced to single space.\n *       Scan usage of `this.spacing` within method\n */\nvar MarkupAccumulator = /*#__PURE__*/function () {\n  /**\n   * Create an instance\n   *\n   * @param {string} text  text to parse for markup\n   */\n  function MarkupAccumulator(text) {\n    _classCallCheck(this, MarkupAccumulator);\n    this.text = text;\n    this.bold = false;\n    this.ital = false;\n    this.mono = false;\n    this.spacing = false;\n    this.position = 0;\n    this.buffer = \"\";\n    this.modStack = [];\n    this.blocks = [];\n  }\n\n  /**\n   * Return the mod label currently on the top of the stack\n   *\n   * @returns {string}  label of topmost mod\n   * @private\n   */\n  _createClass(MarkupAccumulator, [{\n    key: \"mod\",\n    value: function mod() {\n      return this.modStack.length === 0 ? \"normal\" : this.modStack[0];\n    }\n\n    /**\n     * Return the mod label currently active\n     *\n     * @returns {string}  label of active mod\n     * @private\n     */\n  }, {\n    key: \"modName\",\n    value: function modName() {\n      if (this.modStack.length === 0) return \"normal\";else if (this.modStack[0] === \"mono\") return \"mono\";else {\n        if (this.bold && this.ital) {\n          return \"boldital\";\n        } else if (this.bold) {\n          return \"bold\";\n        } else if (this.ital) {\n          return \"ital\";\n        }\n      }\n    }\n\n    /**\n     * @private\n     */\n  }, {\n    key: \"emitBlock\",\n    value: function emitBlock() {\n      if (this.spacing) {\n        this.add(\" \");\n        this.spacing = false;\n      }\n      if (this.buffer.length > 0) {\n        this.blocks.push({\n          text: this.buffer,\n          mod: this.modName()\n        });\n        this.buffer = \"\";\n      }\n    }\n\n    /**\n     * Output text to buffer\n     *\n     * @param {string} text  text to add\n     * @private\n     */\n  }, {\n    key: \"add\",\n    value: function add(text) {\n      if (text === \" \") {\n        this.spacing = true;\n      }\n      if (this.spacing) {\n        this.buffer += \" \";\n        this.spacing = false;\n      }\n      if (text != \" \") {\n        this.buffer += text;\n      }\n    }\n\n    /**\n     * Handle parsing of whitespace\n     *\n     * @param {string} ch  the character to check\n     * @returns {boolean} true if the character was processed as whitespace, false otherwise\n     */\n  }, {\n    key: \"parseWS\",\n    value: function parseWS(ch) {\n      if (/[ \\t]/.test(ch)) {\n        if (!this.mono) {\n          this.spacing = true;\n        } else {\n          this.add(ch);\n        }\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * @param {string} tagName  label for block type to set\n     * @private\n     */\n  }, {\n    key: \"setTag\",\n    value: function setTag(tagName) {\n      this.emitBlock();\n      this[tagName] = true;\n      this.modStack.unshift(tagName);\n    }\n\n    /**\n     * @param {string} tagName  label for block type to unset\n     * @private\n     */\n  }, {\n    key: \"unsetTag\",\n    value: function unsetTag(tagName) {\n      this.emitBlock();\n      this[tagName] = false;\n      this.modStack.shift();\n    }\n\n    /**\n     * @param {string} tagName label for block type we are currently processing\n     * @param {string|RegExp} tag string to match in text\n     * @returns {boolean} true if the tag was processed, false otherwise\n     */\n  }, {\n    key: \"parseStartTag\",\n    value: function parseStartTag(tagName, tag) {\n      // Note: if 'mono' passed as tagName, there is a double check here. This is OK\n      if (!this.mono && !this[tagName] && this.match(tag)) {\n        this.setTag(tagName);\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * @param {string|RegExp} tag\n     * @param {number} [advance=true] if set, advance current position in text\n     * @returns {boolean} true if match at given position, false otherwise\n     * @private\n     */\n  }, {\n    key: \"match\",\n    value: function match(tag) {\n      var advance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var _this$prepareRegExp = this.prepareRegExp(tag),\n        _this$prepareRegExp2 = _slicedToArray(_this$prepareRegExp, 2),\n        regExp = _this$prepareRegExp2[0],\n        length = _this$prepareRegExp2[1];\n      var matched = regExp.test(this.text.substr(this.position, length));\n      if (matched && advance) {\n        this.position += length - 1;\n      }\n      return matched;\n    }\n\n    /**\n     * @param {string} tagName label for block type we are currently processing\n     * @param {string|RegExp} tag string to match in text\n     * @param {RegExp} [nextTag] regular expression to match for characters *following* the current tag\n     * @returns {boolean} true if the tag was processed, false otherwise\n     */\n  }, {\n    key: \"parseEndTag\",\n    value: function parseEndTag(tagName, tag, nextTag) {\n      var checkTag = this.mod() === tagName;\n      if (tagName === \"mono\") {\n        // special handling for 'mono'\n        checkTag = checkTag && this.mono;\n      } else {\n        checkTag = checkTag && !this.mono;\n      }\n      if (checkTag && this.match(tag)) {\n        if (nextTag !== undefined) {\n          // Purpose of the following match is to prevent a direct unset/set of a given tag\n          // E.g. '*bold **still bold*' => '*bold still bold*'\n          if (this.position === this.text.length - 1 || this.match(nextTag, false)) {\n            this.unsetTag(tagName);\n          }\n        } else {\n          this.unsetTag(tagName);\n        }\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * @param {string|RegExp} tag  string to match in text\n     * @param {value} value  string to replace tag with, if found at current position\n     * @returns {boolean} true if the tag was processed, false otherwise\n     */\n  }, {\n    key: \"replace\",\n    value: function replace(tag, value) {\n      if (this.match(tag)) {\n        this.add(value);\n        this.position += length - 1;\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Create a regular expression for the tag if it isn't already one.\n     *\n     * The return value is an array `[RegExp, number]`, with exactly two value, where:\n     *  - RegExp is the regular expression to use\n     *  - number is the lenth of the input string to match\n     *\n     * @param {string|RegExp} tag  string to match in text\n     * @returns {Array}  regular expression to use and length of input string to match\n     * @private\n     */\n  }, {\n    key: \"prepareRegExp\",\n    value: function prepareRegExp(tag) {\n      var length;\n      var regExp;\n      if (tag instanceof RegExp) {\n        regExp = tag;\n        length = 1; // ASSUMPTION: regexp only tests one character\n      } else {\n        // use prepared regexp if present\n        var prepared = tagPattern[tag];\n        if (prepared !== undefined) {\n          regExp = prepared;\n        } else {\n          regExp = new RegExp(tag);\n        }\n        length = tag.length;\n      }\n      return [regExp, length];\n    }\n  }]);\n  return MarkupAccumulator;\n}();\n/**\n * Helper class for Label which explodes the label text into lines and blocks within lines\n *\n * @private\n */\nvar LabelSplitter = /*#__PURE__*/function () {\n  /**\n   * @param {CanvasRenderingContext2D} ctx Canvas rendering context\n   * @param {Label} parent reference to the Label instance using current instance\n   * @param {boolean} selected\n   * @param {boolean} hover\n   */\n  function LabelSplitter(ctx, parent, selected, hover) {\n    var _this = this;\n    _classCallCheck(this, LabelSplitter);\n    this.ctx = ctx;\n    this.parent = parent;\n    this.selected = selected;\n    this.hover = hover;\n\n    /**\n     * Callback to determine text width; passed to LabelAccumulator instance\n     *\n     * @param  {string} text string to determine width of\n     * @param  {string} mod  font type to use for this text\n     * @returns {object} { width, values} width in pixels and font attributes\n     */\n    var textWidth = function textWidth(text, mod) {\n      if (text === undefined) return 0;\n\n      // TODO: This can be done more efficiently with caching\n      // This will set the ctx.font correctly, depending on selected/hover and mod - so that ctx.measureText() will be accurate.\n      var values = _this.parent.getFormattingValues(ctx, selected, hover, mod);\n      var width = 0;\n      if (text !== \"\") {\n        var measure = _this.ctx.measureText(text);\n        width = measure.width;\n      }\n      return {\n        width: width,\n        values: values\n      };\n    };\n    this.lines = new LabelAccumulator(textWidth);\n  }\n\n  /**\n   * Split passed text of a label into lines and blocks.\n   *\n   * # NOTE\n   *\n   * The handling of spacing is option dependent:\n   *\n   * - if `font.multi : false`, all spaces are retained\n   * - if `font.multi : true`, every sequence of spaces is compressed to a single space\n   *\n   * This might not be the best way to do it, but this is as it has been working till now.\n   * In order not to break existing functionality, for the time being this behaviour will\n   * be retained in any code changes.\n   *\n   * @param {string} text  text to split\n   * @returns {Array<line>}\n   */\n  _createClass(LabelSplitter, [{\n    key: \"process\",\n    value: function process(text) {\n      if (!isValidLabel(text)) {\n        return this.lines.finalize();\n      }\n      var font = this.parent.fontOptions;\n\n      // Normalize the end-of-line's to a single representation - order important\n      text = text.replace(/\\r\\n/g, \"\\n\"); // Dos EOL's\n      text = text.replace(/\\r/g, \"\\n\"); // Mac EOL's\n\n      // Note that at this point, there can be no \\r's in the text.\n      // This is used later on splitStringIntoLines() to split multifont texts.\n\n      var nlLines = String(text).split(\"\\n\");\n      var lineCount = nlLines.length;\n      if (font.multi) {\n        // Multi-font case: styling tags active\n        for (var i = 0; i < lineCount; i++) {\n          var blocks = this.splitBlocks(nlLines[i], font.multi);\n          // Post: Sequences of tabs and spaces are reduced to single space\n\n          if (blocks === undefined) continue;\n          if (blocks.length === 0) {\n            this.lines.newLine(\"\");\n            continue;\n          }\n          if (font.maxWdt > 0) {\n            // widthConstraint.maximum defined\n            //console.log('Running widthConstraint multi, max: ' + this.fontOptions.maxWdt);\n            for (var j = 0; j < blocks.length; j++) {\n              var mod = blocks[j].mod;\n              var _text = blocks[j].text;\n              this.splitStringIntoLines(_text, mod, true);\n            }\n          } else {\n            // widthConstraint.maximum NOT defined\n            for (var _j = 0; _j < blocks.length; _j++) {\n              var _mod = blocks[_j].mod;\n              var _text2 = blocks[_j].text;\n              this.lines.append(_text2, _mod);\n            }\n          }\n          this.lines.newLine();\n        }\n      } else {\n        // Single-font case\n        if (font.maxWdt > 0) {\n          // widthConstraint.maximum defined\n          // console.log('Running widthConstraint normal, max: ' + this.fontOptions.maxWdt);\n          for (var _i = 0; _i < lineCount; _i++) {\n            this.splitStringIntoLines(nlLines[_i]);\n          }\n        } else {\n          // widthConstraint.maximum NOT defined\n          for (var _i2 = 0; _i2 < lineCount; _i2++) {\n            this.lines.newLine(nlLines[_i2]);\n          }\n        }\n      }\n      return this.lines.finalize();\n    }\n\n    /**\n     * normalize the markup system\n     *\n     * @param {boolean|'md'|'markdown'|'html'} markupSystem\n     * @returns {string}\n     */\n  }, {\n    key: \"decodeMarkupSystem\",\n    value: function decodeMarkupSystem(markupSystem) {\n      var system = \"none\";\n      if (markupSystem === \"markdown\" || markupSystem === \"md\") {\n        system = \"markdown\";\n      } else if (markupSystem === true || markupSystem === \"html\") {\n        system = \"html\";\n      }\n      return system;\n    }\n\n    /**\n     *\n     * @param {string} text\n     * @returns {Array}\n     */\n  }, {\n    key: \"splitHtmlBlocks\",\n    value: function splitHtmlBlocks(text) {\n      var s = new MarkupAccumulator(text);\n      var parseEntities = function parseEntities(ch) {\n        if (/&/.test(ch)) {\n          var parsed = s.replace(s.text, \"&lt;\", \"<\") || s.replace(s.text, \"&amp;\", \"&\");\n          if (!parsed) {\n            s.add(\"&\");\n          }\n          return true;\n        }\n        return false;\n      };\n      while (s.position < s.text.length) {\n        var ch = s.text.charAt(s.position);\n        var parsed = s.parseWS(ch) || /</.test(ch) && (s.parseStartTag(\"bold\", \"<b>\") || s.parseStartTag(\"ital\", \"<i>\") || s.parseStartTag(\"mono\", \"<code>\") || s.parseEndTag(\"bold\", \"</b>\") || s.parseEndTag(\"ital\", \"</i>\") || s.parseEndTag(\"mono\", \"</code>\")) || parseEntities(ch);\n        if (!parsed) {\n          s.add(ch);\n        }\n        s.position++;\n      }\n      s.emitBlock();\n      return s.blocks;\n    }\n\n    /**\n     *\n     * @param {string} text\n     * @returns {Array}\n     */\n  }, {\n    key: \"splitMarkdownBlocks\",\n    value: function splitMarkdownBlocks(text) {\n      var _this2 = this;\n      var s = new MarkupAccumulator(text);\n      var beginable = true;\n      var parseOverride = function parseOverride(ch) {\n        if (/\\\\/.test(ch)) {\n          if (s.position < _this2.text.length + 1) {\n            s.position++;\n            ch = _this2.text.charAt(s.position);\n            if (/ \\t/.test(ch)) {\n              s.spacing = true;\n            } else {\n              s.add(ch);\n              beginable = false;\n            }\n          }\n          return true;\n        }\n        return false;\n      };\n      while (s.position < s.text.length) {\n        var ch = s.text.charAt(s.position);\n        var parsed = s.parseWS(ch) || parseOverride(ch) || (beginable || s.spacing) && (s.parseStartTag(\"bold\", \"*\") || s.parseStartTag(\"ital\", \"_\") || s.parseStartTag(\"mono\", \"`\")) || s.parseEndTag(\"bold\", \"*\", \"afterBold\") || s.parseEndTag(\"ital\", \"_\", \"afterItal\") || s.parseEndTag(\"mono\", \"`\", \"afterMono\");\n        if (!parsed) {\n          s.add(ch);\n          beginable = false;\n        }\n        s.position++;\n      }\n      s.emitBlock();\n      return s.blocks;\n    }\n\n    /**\n     * Explodes a piece of text into single-font blocks using a given markup\n     *\n     * @param {string} text\n     * @param {boolean|'md'|'markdown'|'html'} markupSystem\n     * @returns {Array.<{text: string, mod: string}>}\n     * @private\n     */\n  }, {\n    key: \"splitBlocks\",\n    value: function splitBlocks(text, markupSystem) {\n      var system = this.decodeMarkupSystem(markupSystem);\n      if (system === \"none\") {\n        return [{\n          text: text,\n          mod: \"normal\"\n        }];\n      } else if (system === \"markdown\") {\n        return this.splitMarkdownBlocks(text);\n      } else if (system === \"html\") {\n        return this.splitHtmlBlocks(text);\n      }\n    }\n\n    /**\n     * @param {string} text\n     * @returns {boolean} true if text length over the current max with\n     * @private\n     */\n  }, {\n    key: \"overMaxWidth\",\n    value: function overMaxWidth(text) {\n      var width = this.ctx.measureText(text).width;\n      return this.lines.curWidth() + width > this.parent.fontOptions.maxWdt;\n    }\n\n    /**\n     * Determine the longest part of the sentence which still fits in the\n     * current max width.\n     *\n     * @param {Array} words  Array of strings signifying a text lines\n     * @returns {number}      index of first item in string making string go over max\n     * @private\n     */\n  }, {\n    key: \"getLongestFit\",\n    value: function getLongestFit(words) {\n      var text = \"\";\n      var w = 0;\n      while (w < words.length) {\n        var pre = text === \"\" ? \"\" : \" \";\n        var newText = text + pre + words[w];\n        if (this.overMaxWidth(newText)) break;\n        text = newText;\n        w++;\n      }\n      return w;\n    }\n\n    /**\n     * Determine the longest part of the string which still fits in the\n     * current max width.\n     *\n     * @param {Array} words Array of strings signifying a text lines\n     * @returns {number} index of first item in string making string go over max\n     */\n  }, {\n    key: \"getLongestFitWord\",\n    value: function getLongestFitWord(words) {\n      var w = 0;\n      while (w < words.length) {\n        if (this.overMaxWidth(_sliceInstanceProperty(words).call(words, 0, w))) break;\n        w++;\n      }\n      return w;\n    }\n\n    /**\n     * Split the passed text into lines, according to width constraint (if any).\n     *\n     * The method assumes that the input string is a single line, i.e. without lines break.\n     *\n     * This method retains spaces, if still present (case `font.multi: false`).\n     * A space which falls on an internal line break, will be replaced by a newline.\n     * There is no special handling of tabs; these go along with the flow.\n     *\n     * @param {string} str\n     * @param {string} [mod='normal']\n     * @param {boolean} [appendLast=false]\n     * @private\n     */\n  }, {\n    key: \"splitStringIntoLines\",\n    value: function splitStringIntoLines(str) {\n      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"normal\";\n      var appendLast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      // Set the canvas context font, based upon the current selected/hover state\n      // and the provided mod, so the text measurement performed by getLongestFit\n      // will be accurate - and not just use the font of whoever last used the canvas.\n      this.parent.getFormattingValues(this.ctx, this.selected, this.hover, mod);\n\n      // Still-present spaces are relevant, retain them\n      str = str.replace(/^( +)/g, \"$1\\r\");\n      str = str.replace(/([^\\r][^ ]*)( +)/g, \"$1\\r$2\\r\");\n      var words = str.split(\"\\r\");\n      while (words.length > 0) {\n        var w = this.getLongestFit(words);\n        if (w === 0) {\n          // Special case: the first word is already larger than the max width.\n          var word = words[0];\n\n          // Break the word to the largest part that fits the line\n          var x = this.getLongestFitWord(word);\n          this.lines.newLine(_sliceInstanceProperty(word).call(word, 0, x), mod);\n\n          // Adjust the word, so that the rest will be done next iteration\n          words[0] = _sliceInstanceProperty(word).call(word, x);\n        } else {\n          // skip any space that is replaced by a newline\n          var newW = w;\n          if (words[w - 1] === \" \") {\n            w--;\n          } else if (words[newW] === \" \") {\n            newW++;\n          }\n          var text = _sliceInstanceProperty(words).call(words, 0, w).join(\"\");\n          if (w == words.length && appendLast) {\n            this.lines.append(text, mod);\n          } else {\n            this.lines.newLine(text, mod);\n          }\n\n          // Adjust the word, so that the rest will be done next iteration\n          words = _sliceInstanceProperty(words).call(words, newW);\n        }\n      }\n    }\n  }]);\n  return LabelSplitter;\n}();\n\n/**\n * List of special styles for multi-fonts\n *\n * @private\n */\nvar multiFontStyle = [\"bold\", \"ital\", \"boldital\", \"mono\"];\n\n/**\n * A Label to be used for Nodes or Edges.\n */\nvar Label = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {object} options\n   * @param {boolean} [edgelabel=false]\n   */\n  function Label(body, options) {\n    var edgelabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    _classCallCheck(this, Label);\n    this.body = body;\n    this.pointToSelf = false;\n    this.baseSize = undefined;\n    this.fontOptions = {}; // instance variable containing the *instance-local* font options\n    this.setOptions(options);\n    this.size = {\n      top: 0,\n      left: 0,\n      width: 0,\n      height: 0,\n      yLine: 0\n    };\n    this.isEdgeLabel = edgelabel;\n  }\n\n  /**\n   * @param {object} options the options of the parent Node-instance\n   */\n  _createClass(Label, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.elementOptions = options; // Reference to the options of the parent Node-instance\n\n      this.initFontOptions(options.font);\n      if (isValidLabel(options.label)) {\n        this.labelDirty = true;\n      } else {\n        // Bad label! Change the option value to prevent bad stuff happening\n        options.label = undefined;\n      }\n      if (options.font !== undefined && options.font !== null) {\n        // font options can be deleted at various levels\n        if (typeof options.font === \"string\") {\n          this.baseSize = this.fontOptions.size;\n        } else if (_typeof(options.font) === \"object\") {\n          var size = options.font.size;\n          if (size !== undefined) {\n            this.baseSize = size;\n          }\n        }\n      }\n    }\n\n    /**\n     * Init the font Options structure.\n     *\n     * Member fontOptions serves as an accumulator for the current font options.\n     * As such, it needs to be completely separated from the node options.\n     *\n     * @param {object} newFontOptions the new font options to process\n     * @private\n     */\n  }, {\n    key: \"initFontOptions\",\n    value: function initFontOptions(newFontOptions) {\n      var _this = this;\n      // Prepare the multi-font option objects.\n      // These will be filled in propagateFonts(), if required\n      forEach$1(multiFontStyle, function (style) {\n        _this.fontOptions[style] = {};\n      });\n\n      // Handle shorthand option, if present\n      if (Label.parseFontString(this.fontOptions, newFontOptions)) {\n        this.fontOptions.vadjust = 0;\n        return;\n      }\n\n      // Copy over the non-multifont options, if specified\n      forEach$1(newFontOptions, function (prop, n) {\n        if (prop !== undefined && prop !== null && _typeof(prop) !== \"object\") {\n          _this.fontOptions[n] = prop;\n        }\n      });\n    }\n\n    /**\n     * If in-variable is a string, parse it as a font specifier.\n     *\n     * Note that following is not done here and have to be done after the call:\n     * - Not all font options are set (vadjust, mod)\n     *\n     * @param {object} outOptions  out-parameter, object in which to store the parse results (if any)\n     * @param {object} inOptions  font options to parse\n     * @returns {boolean} true if font parsed as string, false otherwise\n     * @static\n     */\n  }, {\n    key: \"constrain\",\n    value:\n    /**\n     * Set the width and height constraints based on 'nearest' value\n     *\n     * @param {Array} pile array of option objects to consider\n     * @returns {object} the actual constraint values to use\n     * @private\n     */\n    function constrain(pile) {\n      // NOTE: constrainWidth and  constrainHeight never set!\n      // NOTE: for edge labels, only 'maxWdt' set\n      // Node labels can set all the fields\n      var fontOptions = {\n        constrainWidth: false,\n        maxWdt: -1,\n        minWdt: -1,\n        constrainHeight: false,\n        minHgt: -1,\n        valign: \"middle\"\n      };\n      var widthConstraint = topMost(pile, \"widthConstraint\");\n      if (typeof widthConstraint === \"number\") {\n        fontOptions.maxWdt = Number(widthConstraint);\n        fontOptions.minWdt = Number(widthConstraint);\n      } else if (_typeof(widthConstraint) === \"object\") {\n        var widthConstraintMaximum = topMost(pile, [\"widthConstraint\", \"maximum\"]);\n        if (typeof widthConstraintMaximum === \"number\") {\n          fontOptions.maxWdt = Number(widthConstraintMaximum);\n        }\n        var widthConstraintMinimum = topMost(pile, [\"widthConstraint\", \"minimum\"]);\n        if (typeof widthConstraintMinimum === \"number\") {\n          fontOptions.minWdt = Number(widthConstraintMinimum);\n        }\n      }\n      var heightConstraint = topMost(pile, \"heightConstraint\");\n      if (typeof heightConstraint === \"number\") {\n        fontOptions.minHgt = Number(heightConstraint);\n      } else if (_typeof(heightConstraint) === \"object\") {\n        var heightConstraintMinimum = topMost(pile, [\"heightConstraint\", \"minimum\"]);\n        if (typeof heightConstraintMinimum === \"number\") {\n          fontOptions.minHgt = Number(heightConstraintMinimum);\n        }\n        var heightConstraintValign = topMost(pile, [\"heightConstraint\", \"valign\"]);\n        if (typeof heightConstraintValign === \"string\") {\n          if (heightConstraintValign === \"top\" || heightConstraintValign === \"bottom\") {\n            fontOptions.valign = heightConstraintValign;\n          }\n        }\n      }\n      return fontOptions;\n    }\n\n    /**\n     * Set options and update internal state\n     *\n     * @param {object} options  options to set\n     * @param {Array}  pile     array of option objects to consider for option 'chosen'\n     */\n  }, {\n    key: \"update\",\n    value: function update(options, pile) {\n      this.setOptions(options, true);\n      this.propagateFonts(pile);\n      deepExtend(this.fontOptions, this.constrain(pile));\n      this.fontOptions.chooser = choosify(\"label\", pile);\n    }\n\n    /**\n     * When margins are set in an element, adjust sizes is called to remove them\n     * from the width/height constraints. This must be done prior to label sizing.\n     *\n     * @param {{top: number, right: number, bottom: number, left: number}} margins\n     */\n  }, {\n    key: \"adjustSizes\",\n    value: function adjustSizes(margins) {\n      var widthBias = margins ? margins.right + margins.left : 0;\n      if (this.fontOptions.constrainWidth) {\n        this.fontOptions.maxWdt -= widthBias;\n        this.fontOptions.minWdt -= widthBias;\n      }\n      var heightBias = margins ? margins.top + margins.bottom : 0;\n      if (this.fontOptions.constrainHeight) {\n        this.fontOptions.minHgt -= heightBias;\n      }\n    }\n\n    /////////////////////////////////////////////////////////\n    // Methods for handling options piles\n    // Eventually, these will be moved to a separate class\n    /////////////////////////////////////////////////////////\n\n    /**\n     * Add the font members of the passed list of option objects to the pile.\n     *\n     * @param {Pile} dstPile  pile of option objects add to\n     * @param {Pile} srcPile  pile of option objects to take font options from\n     * @private\n     */\n  }, {\n    key: \"addFontOptionsToPile\",\n    value: function addFontOptionsToPile(dstPile, srcPile) {\n      for (var i = 0; i < srcPile.length; ++i) {\n        this.addFontToPile(dstPile, srcPile[i]);\n      }\n    }\n\n    /**\n     * Add given font option object to the list of objects (the 'pile') to consider for determining\n     * multi-font option values.\n     *\n     * @param {Pile} pile  pile of option objects to use\n     * @param {object} options  instance to add to pile\n     * @private\n     */\n  }, {\n    key: \"addFontToPile\",\n    value: function addFontToPile(pile, options) {\n      if (options === undefined) return;\n      if (options.font === undefined || options.font === null) return;\n      var item = options.font;\n      pile.push(item);\n    }\n\n    /**\n     * Collect all own-property values from the font pile that aren't multi-font option objectss.\n     *\n     * @param {Pile} pile  pile of option objects to use\n     * @returns {object} object with all current own basic font properties\n     * @private\n     */\n  }, {\n    key: \"getBasicOptions\",\n    value: function getBasicOptions(pile) {\n      var ret = {};\n\n      // Scans the whole pile to get all options present\n      for (var n = 0; n < pile.length; ++n) {\n        var fontOptions = pile[n];\n\n        // Convert shorthand if necessary\n        var tmpShorthand = {};\n        if (Label.parseFontString(tmpShorthand, fontOptions)) {\n          fontOptions = tmpShorthand;\n        }\n        forEach$1(fontOptions, function (opt, name) {\n          if (opt === undefined) return; // multi-font option need not be present\n          if (Object.prototype.hasOwnProperty.call(ret, name)) return; // Keep first value we encounter\n\n          if (_indexOfInstanceProperty(multiFontStyle).call(multiFontStyle, name) !== -1) {\n            // Skip multi-font properties but we do need the structure\n            ret[name] = {};\n          } else {\n            ret[name] = opt;\n          }\n        });\n      }\n      return ret;\n    }\n\n    /**\n     * Return the value for given option for the given multi-font.\n     *\n     * All available option objects are trawled in the set order to construct the option values.\n     *\n     * ---------------------------------------------------------------------\n     * ## Traversal of pile for multi-fonts\n     *\n     * The determination of multi-font option values is a special case, because any values not\n     * present in the multi-font options should by definition be taken from the main font options,\n     * i.e. from the current 'parent' object of the multi-font option.\n     *\n     * ### Search order for multi-fonts\n     *\n     * 'bold' used as example:\n     *\n     *   - search in option group 'bold' in local properties\n     *   - search in main font option group in local properties\n     *\n     * ---------------------------------------------------------------------\n     *\n     * @param {Pile} pile  pile of option objects to use\n     * @param {MultiFontStyle} multiName sub path for the multi-font\n     * @param {string} option  the option to search for, for the given multi-font\n     * @returns {string|number} the value for the given option\n     * @private\n     */\n  }, {\n    key: \"getFontOption\",\n    value: function getFontOption(pile, multiName, option) {\n      var multiFont;\n\n      // Search multi font in local properties\n      for (var n = 0; n < pile.length; ++n) {\n        var fontOptions = pile[n];\n        if (Object.prototype.hasOwnProperty.call(fontOptions, multiName)) {\n          multiFont = fontOptions[multiName];\n          if (multiFont === undefined || multiFont === null) continue;\n\n          // Convert shorthand if necessary\n          // TODO: inefficient to do this conversion every time; find a better way.\n          var tmpShorthand = {};\n          if (Label.parseFontString(tmpShorthand, multiFont)) {\n            multiFont = tmpShorthand;\n          }\n          if (Object.prototype.hasOwnProperty.call(multiFont, option)) {\n            return multiFont[option];\n          }\n        }\n      }\n\n      // Option is not mentioned in the multi font options; take it from the parent font options.\n      // These have already been converted with getBasicOptions(), so use the converted values.\n      if (Object.prototype.hasOwnProperty.call(this.fontOptions, option)) {\n        return this.fontOptions[option];\n      }\n\n      // A value **must** be found; you should never get here.\n      throw new Error(\"Did not find value for multi-font for property: '\" + option + \"'\");\n    }\n\n    /**\n     * Return all options values for the given multi-font.\n     *\n     * All available option objects are trawled in the set order to construct the option values.\n     *\n     * @param {Pile} pile  pile of option objects to use\n     * @param {MultiFontStyle} multiName sub path for the mod-font\n     * @returns {MultiFontOptions}\n     * @private\n     */\n  }, {\n    key: \"getFontOptions\",\n    value: function getFontOptions(pile, multiName) {\n      var result = {};\n      var optionNames = [\"color\", \"size\", \"face\", \"mod\", \"vadjust\"]; // List of allowed options per multi-font\n\n      for (var i = 0; i < optionNames.length; ++i) {\n        var mod = optionNames[i];\n        result[mod] = this.getFontOption(pile, multiName, mod);\n      }\n      return result;\n    }\n\n    /////////////////////////////////////////////////////////\n    // End methods for handling options piles\n    /////////////////////////////////////////////////////////\n\n    /**\n     * Collapse the font options for the multi-font to single objects, from\n     * the chain of option objects passed (the 'pile').\n     *\n     * @param {Pile} pile  sequence of option objects to consider.\n     *                     First item in list assumed to be the newly set options.\n     */\n  }, {\n    key: \"propagateFonts\",\n    value: function propagateFonts(pile) {\n      var _this2 = this;\n      var fontPile = []; // sequence of font objects to consider, order important\n\n      // Note that this.elementOptions is not used here.\n      this.addFontOptionsToPile(fontPile, pile);\n      this.fontOptions = this.getBasicOptions(fontPile);\n\n      // We set multifont values even if multi === false, for consistency (things break otherwise)\n      var _loop = function _loop() {\n        var mod = multiFontStyle[i];\n        var modOptions = _this2.fontOptions[mod];\n        var tmpMultiFontOptions = _this2.getFontOptions(fontPile, mod);\n\n        // Copy over found values\n        forEach$1(tmpMultiFontOptions, function (option, n) {\n          modOptions[n] = option;\n        });\n        modOptions.size = Number(modOptions.size);\n        modOptions.vadjust = Number(modOptions.vadjust);\n      };\n      for (var i = 0; i < multiFontStyle.length; ++i) {\n        _loop();\n      }\n    }\n\n    /**\n     * Main function. This is called from anything that wants to draw a label.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x\n     * @param {number} y\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {string} [baseline='middle']\n     */\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover) {\n      var baseline = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"middle\";\n      // if no label, return\n      if (this.elementOptions.label === undefined) return;\n\n      // check if we have to render the label\n      var viewFontSize = this.fontOptions.size * this.body.view.scale;\n      if (this.elementOptions.label && viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1) return;\n\n      // This ensures that there will not be HUGE letters on screen\n      // by setting an upper limit on the visible text size (regardless of zoomLevel)\n      if (viewFontSize >= this.elementOptions.scaling.label.maxVisible) {\n        viewFontSize = Number(this.elementOptions.scaling.label.maxVisible) / this.body.view.scale;\n      }\n\n      // update the size cache if required\n      this.calculateLabelSize(ctx, selected, hover, x, y, baseline);\n      this._drawBackground(ctx);\n      this._drawText(ctx, x, this.size.yLine, baseline, viewFontSize);\n    }\n\n    /**\n     * Draws the label background\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @private\n     */\n  }, {\n    key: \"_drawBackground\",\n    value: function _drawBackground(ctx) {\n      if (this.fontOptions.background !== undefined && this.fontOptions.background !== \"none\") {\n        ctx.fillStyle = this.fontOptions.background;\n        var size = this.getSize();\n        ctx.fillRect(size.left, size.top, size.width, size.height);\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x\n     * @param {number} y\n     * @param {string} [baseline='middle']\n     * @param {number} viewFontSize\n     * @private\n     */\n  }, {\n    key: \"_drawText\",\n    value: function _drawText(ctx, x, y) {\n      var baseline = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"middle\";\n      var viewFontSize = arguments.length > 4 ? arguments[4] : undefined;\n      var _this$_setAlignment = this._setAlignment(ctx, x, y, baseline);\n      var _this$_setAlignment2 = _slicedToArray(_this$_setAlignment, 2);\n      x = _this$_setAlignment2[0];\n      y = _this$_setAlignment2[1];\n      ctx.textAlign = \"left\";\n      x = x - this.size.width / 2; // Shift label 1/2-distance to the left\n      if (this.fontOptions.valign && this.size.height > this.size.labelHeight) {\n        if (this.fontOptions.valign === \"top\") {\n          y -= (this.size.height - this.size.labelHeight) / 2;\n        }\n        if (this.fontOptions.valign === \"bottom\") {\n          y += (this.size.height - this.size.labelHeight) / 2;\n        }\n      }\n\n      // draw the text\n      for (var i = 0; i < this.lineCount; i++) {\n        var line = this.lines[i];\n        if (line && line.blocks) {\n          var width = 0;\n          if (this.isEdgeLabel || this.fontOptions.align === \"center\") {\n            width += (this.size.width - line.width) / 2;\n          } else if (this.fontOptions.align === \"right\") {\n            width += this.size.width - line.width;\n          }\n          for (var j = 0; j < line.blocks.length; j++) {\n            var block = line.blocks[j];\n            ctx.font = block.font;\n            var _this$_getColor = this._getColor(block.color, viewFontSize, block.strokeColor),\n              _this$_getColor2 = _slicedToArray(_this$_getColor, 2),\n              fontColor = _this$_getColor2[0],\n              strokeColor = _this$_getColor2[1];\n            if (block.strokeWidth > 0) {\n              ctx.lineWidth = block.strokeWidth;\n              ctx.strokeStyle = strokeColor;\n              ctx.lineJoin = \"round\";\n            }\n            ctx.fillStyle = fontColor;\n            if (block.strokeWidth > 0) {\n              ctx.strokeText(block.text, x + width, y + block.vadjust);\n            }\n            ctx.fillText(block.text, x + width, y + block.vadjust);\n            width += block.width;\n          }\n          y += line.height;\n        }\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x\n     * @param {number} y\n     * @param {string} baseline\n     * @returns {Array.<number>}\n     * @private\n     */\n  }, {\n    key: \"_setAlignment\",\n    value: function _setAlignment(ctx, x, y, baseline) {\n      // check for label alignment (for edges)\n      // TODO: make alignment for nodes\n      if (this.isEdgeLabel && this.fontOptions.align !== \"horizontal\" && this.pointToSelf === false) {\n        x = 0;\n        y = 0;\n        var lineMargin = 2;\n        if (this.fontOptions.align === \"top\") {\n          ctx.textBaseline = \"alphabetic\";\n          y -= 2 * lineMargin; // distance from edge, required because we use alphabetic. Alphabetic has less difference between browsers\n        } else if (this.fontOptions.align === \"bottom\") {\n          ctx.textBaseline = \"hanging\";\n          y += 2 * lineMargin; // distance from edge, required because we use hanging. Hanging has less difference between browsers\n        } else {\n          ctx.textBaseline = \"middle\";\n        }\n      } else {\n        ctx.textBaseline = baseline;\n      }\n      return [x, y];\n    }\n\n    /**\n     * fade in when relative scale is between threshold and threshold - 1.\n     * If the relative scale would be smaller than threshold -1 the draw function would have returned before coming here.\n     *\n     * @param {string} color  The font color to use\n     * @param {number} viewFontSize\n     * @param {string} initialStrokeColor\n     * @returns {Array.<string>} An array containing the font color and stroke color\n     * @private\n     */\n  }, {\n    key: \"_getColor\",\n    value: function _getColor(color, viewFontSize, initialStrokeColor) {\n      var fontColor = color || \"#000000\";\n      var strokeColor = initialStrokeColor || \"#ffffff\";\n      if (viewFontSize <= this.elementOptions.scaling.label.drawThreshold) {\n        var opacity = Math.max(0, Math.min(1, 1 - (this.elementOptions.scaling.label.drawThreshold - viewFontSize)));\n        fontColor = overrideOpacity(fontColor, opacity);\n        strokeColor = overrideOpacity(strokeColor, opacity);\n      }\n      return [fontColor, strokeColor];\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @returns {{width: number, height: number}}\n     */\n  }, {\n    key: \"getTextSize\",\n    value: function getTextSize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      this._processLabel(ctx, selected, hover);\n      return {\n        width: this.size.width,\n        height: this.size.height,\n        lineCount: this.lineCount\n      };\n    }\n\n    /**\n     * Get the current dimensions of the label\n     *\n     * @returns {rect}\n     */\n  }, {\n    key: \"getSize\",\n    value: function getSize() {\n      var lineMargin = 2;\n      var x = this.size.left; // default values which might be overridden below\n      var y = this.size.top - 0.5 * lineMargin; // idem\n\n      if (this.isEdgeLabel) {\n        var x2 = -this.size.width * 0.5;\n        switch (this.fontOptions.align) {\n          case \"middle\":\n            x = x2;\n            y = -this.size.height * 0.5;\n            break;\n          case \"top\":\n            x = x2;\n            y = -(this.size.height + lineMargin);\n            break;\n          case \"bottom\":\n            x = x2;\n            y = lineMargin;\n            break;\n        }\n      }\n      var ret = {\n        left: x,\n        top: y,\n        width: this.size.width,\n        height: this.size.height\n      };\n      return ret;\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {'middle'|'hanging'} [baseline='middle']\n     */\n  }, {\n    key: \"calculateLabelSize\",\n    value: function calculateLabelSize(ctx, selected, hover) {\n      var x = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var y = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var baseline = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"middle\";\n      this._processLabel(ctx, selected, hover);\n      this.size.left = x - this.size.width * 0.5;\n      this.size.top = y - this.size.height * 0.5;\n      this.size.yLine = y + (1 - this.lineCount) * 0.5 * this.fontOptions.size;\n      if (baseline === \"hanging\") {\n        this.size.top += 0.5 * this.fontOptions.size;\n        this.size.top += 4; // distance from node, required because we use hanging. Hanging has less difference between browsers\n        this.size.yLine += 4; // distance from node\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {string} mod\n     * @returns {{color, size, face, mod, vadjust, strokeWidth: *, strokeColor: (*|string|allOptions.edges.font.strokeColor|{string}|allOptions.nodes.font.strokeColor|Array)}}\n     */\n  }, {\n    key: \"getFormattingValues\",\n    value: function getFormattingValues(ctx, selected, hover, mod) {\n      var getValue = function getValue(fontOptions, mod, option) {\n        if (mod === \"normal\") {\n          if (option === \"mod\") return \"\";\n          return fontOptions[option];\n        }\n        if (fontOptions[mod][option] !== undefined) {\n          // Grumbl leaving out test on undefined equals false for \"\"\n          return fontOptions[mod][option];\n        } else {\n          // Take from parent font option\n          return fontOptions[option];\n        }\n      };\n      var values = {\n        color: getValue(this.fontOptions, mod, \"color\"),\n        size: getValue(this.fontOptions, mod, \"size\"),\n        face: getValue(this.fontOptions, mod, \"face\"),\n        mod: getValue(this.fontOptions, mod, \"mod\"),\n        vadjust: getValue(this.fontOptions, mod, \"vadjust\"),\n        strokeWidth: this.fontOptions.strokeWidth,\n        strokeColor: this.fontOptions.strokeColor\n      };\n      if (selected || hover) {\n        if (mod === \"normal\" && this.fontOptions.chooser === true && this.elementOptions.labelHighlightBold) {\n          values.mod = \"bold\";\n        } else {\n          if (typeof this.fontOptions.chooser === \"function\") {\n            this.fontOptions.chooser(values, this.elementOptions.id, selected, hover);\n          }\n        }\n      }\n      var fontString = \"\";\n      if (values.mod !== undefined && values.mod !== \"\") {\n        // safeguard for undefined - this happened\n        fontString += values.mod + \" \";\n      }\n      fontString += values.size + \"px \" + values.face;\n      ctx.font = fontString.replace(/\"/g, \"\");\n      values.font = ctx.font;\n      values.height = values.size;\n      return values;\n    }\n\n    /**\n     *\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @returns {boolean}\n     */\n  }, {\n    key: \"differentState\",\n    value: function differentState(selected, hover) {\n      return selected !== this.selectedState || hover !== this.hoverState;\n    }\n\n    /**\n     * This explodes the passed text into lines and determines the width, height and number of lines.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {string} inText  the text to explode\n     * @returns {{width, height, lines}|*}\n     * @private\n     */\n  }, {\n    key: \"_processLabelText\",\n    value: function _processLabelText(ctx, selected, hover, inText) {\n      var splitter = new LabelSplitter(ctx, this, selected, hover);\n      return splitter.process(inText);\n    }\n\n    /**\n     * This explodes the label string into lines and sets the width, height and number of lines.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @private\n     */\n  }, {\n    key: \"_processLabel\",\n    value: function _processLabel(ctx, selected, hover) {\n      if (this.labelDirty === false && !this.differentState(selected, hover)) return;\n      var state = this._processLabelText(ctx, selected, hover, this.elementOptions.label);\n      if (this.fontOptions.minWdt > 0 && state.width < this.fontOptions.minWdt) {\n        state.width = this.fontOptions.minWdt;\n      }\n      this.size.labelHeight = state.height;\n      if (this.fontOptions.minHgt > 0 && state.height < this.fontOptions.minHgt) {\n        state.height = this.fontOptions.minHgt;\n      }\n      this.lines = state.lines;\n      this.lineCount = state.lines.length;\n      this.size.width = state.width;\n      this.size.height = state.height;\n      this.selectedState = selected;\n      this.hoverState = hover;\n      this.labelDirty = false;\n    }\n\n    /**\n     * Check if this label is visible\n     *\n     * @returns {boolean} true if this label will be show, false otherwise\n     */\n  }, {\n    key: \"visible\",\n    value: function visible() {\n      if (this.size.width === 0 || this.size.height === 0 || this.elementOptions.label === undefined) {\n        return false; // nothing to display\n      }\n\n      var viewFontSize = this.fontOptions.size * this.body.view.scale;\n      if (viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1) {\n        return false; // Too small or too far away to show\n      }\n\n      return true;\n    }\n  }], [{\n    key: \"parseFontString\",\n    value: function parseFontString(outOptions, inOptions) {\n      if (!inOptions || typeof inOptions !== \"string\") return false;\n      var newOptionsArray = inOptions.split(\" \");\n      outOptions.size = +newOptionsArray[0].replace(\"px\", \"\");\n      outOptions.face = newOptionsArray[1];\n      outOptions.color = newOptionsArray[2];\n      return true;\n    }\n  }]);\n  return Label;\n}();\n\nvar isConstructor = isConstructor$4;\nvar tryToString = tryToString$6;\n\nvar $TypeError$1 = TypeError;\n\n// `Assert: IsConstructor(argument) is true`\nvar aConstructor$1 = function (argument) {\n  if (isConstructor(argument)) return argument;\n  throw new $TypeError$1(tryToString(argument) + ' is not a constructor');\n};\n\nvar $$6 = _export;\nvar getBuiltIn = getBuiltIn$c;\nvar apply = functionApply;\nvar bind$3 = functionBind;\nvar aConstructor = aConstructor$1;\nvar anObject$2 = anObject$d;\nvar isObject$3 = isObject$j;\nvar create$3 = objectCreate;\nvar fails$2 = fails$w;\n\nvar nativeConstruct = getBuiltIn('Reflect', 'construct');\nvar ObjectPrototype = Object.prototype;\nvar push$1 = [].push;\n\n// `Reflect.construct` method\n// https://tc39.es/ecma262/#sec-reflect.construct\n// MS Edge supports only 2 arguments and argumentsList argument is optional\n// FF Nightly sets third argument as `new.target`, but does not create `this` from it\nvar NEW_TARGET_BUG = fails$2(function () {\n  function F() { /* empty */ }\n  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);\n});\n\nvar ARGS_BUG = !fails$2(function () {\n  nativeConstruct(function () { /* empty */ });\n});\n\nvar FORCED$3 = NEW_TARGET_BUG || ARGS_BUG;\n\n$$6({ target: 'Reflect', stat: true, forced: FORCED$3, sham: FORCED$3 }, {\n  construct: function construct(Target, args /* , newTarget */) {\n    aConstructor(Target);\n    anObject$2(args);\n    var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);\n    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);\n    if (Target === newTarget) {\n      // w/o altered newTarget, optimization for 0-4 arguments\n      switch (args.length) {\n        case 0: return new Target();\n        case 1: return new Target(args[0]);\n        case 2: return new Target(args[0], args[1]);\n        case 3: return new Target(args[0], args[1], args[2]);\n        case 4: return new Target(args[0], args[1], args[2], args[3]);\n      }\n      // w/o altered newTarget, lot of arguments case\n      var $args = [null];\n      apply(push$1, $args, args);\n      return new (apply(bind$3, Target, $args))();\n    }\n    // with altered newTarget, not support built-in constructors\n    var proto = newTarget.prototype;\n    var instance = create$3(isObject$3(proto) ? proto : ObjectPrototype);\n    var result = apply(Target, instance, args);\n    return isObject$3(result) ? result : instance;\n  }\n});\n\nvar path$6 = path$w;\n\nvar construct$2 = path$6.Reflect.construct;\n\nvar parent$k = construct$2;\n\nvar construct$1 = parent$k;\n\nvar construct = construct$1;\n\nvar _Reflect$construct = /*@__PURE__*/getDefaultExportFromCjs(construct);\n\nvar parent$j = create$6;\n\nvar create$2 = parent$j;\n\nvar parent$i = create$2;\n\nvar create$1 = parent$i;\n\nvar create = create$1;\n\nvar _Object$create = /*@__PURE__*/getDefaultExportFromCjs(create);\n\nvar $$5 = _export;\nvar setPrototypeOf$5 = objectSetPrototypeOf;\n\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n$$5({ target: 'Object', stat: true }, {\n  setPrototypeOf: setPrototypeOf$5\n});\n\nvar path$5 = path$w;\n\nvar setPrototypeOf$4 = path$5.Object.setPrototypeOf;\n\nvar parent$h = setPrototypeOf$4;\n\nvar setPrototypeOf$3 = parent$h;\n\nvar parent$g = setPrototypeOf$3;\n\nvar setPrototypeOf$2 = parent$g;\n\nvar parent$f = setPrototypeOf$2;\n\nvar setPrototypeOf$1 = parent$f;\n\nvar setPrototypeOf = setPrototypeOf$1;\n\nvar _Object$setPrototypeOf = /*@__PURE__*/getDefaultExportFromCjs(setPrototypeOf);\n\nvar parent$e = bind$9;\n\nvar bind$2 = parent$e;\n\nvar parent$d = bind$2;\n\nvar bind$1 = parent$d;\n\nvar bind = bind$1;\n\nvar _bindInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(bind);\n\nfunction _setPrototypeOf(o, p) {\n  var _context;\n  _setPrototypeOf = _Object$setPrototypeOf ? _bindInstanceProperty(_context = _Object$setPrototypeOf).call(_context) : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = _Object$create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  _Object$defineProperty$1(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\n\nvar parent$c = getPrototypeOf$5;\n\nvar getPrototypeOf$3 = parent$c;\n\nvar parent$b = getPrototypeOf$3;\n\nvar getPrototypeOf$2 = parent$b;\n\nvar getPrototypeOf$1 = getPrototypeOf$2;\n\nvar _Object$getPrototypeOf = /*@__PURE__*/getDefaultExportFromCjs(getPrototypeOf$1);\n\nfunction _getPrototypeOf(o) {\n  var _context;\n  _getPrototypeOf = _Object$setPrototypeOf ? _bindInstanceProperty(_context = _Object$getPrototypeOf).call(_context) : function _getPrototypeOf(o) {\n    return o.__proto__ || _Object$getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\n/**\n * The Base class for all Nodes.\n */\nvar NodeBase = /*#__PURE__*/function () {\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function NodeBase(options, body, labelModule) {\n    _classCallCheck(this, NodeBase);\n    this.body = body;\n    this.labelModule = labelModule;\n    this.setOptions(options);\n    this.top = undefined;\n    this.left = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this.radius = undefined;\n    this.margin = undefined;\n    this.refreshNeeded = true;\n    this.boundingBox = {\n      top: 0,\n      left: 0,\n      right: 0,\n      bottom: 0\n    };\n  }\n\n  /**\n   *\n   * @param {object} options\n   */\n  _createClass(NodeBase, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n    }\n\n    /**\n     *\n     * @param {Label} labelModule\n     * @private\n     */\n  }, {\n    key: \"_setMargins\",\n    value: function _setMargins(labelModule) {\n      this.margin = {};\n      if (this.options.margin) {\n        if (_typeof(this.options.margin) == \"object\") {\n          this.margin.top = this.options.margin.top;\n          this.margin.right = this.options.margin.right;\n          this.margin.bottom = this.options.margin.bottom;\n          this.margin.left = this.options.margin.left;\n        } else {\n          this.margin.top = this.options.margin;\n          this.margin.right = this.options.margin;\n          this.margin.bottom = this.options.margin;\n          this.margin.left = this.options.margin;\n        }\n      }\n      labelModule.adjustSizes(this.margin);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     * @private\n     */\n  }, {\n    key: \"_distanceToBorder\",\n    value: function _distanceToBorder(ctx, angle) {\n      var borderWidth = this.options.borderWidth;\n      if (ctx) {\n        this.resize(ctx);\n      }\n      return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"enableShadow\",\n    value: function enableShadow(ctx, values) {\n      if (values.shadow) {\n        ctx.shadowColor = values.shadowColor;\n        ctx.shadowBlur = values.shadowSize;\n        ctx.shadowOffsetX = values.shadowX;\n        ctx.shadowOffsetY = values.shadowY;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"disableShadow\",\n    value: function disableShadow(ctx, values) {\n      if (values.shadow) {\n        ctx.shadowColor = \"rgba(0,0,0,0)\";\n        ctx.shadowBlur = 0;\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 0;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"enableBorderDashes\",\n    value: function enableBorderDashes(ctx, values) {\n      if (values.borderDashes !== false) {\n        if (ctx.setLineDash !== undefined) {\n          var dashes = values.borderDashes;\n          if (dashes === true) {\n            dashes = [5, 15];\n          }\n          ctx.setLineDash(dashes);\n        } else {\n          console.warn(\"setLineDash is not supported in this browser. The dashed borders cannot be used.\");\n          this.options.shapeProperties.borderDashes = false;\n          values.borderDashes = false;\n        }\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"disableBorderDashes\",\n    value: function disableBorderDashes(ctx, values) {\n      if (values.borderDashes !== false) {\n        if (ctx.setLineDash !== undefined) {\n          ctx.setLineDash([0]);\n        } else {\n          console.warn(\"setLineDash is not supported in this browser. The dashed borders cannot be used.\");\n          this.options.shapeProperties.borderDashes = false;\n          values.borderDashes = false;\n        }\n      }\n    }\n\n    /**\n     * Determine if the shape of a node needs to be recalculated.\n     *\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @returns {boolean}\n     * @protected\n     */\n  }, {\n    key: \"needsRefresh\",\n    value: function needsRefresh(selected, hover) {\n      if (this.refreshNeeded === true) {\n        // This is probably not the best location to reset this member.\n        // However, in the current logic, it is the most convenient one.\n        this.refreshNeeded = false;\n        return true;\n      }\n      return this.width === undefined || this.labelModule.differentState(selected, hover);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"initContextForDraw\",\n    value: function initContextForDraw(ctx, values) {\n      var borderWidth = values.borderWidth / this.body.view.scale;\n      ctx.lineWidth = Math.min(this.width, borderWidth);\n      ctx.strokeStyle = values.borderColor;\n      ctx.fillStyle = values.color;\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"performStroke\",\n    value: function performStroke(ctx, values) {\n      var borderWidth = values.borderWidth / this.body.view.scale;\n\n      //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.\n      ctx.save();\n      // if borders are zero width, they will be drawn with width 1 by default. This prevents that\n      if (borderWidth > 0) {\n        this.enableBorderDashes(ctx, values);\n        //draw the border\n        ctx.stroke();\n        //disable dashed border for other elements\n        this.disableBorderDashes(ctx, values);\n      }\n      ctx.restore();\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"performFill\",\n    value: function performFill(ctx, values) {\n      ctx.save();\n      ctx.fillStyle = values.color;\n      // draw shadow if enabled\n      this.enableShadow(ctx, values);\n      // draw the background\n      _fillInstanceProperty(ctx).call(ctx);\n      // disable shadows for other elements.\n      this.disableShadow(ctx, values);\n      ctx.restore();\n      this.performStroke(ctx, values);\n    }\n\n    /**\n     *\n     * @param {number} margin\n     * @private\n     */\n  }, {\n    key: \"_addBoundingBoxMargin\",\n    value: function _addBoundingBoxMargin(margin) {\n      this.boundingBox.left -= margin;\n      this.boundingBox.top -= margin;\n      this.boundingBox.bottom += margin;\n      this.boundingBox.right += margin;\n    }\n\n    /**\n     * Actual implementation of this method call.\n     *\n     * Doing it like this makes it easier to override\n     * in the child classes.\n     *\n     * @param {number} x width\n     * @param {number} y height\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @private\n     */\n  }, {\n    key: \"_updateBoundingBox\",\n    value: function _updateBoundingBox(x, y, ctx, selected, hover) {\n      if (ctx !== undefined) {\n        this.resize(ctx, selected, hover);\n      }\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      this.boundingBox.left = this.left;\n      this.boundingBox.top = this.top;\n      this.boundingBox.bottom = this.top + this.height;\n      this.boundingBox.right = this.left + this.width;\n    }\n\n    /**\n     * Default implementation of this method call.\n     * This acts as a stub which can be overridden.\n     *\n     * @param {number} x width\n     * @param {number} y height\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     */\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y, ctx, selected, hover) {\n      this._updateBoundingBox(x, y, ctx, selected, hover);\n    }\n\n    /**\n     * Determine the dimensions to use for nodes with an internal label\n     *\n     * Currently, these are: Circle, Ellipse, Database, Box\n     * The other nodes have external labels, and will not call this method\n     *\n     * If there is no label, decent default values are supplied.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} [selected]\n     * @param {boolean} [hover]\n     * @returns {{width:number, height:number}}\n     */\n  }, {\n    key: \"getDimensionsFromLabel\",\n    value: function getDimensionsFromLabel(ctx, selected, hover) {\n      // NOTE: previously 'textSize' was not put in 'this' for Ellipse\n      // TODO: examine the consequences.\n      this.textSize = this.labelModule.getTextSize(ctx, selected, hover);\n      var width = this.textSize.width;\n      var height = this.textSize.height;\n      var DEFAULT_SIZE = 14;\n      if (width === 0) {\n        // This happens when there is no label text set\n        width = DEFAULT_SIZE; // use a decent default\n        height = DEFAULT_SIZE; // if width zero, then height also always zero\n      }\n\n      return {\n        width: width,\n        height: height\n      };\n    }\n  }]);\n  return NodeBase;\n}();\n\nfunction _createSuper$s(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$s(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$s() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A Box Node/Cluster shape.\n *\n * @augments NodeBase\n */\nvar Box$1 = /*#__PURE__*/function (_NodeBase) {\n  _inherits(Box, _NodeBase);\n  var _super = _createSuper$s(Box);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function Box(options, body, labelModule) {\n    var _this;\n    _classCallCheck(this, Box);\n    _this = _super.call(this, options, body, labelModule);\n    _this._setMargins(labelModule);\n    return _this;\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   */\n  _createClass(Box, [{\n    key: \"resize\",\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;\n      if (this.needsRefresh(selected, hover)) {\n        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);\n        this.width = dimensions.width + this.margin.right + this.margin.left;\n        this.height = dimensions.height + this.margin.top + this.margin.bottom;\n        this.radius = this.width / 2;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      this.initContextForDraw(ctx, values);\n      drawRoundRect(ctx, this.left, this.top, this.width, this.height, values.borderRadius);\n      this.performFill(ctx, values);\n      this.updateBoundingBox(x, y, ctx, selected, hover);\n      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);\n    }\n\n    /**\n     *\n     * @param {number} x width\n     * @param {number} y height\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     */\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y, ctx, selected, hover) {\n      this._updateBoundingBox(x, y, ctx, selected, hover);\n      var borderRadius = this.options.shapeProperties.borderRadius; // only effective for box\n      this._addBoundingBoxMargin(borderRadius);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      if (ctx) {\n        this.resize(ctx);\n      }\n      var borderWidth = this.options.borderWidth;\n      return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;\n    }\n  }]);\n  return Box;\n}(NodeBase);\n\nfunction _createSuper$r(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$r(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$r() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * NOTE: This is a bad base class\n *\n * Child classes are:\n *\n *   Image       - uses *only* image methods\n *   Circle      - uses *only* _drawRawCircle\n *   CircleImage - uses all\n *\n * TODO: Refactor, move _drawRawCircle to different module, derive Circle from NodeBase\n *       Rename this to ImageBase\n *       Consolidate common code in Image and CircleImage to base class\n *\n * @augments NodeBase\n */\nvar CircleImageBase = /*#__PURE__*/function (_NodeBase) {\n  _inherits(CircleImageBase, _NodeBase);\n  var _super = _createSuper$r(CircleImageBase);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function CircleImageBase(options, body, labelModule) {\n    var _this;\n    _classCallCheck(this, CircleImageBase);\n    _this = _super.call(this, options, body, labelModule);\n    _this.labelOffset = 0;\n    _this.selected = false;\n    return _this;\n  }\n\n  /**\n   *\n   * @param {object} options\n   * @param {object} [imageObj]\n   * @param {object} [imageObjAlt]\n   */\n  _createClass(CircleImageBase, [{\n    key: \"setOptions\",\n    value: function setOptions(options, imageObj, imageObjAlt) {\n      this.options = options;\n      if (!(imageObj === undefined && imageObjAlt === undefined)) {\n        this.setImages(imageObj, imageObjAlt);\n      }\n    }\n\n    /**\n     * Set the images for this node.\n     *\n     * The images can be updated after the initial setting of options;\n     * therefore, this method needs to be reentrant.\n     *\n     * For correct working in error cases, it is necessary to properly set\n     * field 'nodes.brokenImage' in the options.\n     *\n     * @param {Image} imageObj  required; main image to show for this node\n     * @param {Image|undefined} imageObjAlt optional; image to show when node is selected\n     */\n  }, {\n    key: \"setImages\",\n    value: function setImages(imageObj, imageObjAlt) {\n      if (imageObjAlt && this.selected) {\n        this.imageObj = imageObjAlt;\n        this.imageObjAlt = imageObj;\n      } else {\n        this.imageObj = imageObj;\n        this.imageObjAlt = imageObjAlt;\n      }\n    }\n\n    /**\n     * Set selection and switch between the base and the selected image.\n     *\n     * Do the switch only if imageObjAlt exists.\n     *\n     * @param {boolean} selected value of new selected state for current node\n     */\n  }, {\n    key: \"switchImages\",\n    value: function switchImages(selected) {\n      var selection_changed = selected && !this.selected || !selected && this.selected;\n      this.selected = selected; // Remember new selection\n\n      if (this.imageObjAlt !== undefined && selection_changed) {\n        var imageTmp = this.imageObj;\n        this.imageObj = this.imageObjAlt;\n        this.imageObjAlt = imageTmp;\n      }\n    }\n\n    /**\n     * Returns Image Padding from node options\n     *\n     * @returns {{top: number,left: number,bottom: number,right: number}} image padding inside this shape\n     * @private\n     */\n  }, {\n    key: \"_getImagePadding\",\n    value: function _getImagePadding() {\n      var imgPadding = {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      };\n      if (this.options.imagePadding) {\n        var optImgPadding = this.options.imagePadding;\n        if (_typeof(optImgPadding) == \"object\") {\n          imgPadding.top = optImgPadding.top;\n          imgPadding.right = optImgPadding.right;\n          imgPadding.bottom = optImgPadding.bottom;\n          imgPadding.left = optImgPadding.left;\n        } else {\n          imgPadding.top = optImgPadding;\n          imgPadding.right = optImgPadding;\n          imgPadding.bottom = optImgPadding;\n          imgPadding.left = optImgPadding;\n        }\n      }\n      return imgPadding;\n    }\n\n    /**\n     * Adjust the node dimensions for a loaded image.\n     *\n     * Pre: this.imageObj is valid\n     */\n  }, {\n    key: \"_resizeImage\",\n    value: function _resizeImage() {\n      var width, height;\n      if (this.options.shapeProperties.useImageSize === false) {\n        // Use the size property\n        var ratio_width = 1;\n        var ratio_height = 1;\n\n        // Only calculate the proper ratio if both width and height not zero\n        if (this.imageObj.width && this.imageObj.height) {\n          if (this.imageObj.width > this.imageObj.height) {\n            ratio_width = this.imageObj.width / this.imageObj.height;\n          } else {\n            ratio_height = this.imageObj.height / this.imageObj.width;\n          }\n        }\n        width = this.options.size * 2 * ratio_width;\n        height = this.options.size * 2 * ratio_height;\n      } else {\n        // Use the image size with image padding\n        var imgPadding = this._getImagePadding();\n        width = this.imageObj.width + imgPadding.left + imgPadding.right;\n        height = this.imageObj.height + imgPadding.top + imgPadding.bottom;\n      }\n      this.width = width;\n      this.height = height;\n      this.radius = 0.5 * this.width;\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {ArrowOptions} values\n     * @private\n     */\n  }, {\n    key: \"_drawRawCircle\",\n    value: function _drawRawCircle(ctx, x, y, values) {\n      this.initContextForDraw(ctx, values);\n      drawCircle(ctx, x, y, values.size);\n      this.performFill(ctx, values);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     * @private\n     */\n  }, {\n    key: \"_drawImageAtPosition\",\n    value: function _drawImageAtPosition(ctx, values) {\n      if (this.imageObj.width != 0) {\n        // draw the image\n        ctx.globalAlpha = values.opacity !== undefined ? values.opacity : 1;\n\n        // draw shadow if enabled\n        this.enableShadow(ctx, values);\n        var factor = 1;\n        if (this.options.shapeProperties.interpolation === true) {\n          factor = this.imageObj.width / this.width / this.body.view.scale;\n        }\n        var imgPadding = this._getImagePadding();\n        var imgPosLeft = this.left + imgPadding.left;\n        var imgPosTop = this.top + imgPadding.top;\n        var imgWidth = this.width - imgPadding.left - imgPadding.right;\n        var imgHeight = this.height - imgPadding.top - imgPadding.bottom;\n        this.imageObj.drawImageAtPosition(ctx, factor, imgPosLeft, imgPosTop, imgWidth, imgHeight);\n\n        // disable shadows for other elements.\n        this.disableShadow(ctx, values);\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @private\n     */\n  }, {\n    key: \"_drawImageLabel\",\n    value: function _drawImageLabel(ctx, x, y, selected, hover) {\n      var offset = 0;\n      if (this.height !== undefined) {\n        offset = this.height * 0.5;\n        var labelDimensions = this.labelModule.getTextSize(ctx, selected, hover);\n        if (labelDimensions.lineCount >= 1) {\n          offset += labelDimensions.height / 2;\n        }\n      }\n      var yLabel = y + offset;\n      if (this.options.label) {\n        this.labelOffset = offset;\n      }\n      this.labelModule.draw(ctx, x, yLabel, selected, hover, \"hanging\");\n    }\n  }]);\n  return CircleImageBase;\n}(NodeBase);\n\nfunction _createSuper$q(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$q(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$q() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A Circle Node/Cluster shape.\n *\n * @augments CircleImageBase\n */\nvar Circle$1 = /*#__PURE__*/function (_CircleImageBase) {\n  _inherits(Circle, _CircleImageBase);\n  var _super = _createSuper$q(Circle);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function Circle(options, body, labelModule) {\n    var _this;\n    _classCallCheck(this, Circle);\n    _this = _super.call(this, options, body, labelModule);\n    _this._setMargins(labelModule);\n    return _this;\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   */\n  _createClass(Circle, [{\n    key: \"resize\",\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;\n      if (this.needsRefresh(selected, hover)) {\n        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);\n        var diameter = Math.max(dimensions.width + this.margin.right + this.margin.left, dimensions.height + this.margin.top + this.margin.bottom);\n        this.options.size = diameter / 2; // NOTE: this size field only set here, not in Ellipse, Database, Box\n        this.width = diameter;\n        this.height = diameter;\n        this.radius = this.width / 2;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      this._drawRawCircle(ctx, x, y, values);\n      this.updateBoundingBox(x, y);\n      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, y, selected, hover);\n    }\n\n    /**\n     *\n     * @param {number} x width\n     * @param {number} y height\n     */\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y) {\n      this.boundingBox.top = y - this.options.size;\n      this.boundingBox.left = x - this.options.size;\n      this.boundingBox.right = x + this.options.size;\n      this.boundingBox.bottom = y + this.options.size;\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx) {\n      if (ctx) {\n        this.resize(ctx);\n      }\n      return this.width * 0.5;\n    }\n  }]);\n  return Circle;\n}(CircleImageBase);\n\nfunction _createSuper$p(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$p(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$p() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A CircularImage Node/Cluster shape.\n *\n * @augments CircleImageBase\n */\nvar CircularImage = /*#__PURE__*/function (_CircleImageBase) {\n  _inherits(CircularImage, _CircleImageBase);\n  var _super = _createSuper$p(CircularImage);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   * @param {Image} imageObj\n   * @param {Image} imageObjAlt\n   */\n  function CircularImage(options, body, labelModule, imageObj, imageObjAlt) {\n    var _this;\n    _classCallCheck(this, CircularImage);\n    _this = _super.call(this, options, body, labelModule);\n    _this.setImages(imageObj, imageObjAlt);\n    return _this;\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   */\n  _createClass(CircularImage, [{\n    key: \"resize\",\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;\n      var imageAbsent = this.imageObj.src === undefined || this.imageObj.width === undefined || this.imageObj.height === undefined;\n      if (imageAbsent) {\n        var diameter = this.options.size * 2;\n        this.width = diameter;\n        this.height = diameter;\n        this.radius = 0.5 * this.width;\n        return;\n      }\n\n      // At this point, an image is present, i.e. this.imageObj is valid.\n      if (this.needsRefresh(selected, hover)) {\n        this._resizeImage();\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.switchImages(selected);\n      this.resize();\n      var labelX = x,\n        labelY = y;\n      if (this.options.shapeProperties.coordinateOrigin === \"top-left\") {\n        this.left = x;\n        this.top = y;\n        labelX += this.width / 2;\n        labelY += this.height / 2;\n      } else {\n        this.left = x - this.width / 2;\n        this.top = y - this.height / 2;\n      }\n\n      // draw the background circle. IMPORTANT: the stroke in this method is used by the clip method below.\n      this._drawRawCircle(ctx, labelX, labelY, values);\n\n      // now we draw in the circle, we save so we can revert the clip operation after drawing.\n      ctx.save();\n      // clip is used to use the stroke in drawRawCircle as an area that we can draw in.\n      ctx.clip();\n      // draw the image\n      this._drawImageAtPosition(ctx, values);\n      // restore so we can again draw on the full canvas\n      ctx.restore();\n      this._drawImageLabel(ctx, labelX, labelY, selected, hover);\n      this.updateBoundingBox(x, y);\n    }\n\n    // TODO: compare with Circle.updateBoundingBox(), consolidate? More stuff is happening here\n    /**\n     *\n     * @param {number} x width\n     * @param {number} y height\n     */\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y) {\n      if (this.options.shapeProperties.coordinateOrigin === \"top-left\") {\n        this.boundingBox.top = y;\n        this.boundingBox.left = x;\n        this.boundingBox.right = x + this.options.size * 2;\n        this.boundingBox.bottom = y + this.options.size * 2;\n      } else {\n        this.boundingBox.top = y - this.options.size;\n        this.boundingBox.left = x - this.options.size;\n        this.boundingBox.right = x + this.options.size;\n        this.boundingBox.bottom = y + this.options.size;\n      }\n\n      // TODO: compare with Image.updateBoundingBox(), consolidate?\n      this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);\n      this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);\n      this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx) {\n      if (ctx) {\n        this.resize(ctx);\n      }\n      return this.width * 0.5;\n    }\n  }]);\n  return CircularImage;\n}(CircleImageBase);\n\nfunction _createSuper$o(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$o(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$o() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * Base class for constructing Node/Cluster Shapes.\n *\n * @augments NodeBase\n */\nvar ShapeBase = /*#__PURE__*/function (_NodeBase) {\n  _inherits(ShapeBase, _NodeBase);\n  var _super = _createSuper$o(ShapeBase);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function ShapeBase(options, body, labelModule) {\n    _classCallCheck(this, ShapeBase);\n    return _super.call(this, options, body, labelModule);\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   * @param {object} [values={size: this.options.size}]\n   */\n  _createClass(ShapeBase, [{\n    key: \"resize\",\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;\n      var values = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n        size: this.options.size\n      };\n      if (this.needsRefresh(selected, hover)) {\n        var _this$customSizeWidth, _this$customSizeHeigh;\n        this.labelModule.getTextSize(ctx, selected, hover);\n        var size = 2 * values.size;\n        this.width = (_this$customSizeWidth = this.customSizeWidth) !== null && _this$customSizeWidth !== void 0 ? _this$customSizeWidth : size;\n        this.height = (_this$customSizeHeigh = this.customSizeHeight) !== null && _this$customSizeHeigh !== void 0 ? _this$customSizeHeigh : size;\n        this.radius = 0.5 * this.width;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {string} shape\n     * @param {number} sizeMultiplier - Unused! TODO: Remove next major release\n     * @param {number} x\n     * @param {number} y\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     * @private\n     * @returns {object} Callbacks to draw later on higher layers.\n     */\n  }, {\n    key: \"_drawShape\",\n    value: function _drawShape(ctx, shape, sizeMultiplier, x, y, selected, hover, values) {\n      var _this = this;\n      this.resize(ctx, selected, hover, values);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      this.initContextForDraw(ctx, values);\n      getShape(shape)(ctx, x, y, values.size);\n      this.performFill(ctx, values);\n      if (this.options.icon !== undefined) {\n        if (this.options.icon.code !== undefined) {\n          ctx.font = (selected ? \"bold \" : \"\") + this.height / 2 + \"px \" + (this.options.icon.face || \"FontAwesome\");\n          ctx.fillStyle = this.options.icon.color || \"black\";\n          ctx.textAlign = \"center\";\n          ctx.textBaseline = \"middle\";\n          ctx.fillText(this.options.icon.code, x, y);\n        }\n      }\n      return {\n        drawExternalLabel: function drawExternalLabel() {\n          if (_this.options.label !== undefined) {\n            // Need to call following here in order to ensure value for\n            // `this.labelModule.size.height`.\n            _this.labelModule.calculateLabelSize(ctx, selected, hover, x, y, \"hanging\");\n            var yLabel = y + 0.5 * _this.height + 0.5 * _this.labelModule.size.height;\n            _this.labelModule.draw(ctx, x, yLabel, selected, hover, \"hanging\");\n          }\n          _this.updateBoundingBox(x, y);\n        }\n      };\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     */\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y) {\n      this.boundingBox.top = y - this.options.size;\n      this.boundingBox.left = x - this.options.size;\n      this.boundingBox.right = x + this.options.size;\n      this.boundingBox.bottom = y + this.options.size;\n      if (this.options.label !== undefined && this.labelModule.size.width > 0) {\n        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);\n        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);\n        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height);\n      }\n    }\n  }]);\n  return ShapeBase;\n}(NodeBase);\n\nfunction ownKeys$3(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = _filterInstanceProperty(o).call(o, function (r) { return _Object$getOwnPropertyDescriptor$1(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$3(e) { for (var r = 1; r < arguments.length; r++) { var _context, _context2; var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? _forEachInstanceProperty(_context = ownKeys$3(Object(t), !0)).call(_context, function (r) { _defineProperty(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context2 = ownKeys$3(Object(t))).call(_context2, function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor$1(t, r)); }); } return e; }\nfunction _createSuper$n(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$n(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$n() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A CustomShape Node/Cluster shape.\n *\n * @augments ShapeBase\n */\nvar CustomShape = /*#__PURE__*/function (_ShapeBase) {\n  _inherits(CustomShape, _ShapeBase);\n  var _super = _createSuper$n(CustomShape);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   * @param {Function} ctxRenderer\n   */\n  function CustomShape(options, body, labelModule, ctxRenderer) {\n    var _this;\n    _classCallCheck(this, CustomShape);\n    _this = _super.call(this, options, body, labelModule, ctxRenderer);\n    _this.ctxRenderer = ctxRenderer;\n    return _this;\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x width\n   * @param {number} y height\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   * @returns {object} Callbacks to draw later on different layers.\n   */\n  _createClass(CustomShape, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover, values);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n\n      // Guard right away because someone may just draw in the function itself.\n      ctx.save();\n      var drawLater = this.ctxRenderer({\n        ctx: ctx,\n        id: this.options.id,\n        x: x,\n        y: y,\n        state: {\n          selected: selected,\n          hover: hover\n        },\n        style: _objectSpread$3({}, values),\n        label: this.options.label\n      });\n      // Render the node shape bellow arrows.\n      if (drawLater.drawNode != null) {\n        drawLater.drawNode();\n      }\n      ctx.restore();\n      if (drawLater.drawExternalLabel) {\n        // Guard the external label (above arrows) drawing function.\n        var drawExternalLabel = drawLater.drawExternalLabel;\n        drawLater.drawExternalLabel = function () {\n          ctx.save();\n          drawExternalLabel();\n          ctx.restore();\n        };\n      }\n      if (drawLater.nodeDimensions) {\n        this.customSizeWidth = drawLater.nodeDimensions.width;\n        this.customSizeHeight = drawLater.nodeDimensions.height;\n      }\n      return drawLater;\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return CustomShape;\n}(ShapeBase);\n\nfunction _createSuper$m(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$m(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$m() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A Database Node/Cluster shape.\n *\n * @augments NodeBase\n */\nvar Database = /*#__PURE__*/function (_NodeBase) {\n  _inherits(Database, _NodeBase);\n  var _super = _createSuper$m(Database);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function Database(options, body, labelModule) {\n    var _this;\n    _classCallCheck(this, Database);\n    _this = _super.call(this, options, body, labelModule);\n    _this._setMargins(labelModule);\n    return _this;\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} selected\n   * @param {boolean} hover\n   */\n  _createClass(Database, [{\n    key: \"resize\",\n    value: function resize(ctx, selected, hover) {\n      if (this.needsRefresh(selected, hover)) {\n        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);\n        var size = dimensions.width + this.margin.right + this.margin.left;\n        this.width = size;\n        this.height = size;\n        this.radius = this.width / 2;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      this.initContextForDraw(ctx, values);\n      drawDatabase(ctx, x - this.width / 2, y - this.height / 2, this.width, this.height);\n      this.performFill(ctx, values);\n      this.updateBoundingBox(x, y, ctx, selected, hover);\n      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Database;\n}(NodeBase);\n\nfunction _createSuper$l(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$l(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$l() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A Diamond Node/Cluster shape.\n *\n * @augments ShapeBase\n */\nvar Diamond$1 = /*#__PURE__*/function (_ShapeBase) {\n  _inherits(Diamond, _ShapeBase);\n  var _super = _createSuper$l(Diamond);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function Diamond(options, body, labelModule) {\n    _classCallCheck(this, Diamond);\n    return _super.call(this, options, body, labelModule);\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x width\n   * @param {number} y height\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   * @returns {object} Callbacks to draw later on higher layers.\n   */\n  _createClass(Diamond, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      return this._drawShape(ctx, \"diamond\", 4, x, y, selected, hover, values);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Diamond;\n}(ShapeBase);\n\nfunction _createSuper$k(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$k(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$k() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A Dot Node/Cluster shape.\n *\n * @augments ShapeBase\n */\nvar Dot = /*#__PURE__*/function (_ShapeBase) {\n  _inherits(Dot, _ShapeBase);\n  var _super = _createSuper$k(Dot);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function Dot(options, body, labelModule) {\n    _classCallCheck(this, Dot);\n    return _super.call(this, options, body, labelModule);\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x width\n   * @param {number} y height\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   * @returns {object} Callbacks to draw later on higher layers.\n   */\n  _createClass(Dot, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      return this._drawShape(ctx, \"circle\", 2, x, y, selected, hover, values);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx) {\n      if (ctx) {\n        this.resize(ctx);\n      }\n      return this.options.size;\n    }\n  }]);\n  return Dot;\n}(ShapeBase);\n\nfunction _createSuper$j(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$j(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$j() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * Am Ellipse Node/Cluster shape.\n *\n * @augments NodeBase\n */\nvar Ellipse = /*#__PURE__*/function (_NodeBase) {\n  _inherits(Ellipse, _NodeBase);\n  var _super = _createSuper$j(Ellipse);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function Ellipse(options, body, labelModule) {\n    _classCallCheck(this, Ellipse);\n    return _super.call(this, options, body, labelModule);\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   */\n  _createClass(Ellipse, [{\n    key: \"resize\",\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;\n      if (this.needsRefresh(selected, hover)) {\n        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);\n        this.height = dimensions.height * 2;\n        this.width = dimensions.width + dimensions.height;\n        this.radius = 0.5 * this.width;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width * 0.5;\n      this.top = y - this.height * 0.5;\n      this.initContextForDraw(ctx, values);\n      drawEllipse(ctx, this.left, this.top, this.width, this.height);\n      this.performFill(ctx, values);\n      this.updateBoundingBox(x, y, ctx, selected, hover);\n      this.labelModule.draw(ctx, x, y, selected, hover);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      if (ctx) {\n        this.resize(ctx);\n      }\n      var a = this.width * 0.5;\n      var b = this.height * 0.5;\n      var w = Math.sin(angle) * a;\n      var h = Math.cos(angle) * b;\n      return a * b / Math.sqrt(w * w + h * h);\n    }\n  }]);\n  return Ellipse;\n}(NodeBase);\n\nfunction _createSuper$i(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$i(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$i() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * An icon replacement for the default Node shape.\n *\n * @augments NodeBase\n */\nvar Icon = /*#__PURE__*/function (_NodeBase) {\n  _inherits(Icon, _NodeBase);\n  var _super = _createSuper$i(Icon);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function Icon(options, body, labelModule) {\n    var _this;\n    _classCallCheck(this, Icon);\n    _this = _super.call(this, options, body, labelModule);\n    _this._setMargins(labelModule);\n    return _this;\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx - Unused.\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   */\n  _createClass(Icon, [{\n    key: \"resize\",\n    value: function resize(ctx, selected, hover) {\n      if (this.needsRefresh(selected, hover)) {\n        this.iconSize = {\n          width: Number(this.options.icon.size),\n          height: Number(this.options.icon.size)\n        };\n        this.width = this.iconSize.width + this.margin.right + this.margin.left;\n        this.height = this.iconSize.height + this.margin.top + this.margin.bottom;\n        this.radius = 0.5 * this.width;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     * @returns {object} Callbacks to draw later on higher layers.\n     */\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      var _this2 = this;\n      this.resize(ctx, selected, hover);\n      this.options.icon.size = this.options.icon.size || 50;\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      this._icon(ctx, x, y, selected, hover, values);\n      return {\n        drawExternalLabel: function drawExternalLabel() {\n          if (_this2.options.label !== undefined) {\n            var iconTextSpacing = 5;\n            _this2.labelModule.draw(ctx, _this2.left + _this2.iconSize.width / 2 + _this2.margin.left, y + _this2.height / 2 + iconTextSpacing, selected);\n          }\n          _this2.updateBoundingBox(x, y);\n        }\n      };\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     */\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y) {\n      this.boundingBox.top = y - this.options.icon.size * 0.5;\n      this.boundingBox.left = x - this.options.icon.size * 0.5;\n      this.boundingBox.right = x + this.options.icon.size * 0.5;\n      this.boundingBox.bottom = y + this.options.icon.size * 0.5;\n      if (this.options.label !== undefined && this.labelModule.size.width > 0) {\n        var iconTextSpacing = 5;\n        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);\n        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);\n        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height + iconTextSpacing);\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover - Unused\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"_icon\",\n    value: function _icon(ctx, x, y, selected, hover, values) {\n      var iconSize = Number(this.options.icon.size);\n      if (this.options.icon.code !== undefined) {\n        ctx.font = [this.options.icon.weight != null ? this.options.icon.weight : selected ? \"bold\" : \"\",\n        // If the weight is forced (for example to make Font Awesome 5 work\n        // properly) substitute slightly bigger size for bold font face.\n        (this.options.icon.weight != null && selected ? 5 : 0) + iconSize + \"px\", this.options.icon.face].join(\" \");\n\n        // draw icon\n        ctx.fillStyle = this.options.icon.color || \"black\";\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n\n        // draw shadow if enabled\n        this.enableShadow(ctx, values);\n        ctx.fillText(this.options.icon.code, x, y);\n\n        // disable shadows for other elements.\n        this.disableShadow(ctx, values);\n      } else {\n        console.error(\"When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.\");\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Icon;\n}(NodeBase);\n\nfunction _createSuper$h(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$h(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$h() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * An image-based replacement for the default Node shape.\n *\n * @augments CircleImageBase\n */\nvar Image$2 = /*#__PURE__*/function (_CircleImageBase) {\n  _inherits(Image, _CircleImageBase);\n  var _super = _createSuper$h(Image);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   * @param {Image} imageObj\n   * @param {Image} imageObjAlt\n   */\n  function Image(options, body, labelModule, imageObj, imageObjAlt) {\n    var _this;\n    _classCallCheck(this, Image);\n    _this = _super.call(this, options, body, labelModule);\n    _this.setImages(imageObj, imageObjAlt);\n    return _this;\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx - Unused.\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   */\n  _createClass(Image, [{\n    key: \"resize\",\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;\n      var imageAbsent = this.imageObj.src === undefined || this.imageObj.width === undefined || this.imageObj.height === undefined;\n      if (imageAbsent) {\n        var side = this.options.size * 2;\n        this.width = side;\n        this.height = side;\n        return;\n      }\n      if (this.needsRefresh(selected, hover)) {\n        this._resizeImage();\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      ctx.save();\n      this.switchImages(selected);\n      this.resize();\n      var labelX = x,\n        labelY = y;\n      if (this.options.shapeProperties.coordinateOrigin === \"top-left\") {\n        this.left = x;\n        this.top = y;\n        labelX += this.width / 2;\n        labelY += this.height / 2;\n      } else {\n        this.left = x - this.width / 2;\n        this.top = y - this.height / 2;\n      }\n      if (this.options.shapeProperties.useBorderWithImage === true) {\n        var neutralborderWidth = this.options.borderWidth;\n        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;\n        var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;\n        ctx.lineWidth = Math.min(this.width, borderWidth);\n        ctx.beginPath();\n        var strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;\n        var fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;\n        if (values.opacity !== undefined) {\n          strokeStyle = overrideOpacity(strokeStyle, values.opacity);\n          fillStyle = overrideOpacity(fillStyle, values.opacity);\n        }\n        // setup the line properties.\n        ctx.strokeStyle = strokeStyle;\n\n        // set a fillstyle\n        ctx.fillStyle = fillStyle;\n\n        // draw a rectangle to form the border around. This rectangle is filled so the opacity of a picture (in future vis releases?) can be used to tint the image\n        ctx.rect(this.left - 0.5 * ctx.lineWidth, this.top - 0.5 * ctx.lineWidth, this.width + ctx.lineWidth, this.height + ctx.lineWidth);\n        _fillInstanceProperty(ctx).call(ctx);\n        this.performStroke(ctx, values);\n        ctx.closePath();\n      }\n      this._drawImageAtPosition(ctx, values);\n      this._drawImageLabel(ctx, labelX, labelY, selected, hover);\n      this.updateBoundingBox(x, y);\n      ctx.restore();\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     */\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y) {\n      this.resize();\n      if (this.options.shapeProperties.coordinateOrigin === \"top-left\") {\n        this.left = x;\n        this.top = y;\n      } else {\n        this.left = x - this.width / 2;\n        this.top = y - this.height / 2;\n      }\n      this.boundingBox.left = this.left;\n      this.boundingBox.top = this.top;\n      this.boundingBox.bottom = this.top + this.height;\n      this.boundingBox.right = this.left + this.width;\n      if (this.options.label !== undefined && this.labelModule.size.width > 0) {\n        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);\n        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);\n        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Image;\n}(CircleImageBase);\n\nfunction _createSuper$g(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$g(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$g() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A Square Node/Cluster shape.\n *\n * @augments ShapeBase\n */\nvar Square = /*#__PURE__*/function (_ShapeBase) {\n  _inherits(Square, _ShapeBase);\n  var _super = _createSuper$g(Square);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function Square(options, body, labelModule) {\n    _classCallCheck(this, Square);\n    return _super.call(this, options, body, labelModule);\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x width\n   * @param {number} y height\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   * @returns {object} Callbacks to draw later on higher layers.\n   */\n  _createClass(Square, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      return this._drawShape(ctx, \"square\", 2, x, y, selected, hover, values);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Square;\n}(ShapeBase);\n\nfunction _createSuper$f(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$f(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$f() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A Hexagon Node/Cluster shape.\n *\n * @augments ShapeBase\n */\nvar Hexagon = /*#__PURE__*/function (_ShapeBase) {\n  _inherits(Hexagon, _ShapeBase);\n  var _super = _createSuper$f(Hexagon);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function Hexagon(options, body, labelModule) {\n    _classCallCheck(this, Hexagon);\n    return _super.call(this, options, body, labelModule);\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x width\n   * @param {number} y height\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   * @returns {object} Callbacks to draw later on higher layers.\n   */\n  _createClass(Hexagon, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      return this._drawShape(ctx, \"hexagon\", 4, x, y, selected, hover, values);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Hexagon;\n}(ShapeBase);\n\nfunction _createSuper$e(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$e(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$e() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A Star Node/Cluster shape.\n *\n * @augments ShapeBase\n */\nvar Star = /*#__PURE__*/function (_ShapeBase) {\n  _inherits(Star, _ShapeBase);\n  var _super = _createSuper$e(Star);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function Star(options, body, labelModule) {\n    _classCallCheck(this, Star);\n    return _super.call(this, options, body, labelModule);\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x width\n   * @param {number} y height\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   * @returns {object} Callbacks to draw later on higher layers.\n   */\n  _createClass(Star, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      return this._drawShape(ctx, \"star\", 4, x, y, selected, hover, values);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Star;\n}(ShapeBase);\n\nfunction _createSuper$d(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$d(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$d() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A text-based replacement for the default Node shape.\n *\n * @augments NodeBase\n */\nvar Text = /*#__PURE__*/function (_NodeBase) {\n  _inherits(Text, _NodeBase);\n  var _super = _createSuper$d(Text);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function Text(options, body, labelModule) {\n    var _this;\n    _classCallCheck(this, Text);\n    _this = _super.call(this, options, body, labelModule);\n    _this._setMargins(labelModule);\n    return _this;\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} selected\n   * @param {boolean} hover\n   */\n  _createClass(Text, [{\n    key: \"resize\",\n    value: function resize(ctx, selected, hover) {\n      if (this.needsRefresh(selected, hover)) {\n        this.textSize = this.labelModule.getTextSize(ctx, selected, hover);\n        this.width = this.textSize.width + this.margin.right + this.margin.left;\n        this.height = this.textSize.height + this.margin.top + this.margin.bottom;\n        this.radius = 0.5 * this.width;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n\n      // draw shadow if enabled\n      this.enableShadow(ctx, values);\n      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);\n\n      // disable shadows for other elements.\n      this.disableShadow(ctx, values);\n      this.updateBoundingBox(x, y, ctx, selected, hover);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Text;\n}(NodeBase);\n\nfunction _createSuper$c(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$c(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$c() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A Triangle Node/Cluster shape.\n *\n * @augments ShapeBase\n */\nvar Triangle$1 = /*#__PURE__*/function (_ShapeBase) {\n  _inherits(Triangle, _ShapeBase);\n  var _super = _createSuper$c(Triangle);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function Triangle(options, body, labelModule) {\n    _classCallCheck(this, Triangle);\n    return _super.call(this, options, body, labelModule);\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x\n   * @param {number} y\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   * @returns {object} Callbacks to draw later on higher layers.\n   */\n  _createClass(Triangle, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      return this._drawShape(ctx, \"triangle\", 3, x, y, selected, hover, values);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Triangle;\n}(ShapeBase);\n\nfunction _createSuper$b(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$b(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$b() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A downward facing Triangle Node/Cluster shape.\n *\n * @augments ShapeBase\n */\nvar TriangleDown = /*#__PURE__*/function (_ShapeBase) {\n  _inherits(TriangleDown, _ShapeBase);\n  var _super = _createSuper$b(TriangleDown);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function TriangleDown(options, body, labelModule) {\n    _classCallCheck(this, TriangleDown);\n    return _super.call(this, options, body, labelModule);\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x\n   * @param {number} y\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   * @returns {object} Callbacks to draw later on higher layers.\n   */\n  _createClass(TriangleDown, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      return this._drawShape(ctx, \"triangleDown\", 3, x, y, selected, hover, values);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return TriangleDown;\n}(ShapeBase);\n\nfunction ownKeys$2(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = _filterInstanceProperty(o).call(o, function (r) { return _Object$getOwnPropertyDescriptor$1(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var _context5, _context6; var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? _forEachInstanceProperty(_context5 = ownKeys$2(Object(t), !0)).call(_context5, function (r) { _defineProperty(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context6 = ownKeys$2(Object(t))).call(_context6, function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor$1(t, r)); }); } return e; }\n\n/**\n * A node. A node can be connected to other nodes via one or multiple edges.\n */\nvar Node = /*#__PURE__*/function () {\n  /**\n   *\n   * @param {object} options An object containing options for the node. All\n   *                            options are optional, except for the id.\n   *                              {number} id     Id of the node. Required\n   *                              {string} label  Text label for the node\n   *                              {number} x      Horizontal position of the node\n   *                              {number} y      Vertical position of the node\n   *                              {string} shape  Node shape\n   *                              {string} image  An image url\n   *                              {string} title  A title text, can be HTML\n   *                              {anytype} group A group name or number\n   * @param {object} body               Shared state of current network instance\n   * @param {Network.Images} imagelist  A list with images. Only needed when the node has an image\n   * @param {Groups} grouplist          A list with groups. Needed for retrieving group options\n   * @param {object} globalOptions      Current global node options; these serve as defaults for the node instance\n   * @param {object} defaultOptions     Global default options for nodes; note that this is also the prototype\n   *                                    for parameter `globalOptions`.\n   */\n  function Node(options, body, imagelist, grouplist, globalOptions, defaultOptions) {\n    _classCallCheck(this, Node);\n    this.options = bridgeObject(globalOptions);\n    this.globalOptions = globalOptions;\n    this.defaultOptions = defaultOptions;\n    this.body = body;\n    this.edges = []; // all edges connected to this node\n\n    // set defaults for the options\n    this.id = undefined;\n    this.imagelist = imagelist;\n    this.grouplist = grouplist;\n\n    // state options\n    this.x = undefined;\n    this.y = undefined;\n    this.baseSize = this.options.size;\n    this.baseFontSize = this.options.font.size;\n    this.predefinedPosition = false; // used to check if initial fit should just take the range or approximate\n    this.selected = false;\n    this.hover = false;\n    this.labelModule = new Label(this.body, this.options, false /* Not edge label */);\n\n    this.setOptions(options);\n  }\n\n  /**\n   * Attach a edge to the node\n   *\n   * @param {Edge} edge\n   */\n  _createClass(Node, [{\n    key: \"attachEdge\",\n    value: function attachEdge(edge) {\n      var _context;\n      if (_indexOfInstanceProperty(_context = this.edges).call(_context, edge) === -1) {\n        this.edges.push(edge);\n      }\n    }\n\n    /**\n     * Detach a edge from the node\n     *\n     * @param {Edge} edge\n     */\n  }, {\n    key: \"detachEdge\",\n    value: function detachEdge(edge) {\n      var _context2;\n      var index = _indexOfInstanceProperty(_context2 = this.edges).call(_context2, edge);\n      if (index != -1) {\n        var _context3;\n        _spliceInstanceProperty(_context3 = this.edges).call(_context3, index, 1);\n      }\n    }\n\n    /**\n     * Set or overwrite options for the node\n     *\n     * @param {object} options an object with options\n     * @returns {null|boolean}\n     */\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      var currentShape = this.options.shape;\n      if (!options) {\n        return; // Note that the return value will be 'undefined'! This is OK.\n      }\n\n      // Save the color for later.\n      // This is necessary in order to prevent local color from being overwritten by group color.\n      // TODO: To prevent such workarounds the way options are handled should be rewritten from scratch.\n      // This is not the only problem with current options handling.\n      if (typeof options.color !== \"undefined\") {\n        this._localColor = options.color;\n      }\n\n      // basic options\n      if (options.id !== undefined) {\n        this.id = options.id;\n      }\n      if (this.id === undefined) {\n        throw new Error(\"Node must have an id\");\n      }\n      Node.checkMass(options, this.id);\n\n      // set these options locally\n      // clear x and y positions\n      if (options.x !== undefined) {\n        if (options.x === null) {\n          this.x = undefined;\n          this.predefinedPosition = false;\n        } else {\n          this.x = _parseInt$1(options.x);\n          this.predefinedPosition = true;\n        }\n      }\n      if (options.y !== undefined) {\n        if (options.y === null) {\n          this.y = undefined;\n          this.predefinedPosition = false;\n        } else {\n          this.y = _parseInt$1(options.y);\n          this.predefinedPosition = true;\n        }\n      }\n      if (options.size !== undefined) {\n        this.baseSize = options.size;\n      }\n      if (options.value !== undefined) {\n        options.value = _parseFloat$1(options.value);\n      }\n\n      // this transforms all shorthands into fully defined options\n      Node.parseOptions(this.options, options, true, this.globalOptions, this.grouplist);\n      var pile = [options, this.options, this.defaultOptions];\n      this.chooser = choosify(\"node\", pile);\n      this._load_images();\n      this.updateLabelModule(options);\n\n      // Need to set local opacity after `this.updateLabelModule(options);` because `this.updateLabelModule(options);` overrites local opacity with group opacity\n      if (options.opacity !== undefined && Node.checkOpacity(options.opacity)) {\n        this.options.opacity = options.opacity;\n      }\n      this.updateShape(currentShape);\n      return options.hidden !== undefined || options.physics !== undefined;\n    }\n\n    /**\n     * Load the images from the options, for the nodes that need them.\n     *\n     * Images are always loaded, even if they are not used in the current shape.\n     * The user may switch to an image shape later on.\n     *\n     * @private\n     */\n  }, {\n    key: \"_load_images\",\n    value: function _load_images() {\n      if (this.options.shape === \"circularImage\" || this.options.shape === \"image\") {\n        if (this.options.image === undefined) {\n          throw new Error(\"Option image must be defined for node type '\" + this.options.shape + \"'\");\n        }\n      }\n      if (this.options.image === undefined) {\n        return;\n      }\n      if (this.imagelist === undefined) {\n        throw new Error(\"Internal Error: No images provided\");\n      }\n      if (typeof this.options.image === \"string\") {\n        this.imageObj = this.imagelist.load(this.options.image, this.options.brokenImage, this.id);\n      } else {\n        if (this.options.image.unselected === undefined) {\n          throw new Error(\"No unselected image provided\");\n        }\n        this.imageObj = this.imagelist.load(this.options.image.unselected, this.options.brokenImage, this.id);\n        if (this.options.image.selected !== undefined) {\n          this.imageObjAlt = this.imagelist.load(this.options.image.selected, this.options.brokenImage, this.id);\n        } else {\n          this.imageObjAlt = undefined;\n        }\n      }\n    }\n\n    /**\n     * Check that opacity is only between 0 and 1\n     *\n     * @param {number} opacity\n     * @returns {boolean}\n     */\n  }, {\n    key: \"getFormattingValues\",\n    value:\n    /**\n     *\n     * @returns {{color: *, borderWidth: *, borderColor: *, size: *, borderDashes: (boolean|Array|allOptions.nodes.shapeProperties.borderDashes|{boolean, array}), borderRadius: (number|allOptions.nodes.shapeProperties.borderRadius|{number}|Array), shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *}}\n     */\n    function getFormattingValues() {\n      var values = {\n        color: this.options.color.background,\n        opacity: this.options.opacity,\n        borderWidth: this.options.borderWidth,\n        borderColor: this.options.color.border,\n        size: this.options.size,\n        borderDashes: this.options.shapeProperties.borderDashes,\n        borderRadius: this.options.shapeProperties.borderRadius,\n        shadow: this.options.shadow.enabled,\n        shadowColor: this.options.shadow.color,\n        shadowSize: this.options.shadow.size,\n        shadowX: this.options.shadow.x,\n        shadowY: this.options.shadow.y\n      };\n      if (this.selected || this.hover) {\n        if (this.chooser === true) {\n          if (this.selected) {\n            if (this.options.borderWidthSelected != null) {\n              values.borderWidth = this.options.borderWidthSelected;\n            } else {\n              values.borderWidth *= 2;\n            }\n            values.color = this.options.color.highlight.background;\n            values.borderColor = this.options.color.highlight.border;\n            values.shadow = this.options.shadow.enabled;\n          } else if (this.hover) {\n            values.color = this.options.color.hover.background;\n            values.borderColor = this.options.color.hover.border;\n            values.shadow = this.options.shadow.enabled;\n          }\n        } else if (typeof this.chooser === \"function\") {\n          this.chooser(values, this.options.id, this.selected, this.hover);\n          if (values.shadow === false) {\n            if (values.shadowColor !== this.options.shadow.color || values.shadowSize !== this.options.shadow.size || values.shadowX !== this.options.shadow.x || values.shadowY !== this.options.shadow.y) {\n              values.shadow = true;\n            }\n          }\n        }\n      } else {\n        values.shadow = this.options.shadow.enabled;\n      }\n      if (this.options.opacity !== undefined) {\n        var opacity = this.options.opacity;\n        values.borderColor = overrideOpacity(values.borderColor, opacity);\n        values.color = overrideOpacity(values.color, opacity);\n        values.shadowColor = overrideOpacity(values.shadowColor, opacity);\n      }\n      return values;\n    }\n\n    /**\n     *\n     * @param {object} options\n     */\n  }, {\n    key: \"updateLabelModule\",\n    value: function updateLabelModule(options) {\n      if (this.options.label === undefined || this.options.label === null) {\n        this.options.label = \"\";\n      }\n      Node.updateGroupOptions(this.options, _objectSpread$2(_objectSpread$2({}, options), {}, {\n        color: options && options.color || this._localColor || undefined\n      }), this.grouplist);\n\n      //\n      // Note:The prototype chain for this.options is:\n      //\n      // this.options ->    NodesHandler.options    -> NodesHandler.defaultOptions\n      //                 (also: this.globalOptions)\n      //\n      // Note that the prototypes are mentioned explicitly in the pile list below;\n      // WE DON'T WANT THE ORDER OF THE PROTOTYPES!!!! At least, not for font handling of labels.\n      // This is a good indication that the prototype usage of options is deficient.\n      //\n      var currentGroup = this.grouplist.get(this.options.group, false);\n      var pile = [options,\n      // new options\n      this.options,\n      // current node options, see comment above for prototype\n      currentGroup,\n      // group options, if any\n      this.globalOptions,\n      // Currently set global node options\n      this.defaultOptions // Default global node options\n      ];\n\n      this.labelModule.update(this.options, pile);\n      if (this.labelModule.baseSize !== undefined) {\n        this.baseFontSize = this.labelModule.baseSize;\n      }\n    }\n\n    /**\n     *\n     * @param {string} currentShape\n     */\n  }, {\n    key: \"updateShape\",\n    value: function updateShape(currentShape) {\n      if (currentShape === this.options.shape && this.shape) {\n        this.shape.setOptions(this.options, this.imageObj, this.imageObjAlt);\n      } else {\n        // choose draw method depending on the shape\n        switch (this.options.shape) {\n          case \"box\":\n            this.shape = new Box$1(this.options, this.body, this.labelModule);\n            break;\n          case \"circle\":\n            this.shape = new Circle$1(this.options, this.body, this.labelModule);\n            break;\n          case \"circularImage\":\n            this.shape = new CircularImage(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);\n            break;\n          case \"custom\":\n            this.shape = new CustomShape(this.options, this.body, this.labelModule, this.options.ctxRenderer);\n            break;\n          case \"database\":\n            this.shape = new Database(this.options, this.body, this.labelModule);\n            break;\n          case \"diamond\":\n            this.shape = new Diamond$1(this.options, this.body, this.labelModule);\n            break;\n          case \"dot\":\n            this.shape = new Dot(this.options, this.body, this.labelModule);\n            break;\n          case \"ellipse\":\n            this.shape = new Ellipse(this.options, this.body, this.labelModule);\n            break;\n          case \"icon\":\n            this.shape = new Icon(this.options, this.body, this.labelModule);\n            break;\n          case \"image\":\n            this.shape = new Image$2(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);\n            break;\n          case \"square\":\n            this.shape = new Square(this.options, this.body, this.labelModule);\n            break;\n          case \"hexagon\":\n            this.shape = new Hexagon(this.options, this.body, this.labelModule);\n            break;\n          case \"star\":\n            this.shape = new Star(this.options, this.body, this.labelModule);\n            break;\n          case \"text\":\n            this.shape = new Text(this.options, this.body, this.labelModule);\n            break;\n          case \"triangle\":\n            this.shape = new Triangle$1(this.options, this.body, this.labelModule);\n            break;\n          case \"triangleDown\":\n            this.shape = new TriangleDown(this.options, this.body, this.labelModule);\n            break;\n          default:\n            this.shape = new Ellipse(this.options, this.body, this.labelModule);\n            break;\n        }\n      }\n      this.needsRefresh();\n    }\n\n    /**\n     * select this node\n     */\n  }, {\n    key: \"select\",\n    value: function select() {\n      this.selected = true;\n      this.needsRefresh();\n    }\n\n    /**\n     * unselect this node\n     */\n  }, {\n    key: \"unselect\",\n    value: function unselect() {\n      this.selected = false;\n      this.needsRefresh();\n    }\n\n    /**\n     * Reset the calculated size of the node, forces it to recalculate its size\n     */\n  }, {\n    key: \"needsRefresh\",\n    value: function needsRefresh() {\n      this.shape.refreshNeeded = true;\n    }\n\n    /**\n     * get the title of this node.\n     *\n     * @returns {string} title    The title of the node, or undefined when no title\n     *                           has been set.\n     */\n  }, {\n    key: \"getTitle\",\n    value: function getTitle() {\n      return this.options.title;\n    }\n\n    /**\n     * Calculate the distance to the border of the Node\n     *\n     * @param {CanvasRenderingContext2D}   ctx\n     * @param {number} angle        Angle in radians\n     * @returns {number} distance   Distance to the border in pixels\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this.shape.distanceToBorder(ctx, angle);\n    }\n\n    /**\n     * Check if this node has a fixed x and y position\n     *\n     * @returns {boolean}      true if fixed, false if not\n     */\n  }, {\n    key: \"isFixed\",\n    value: function isFixed() {\n      return this.options.fixed.x && this.options.fixed.y;\n    }\n\n    /**\n     * check if this node is selecte\n     *\n     * @returns {boolean} selected   True if node is selected, else false\n     */\n  }, {\n    key: \"isSelected\",\n    value: function isSelected() {\n      return this.selected;\n    }\n\n    /**\n     * Retrieve the value of the node. Can be undefined\n     *\n     * @returns {number} value\n     */\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.options.value;\n    }\n\n    /**\n     * Get the current dimensions of the label\n     *\n     * @returns {rect}\n     */\n  }, {\n    key: \"getLabelSize\",\n    value: function getLabelSize() {\n      return this.labelModule.size();\n    }\n\n    /**\n     * Adjust the value range of the node. The node will adjust it's size\n     * based on its value.\n     *\n     * @param {number} min\n     * @param {number} max\n     * @param {number} total\n     */\n  }, {\n    key: \"setValueRange\",\n    value: function setValueRange(min, max, total) {\n      if (this.options.value !== undefined) {\n        var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);\n        var sizeDiff = this.options.scaling.max - this.options.scaling.min;\n        if (this.options.scaling.label.enabled === true) {\n          var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;\n          this.options.font.size = this.options.scaling.label.min + scale * fontDiff;\n        }\n        this.options.size = this.options.scaling.min + scale * sizeDiff;\n      } else {\n        this.options.size = this.baseSize;\n        this.options.font.size = this.baseFontSize;\n      }\n      this.updateLabelModule();\n    }\n\n    /**\n     * Draw this node in the given canvas\n     * The 2d context of a HTML canvas can be retrieved by canvas.getContext(\"2d\");\n     *\n     * @param {CanvasRenderingContext2D}   ctx\n     * @returns {object} Callbacks to draw later on higher layers.\n     */\n  }, {\n    key: \"draw\",\n    value: function draw(ctx) {\n      var values = this.getFormattingValues();\n      return this.shape.draw(ctx, this.x, this.y, this.selected, this.hover, values) || {};\n    }\n\n    /**\n     * Update the bounding box of the shape\n     *\n     * @param {CanvasRenderingContext2D}   ctx\n     */\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(ctx) {\n      this.shape.updateBoundingBox(this.x, this.y, ctx);\n    }\n\n    /**\n     * Recalculate the size of this node in the given canvas\n     * The 2d context of a HTML canvas can be retrieved by canvas.getContext(\"2d\");\n     *\n     * @param {CanvasRenderingContext2D}   ctx\n     */\n  }, {\n    key: \"resize\",\n    value: function resize(ctx) {\n      var values = this.getFormattingValues();\n      this.shape.resize(ctx, this.selected, this.hover, values);\n    }\n\n    /**\n     * Determine all visual elements of this node instance, in which the given\n     * point falls within the bounding shape.\n     *\n     * @param {point} point\n     * @returns {Array.<nodeClickItem|nodeLabelClickItem>} list with the items which are on the point\n     */\n  }, {\n    key: \"getItemsOnPoint\",\n    value: function getItemsOnPoint(point) {\n      var ret = [];\n      if (this.labelModule.visible()) {\n        if (pointInRect(this.labelModule.getSize(), point)) {\n          ret.push({\n            nodeId: this.id,\n            labelId: 0\n          });\n        }\n      }\n      if (pointInRect(this.shape.boundingBox, point)) {\n        ret.push({\n          nodeId: this.id\n        });\n      }\n      return ret;\n    }\n\n    /**\n     * Check if this object is overlapping with the provided object\n     *\n     * @param {object} obj   an object with parameters left, top, right, bottom\n     * @returns {boolean}     True if location is located on node\n     */\n  }, {\n    key: \"isOverlappingWith\",\n    value: function isOverlappingWith(obj) {\n      return this.shape.left < obj.right && this.shape.left + this.shape.width > obj.left && this.shape.top < obj.bottom && this.shape.top + this.shape.height > obj.top;\n    }\n\n    /**\n     * Check if this object is overlapping with the provided object\n     *\n     * @param {object} obj   an object with parameters left, top, right, bottom\n     * @returns {boolean}     True if location is located on node\n     */\n  }, {\n    key: \"isBoundingBoxOverlappingWith\",\n    value: function isBoundingBoxOverlappingWith(obj) {\n      return this.shape.boundingBox.left < obj.right && this.shape.boundingBox.right > obj.left && this.shape.boundingBox.top < obj.bottom && this.shape.boundingBox.bottom > obj.top;\n    }\n\n    /**\n     * Check valid values for mass\n     *\n     * The mass may not be negative or zero. If it is, reset to 1\n     *\n     * @param {object} options\n     * @param {Node.id} id\n     * @static\n     */\n  }], [{\n    key: \"checkOpacity\",\n    value: function checkOpacity(opacity) {\n      return 0 <= opacity && opacity <= 1;\n    }\n\n    /**\n     * Check that origin is 'center' or 'top-left'\n     *\n     * @param {string} origin\n     * @returns {boolean}\n     */\n  }, {\n    key: \"checkCoordinateOrigin\",\n    value: function checkCoordinateOrigin(origin) {\n      return origin === undefined || origin === \"center\" || origin === \"top-left\";\n    }\n\n    /**\n     * Copy group option values into the node options.\n     *\n     * The group options override the global node options, so the copy of group options\n     *  must happen *after* the global node options have been set.\n     *\n     * This method must also be called also if the global node options have changed and the group options did not.\n     *\n     * @param {object} parentOptions\n     * @param {object} newOptions  new values for the options, currently only passed in for check\n     * @param {object} groupList\n     */\n  }, {\n    key: \"updateGroupOptions\",\n    value: function updateGroupOptions(parentOptions, newOptions, groupList) {\n      var _context4;\n      if (groupList === undefined) return; // No groups, nothing to do\n\n      var group = parentOptions.group;\n\n      // paranoia: the selected group is already merged into node options, check.\n      if (newOptions !== undefined && newOptions.group !== undefined && group !== newOptions.group) {\n        throw new Error(\"updateGroupOptions: group values in options don't match.\");\n      }\n      var hasGroup = typeof group === \"number\" || typeof group === \"string\" && group != \"\";\n      if (!hasGroup) return; // current node has no group, no need to merge\n\n      var groupObj = groupList.get(group);\n      if (groupObj.opacity !== undefined && newOptions.opacity === undefined) {\n        if (!Node.checkOpacity(groupObj.opacity)) {\n          console.error(\"Invalid option for node opacity. Value must be between 0 and 1, found: \" + groupObj.opacity);\n          groupObj.opacity = undefined;\n        }\n      }\n\n      // Skip any new option to avoid them being overridden by the group options.\n      var skipProperties = _filterInstanceProperty(_context4 = _Object$getOwnPropertyNames(newOptions)).call(_context4, function (p) {\n        return newOptions[p] != null;\n      });\n      // Always skip merging group font options into parent; these are required to be distinct for labels\n      skipProperties.push(\"font\");\n      selectiveNotDeepExtend(skipProperties, parentOptions, groupObj);\n\n      // the color object needs to be completely defined.\n      // Since groups can partially overwrite the colors, we parse it again, just in case.\n      parentOptions.color = parseColor(parentOptions.color);\n    }\n\n    /**\n     * This process all possible shorthands in the new options and makes sure that the parentOptions are fully defined.\n     * Static so it can also be used by the handler.\n     *\n     * @param {object} parentOptions\n     * @param {object} newOptions\n     * @param {boolean} [allowDeletion=false]\n     * @param {object} [globalOptions={}]\n     * @param {object} [groupList]\n     * @static\n     */\n  }, {\n    key: \"parseOptions\",\n    value: function parseOptions(parentOptions, newOptions) {\n      var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var groupList = arguments.length > 4 ? arguments[4] : undefined;\n      var fields = [\"color\", \"fixed\", \"shadow\"];\n      selectiveNotDeepExtend(fields, parentOptions, newOptions, allowDeletion);\n      Node.checkMass(newOptions);\n      if (parentOptions.opacity !== undefined) {\n        if (!Node.checkOpacity(parentOptions.opacity)) {\n          console.error(\"Invalid option for node opacity. Value must be between 0 and 1, found: \" + parentOptions.opacity);\n          parentOptions.opacity = undefined;\n        }\n      }\n      if (newOptions.opacity !== undefined) {\n        if (!Node.checkOpacity(newOptions.opacity)) {\n          console.error(\"Invalid option for node opacity. Value must be between 0 and 1, found: \" + newOptions.opacity);\n          newOptions.opacity = undefined;\n        }\n      }\n      if (newOptions.shapeProperties && !Node.checkCoordinateOrigin(newOptions.shapeProperties.coordinateOrigin)) {\n        console.error(\"Invalid option for node coordinateOrigin, found: \" + newOptions.shapeProperties.coordinateOrigin);\n      }\n\n      // merge the shadow options into the parent.\n      mergeOptions(parentOptions, newOptions, \"shadow\", globalOptions);\n\n      // individual shape newOptions\n      if (newOptions.color !== undefined && newOptions.color !== null) {\n        var parsedColor = parseColor(newOptions.color);\n        fillIfDefined(parentOptions.color, parsedColor);\n      } else if (allowDeletion === true && newOptions.color === null) {\n        parentOptions.color = bridgeObject(globalOptions.color); // set the object back to the global options\n      }\n\n      // handle the fixed options\n      if (newOptions.fixed !== undefined && newOptions.fixed !== null) {\n        if (typeof newOptions.fixed === \"boolean\") {\n          parentOptions.fixed.x = newOptions.fixed;\n          parentOptions.fixed.y = newOptions.fixed;\n        } else {\n          if (newOptions.fixed.x !== undefined && typeof newOptions.fixed.x === \"boolean\") {\n            parentOptions.fixed.x = newOptions.fixed.x;\n          }\n          if (newOptions.fixed.y !== undefined && typeof newOptions.fixed.y === \"boolean\") {\n            parentOptions.fixed.y = newOptions.fixed.y;\n          }\n        }\n      }\n      if (allowDeletion === true && newOptions.font === null) {\n        parentOptions.font = bridgeObject(globalOptions.font); // set the object back to the global options\n      }\n\n      Node.updateGroupOptions(parentOptions, newOptions, groupList);\n\n      // handle the scaling options, specifically the label part\n      if (newOptions.scaling !== undefined) {\n        mergeOptions(parentOptions.scaling, newOptions.scaling, \"label\", globalOptions.scaling);\n      }\n    }\n  }, {\n    key: \"checkMass\",\n    value: function checkMass(options, id) {\n      if (options.mass !== undefined && options.mass <= 0) {\n        var strId = \"\";\n        if (id !== undefined) {\n          strId = \" in node id: \" + id;\n        }\n        console.error(\"%cNegative or zero mass disallowed\" + strId + \", setting mass to 1.\", VALIDATOR_PRINT_STYLE);\n        options.mass = 1;\n      }\n    }\n  }]);\n  return Node;\n}();\n\nfunction _createForOfIteratorHelper$5(o, allowArrayLike) { var it = typeof _Symbol !== \"undefined\" && _getIteratorMethod(o) || o[\"@@iterator\"]; if (!it) { if (_Array$isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$5(o, minLen) { var _context4; if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$5(o, minLen); var n = _sliceInstanceProperty(_context4 = Object.prototype.toString.call(o)).call(_context4, 8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return _Array$from$1(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen); }\nfunction _arrayLikeToArray$5(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n/**\n * Handler for Nodes\n */\nvar NodesHandler = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {Images} images\n   * @param {Array.<Group>} groups\n   * @param {LayoutEngine} layoutEngine\n   */\n  function NodesHandler(body, images, groups, layoutEngine) {\n    var _context,\n      _this = this;\n    _classCallCheck(this, NodesHandler);\n    this.body = body;\n    this.images = images;\n    this.groups = groups;\n    this.layoutEngine = layoutEngine;\n\n    // create the node API in the body container\n    this.body.functions.createNode = _bindInstanceProperty$1(_context = this.create).call(_context, this);\n    this.nodesListeners = {\n      add: function add(event, params) {\n        _this.add(params.items);\n      },\n      update: function update(event, params) {\n        _this.update(params.items, params.data, params.oldData);\n      },\n      remove: function remove(event, params) {\n        _this.remove(params.items);\n      }\n    };\n    this.defaultOptions = {\n      borderWidth: 1,\n      borderWidthSelected: undefined,\n      brokenImage: undefined,\n      color: {\n        border: \"#2B7CE9\",\n        background: \"#97C2FC\",\n        highlight: {\n          border: \"#2B7CE9\",\n          background: \"#D2E5FF\"\n        },\n        hover: {\n          border: \"#2B7CE9\",\n          background: \"#D2E5FF\"\n        }\n      },\n      opacity: undefined,\n      // number between 0 and 1\n      fixed: {\n        x: false,\n        y: false\n      },\n      font: {\n        color: \"#343434\",\n        size: 14,\n        // px\n        face: \"arial\",\n        background: \"none\",\n        strokeWidth: 0,\n        // px\n        strokeColor: \"#ffffff\",\n        align: \"center\",\n        vadjust: 0,\n        multi: false,\n        bold: {\n          mod: \"bold\"\n        },\n        boldital: {\n          mod: \"bold italic\"\n        },\n        ital: {\n          mod: \"italic\"\n        },\n        mono: {\n          mod: \"\",\n          size: 15,\n          // px\n          face: \"monospace\",\n          vadjust: 2\n        }\n      },\n      group: undefined,\n      hidden: false,\n      icon: {\n        face: \"FontAwesome\",\n        //'FontAwesome',\n        code: undefined,\n        //'\\uf007',\n        size: 50,\n        //50,\n        color: \"#2B7CE9\" //'#aa00ff'\n      },\n\n      image: undefined,\n      // --> URL\n      imagePadding: {\n        // only for image shape\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      },\n      label: undefined,\n      labelHighlightBold: true,\n      level: undefined,\n      margin: {\n        top: 5,\n        right: 5,\n        bottom: 5,\n        left: 5\n      },\n      mass: 1,\n      physics: true,\n      scaling: {\n        min: 10,\n        max: 30,\n        label: {\n          enabled: false,\n          min: 14,\n          max: 30,\n          maxVisible: 30,\n          drawThreshold: 5\n        },\n        customScalingFunction: function customScalingFunction(min, max, total, value) {\n          if (max === min) {\n            return 0.5;\n          } else {\n            var scale = 1 / (max - min);\n            return Math.max(0, (value - min) * scale);\n          }\n        }\n      },\n      shadow: {\n        enabled: false,\n        color: \"rgba(0,0,0,0.5)\",\n        size: 10,\n        x: 5,\n        y: 5\n      },\n      shape: \"ellipse\",\n      shapeProperties: {\n        borderDashes: false,\n        // only for borders\n        borderRadius: 6,\n        // only for box shape\n        interpolation: true,\n        // only for image and circularImage shapes\n        useImageSize: false,\n        // only for image and circularImage shapes\n        useBorderWithImage: false,\n        // only for image shape\n        coordinateOrigin: \"center\" // only for image and circularImage shapes\n      },\n\n      size: 25,\n      title: undefined,\n      value: undefined,\n      x: undefined,\n      y: undefined\n    };\n\n    // Protect from idiocy\n    if (this.defaultOptions.mass <= 0) {\n      throw \"Internal error: mass in defaultOptions of NodesHandler may not be zero or negative\";\n    }\n    this.options = bridgeObject(this.defaultOptions);\n    this.bindEventListeners();\n  }\n\n  /**\n   * Binds event listeners\n   */\n  _createClass(NodesHandler, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _context2,\n        _context3,\n        _this2 = this;\n      // refresh the nodes. Used when reverting from hierarchical layout\n      this.body.emitter.on(\"refreshNodes\", _bindInstanceProperty$1(_context2 = this.refresh).call(_context2, this));\n      this.body.emitter.on(\"refresh\", _bindInstanceProperty$1(_context3 = this.refresh).call(_context3, this));\n      this.body.emitter.on(\"destroy\", function () {\n        forEach$1(_this2.nodesListeners, function (callback, event) {\n          if (_this2.body.data.nodes) _this2.body.data.nodes.off(event, callback);\n        });\n        delete _this2.body.functions.createNode;\n        delete _this2.nodesListeners.add;\n        delete _this2.nodesListeners.update;\n        delete _this2.nodesListeners.remove;\n        delete _this2.nodesListeners;\n      });\n    }\n\n    /**\n     *\n     * @param {object} options\n     */\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        Node.parseOptions(this.options, options);\n\n        // Need to set opacity here because Node.parseOptions is also used for groups,\n        // if you set opacity in Node.parseOptions it overwrites group opacity.\n        if (options.opacity !== undefined) {\n          if (_Number$isNaN(options.opacity) || !_Number$isFinite(options.opacity) || options.opacity < 0 || options.opacity > 1) {\n            console.error(\"Invalid option for node opacity. Value must be between 0 and 1, found: \" + options.opacity);\n          } else {\n            this.options.opacity = options.opacity;\n          }\n        }\n\n        // update the shape in all nodes\n        if (options.shape !== undefined) {\n          for (var nodeId in this.body.nodes) {\n            if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {\n              this.body.nodes[nodeId].updateShape();\n            }\n          }\n        }\n\n        // Update the labels of nodes if any relevant options changed.\n        if (typeof options.font !== \"undefined\" || typeof options.widthConstraint !== \"undefined\" || typeof options.heightConstraint !== \"undefined\") {\n          for (var _i = 0, _Object$keys$1 = _Object$keys(this.body.nodes); _i < _Object$keys$1.length; _i++) {\n            var _nodeId = _Object$keys$1[_i];\n            this.body.nodes[_nodeId].updateLabelModule();\n            this.body.nodes[_nodeId].needsRefresh();\n          }\n        }\n\n        // update the shape size in all nodes\n        if (options.size !== undefined) {\n          for (var _nodeId2 in this.body.nodes) {\n            if (Object.prototype.hasOwnProperty.call(this.body.nodes, _nodeId2)) {\n              this.body.nodes[_nodeId2].needsRefresh();\n            }\n          }\n        }\n\n        // update the state of the variables if needed\n        if (options.hidden !== undefined || options.physics !== undefined) {\n          this.body.emitter.emit(\"_dataChanged\");\n        }\n      }\n    }\n\n    /**\n     * Set a data set with nodes for the network\n     *\n     * @param {Array | DataSet | DataView} nodes         The data containing the nodes.\n     * @param {boolean} [doNotEmit=false] - Suppress data changed event.\n     * @private\n     */\n  }, {\n    key: \"setData\",\n    value: function setData(nodes) {\n      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var oldNodesData = this.body.data.nodes;\n      if ((0,vis_data_peer_esm_vis_data_js__WEBPACK_IMPORTED_MODULE_0__.isDataViewLike)(\"id\", nodes)) {\n        this.body.data.nodes = nodes;\n      } else if (_Array$isArray(nodes)) {\n        this.body.data.nodes = new vis_data_peer_esm_vis_data_js__WEBPACK_IMPORTED_MODULE_0__.DataSet();\n        this.body.data.nodes.add(nodes);\n      } else if (!nodes) {\n        this.body.data.nodes = new vis_data_peer_esm_vis_data_js__WEBPACK_IMPORTED_MODULE_0__.DataSet();\n      } else {\n        throw new TypeError(\"Array or DataSet expected\");\n      }\n      if (oldNodesData) {\n        // unsubscribe from old dataset\n        forEach$1(this.nodesListeners, function (callback, event) {\n          oldNodesData.off(event, callback);\n        });\n      }\n\n      // remove drawn nodes\n      this.body.nodes = {};\n      if (this.body.data.nodes) {\n        // subscribe to new dataset\n        var me = this;\n        forEach$1(this.nodesListeners, function (callback, event) {\n          me.body.data.nodes.on(event, callback);\n        });\n\n        // draw all new nodes\n        var ids = this.body.data.nodes.getIds();\n        this.add(ids, true);\n      }\n      if (doNotEmit === false) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n\n    /**\n     * Add nodes\n     *\n     * @param {number[] | string[]} ids\n     * @param {boolean} [doNotEmit=false]\n     * @private\n     */\n  }, {\n    key: \"add\",\n    value: function add(ids) {\n      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var id;\n      var newNodes = [];\n      for (var i = 0; i < ids.length; i++) {\n        id = ids[i];\n        var properties = this.body.data.nodes.get(id);\n        var node = this.create(properties);\n        newNodes.push(node);\n        this.body.nodes[id] = node; // note: this may replace an existing node\n      }\n\n      this.layoutEngine.positionInitially(newNodes);\n      if (doNotEmit === false) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n\n    /**\n     * Update existing nodes, or create them when not yet existing\n     *\n     * @param {number[] | string[]} ids id's of changed nodes\n     * @param {Array} changedData array with changed data\n     * @param {Array|undefined} oldData optional; array with previous data\n     * @private\n     */\n  }, {\n    key: \"update\",\n    value: function update(ids, changedData, oldData) {\n      var nodes = this.body.nodes;\n      var dataChanged = false;\n      for (var i = 0; i < ids.length; i++) {\n        var id = ids[i];\n        var node = nodes[id];\n        var data = changedData[i];\n        if (node !== undefined) {\n          // update node\n          if (node.setOptions(data)) {\n            dataChanged = true;\n          }\n        } else {\n          dataChanged = true;\n          // create node\n          node = this.create(data);\n          nodes[id] = node;\n        }\n      }\n      if (!dataChanged && oldData !== undefined) {\n        // Check for any changes which should trigger a layout recalculation\n        // For now, this is just 'level' for hierarchical layout\n        // Assumption: old and new data arranged in same order; at time of writing, this holds.\n        dataChanged = _someInstanceProperty(changedData).call(changedData, function (newValue, index) {\n          var oldValue = oldData[index];\n          return oldValue && oldValue.level !== newValue.level;\n        });\n      }\n      if (dataChanged === true) {\n        this.body.emitter.emit(\"_dataChanged\");\n      } else {\n        this.body.emitter.emit(\"_dataUpdated\");\n      }\n    }\n\n    /**\n     * Remove existing nodes. If nodes do not exist, the method will just ignore it.\n     *\n     * @param {number[] | string[]} ids\n     * @private\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(ids) {\n      var nodes = this.body.nodes;\n      for (var i = 0; i < ids.length; i++) {\n        var id = ids[i];\n        delete nodes[id];\n      }\n      this.body.emitter.emit(\"_dataChanged\");\n    }\n\n    /**\n     * create a node\n     *\n     * @param {object} properties\n     * @param {class} [constructorClass=Node.default]\n     * @returns {*}\n     */\n  }, {\n    key: \"create\",\n    value: function create(properties) {\n      var constructorClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Node;\n      return new constructorClass(properties, this.body, this.images, this.groups, this.options, this.defaultOptions);\n    }\n\n    /**\n     *\n     * @param {boolean} [clearPositions=false]\n     */\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var _this3 = this;\n      var clearPositions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      forEach$1(this.body.nodes, function (node, nodeId) {\n        var data = _this3.body.data.nodes.get(nodeId);\n        if (data !== undefined) {\n          if (clearPositions === true) {\n            node.setOptions({\n              x: null,\n              y: null\n            });\n          }\n          node.setOptions({\n            fixed: false\n          });\n          node.setOptions(data);\n        }\n      });\n    }\n\n    /**\n     * Returns the positions of the nodes.\n     *\n     * @param {Array.<Node.id> | string} [ids]  --> optional, can be array of nodeIds, can be string\n     * @returns {{}}\n     */\n  }, {\n    key: \"getPositions\",\n    value: function getPositions(ids) {\n      var dataArray = {};\n      if (ids !== undefined) {\n        if (_Array$isArray(ids) === true) {\n          for (var i = 0; i < ids.length; i++) {\n            if (this.body.nodes[ids[i]] !== undefined) {\n              var node = this.body.nodes[ids[i]];\n              dataArray[ids[i]] = {\n                x: Math.round(node.x),\n                y: Math.round(node.y)\n              };\n            }\n          }\n        } else {\n          if (this.body.nodes[ids] !== undefined) {\n            var _node = this.body.nodes[ids];\n            dataArray[ids] = {\n              x: Math.round(_node.x),\n              y: Math.round(_node.y)\n            };\n          }\n        }\n      } else {\n        for (var _i2 = 0; _i2 < this.body.nodeIndices.length; _i2++) {\n          var _node2 = this.body.nodes[this.body.nodeIndices[_i2]];\n          dataArray[this.body.nodeIndices[_i2]] = {\n            x: Math.round(_node2.x),\n            y: Math.round(_node2.y)\n          };\n        }\n      }\n      return dataArray;\n    }\n\n    /**\n     * Retrieves the x y position of a specific id.\n     *\n     * @param {string} id The id to retrieve.\n     * @throws {TypeError} If no id is included.\n     * @throws {ReferenceError} If an invalid id is provided.\n     * @returns {{ x: number, y: number }} Returns X, Y canvas position of the node with given id.\n     */\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(id) {\n      if (id == undefined) {\n        throw new TypeError(\"No id was specified for getPosition method.\");\n      } else if (this.body.nodes[id] == undefined) {\n        throw new ReferenceError(\"NodeId provided for getPosition does not exist. Provided: \".concat(id));\n      } else {\n        return {\n          x: Math.round(this.body.nodes[id].x),\n          y: Math.round(this.body.nodes[id].y)\n        };\n      }\n    }\n\n    /**\n     * Load the XY positions of the nodes into the dataset.\n     */\n  }, {\n    key: \"storePositions\",\n    value: function storePositions() {\n      // todo: add support for clusters and hierarchical.\n      var dataArray = [];\n      var dataset = this.body.data.nodes.getDataSet();\n      var _iterator = _createForOfIteratorHelper$5(dataset.get()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var dsNode = _step.value;\n          var id = dsNode.id;\n          var bodyNode = this.body.nodes[id];\n          var x = Math.round(bodyNode.x);\n          var y = Math.round(bodyNode.y);\n          if (dsNode.x !== x || dsNode.y !== y) {\n            dataArray.push({\n              id: id,\n              x: x,\n              y: y\n            });\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      dataset.update(dataArray);\n    }\n\n    /**\n     * get the bounding box of a node.\n     *\n     * @param {Node.id} nodeId\n     * @returns {j|*}\n     */\n  }, {\n    key: \"getBoundingBox\",\n    value: function getBoundingBox(nodeId) {\n      if (this.body.nodes[nodeId] !== undefined) {\n        return this.body.nodes[nodeId].shape.boundingBox;\n      }\n    }\n\n    /**\n     * Get the Ids of nodes connected to this node.\n     *\n     * @param {Node.id} nodeId\n     * @param {'to'|'from'|undefined} direction values 'from' and 'to' select respectively parent and child nodes only.\n     *                                          Any other value returns both parent and child nodes.\n     * @returns {Array}\n     */\n  }, {\n    key: \"getConnectedNodes\",\n    value: function getConnectedNodes(nodeId, direction) {\n      var nodeList = [];\n      if (this.body.nodes[nodeId] !== undefined) {\n        var node = this.body.nodes[nodeId];\n        var nodeObj = {}; // used to quickly check if node already exists\n        for (var i = 0; i < node.edges.length; i++) {\n          var edge = node.edges[i];\n          if (direction !== \"to\" && edge.toId == node.id) {\n            // these are double equals since ids can be numeric or string\n            if (nodeObj[edge.fromId] === undefined) {\n              nodeList.push(edge.fromId);\n              nodeObj[edge.fromId] = true;\n            }\n          } else if (direction !== \"from\" && edge.fromId == node.id) {\n            // these are double equals since ids can be numeric or string\n            if (nodeObj[edge.toId] === undefined) {\n              nodeList.push(edge.toId);\n              nodeObj[edge.toId] = true;\n            }\n          }\n        }\n      }\n      return nodeList;\n    }\n\n    /**\n     * Get the ids of the edges connected to this node.\n     *\n     * @param {Node.id} nodeId\n     * @returns {*}\n     */\n  }, {\n    key: \"getConnectedEdges\",\n    value: function getConnectedEdges(nodeId) {\n      var edgeList = [];\n      if (this.body.nodes[nodeId] !== undefined) {\n        var node = this.body.nodes[nodeId];\n        for (var i = 0; i < node.edges.length; i++) {\n          edgeList.push(node.edges[i].id);\n        }\n      } else {\n        console.error(\"NodeId provided for getConnectedEdges does not exist. Provided: \", nodeId);\n      }\n      return edgeList;\n    }\n\n    /**\n     * Move a node.\n     *\n     * @param {Node.id} nodeId\n     * @param {number} x\n     * @param {number} y\n     */\n  }, {\n    key: \"moveNode\",\n    value: function moveNode(nodeId, x, y) {\n      var _this4 = this;\n      if (this.body.nodes[nodeId] !== undefined) {\n        this.body.nodes[nodeId].x = Number(x);\n        this.body.nodes[nodeId].y = Number(y);\n        _setTimeout(function () {\n          _this4.body.emitter.emit(\"startSimulation\");\n        }, 0);\n      } else {\n        console.error(\"Node id supplied to moveNode does not exist. Provided: \", nodeId);\n      }\n    }\n  }]);\n  return NodesHandler;\n}();\n\nvar hasOwn$1 = hasOwnProperty_1;\n\nvar isDataDescriptor$1 = function (descriptor) {\n  return descriptor !== undefined && (hasOwn$1(descriptor, 'value') || hasOwn$1(descriptor, 'writable'));\n};\n\nvar $$4 = _export;\nvar call = functionCall;\nvar isObject$2 = isObject$j;\nvar anObject$1 = anObject$d;\nvar isDataDescriptor = isDataDescriptor$1;\nvar getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;\nvar getPrototypeOf = objectGetPrototypeOf;\n\n// `Reflect.get` method\n// https://tc39.es/ecma262/#sec-reflect.get\nfunction get$5(target, propertyKey /* , receiver */) {\n  var receiver = arguments.length < 3 ? target : arguments[2];\n  var descriptor, prototype;\n  if (anObject$1(target) === receiver) return target[propertyKey];\n  descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey);\n  if (descriptor) return isDataDescriptor(descriptor)\n    ? descriptor.value\n    : descriptor.get === undefined ? undefined : call(descriptor.get, receiver);\n  if (isObject$2(prototype = getPrototypeOf(target))) return get$5(prototype, propertyKey, receiver);\n}\n\n$$4({ target: 'Reflect', stat: true }, {\n  get: get$5\n});\n\nvar path$4 = path$w;\n\nvar get$4 = path$4.Reflect.get;\n\nvar parent$a = get$4;\n\nvar get$3 = parent$a;\n\nvar parent$9 = get$3;\n\nvar get$2 = parent$9;\n\nvar parent$8 = get$2;\n\nvar get$1 = parent$8;\n\nvar get = get$1;\n\nvar _Reflect$get = /*@__PURE__*/getDefaultExportFromCjs(get);\n\nvar parent$7 = getOwnPropertyDescriptor$4;\n\nvar getOwnPropertyDescriptor$2 = parent$7;\n\nvar parent$6 = getOwnPropertyDescriptor$2;\n\nvar getOwnPropertyDescriptor$1 = parent$6;\n\nvar getOwnPropertyDescriptor = getOwnPropertyDescriptor$1;\n\nvar _Object$getOwnPropertyDescriptor = /*@__PURE__*/getDefaultExportFromCjs(getOwnPropertyDescriptor);\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n  return object;\n}\n\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && _Reflect$get) {\n    var _context;\n    _get = _bindInstanceProperty(_context = _Reflect$get).call(_context);\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n      if (!base) return;\n      var desc = _Object$getOwnPropertyDescriptor(base, property);\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n      return desc.value;\n    };\n  }\n  return _get.apply(this, arguments);\n}\n\nvar $$3 = _export;\n\n// eslint-disable-next-line es/no-math-hypot -- required for testing\nvar $hypot = Math.hypot;\nvar abs = Math.abs;\nvar sqrt = Math.sqrt;\n\n// Chrome 77 bug\n// https://bugs.chromium.org/p/v8/issues/detail?id=9546\nvar FORCED$2 = !!$hypot && $hypot(Infinity, NaN) !== Infinity;\n\n// `Math.hypot` method\n// https://tc39.es/ecma262/#sec-math.hypot\n$$3({ target: 'Math', stat: true, arity: 2, forced: FORCED$2 }, {\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  hypot: function hypot(value1, value2) {\n    var sum = 0;\n    var i = 0;\n    var aLen = arguments.length;\n    var larg = 0;\n    var arg, div;\n    while (i < aLen) {\n      arg = abs(arguments[i++]);\n      if (larg < arg) {\n        div = larg / arg;\n        sum = sum * div * div + 1;\n        larg = arg;\n      } else if (arg > 0) {\n        div = arg / larg;\n        sum += div * div;\n      } else sum += arg;\n    }\n    return larg === Infinity ? Infinity : larg * sqrt(sum);\n  }\n});\n\nvar path$3 = path$w;\n\nvar hypot$2 = path$3.Math.hypot;\n\nvar parent$5 = hypot$2;\n\nvar hypot$1 = parent$5;\n\nvar hypot = hypot$1;\n\nvar _Math$hypot = /*@__PURE__*/getDefaultExportFromCjs(hypot);\n\nfunction _createSuper$a(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$a(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$a() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n/**\r\n * Common methods for endpoints\r\n *\r\n * @class\r\n */\nvar EndPoint = /*#__PURE__*/function () {\n  function EndPoint() {\n    _classCallCheck(this, EndPoint);\n  }\n  _createClass(EndPoint, null, [{\n    key: \"transform\",\n    value:\n    /**\r\n     * Apply transformation on points for display.\r\n     *\r\n     * The following is done:\r\n     * - rotate by the specified angle\r\n     * - multiply the (normalized) coordinates by the passed length\r\n     * - offset by the target coordinates\r\n     *\r\n     * @param points - The point(s) to be transformed.\r\n     * @param arrowData - The data determining the result of the transformation.\r\n     */\n    function transform(points, arrowData) {\n      if (!_Array$isArray(points)) {\n        points = [points];\n      }\n      var x = arrowData.point.x;\n      var y = arrowData.point.y;\n      var angle = arrowData.angle;\n      var length = arrowData.length;\n      for (var i = 0; i < points.length; ++i) {\n        var p = points[i];\n        var xt = p.x * Math.cos(angle) - p.y * Math.sin(angle);\n        var yt = p.x * Math.sin(angle) + p.y * Math.cos(angle);\n        p.x = x + length * xt;\n        p.y = y + length * yt;\n      }\n    }\n    /**\r\n     * Draw a closed path using the given real coordinates.\r\n     *\r\n     * @param ctx - The path will be rendered into this context.\r\n     * @param points - The points of the path.\r\n     */\n  }, {\n    key: \"drawPath\",\n    value: function drawPath(ctx, points) {\n      ctx.beginPath();\n      ctx.moveTo(points[0].x, points[0].y);\n      for (var i = 1; i < points.length; ++i) {\n        ctx.lineTo(points[i].x, points[i].y);\n      }\n      ctx.closePath();\n    }\n  }]);\n  return EndPoint;\n}();\n/**\r\n * Drawing methods for the arrow endpoint.\r\n */\nvar Image$1 = /*#__PURE__*/function (_EndPoint) {\n  _inherits(Image, _EndPoint);\n  var _super = _createSuper$a(Image);\n  function Image() {\n    _classCallCheck(this, Image);\n    return _super.apply(this, arguments);\n  }\n  _createClass(Image, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns False as there is no way to fill an image.\r\n     */\n    function draw(ctx, arrowData) {\n      if (arrowData.image) {\n        ctx.save();\n        ctx.translate(arrowData.point.x, arrowData.point.y);\n        ctx.rotate(Math.PI / 2 + arrowData.angle);\n        var width = arrowData.imageWidth != null ? arrowData.imageWidth : arrowData.image.width;\n        var height = arrowData.imageHeight != null ? arrowData.imageHeight : arrowData.image.height;\n        arrowData.image.drawImageAtPosition(ctx, 1,\n        // scale\n        -width / 2,\n        // x\n        0,\n        // y\n        width, height);\n        ctx.restore();\n      }\n      return false;\n    }\n  }]);\n  return Image;\n}(EndPoint);\n/**\r\n * Drawing methods for the arrow endpoint.\r\n */\nvar Arrow = /*#__PURE__*/function (_EndPoint2) {\n  _inherits(Arrow, _EndPoint2);\n  var _super2 = _createSuper$a(Arrow);\n  function Arrow() {\n    _classCallCheck(this, Arrow);\n    return _super2.apply(this, arguments);\n  }\n  _createClass(Arrow, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var points = [{\n        x: 0,\n        y: 0\n      }, {\n        x: -1,\n        y: 0.3\n      }, {\n        x: -0.9,\n        y: 0\n      }, {\n        x: -1,\n        y: -0.3\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Arrow;\n}(EndPoint);\n/**\r\n * Drawing methods for the crow endpoint.\r\n */\nvar Crow = /*#__PURE__*/function () {\n  function Crow() {\n    _classCallCheck(this, Crow);\n  }\n  _createClass(Crow, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var points = [{\n        x: -1,\n        y: 0\n      }, {\n        x: 0,\n        y: 0.3\n      }, {\n        x: -0.4,\n        y: 0\n      }, {\n        x: 0,\n        y: -0.3\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Crow;\n}();\n/**\r\n * Drawing methods for the curve endpoint.\r\n */\nvar Curve = /*#__PURE__*/function () {\n  function Curve() {\n    _classCallCheck(this, Curve);\n  }\n  _createClass(Curve, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var point = {\n        x: -0.4,\n        y: 0\n      };\n      EndPoint.transform(point, arrowData);\n      // Update endpoint style for drawing transparent arc.\n      ctx.strokeStyle = ctx.fillStyle;\n      ctx.fillStyle = \"rgba(0, 0, 0, 0)\";\n      // Define curve endpoint as semicircle.\n      var pi = Math.PI;\n      var startAngle = arrowData.angle - pi / 2;\n      var endAngle = arrowData.angle + pi / 2;\n      ctx.beginPath();\n      ctx.arc(point.x, point.y, arrowData.length * 0.4, startAngle, endAngle, false);\n      ctx.stroke();\n      return true;\n    }\n  }]);\n  return Curve;\n}();\n/**\r\n * Drawing methods for the inverted curve endpoint.\r\n */\nvar InvertedCurve = /*#__PURE__*/function () {\n  function InvertedCurve() {\n    _classCallCheck(this, InvertedCurve);\n  }\n  _createClass(InvertedCurve, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var point = {\n        x: -0.3,\n        y: 0\n      };\n      EndPoint.transform(point, arrowData);\n      // Update endpoint style for drawing transparent arc.\n      ctx.strokeStyle = ctx.fillStyle;\n      ctx.fillStyle = \"rgba(0, 0, 0, 0)\";\n      // Define inverted curve endpoint as semicircle.\n      var pi = Math.PI;\n      var startAngle = arrowData.angle + pi / 2;\n      var endAngle = arrowData.angle + 3 * pi / 2;\n      ctx.beginPath();\n      ctx.arc(point.x, point.y, arrowData.length * 0.4, startAngle, endAngle, false);\n      ctx.stroke();\n      return true;\n    }\n  }]);\n  return InvertedCurve;\n}();\n/**\r\n * Drawing methods for the trinagle endpoint.\r\n */\nvar Triangle = /*#__PURE__*/function () {\n  function Triangle() {\n    _classCallCheck(this, Triangle);\n  }\n  _createClass(Triangle, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var points = [{\n        x: 0.02,\n        y: 0\n      }, {\n        x: -1,\n        y: 0.3\n      }, {\n        x: -1,\n        y: -0.3\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Triangle;\n}();\n/**\r\n * Drawing methods for the inverted trinagle endpoint.\r\n */\nvar InvertedTriangle = /*#__PURE__*/function () {\n  function InvertedTriangle() {\n    _classCallCheck(this, InvertedTriangle);\n  }\n  _createClass(InvertedTriangle, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var points = [{\n        x: 0,\n        y: 0.3\n      }, {\n        x: 0,\n        y: -0.3\n      }, {\n        x: -1,\n        y: 0\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return InvertedTriangle;\n}();\n/**\r\n * Drawing methods for the circle endpoint.\r\n */\nvar Circle = /*#__PURE__*/function () {\n  function Circle() {\n    _classCallCheck(this, Circle);\n  }\n  _createClass(Circle, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    function draw(ctx, arrowData) {\n      var point = {\n        x: -0.4,\n        y: 0\n      };\n      EndPoint.transform(point, arrowData);\n      drawCircle(ctx, point.x, point.y, arrowData.length * 0.4);\n      return true;\n    }\n  }]);\n  return Circle;\n}();\n/**\r\n * Drawing methods for the bar endpoint.\r\n */\nvar Bar = /*#__PURE__*/function () {\n  function Bar() {\n    _classCallCheck(this, Bar);\n  }\n  _createClass(Bar, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    function draw(ctx, arrowData) {\n      /*\r\n      var points = [\r\n        {x:0, y:0.5},\r\n        {x:0, y:-0.5}\r\n      ];\r\n           EndPoint.transform(points, arrowData);\r\n      ctx.beginPath();\r\n      ctx.moveTo(points[0].x, points[0].y);\r\n      ctx.lineTo(points[1].x, points[1].y);\r\n      ctx.stroke();\r\n      */\n      var points = [{\n        x: 0,\n        y: 0.5\n      }, {\n        x: 0,\n        y: -0.5\n      }, {\n        x: -0.15,\n        y: -0.5\n      }, {\n        x: -0.15,\n        y: 0.5\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Bar;\n}();\n/**\r\n * Drawing methods for the box endpoint.\r\n */\nvar Box = /*#__PURE__*/function () {\n  function Box() {\n    _classCallCheck(this, Box);\n  }\n  _createClass(Box, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    function draw(ctx, arrowData) {\n      var points = [{\n        x: 0,\n        y: 0.3\n      }, {\n        x: 0,\n        y: -0.3\n      }, {\n        x: -0.6,\n        y: -0.3\n      }, {\n        x: -0.6,\n        y: 0.3\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Box;\n}();\n/**\r\n * Drawing methods for the diamond endpoint.\r\n */\nvar Diamond = /*#__PURE__*/function () {\n  function Diamond() {\n    _classCallCheck(this, Diamond);\n  }\n  _createClass(Diamond, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    function draw(ctx, arrowData) {\n      var points = [{\n        x: 0,\n        y: 0\n      }, {\n        x: -0.5,\n        y: -0.3\n      }, {\n        x: -1,\n        y: 0\n      }, {\n        x: -0.5,\n        y: 0.3\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Diamond;\n}();\n/**\r\n * Drawing methods for the vee endpoint.\r\n */\nvar Vee = /*#__PURE__*/function () {\n  function Vee() {\n    _classCallCheck(this, Vee);\n  }\n  _createClass(Vee, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var points = [{\n        x: -1,\n        y: 0.3\n      }, {\n        x: -0.5,\n        y: 0\n      }, {\n        x: -1,\n        y: -0.3\n      }, {\n        x: 0,\n        y: 0\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Vee;\n}();\n/**\r\n * Drawing methods for the endpoints.\r\n */\nvar EndPoints = /*#__PURE__*/function () {\n  function EndPoints() {\n    _classCallCheck(this, EndPoints);\n  }\n  _createClass(EndPoints, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw an endpoint.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns True if ctx.fill() can be used to fill the arrow, false otherwise.\r\n     */\n    function draw(ctx, arrowData) {\n      var type;\n      if (arrowData.type) {\n        type = arrowData.type.toLowerCase();\n      }\n      switch (type) {\n        case \"image\":\n          return Image$1.draw(ctx, arrowData);\n        case \"circle\":\n          return Circle.draw(ctx, arrowData);\n        case \"box\":\n          return Box.draw(ctx, arrowData);\n        case \"crow\":\n          return Crow.draw(ctx, arrowData);\n        case \"curve\":\n          return Curve.draw(ctx, arrowData);\n        case \"diamond\":\n          return Diamond.draw(ctx, arrowData);\n        case \"inv_curve\":\n          return InvertedCurve.draw(ctx, arrowData);\n        case \"triangle\":\n          return Triangle.draw(ctx, arrowData);\n        case \"inv_triangle\":\n          return InvertedTriangle.draw(ctx, arrowData);\n        case \"bar\":\n          return Bar.draw(ctx, arrowData);\n        case \"vee\":\n          return Vee.draw(ctx, arrowData);\n        case \"arrow\": // fall-through\n        default:\n          return Arrow.draw(ctx, arrowData);\n      }\n    }\n  }]);\n  return EndPoints;\n}();\n\nfunction ownKeys$1(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = _filterInstanceProperty(o).call(o, function (r) { return _Object$getOwnPropertyDescriptor$1(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var _context2, _context3; var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? _forEachInstanceProperty(_context2 = ownKeys$1(Object(t), !0)).call(_context2, function (r) { _defineProperty(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context3 = ownKeys$1(Object(t))).call(_context3, function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor$1(t, r)); }); } return e; }\n/**\r\n * The Base Class for all edges.\r\n */\nvar EdgeBase = /*#__PURE__*/function () {\n  /**\r\n   * Create a new instance.\r\n   *\r\n   * @param options - The options object of given edge.\r\n   * @param _body - The body of the network.\r\n   * @param _labelModule - Label module.\r\n   */\n  function EdgeBase(options, _body, _labelModule) {\n    _classCallCheck(this, EdgeBase);\n    this._body = _body;\n    this._labelModule = _labelModule;\n    this.color = {};\n    this.colorDirty = true;\n    this.hoverWidth = 1.5;\n    this.selectionWidth = 2;\n    this.setOptions(options);\n    this.fromPoint = this.from;\n    this.toPoint = this.to;\n  }\n  /** @inheritDoc */\n  _createClass(EdgeBase, [{\n    key: \"connect\",\n    value: function connect() {\n      this.from = this._body.nodes[this.options.from];\n      this.to = this._body.nodes[this.options.to];\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      return false;\n    }\n    /**\r\n     * Set new edge options.\r\n     *\r\n     * @param options - The new edge options object.\r\n     */\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n      this.from = this._body.nodes[this.options.from];\n      this.to = this._body.nodes[this.options.to];\n      this.id = this.options.id;\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"drawLine\",\n    value: function drawLine(ctx, values, _selected, _hover) {\n      var viaNode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.getViaNode();\n      // set style\n      ctx.strokeStyle = this.getColor(ctx, values);\n      ctx.lineWidth = values.width;\n      if (values.dashes !== false) {\n        this._drawDashedLine(ctx, values, viaNode);\n      } else {\n        this._drawLine(ctx, values, viaNode);\n      }\n    }\n    /**\r\n     * Draw a line with given style between two nodes through supplied node(s).\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param values - Formatting values like color, opacity or shadow.\r\n     * @param viaNode - Additional control point(s) for the edge.\r\n     * @param fromPoint - TODO: Seems ignored, remove?\r\n     * @param toPoint - TODO: Seems ignored, remove?\r\n     */\n  }, {\n    key: \"_drawLine\",\n    value: function _drawLine(ctx, values, viaNode, fromPoint, toPoint) {\n      if (this.from != this.to) {\n        // draw line\n        this._line(ctx, values, viaNode, fromPoint, toPoint);\n      } else {\n        var _this$_getCircleData = this._getCircleData(ctx),\n          _this$_getCircleData2 = _slicedToArray(_this$_getCircleData, 3),\n          x = _this$_getCircleData2[0],\n          y = _this$_getCircleData2[1],\n          radius = _this$_getCircleData2[2];\n        this._circle(ctx, values, x, y, radius);\n      }\n    }\n    /**\r\n     * Draw a dashed line with given style between two nodes through supplied node(s).\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param values - Formatting values like color, opacity or shadow.\r\n     * @param viaNode - Additional control point(s) for the edge.\r\n     * @param _fromPoint - Ignored (TODO: remove in the future).\r\n     * @param _toPoint - Ignored (TODO: remove in the future).\r\n     */\n  }, {\n    key: \"_drawDashedLine\",\n    value: function _drawDashedLine(ctx, values, viaNode, _fromPoint, _toPoint) {\n      ctx.lineCap = \"round\";\n      var pattern = _Array$isArray(values.dashes) ? values.dashes : [5, 5];\n      // only firefox and chrome support this method, else we use the legacy one.\n      if (ctx.setLineDash !== undefined) {\n        ctx.save();\n        // set dash settings for chrome or firefox\n        ctx.setLineDash(pattern);\n        ctx.lineDashOffset = 0;\n        // draw the line\n        if (this.from != this.to) {\n          // draw line\n          this._line(ctx, values, viaNode);\n        } else {\n          var _this$_getCircleData3 = this._getCircleData(ctx),\n            _this$_getCircleData4 = _slicedToArray(_this$_getCircleData3, 3),\n            x = _this$_getCircleData4[0],\n            y = _this$_getCircleData4[1],\n            radius = _this$_getCircleData4[2];\n          this._circle(ctx, values, x, y, radius);\n        }\n        // restore the dash settings.\n        ctx.setLineDash([0]);\n        ctx.lineDashOffset = 0;\n        ctx.restore();\n      } else {\n        // unsupporting smooth lines\n        if (this.from != this.to) {\n          // draw line\n          drawDashedLine(ctx, this.from.x, this.from.y, this.to.x, this.to.y, pattern);\n        } else {\n          var _this$_getCircleData5 = this._getCircleData(ctx),\n            _this$_getCircleData6 = _slicedToArray(_this$_getCircleData5, 3),\n            _x = _this$_getCircleData6[0],\n            _y = _this$_getCircleData6[1],\n            _radius = _this$_getCircleData6[2];\n          this._circle(ctx, values, _x, _y, _radius);\n        }\n        // draw shadow if enabled\n        this.enableShadow(ctx, values);\n        ctx.stroke();\n        // disable shadows for other elements.\n        this.disableShadow(ctx, values);\n      }\n    }\n    /**\r\n     * Find the intersection between the border of the node and the edge.\r\n     *\r\n     * @param node - The node (either from or to node of the edge).\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param options - Additional options.\r\n     * @returns Cartesian coordinates of the intersection between the border of the node and the edge.\r\n     */\n  }, {\n    key: \"findBorderPosition\",\n    value: function findBorderPosition(node, ctx, options) {\n      if (this.from != this.to) {\n        return this._findBorderPosition(node, ctx, options);\n      } else {\n        return this._findBorderPositionCircle(node, ctx, options);\n      }\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"findBorderPositions\",\n    value: function findBorderPositions(ctx) {\n      if (this.from != this.to) {\n        return {\n          from: this._findBorderPosition(this.from, ctx),\n          to: this._findBorderPosition(this.to, ctx)\n        };\n      } else {\n        var _context;\n        var _this$_getCircleData$ = _sliceInstanceProperty(_context = this._getCircleData(ctx)).call(_context, 0, 2),\n          _this$_getCircleData$2 = _slicedToArray(_this$_getCircleData$, 2),\n          x = _this$_getCircleData$2[0],\n          y = _this$_getCircleData$2[1];\n        return {\n          from: this._findBorderPositionCircle(this.from, ctx, {\n            x: x,\n            y: y,\n            low: 0.25,\n            high: 0.6,\n            direction: -1\n          }),\n          to: this._findBorderPositionCircle(this.from, ctx, {\n            x: x,\n            y: y,\n            low: 0.6,\n            high: 0.8,\n            direction: 1\n          })\n        };\n      }\n    }\n    /**\r\n     * Compute the center point and radius of an edge connected to the same node at both ends.\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @returns `[x, y, radius]`\r\n     */\n  }, {\n    key: \"_getCircleData\",\n    value: function _getCircleData(ctx) {\n      var radius = this.options.selfReference.size;\n      if (ctx !== undefined) {\n        if (this.from.shape.width === undefined) {\n          this.from.shape.resize(ctx);\n        }\n      }\n      // get circle coordinates\n      var coordinates = getSelfRefCoordinates(ctx, this.options.selfReference.angle, radius, this.from);\n      return [coordinates.x, coordinates.y, radius];\n    }\n    /**\r\n     * Get a point on a circle.\r\n     *\r\n     * @param x - Center of the circle on the x axis.\r\n     * @param y - Center of the circle on the y axis.\r\n     * @param radius - Radius of the circle.\r\n     * @param position - Value between 0 (line start) and 1 (line end).\r\n     * @returns Cartesian coordinates of requested point on the circle.\r\n     */\n  }, {\n    key: \"_pointOnCircle\",\n    value: function _pointOnCircle(x, y, radius, position) {\n      var angle = position * 2 * Math.PI;\n      return {\n        x: x + radius * Math.cos(angle),\n        y: y - radius * Math.sin(angle)\n      };\n    }\n    /**\r\n     * Find the intersection between the border of the node and the edge.\r\n     *\r\n     * @remarks\r\n     * This function uses binary search to look for the point where the circle crosses the border of the node.\r\n     * @param nearNode - The node (either from or to node of the edge).\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param options - Additional options.\r\n     * @returns Cartesian coordinates of the intersection between the border of the node and the edge.\r\n     */\n  }, {\n    key: \"_findBorderPositionCircle\",\n    value: function _findBorderPositionCircle(nearNode, ctx, options) {\n      var x = options.x;\n      var y = options.y;\n      var low = options.low;\n      var high = options.high;\n      var direction = options.direction;\n      var maxIterations = 10;\n      var radius = this.options.selfReference.size;\n      var threshold = 0.05;\n      var pos;\n      var middle = (low + high) * 0.5;\n      var endPointOffset = 0;\n      if (this.options.arrowStrikethrough === true) {\n        if (direction === -1) {\n          endPointOffset = this.options.endPointOffset.from;\n        } else if (direction === 1) {\n          endPointOffset = this.options.endPointOffset.to;\n        }\n      }\n      var iteration = 0;\n      do {\n        middle = (low + high) * 0.5;\n        pos = this._pointOnCircle(x, y, radius, middle);\n        var angle = Math.atan2(nearNode.y - pos.y, nearNode.x - pos.x);\n        var distanceToBorder = nearNode.distanceToBorder(ctx, angle) + endPointOffset;\n        var distanceToPoint = Math.sqrt(Math.pow(pos.x - nearNode.x, 2) + Math.pow(pos.y - nearNode.y, 2));\n        var difference = distanceToBorder - distanceToPoint;\n        if (Math.abs(difference) < threshold) {\n          break; // found\n        } else if (difference > 0) {\n          // distance to nodes is larger than distance to border --> t needs to be bigger if we're looking at the to node.\n          if (direction > 0) {\n            low = middle;\n          } else {\n            high = middle;\n          }\n        } else {\n          if (direction > 0) {\n            high = middle;\n          } else {\n            low = middle;\n          }\n        }\n        ++iteration;\n      } while (low <= high && iteration < maxIterations);\n      return _objectSpread$1(_objectSpread$1({}, pos), {}, {\n        t: middle\n      });\n    }\n    /**\r\n     * Get the line width of the edge. Depends on width and whether one of the connected nodes is selected.\r\n     *\r\n     * @param selected - Determines wheter the line is selected.\r\n     * @param hover - Determines wheter the line is being hovered, only applies if selected is false.\r\n     * @returns The width of the line.\r\n     */\n  }, {\n    key: \"getLineWidth\",\n    value: function getLineWidth(selected, hover) {\n      if (selected === true) {\n        return Math.max(this.selectionWidth, 0.3 / this._body.view.scale);\n      } else if (hover === true) {\n        return Math.max(this.hoverWidth, 0.3 / this._body.view.scale);\n      } else {\n        return Math.max(this.options.width, 0.3 / this._body.view.scale);\n      }\n    }\n    /**\r\n     * Compute the color or gradient for given edge.\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param values - Formatting values like color, opacity or shadow.\r\n     * @param _selected - Ignored (TODO: remove in the future).\r\n     * @param _hover - Ignored (TODO: remove in the future).\r\n     * @returns Color string if single color is inherited or gradient if two.\r\n     */\n  }, {\n    key: \"getColor\",\n    value: function getColor(ctx, values) {\n      if (values.inheritsColor !== false) {\n        // when this is a loop edge, just use the 'from' method\n        if (values.inheritsColor === \"both\" && this.from.id !== this.to.id) {\n          var grd = ctx.createLinearGradient(this.from.x, this.from.y, this.to.x, this.to.y);\n          var fromColor = this.from.options.color.highlight.border;\n          var toColor = this.to.options.color.highlight.border;\n          if (this.from.selected === false && this.to.selected === false) {\n            fromColor = overrideOpacity(this.from.options.color.border, values.opacity);\n            toColor = overrideOpacity(this.to.options.color.border, values.opacity);\n          } else if (this.from.selected === true && this.to.selected === false) {\n            toColor = this.to.options.color.border;\n          } else if (this.from.selected === false && this.to.selected === true) {\n            fromColor = this.from.options.color.border;\n          }\n          grd.addColorStop(0, fromColor);\n          grd.addColorStop(1, toColor);\n          // -------------------- this returns -------------------- //\n          return grd;\n        }\n        if (values.inheritsColor === \"to\") {\n          return overrideOpacity(this.to.options.color.border, values.opacity);\n        } else {\n          // \"from\"\n          return overrideOpacity(this.from.options.color.border, values.opacity);\n        }\n      } else {\n        return overrideOpacity(values.color, values.opacity);\n      }\n    }\n    /**\r\n     * Draw a line from a node to itself, a circle.\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param values - Formatting values like color, opacity or shadow.\r\n     * @param x - Center of the circle on the x axis.\r\n     * @param y - Center of the circle on the y axis.\r\n     * @param radius - Radius of the circle.\r\n     */\n  }, {\n    key: \"_circle\",\n    value: function _circle(ctx, values, x, y, radius) {\n      // draw shadow if enabled\n      this.enableShadow(ctx, values);\n      //full circle\n      var angleFrom = 0;\n      var angleTo = Math.PI * 2;\n      if (!this.options.selfReference.renderBehindTheNode) {\n        //render only parts which are not overlaping with parent node\n        //need to find x,y of from point and x,y to point\n        //calculating radians\n        var low = this.options.selfReference.angle;\n        var high = this.options.selfReference.angle + Math.PI;\n        var pointTFrom = this._findBorderPositionCircle(this.from, ctx, {\n          x: x,\n          y: y,\n          low: low,\n          high: high,\n          direction: -1\n        });\n        var pointTTo = this._findBorderPositionCircle(this.from, ctx, {\n          x: x,\n          y: y,\n          low: low,\n          high: high,\n          direction: 1\n        });\n        angleFrom = Math.atan2(pointTFrom.y - y, pointTFrom.x - x);\n        angleTo = Math.atan2(pointTTo.y - y, pointTTo.x - x);\n      }\n      // draw a circle\n      ctx.beginPath();\n      ctx.arc(x, y, radius, angleFrom, angleTo, false);\n      ctx.stroke();\n      // disable shadows for other elements.\n      this.disableShadow(ctx, values);\n    }\n    /**\r\n     * @inheritDoc\r\n     * @remarks\r\n     * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment\r\n     */\n  }, {\n    key: \"getDistanceToEdge\",\n    value: function getDistanceToEdge(x1, y1, x2, y2, x3, y3) {\n      if (this.from != this.to) {\n        return this._getDistanceToEdge(x1, y1, x2, y2, x3, y3);\n      } else {\n        var _this$_getCircleData7 = this._getCircleData(undefined),\n          _this$_getCircleData8 = _slicedToArray(_this$_getCircleData7, 3),\n          x = _this$_getCircleData8[0],\n          y = _this$_getCircleData8[1],\n          radius = _this$_getCircleData8[2];\n        var dx = x - x3;\n        var dy = y - y3;\n        return Math.abs(Math.sqrt(dx * dx + dy * dy) - radius);\n      }\n    }\n    /**\r\n     * Calculate the distance between a point (x3, y3) and a line segment from (x1, y1) to (x2, y2).\r\n     *\r\n     * @param x1 - First end of the line segment on the x axis.\r\n     * @param y1 - First end of the line segment on the y axis.\r\n     * @param x2 - Second end of the line segment on the x axis.\r\n     * @param y2 - Second end of the line segment on the y axis.\r\n     * @param x3 - Position of the point on the x axis.\r\n     * @param y3 - Position of the point on the y axis.\r\n     * @returns The distance between the line segment and the point.\r\n     */\n  }, {\n    key: \"_getDistanceToLine\",\n    value: function _getDistanceToLine(x1, y1, x2, y2, x3, y3) {\n      var px = x2 - x1;\n      var py = y2 - y1;\n      var something = px * px + py * py;\n      var u = ((x3 - x1) * px + (y3 - y1) * py) / something;\n      if (u > 1) {\n        u = 1;\n      } else if (u < 0) {\n        u = 0;\n      }\n      var x = x1 + u * px;\n      var y = y1 + u * py;\n      var dx = x - x3;\n      var dy = y - y3;\n      //# Note: If the actual distance does not matter,\n      //# if you only want to compare what this function\n      //# returns to other results of this function, you\n      //# can just return the squared distance instead\n      //# (i.e. remove the sqrt) to gain a little performance\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"getArrowData\",\n    value: function getArrowData(ctx, position, viaNode, _selected, _hover, values) {\n      // set lets\n      var angle;\n      var arrowPoint;\n      var node1;\n      var node2;\n      var reversed;\n      var scaleFactor;\n      var type;\n      var lineWidth = values.width;\n      if (position === \"from\") {\n        node1 = this.from;\n        node2 = this.to;\n        reversed = values.fromArrowScale < 0;\n        scaleFactor = Math.abs(values.fromArrowScale);\n        type = values.fromArrowType;\n      } else if (position === \"to\") {\n        node1 = this.to;\n        node2 = this.from;\n        reversed = values.toArrowScale < 0;\n        scaleFactor = Math.abs(values.toArrowScale);\n        type = values.toArrowType;\n      } else {\n        node1 = this.to;\n        node2 = this.from;\n        reversed = values.middleArrowScale < 0;\n        scaleFactor = Math.abs(values.middleArrowScale);\n        type = values.middleArrowType;\n      }\n      var length = 15 * scaleFactor + 3 * lineWidth; // 3* lineWidth is the width of the edge.\n      // if not connected to itself\n      if (node1 != node2) {\n        var approximateEdgeLength = _Math$hypot(node1.x - node2.x, node1.y - node2.y);\n        var relativeLength = length / approximateEdgeLength;\n        if (position !== \"middle\") {\n          // draw arrow head\n          if (this.options.smooth.enabled === true) {\n            var pointT = this._findBorderPosition(node1, ctx, {\n              via: viaNode\n            });\n            var guidePos = this.getPoint(pointT.t + relativeLength * (position === \"from\" ? 1 : -1), viaNode);\n            angle = Math.atan2(pointT.y - guidePos.y, pointT.x - guidePos.x);\n            arrowPoint = pointT;\n          } else {\n            angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);\n            arrowPoint = this._findBorderPosition(node1, ctx);\n          }\n        } else {\n          // Negative half length reverses arrow direction.\n          var halfLength = (reversed ? -relativeLength : relativeLength) / 2;\n          var guidePos1 = this.getPoint(0.5 + halfLength, viaNode);\n          var guidePos2 = this.getPoint(0.5 - halfLength, viaNode);\n          angle = Math.atan2(guidePos1.y - guidePos2.y, guidePos1.x - guidePos2.x);\n          arrowPoint = this.getPoint(0.5, viaNode);\n        }\n      } else {\n        // draw circle\n        var _this$_getCircleData9 = this._getCircleData(ctx),\n          _this$_getCircleData10 = _slicedToArray(_this$_getCircleData9, 3),\n          x = _this$_getCircleData10[0],\n          y = _this$_getCircleData10[1],\n          radius = _this$_getCircleData10[2];\n        if (position === \"from\") {\n          var low = this.options.selfReference.angle;\n          var high = this.options.selfReference.angle + Math.PI;\n          var _pointT = this._findBorderPositionCircle(this.from, ctx, {\n            x: x,\n            y: y,\n            low: low,\n            high: high,\n            direction: -1\n          });\n          angle = _pointT.t * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;\n          arrowPoint = _pointT;\n        } else if (position === \"to\") {\n          var _low = this.options.selfReference.angle;\n          var _high = this.options.selfReference.angle + Math.PI;\n          var _pointT2 = this._findBorderPositionCircle(this.from, ctx, {\n            x: x,\n            y: y,\n            low: _low,\n            high: _high,\n            direction: 1\n          });\n          angle = _pointT2.t * -2 * Math.PI + 1.5 * Math.PI - 1.1 * Math.PI;\n          arrowPoint = _pointT2;\n        } else {\n          var pos = this.options.selfReference.angle / (2 * Math.PI);\n          arrowPoint = this._pointOnCircle(x, y, radius, pos);\n          angle = pos * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;\n        }\n      }\n      var xi = arrowPoint.x - length * 0.9 * Math.cos(angle);\n      var yi = arrowPoint.y - length * 0.9 * Math.sin(angle);\n      var arrowCore = {\n        x: xi,\n        y: yi\n      };\n      return {\n        point: arrowPoint,\n        core: arrowCore,\n        angle: angle,\n        length: length,\n        type: type\n      };\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"drawArrowHead\",\n    value: function drawArrowHead(ctx, values, _selected, _hover, arrowData) {\n      // set style\n      ctx.strokeStyle = this.getColor(ctx, values);\n      ctx.fillStyle = ctx.strokeStyle;\n      ctx.lineWidth = values.width;\n      var canFill = EndPoints.draw(ctx, arrowData);\n      if (canFill) {\n        // draw shadow if enabled\n        this.enableShadow(ctx, values);\n        _fillInstanceProperty(ctx).call(ctx);\n        // disable shadows for other elements.\n        this.disableShadow(ctx, values);\n      }\n    }\n    /**\r\n     * Set the shadow formatting values in the context if enabled, do nothing otherwise.\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param values - Formatting values for the shadow.\r\n     */\n  }, {\n    key: \"enableShadow\",\n    value: function enableShadow(ctx, values) {\n      if (values.shadow === true) {\n        ctx.shadowColor = values.shadowColor;\n        ctx.shadowBlur = values.shadowSize;\n        ctx.shadowOffsetX = values.shadowX;\n        ctx.shadowOffsetY = values.shadowY;\n      }\n    }\n    /**\r\n     * Reset the shadow formatting values in the context if enabled, do nothing otherwise.\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param values - Formatting values for the shadow.\r\n     */\n  }, {\n    key: \"disableShadow\",\n    value: function disableShadow(ctx, values) {\n      if (values.shadow === true) {\n        ctx.shadowColor = \"rgba(0,0,0,0)\";\n        ctx.shadowBlur = 0;\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 0;\n      }\n    }\n    /**\r\n     * Render the background according to the formatting values.\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param values - Formatting values for the background.\r\n     */\n  }, {\n    key: \"drawBackground\",\n    value: function drawBackground(ctx, values) {\n      if (values.background !== false) {\n        // save original line attrs\n        var origCtxAttr = {\n          strokeStyle: ctx.strokeStyle,\n          lineWidth: ctx.lineWidth,\n          dashes: ctx.dashes\n        };\n        ctx.strokeStyle = values.backgroundColor;\n        ctx.lineWidth = values.backgroundSize;\n        this.setStrokeDashed(ctx, values.backgroundDashes);\n        ctx.stroke();\n        // restore original line attrs\n        ctx.strokeStyle = origCtxAttr.strokeStyle;\n        ctx.lineWidth = origCtxAttr.lineWidth;\n        ctx.dashes = origCtxAttr.dashes;\n        this.setStrokeDashed(ctx, values.dashes);\n      }\n    }\n    /**\r\n     * Set the line dash pattern if supported. Logs a warning to the console if it isn't supported.\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param dashes - The pattern [line, space, lineâ¦], true for default dashed line or false for normal line.\r\n     */\n  }, {\n    key: \"setStrokeDashed\",\n    value: function setStrokeDashed(ctx, dashes) {\n      if (dashes !== false) {\n        if (ctx.setLineDash !== undefined) {\n          var pattern = _Array$isArray(dashes) ? dashes : [5, 5];\n          ctx.setLineDash(pattern);\n        } else {\n          console.warn(\"setLineDash is not supported in this browser. The dashed stroke cannot be used.\");\n        }\n      } else {\n        if (ctx.setLineDash !== undefined) {\n          ctx.setLineDash([]);\n        } else {\n          console.warn(\"setLineDash is not supported in this browser. The dashed stroke cannot be used.\");\n        }\n      }\n    }\n  }]);\n  return EdgeBase;\n}();\n\nfunction ownKeys(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = _filterInstanceProperty(o).call(o, function (r) { return _Object$getOwnPropertyDescriptor$1(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var _context, _context2; var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? _forEachInstanceProperty(_context = ownKeys(Object(t), !0)).call(_context, function (r) { _defineProperty(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context2 = ownKeys(Object(t))).call(_context2, function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor$1(t, r)); }); } return e; }\nfunction _createSuper$9(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$9(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$9() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n/**\r\n * The Base Class for all Bezier edges.\r\n * Bezier curves are used to model smooth gradual curves in paths between nodes.\r\n */\nvar BezierEdgeBase = /*#__PURE__*/function (_EdgeBase) {\n  _inherits(BezierEdgeBase, _EdgeBase);\n  var _super = _createSuper$9(BezierEdgeBase);\n  /**\r\n   * Create a new instance.\r\n   *\r\n   * @param options - The options object of given edge.\r\n   * @param body - The body of the network.\r\n   * @param labelModule - Label module.\r\n   */\n  function BezierEdgeBase(options, body, labelModule) {\n    _classCallCheck(this, BezierEdgeBase);\n    return _super.call(this, options, body, labelModule);\n  }\n  /**\r\n   * Find the intersection between the border of the node and the edge.\r\n   *\r\n   * @remarks\r\n   * This function uses binary search to look for the point where the bezier curve crosses the border of the node.\r\n   * @param nearNode - The node (either from or to node of the edge).\r\n   * @param ctx - The context that will be used for rendering.\r\n   * @param viaNode - Additional node(s) the edge passes through.\r\n   * @returns Cartesian coordinates of the intersection between the border of the node and the edge.\r\n   */\n  _createClass(BezierEdgeBase, [{\n    key: \"_findBorderPositionBezier\",\n    value: function _findBorderPositionBezier(nearNode, ctx) {\n      var viaNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._getViaCoordinates();\n      var maxIterations = 10;\n      var threshold = 0.2;\n      var from = false;\n      var high = 1;\n      var low = 0;\n      var node = this.to;\n      var pos;\n      var middle;\n      var endPointOffset = this.options.endPointOffset ? this.options.endPointOffset.to : 0;\n      if (nearNode.id === this.from.id) {\n        node = this.from;\n        from = true;\n        endPointOffset = this.options.endPointOffset ? this.options.endPointOffset.from : 0;\n      }\n      if (this.options.arrowStrikethrough === false) {\n        endPointOffset = 0;\n      }\n      var iteration = 0;\n      do {\n        middle = (low + high) * 0.5;\n        pos = this.getPoint(middle, viaNode);\n        var angle = Math.atan2(node.y - pos.y, node.x - pos.x);\n        var distanceToBorder = node.distanceToBorder(ctx, angle) + endPointOffset;\n        var distanceToPoint = Math.sqrt(Math.pow(pos.x - node.x, 2) + Math.pow(pos.y - node.y, 2));\n        var difference = distanceToBorder - distanceToPoint;\n        if (Math.abs(difference) < threshold) {\n          break; // found\n        } else if (difference < 0) {\n          // distance to nodes is larger than distance to border --> t needs to be bigger if we're looking at the to node.\n          if (from === false) {\n            low = middle;\n          } else {\n            high = middle;\n          }\n        } else {\n          if (from === false) {\n            high = middle;\n          } else {\n            low = middle;\n          }\n        }\n        ++iteration;\n      } while (low <= high && iteration < maxIterations);\n      return _objectSpread(_objectSpread({}, pos), {}, {\n        t: middle\n      });\n    }\n    /**\r\n     * Calculate the distance between a point (x3,y3) and a line segment from (x1,y1) to (x2,y2).\r\n     *\r\n     * @remarks\r\n     * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment\r\n     * @param x1 - First end of the line segment on the x axis.\r\n     * @param y1 - First end of the line segment on the y axis.\r\n     * @param x2 - Second end of the line segment on the x axis.\r\n     * @param y2 - Second end of the line segment on the y axis.\r\n     * @param x3 - Position of the point on the x axis.\r\n     * @param y3 - Position of the point on the y axis.\r\n     * @param via - The control point for the edge.\r\n     * @returns The distance between the line segment and the point.\r\n     */\n  }, {\n    key: \"_getDistanceToBezierEdge\",\n    value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via) {\n      // x3,y3 is the point\n      var minDistance = 1e9;\n      var distance;\n      var i, t, x, y;\n      var lastX = x1;\n      var lastY = y1;\n      for (i = 1; i < 10; i++) {\n        t = 0.1 * i;\n        x = Math.pow(1 - t, 2) * x1 + 2 * t * (1 - t) * via.x + Math.pow(t, 2) * x2;\n        y = Math.pow(1 - t, 2) * y1 + 2 * t * (1 - t) * via.y + Math.pow(t, 2) * y2;\n        if (i > 0) {\n          distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);\n          minDistance = distance < minDistance ? distance : minDistance;\n        }\n        lastX = x;\n        lastY = y;\n      }\n      return minDistance;\n    }\n    /**\r\n     * Render a bezier curve between two nodes.\r\n     *\r\n     * @remarks\r\n     * The method accepts zero, one or two control points.\r\n     * Passing zero control points just draws a straight line.\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param values - Style options for edge drawing.\r\n     * @param viaNode1 - First control point for curve drawing.\r\n     * @param viaNode2 - Second control point for curve drawing.\r\n     */\n  }, {\n    key: \"_bezierCurve\",\n    value: function _bezierCurve(ctx, values, viaNode1, viaNode2) {\n      ctx.beginPath();\n      ctx.moveTo(this.fromPoint.x, this.fromPoint.y);\n      if (viaNode1 != null && viaNode1.x != null) {\n        if (viaNode2 != null && viaNode2.x != null) {\n          ctx.bezierCurveTo(viaNode1.x, viaNode1.y, viaNode2.x, viaNode2.y, this.toPoint.x, this.toPoint.y);\n        } else {\n          ctx.quadraticCurveTo(viaNode1.x, viaNode1.y, this.toPoint.x, this.toPoint.y);\n        }\n      } else {\n        // fallback to normal straight edge\n        ctx.lineTo(this.toPoint.x, this.toPoint.y);\n      }\n      // draw a background\n      this.drawBackground(ctx, values);\n      // draw shadow if enabled\n      this.enableShadow(ctx, values);\n      ctx.stroke();\n      this.disableShadow(ctx, values);\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"getViaNode\",\n    value: function getViaNode() {\n      return this._getViaCoordinates();\n    }\n  }]);\n  return BezierEdgeBase;\n}(EdgeBase);\n\nfunction _createSuper$8(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$8(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$8() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n/**\r\n * A Dynamic Bezier Edge. Bezier curves are used to model smooth gradual\r\n * curves in paths between nodes. The Dynamic piece refers to how the curve\r\n * reacts to physics changes.\r\n *\r\n * @augments BezierEdgeBase\r\n */\nvar BezierEdgeDynamic = /*#__PURE__*/function (_BezierEdgeBase) {\n  _inherits(BezierEdgeDynamic, _BezierEdgeBase);\n  var _super = _createSuper$8(BezierEdgeDynamic);\n  /**\r\n   * Create a new instance.\r\n   *\r\n   * @param options - The options object of given edge.\r\n   * @param body - The body of the network.\r\n   * @param labelModule - Label module.\r\n   */\n  function BezierEdgeDynamic(options, body, labelModule) {\n    var _this;\n    _classCallCheck(this, BezierEdgeDynamic);\n    //this.via = undefined; // Here for completeness but not allowed to defined before super() is invoked.\n    _this = _super.call(this, options, body, labelModule); // --> this calls the setOptions below\n    _this.via = _this.via; // constructor â super â super â setOptions â setupSupportNode\n    _this._boundFunction = function () {\n      _this.positionBezierNode();\n    };\n    _this._body.emitter.on(\"_repositionBezierNodes\", _this._boundFunction);\n    return _this;\n  }\n  /** @inheritDoc */\n  _createClass(BezierEdgeDynamic, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      _get(_getPrototypeOf(BezierEdgeDynamic.prototype), \"setOptions\", this).call(this, options);\n      // check if the physics has changed.\n      var physicsChange = false;\n      if (this.options.physics !== options.physics) {\n        physicsChange = true;\n      }\n      // set the options and the to and from nodes\n      this.options = options;\n      this.id = this.options.id;\n      this.from = this._body.nodes[this.options.from];\n      this.to = this._body.nodes[this.options.to];\n      // setup the support node and connect\n      this.setupSupportNode();\n      this.connect();\n      // when we change the physics state of the edge, we reposition the support node.\n      if (physicsChange === true) {\n        this.via.setOptions({\n          physics: this.options.physics\n        });\n        this.positionBezierNode();\n      }\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      this.from = this._body.nodes[this.options.from];\n      this.to = this._body.nodes[this.options.to];\n      if (this.from === undefined || this.to === undefined || this.options.physics === false) {\n        this.via.setOptions({\n          physics: false\n        });\n      } else {\n        // fix weird behaviour where a self referencing node has physics enabled\n        if (this.from.id === this.to.id) {\n          this.via.setOptions({\n            physics: false\n          });\n        } else {\n          this.via.setOptions({\n            physics: true\n          });\n        }\n      }\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      this._body.emitter.off(\"_repositionBezierNodes\", this._boundFunction);\n      if (this.via !== undefined) {\n        delete this._body.nodes[this.via.id];\n        this.via = undefined;\n        return true;\n      }\n      return false;\n    }\n    /**\r\n     * Create and add a support node if not already present.\r\n     *\r\n     * @remarks\r\n     * Bezier curves require an anchor point to calculate the smooth flow.\r\n     * These points are nodes.\r\n     * These nodes are invisible but are used for the force calculation.\r\n     *\r\n     * The changed data is not called, if needed, it is returned by the main edge constructor.\r\n     */\n  }, {\n    key: \"setupSupportNode\",\n    value: function setupSupportNode() {\n      if (this.via === undefined) {\n        var nodeId = \"edgeId:\" + this.id;\n        var node = this._body.functions.createNode({\n          id: nodeId,\n          shape: \"circle\",\n          physics: true,\n          hidden: true\n        });\n        this._body.nodes[nodeId] = node;\n        this.via = node;\n        this.via.parentEdgeId = this.id;\n        this.positionBezierNode();\n      }\n    }\n    /**\r\n     * Position bezier node.\r\n     */\n  }, {\n    key: \"positionBezierNode\",\n    value: function positionBezierNode() {\n      if (this.via !== undefined && this.from !== undefined && this.to !== undefined) {\n        this.via.x = 0.5 * (this.from.x + this.to.x);\n        this.via.y = 0.5 * (this.from.y + this.to.y);\n      } else if (this.via !== undefined) {\n        this.via.x = 0;\n        this.via.y = 0;\n      }\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"_line\",\n    value: function _line(ctx, values, viaNode) {\n      this._bezierCurve(ctx, values, viaNode);\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"_getViaCoordinates\",\n    value: function _getViaCoordinates() {\n      return this.via;\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"getViaNode\",\n    value: function getViaNode() {\n      return this.via;\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"getPoint\",\n    value: function getPoint(position) {\n      var viaNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.via;\n      if (this.from === this.to) {\n        var _this$_getCircleData = this._getCircleData(),\n          _this$_getCircleData2 = _slicedToArray(_this$_getCircleData, 3),\n          cx = _this$_getCircleData2[0],\n          cy = _this$_getCircleData2[1],\n          cr = _this$_getCircleData2[2];\n        var a = 2 * Math.PI * (1 - position);\n        return {\n          x: cx + cr * Math.sin(a),\n          y: cy + cr - cr * (1 - Math.cos(a))\n        };\n      } else {\n        return {\n          x: Math.pow(1 - position, 2) * this.fromPoint.x + 2 * position * (1 - position) * viaNode.x + Math.pow(position, 2) * this.toPoint.x,\n          y: Math.pow(1 - position, 2) * this.fromPoint.y + 2 * position * (1 - position) * viaNode.y + Math.pow(position, 2) * this.toPoint.y\n        };\n      }\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"_findBorderPosition\",\n    value: function _findBorderPosition(nearNode, ctx) {\n      return this._findBorderPositionBezier(nearNode, ctx, this.via);\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"_getDistanceToEdge\",\n    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {\n      // x3,y3 is the point\n      return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, this.via);\n    }\n  }]);\n  return BezierEdgeDynamic;\n}(BezierEdgeBase);\n\nfunction _createSuper$7(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$7(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$7() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n/**\r\n * A Static Bezier Edge. Bezier curves are used to model smooth gradual curves in paths between nodes.\r\n */\nvar BezierEdgeStatic = /*#__PURE__*/function (_BezierEdgeBase) {\n  _inherits(BezierEdgeStatic, _BezierEdgeBase);\n  var _super = _createSuper$7(BezierEdgeStatic);\n  /**\r\n   * Create a new instance.\r\n   *\r\n   * @param options - The options object of given edge.\r\n   * @param body - The body of the network.\r\n   * @param labelModule - Label module.\r\n   */\n  function BezierEdgeStatic(options, body, labelModule) {\n    _classCallCheck(this, BezierEdgeStatic);\n    return _super.call(this, options, body, labelModule);\n  }\n  /** @inheritDoc */\n  _createClass(BezierEdgeStatic, [{\n    key: \"_line\",\n    value: function _line(ctx, values, viaNode) {\n      this._bezierCurve(ctx, values, viaNode);\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"getViaNode\",\n    value: function getViaNode() {\n      return this._getViaCoordinates();\n    }\n    /**\r\n     * Compute the coordinates of the via node.\r\n     *\r\n     * @remarks\r\n     * We do not use the to and fromPoints here to make the via nodes the same as edges without arrows.\r\n     * @returns Cartesian coordinates of the via node.\r\n     */\n  }, {\n    key: \"_getViaCoordinates\",\n    value: function _getViaCoordinates() {\n      // Assumption: x/y coordinates in from/to always defined\n      var factor = this.options.smooth.roundness;\n      var type = this.options.smooth.type;\n      var dx = Math.abs(this.from.x - this.to.x);\n      var dy = Math.abs(this.from.y - this.to.y);\n      if (type === \"discrete\" || type === \"diagonalCross\") {\n        var stepX;\n        var stepY;\n        if (dx <= dy) {\n          stepX = stepY = factor * dy;\n        } else {\n          stepX = stepY = factor * dx;\n        }\n        if (this.from.x > this.to.x) {\n          stepX = -stepX;\n        }\n        if (this.from.y >= this.to.y) {\n          stepY = -stepY;\n        }\n        var xVia = this.from.x + stepX;\n        var yVia = this.from.y + stepY;\n        if (type === \"discrete\") {\n          if (dx <= dy) {\n            xVia = dx < factor * dy ? this.from.x : xVia;\n          } else {\n            yVia = dy < factor * dx ? this.from.y : yVia;\n          }\n        }\n        return {\n          x: xVia,\n          y: yVia\n        };\n      } else if (type === \"straightCross\") {\n        var _stepX = (1 - factor) * dx;\n        var _stepY = (1 - factor) * dy;\n        if (dx <= dy) {\n          // up - down\n          _stepX = 0;\n          if (this.from.y < this.to.y) {\n            _stepY = -_stepY;\n          }\n        } else {\n          // left - right\n          if (this.from.x < this.to.x) {\n            _stepX = -_stepX;\n          }\n          _stepY = 0;\n        }\n        return {\n          x: this.to.x + _stepX,\n          y: this.to.y + _stepY\n        };\n      } else if (type === \"horizontal\") {\n        var _stepX2 = (1 - factor) * dx;\n        if (this.from.x < this.to.x) {\n          _stepX2 = -_stepX2;\n        }\n        return {\n          x: this.to.x + _stepX2,\n          y: this.from.y\n        };\n      } else if (type === \"vertical\") {\n        var _stepY2 = (1 - factor) * dy;\n        if (this.from.y < this.to.y) {\n          _stepY2 = -_stepY2;\n        }\n        return {\n          x: this.from.x,\n          y: this.to.y + _stepY2\n        };\n      } else if (type === \"curvedCW\") {\n        dx = this.to.x - this.from.x;\n        dy = this.from.y - this.to.y;\n        var radius = Math.sqrt(dx * dx + dy * dy);\n        var pi = Math.PI;\n        var originalAngle = Math.atan2(dy, dx);\n        var myAngle = (originalAngle + (factor * 0.5 + 0.5) * pi) % (2 * pi);\n        return {\n          x: this.from.x + (factor * 0.5 + 0.5) * radius * Math.sin(myAngle),\n          y: this.from.y + (factor * 0.5 + 0.5) * radius * Math.cos(myAngle)\n        };\n      } else if (type === \"curvedCCW\") {\n        dx = this.to.x - this.from.x;\n        dy = this.from.y - this.to.y;\n        var _radius = Math.sqrt(dx * dx + dy * dy);\n        var _pi = Math.PI;\n        var _originalAngle = Math.atan2(dy, dx);\n        var _myAngle = (_originalAngle + (-factor * 0.5 + 0.5) * _pi) % (2 * _pi);\n        return {\n          x: this.from.x + (factor * 0.5 + 0.5) * _radius * Math.sin(_myAngle),\n          y: this.from.y + (factor * 0.5 + 0.5) * _radius * Math.cos(_myAngle)\n        };\n      } else {\n        // continuous\n        var _stepX3;\n        var _stepY3;\n        if (dx <= dy) {\n          _stepX3 = _stepY3 = factor * dy;\n        } else {\n          _stepX3 = _stepY3 = factor * dx;\n        }\n        if (this.from.x > this.to.x) {\n          _stepX3 = -_stepX3;\n        }\n        if (this.from.y >= this.to.y) {\n          _stepY3 = -_stepY3;\n        }\n        var _xVia = this.from.x + _stepX3;\n        var _yVia = this.from.y + _stepY3;\n        if (dx <= dy) {\n          if (this.from.x <= this.to.x) {\n            _xVia = this.to.x < _xVia ? this.to.x : _xVia;\n          } else {\n            _xVia = this.to.x > _xVia ? this.to.x : _xVia;\n          }\n        } else {\n          if (this.from.y >= this.to.y) {\n            _yVia = this.to.y > _yVia ? this.to.y : _yVia;\n          } else {\n            _yVia = this.to.y < _yVia ? this.to.y : _yVia;\n          }\n        }\n        return {\n          x: _xVia,\n          y: _yVia\n        };\n      }\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"_findBorderPosition\",\n    value: function _findBorderPosition(nearNode, ctx) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this._findBorderPositionBezier(nearNode, ctx, options.via);\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"_getDistanceToEdge\",\n    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {\n      var viaNode = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this._getViaCoordinates();\n      // x3,y3 is the point\n      return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, viaNode);\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"getPoint\",\n    value: function getPoint(position) {\n      var viaNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._getViaCoordinates();\n      var t = position;\n      var x = Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * viaNode.x + Math.pow(t, 2) * this.toPoint.x;\n      var y = Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * viaNode.y + Math.pow(t, 2) * this.toPoint.y;\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }]);\n  return BezierEdgeStatic;\n}(BezierEdgeBase);\n\nfunction _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$6() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n/**\r\n * A Base Class for all Cubic Bezier Edges. Bezier curves are used to model\r\n * smooth gradual curves in paths between nodes.\r\n *\r\n * @augments BezierEdgeBase\r\n */\nvar CubicBezierEdgeBase = /*#__PURE__*/function (_BezierEdgeBase) {\n  _inherits(CubicBezierEdgeBase, _BezierEdgeBase);\n  var _super = _createSuper$6(CubicBezierEdgeBase);\n  /**\r\n   * Create a new instance.\r\n   *\r\n   * @param options - The options object of given edge.\r\n   * @param body - The body of the network.\r\n   * @param labelModule - Label module.\r\n   */\n  function CubicBezierEdgeBase(options, body, labelModule) {\n    _classCallCheck(this, CubicBezierEdgeBase);\n    return _super.call(this, options, body, labelModule);\n  }\n  /**\r\n   * Calculate the distance between a point (x3,y3) and a line segment from (x1,y1) to (x2,y2).\r\n   *\r\n   * @remarks\r\n   * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment\r\n   * https://en.wikipedia.org/wiki/B%C3%A9zier_curve\r\n   * @param x1 - First end of the line segment on the x axis.\r\n   * @param y1 - First end of the line segment on the y axis.\r\n   * @param x2 - Second end of the line segment on the x axis.\r\n   * @param y2 - Second end of the line segment on the y axis.\r\n   * @param x3 - Position of the point on the x axis.\r\n   * @param y3 - Position of the point on the y axis.\r\n   * @param via1 - The first point this edge passes through.\r\n   * @param via2 - The second point this edge passes through.\r\n   * @returns The distance between the line segment and the point.\r\n   */\n  _createClass(CubicBezierEdgeBase, [{\n    key: \"_getDistanceToBezierEdge2\",\n    value: function _getDistanceToBezierEdge2(x1, y1, x2, y2, x3, y3, via1, via2) {\n      // x3,y3 is the point\n      var minDistance = 1e9;\n      var lastX = x1;\n      var lastY = y1;\n      var vec = [0, 0, 0, 0];\n      for (var i = 1; i < 10; i++) {\n        var t = 0.1 * i;\n        vec[0] = Math.pow(1 - t, 3);\n        vec[1] = 3 * t * Math.pow(1 - t, 2);\n        vec[2] = 3 * Math.pow(t, 2) * (1 - t);\n        vec[3] = Math.pow(t, 3);\n        var x = vec[0] * x1 + vec[1] * via1.x + vec[2] * via2.x + vec[3] * x2;\n        var y = vec[0] * y1 + vec[1] * via1.y + vec[2] * via2.y + vec[3] * y2;\n        if (i > 0) {\n          var distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);\n          minDistance = distance < minDistance ? distance : minDistance;\n        }\n        lastX = x;\n        lastY = y;\n      }\n      return minDistance;\n    }\n  }]);\n  return CubicBezierEdgeBase;\n}(BezierEdgeBase);\n\nfunction _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$5() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n/**\r\n * A Cubic Bezier Edge. Bezier curves are used to model smooth gradual curves in paths between nodes.\r\n */\nvar CubicBezierEdge = /*#__PURE__*/function (_CubicBezierEdgeBase) {\n  _inherits(CubicBezierEdge, _CubicBezierEdgeBase);\n  var _super = _createSuper$5(CubicBezierEdge);\n  /**\r\n   * Create a new instance.\r\n   *\r\n   * @param options - The options object of given edge.\r\n   * @param body - The body of the network.\r\n   * @param labelModule - Label module.\r\n   */\n  function CubicBezierEdge(options, body, labelModule) {\n    _classCallCheck(this, CubicBezierEdge);\n    return _super.call(this, options, body, labelModule);\n  }\n  /** @inheritDoc */\n  _createClass(CubicBezierEdge, [{\n    key: \"_line\",\n    value: function _line(ctx, values, viaNodes) {\n      // get the coordinates of the support points.\n      var via1 = viaNodes[0];\n      var via2 = viaNodes[1];\n      this._bezierCurve(ctx, values, via1, via2);\n    }\n    /**\r\n     * Compute the additional points the edge passes through.\r\n     *\r\n     * @returns Cartesian coordinates of the points the edge passes through.\r\n     */\n  }, {\n    key: \"_getViaCoordinates\",\n    value: function _getViaCoordinates() {\n      var dx = this.from.x - this.to.x;\n      var dy = this.from.y - this.to.y;\n      var x1;\n      var y1;\n      var x2;\n      var y2;\n      var roundness = this.options.smooth.roundness;\n      // horizontal if x > y or if direction is forced or if direction is horizontal\n      if ((Math.abs(dx) > Math.abs(dy) || this.options.smooth.forceDirection === true || this.options.smooth.forceDirection === \"horizontal\") && this.options.smooth.forceDirection !== \"vertical\") {\n        y1 = this.from.y;\n        y2 = this.to.y;\n        x1 = this.from.x - roundness * dx;\n        x2 = this.to.x + roundness * dx;\n      } else {\n        y1 = this.from.y - roundness * dy;\n        y2 = this.to.y + roundness * dy;\n        x1 = this.from.x;\n        x2 = this.to.x;\n      }\n      return [{\n        x: x1,\n        y: y1\n      }, {\n        x: x2,\n        y: y2\n      }];\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"getViaNode\",\n    value: function getViaNode() {\n      return this._getViaCoordinates();\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"_findBorderPosition\",\n    value: function _findBorderPosition(nearNode, ctx) {\n      return this._findBorderPositionBezier(nearNode, ctx);\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"_getDistanceToEdge\",\n    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {\n      var _ref = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this._getViaCoordinates(),\n        _ref2 = _slicedToArray(_ref, 2),\n        via1 = _ref2[0],\n        via2 = _ref2[1];\n      // x3,y3 is the point\n      return this._getDistanceToBezierEdge2(x1, y1, x2, y2, x3, y3, via1, via2);\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"getPoint\",\n    value: function getPoint(position) {\n      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._getViaCoordinates(),\n        _ref4 = _slicedToArray(_ref3, 2),\n        via1 = _ref4[0],\n        via2 = _ref4[1];\n      var t = position;\n      var vec = [Math.pow(1 - t, 3), 3 * t * Math.pow(1 - t, 2), 3 * Math.pow(t, 2) * (1 - t), Math.pow(t, 3)];\n      var x = vec[0] * this.fromPoint.x + vec[1] * via1.x + vec[2] * via2.x + vec[3] * this.toPoint.x;\n      var y = vec[0] * this.fromPoint.y + vec[1] * via1.y + vec[2] * via2.y + vec[3] * this.toPoint.y;\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }]);\n  return CubicBezierEdge;\n}(CubicBezierEdgeBase);\n\nfunction _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$4() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n/**\r\n * A Straight Edge.\r\n */\nvar StraightEdge = /*#__PURE__*/function (_EdgeBase) {\n  _inherits(StraightEdge, _EdgeBase);\n  var _super = _createSuper$4(StraightEdge);\n  /**\r\n   * Create a new instance.\r\n   *\r\n   * @param options - The options object of given edge.\r\n   * @param body - The body of the network.\r\n   * @param labelModule - Label module.\r\n   */\n  function StraightEdge(options, body, labelModule) {\n    _classCallCheck(this, StraightEdge);\n    return _super.call(this, options, body, labelModule);\n  }\n  /** @inheritDoc */\n  _createClass(StraightEdge, [{\n    key: \"_line\",\n    value: function _line(ctx, values) {\n      // draw a straight line\n      ctx.beginPath();\n      ctx.moveTo(this.fromPoint.x, this.fromPoint.y);\n      ctx.lineTo(this.toPoint.x, this.toPoint.y);\n      // draw shadow if enabled\n      this.enableShadow(ctx, values);\n      ctx.stroke();\n      this.disableShadow(ctx, values);\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"getViaNode\",\n    value: function getViaNode() {\n      return undefined;\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"getPoint\",\n    value: function getPoint(position) {\n      return {\n        x: (1 - position) * this.fromPoint.x + position * this.toPoint.x,\n        y: (1 - position) * this.fromPoint.y + position * this.toPoint.y\n      };\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"_findBorderPosition\",\n    value: function _findBorderPosition(nearNode, ctx) {\n      var node1 = this.to;\n      var node2 = this.from;\n      if (nearNode.id === this.from.id) {\n        node1 = this.from;\n        node2 = this.to;\n      }\n      var angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);\n      var dx = node1.x - node2.x;\n      var dy = node1.y - node2.y;\n      var edgeSegmentLength = Math.sqrt(dx * dx + dy * dy);\n      var toBorderDist = nearNode.distanceToBorder(ctx, angle);\n      var toBorderPoint = (edgeSegmentLength - toBorderDist) / edgeSegmentLength;\n      return {\n        x: (1 - toBorderPoint) * node2.x + toBorderPoint * node1.x,\n        y: (1 - toBorderPoint) * node2.y + toBorderPoint * node1.y,\n        t: 0\n      };\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"_getDistanceToEdge\",\n    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {\n      // x3,y3 is the point\n      return this._getDistanceToLine(x1, y1, x2, y2, x3, y3);\n    }\n  }]);\n  return StraightEdge;\n}(EdgeBase);\n\n/**\n * An edge connects two nodes and has a specific direction.\n */\nvar Edge = /*#__PURE__*/function () {\n  /**\n   * @param {object} options        values specific to this edge, must contain at least 'from' and 'to'\n   * @param {object} body           shared state from Network instance\n   * @param {Network.Images} imagelist  A list with images. Only needed when the edge has image arrows.\n   * @param {object} globalOptions  options from the EdgesHandler instance\n   * @param {object} defaultOptions default options from the EdgeHandler instance. Value and reference are constant\n   */\n  function Edge(options, body, imagelist, globalOptions, defaultOptions) {\n    _classCallCheck(this, Edge);\n    if (body === undefined) {\n      throw new Error(\"No body provided\");\n    }\n\n    // Since globalOptions is constant in values as well as reference,\n    // Following needs to be done only once.\n\n    this.options = bridgeObject(globalOptions);\n    this.globalOptions = globalOptions;\n    this.defaultOptions = defaultOptions;\n    this.body = body;\n    this.imagelist = imagelist;\n\n    // initialize variables\n    this.id = undefined;\n    this.fromId = undefined;\n    this.toId = undefined;\n    this.selected = false;\n    this.hover = false;\n    this.labelDirty = true;\n    this.baseWidth = this.options.width;\n    this.baseFontSize = this.options.font.size;\n    this.from = undefined; // a node\n    this.to = undefined; // a node\n\n    this.edgeType = undefined;\n    this.connected = false;\n    this.labelModule = new Label(this.body, this.options, true /* It's an edge label */);\n\n    this.setOptions(options);\n  }\n\n  /**\n   * Set or overwrite options for the edge\n   *\n   * @param {object} options  an object with options\n   * @returns {undefined|boolean} undefined if no options, true if layout affecting data changed, false otherwise.\n   */\n  _createClass(Edge, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (!options) {\n        return;\n      }\n\n      // Following options if changed affect the layout.\n      var affectsLayout = typeof options.physics !== \"undefined\" && this.options.physics !== options.physics || typeof options.hidden !== \"undefined\" && (this.options.hidden || false) !== (options.hidden || false) || typeof options.from !== \"undefined\" && this.options.from !== options.from || typeof options.to !== \"undefined\" && this.options.to !== options.to;\n      Edge.parseOptions(this.options, options, true, this.globalOptions);\n      if (options.id !== undefined) {\n        this.id = options.id;\n      }\n      if (options.from !== undefined) {\n        this.fromId = options.from;\n      }\n      if (options.to !== undefined) {\n        this.toId = options.to;\n      }\n      if (options.title !== undefined) {\n        this.title = options.title;\n      }\n      if (options.value !== undefined) {\n        options.value = _parseFloat$1(options.value);\n      }\n      var pile = [options, this.options, this.defaultOptions];\n      this.chooser = choosify(\"edge\", pile);\n\n      // update label Module\n      this.updateLabelModule(options);\n\n      // Update edge type, this if changed affects the layout.\n      affectsLayout = this.updateEdgeType() || affectsLayout;\n\n      // if anything has been updates, reset the selection width and the hover width\n      this._setInteractionWidths();\n\n      // A node is connected when it has a from and to node that both exist in the network.body.nodes.\n      this.connect();\n      return affectsLayout;\n    }\n\n    /**\n     *\n     * @param {object} parentOptions\n     * @param {object} newOptions\n     * @param {boolean} [allowDeletion=false]\n     * @param {object} [globalOptions={}]\n     * @param {boolean} [copyFromGlobals=false]\n     */\n  }, {\n    key: \"getFormattingValues\",\n    value:\n    /**\n     *\n     * @returns {ArrowOptions}\n     */\n    function getFormattingValues() {\n      var toArrow = this.options.arrows.to === true || this.options.arrows.to.enabled === true;\n      var fromArrow = this.options.arrows.from === true || this.options.arrows.from.enabled === true;\n      var middleArrow = this.options.arrows.middle === true || this.options.arrows.middle.enabled === true;\n      var inheritsColor = this.options.color.inherit;\n      var values = {\n        toArrow: toArrow,\n        toArrowScale: this.options.arrows.to.scaleFactor,\n        toArrowType: this.options.arrows.to.type,\n        toArrowSrc: this.options.arrows.to.src,\n        toArrowImageWidth: this.options.arrows.to.imageWidth,\n        toArrowImageHeight: this.options.arrows.to.imageHeight,\n        middleArrow: middleArrow,\n        middleArrowScale: this.options.arrows.middle.scaleFactor,\n        middleArrowType: this.options.arrows.middle.type,\n        middleArrowSrc: this.options.arrows.middle.src,\n        middleArrowImageWidth: this.options.arrows.middle.imageWidth,\n        middleArrowImageHeight: this.options.arrows.middle.imageHeight,\n        fromArrow: fromArrow,\n        fromArrowScale: this.options.arrows.from.scaleFactor,\n        fromArrowType: this.options.arrows.from.type,\n        fromArrowSrc: this.options.arrows.from.src,\n        fromArrowImageWidth: this.options.arrows.from.imageWidth,\n        fromArrowImageHeight: this.options.arrows.from.imageHeight,\n        arrowStrikethrough: this.options.arrowStrikethrough,\n        color: inheritsColor ? undefined : this.options.color.color,\n        inheritsColor: inheritsColor,\n        opacity: this.options.color.opacity,\n        hidden: this.options.hidden,\n        length: this.options.length,\n        shadow: this.options.shadow.enabled,\n        shadowColor: this.options.shadow.color,\n        shadowSize: this.options.shadow.size,\n        shadowX: this.options.shadow.x,\n        shadowY: this.options.shadow.y,\n        dashes: this.options.dashes,\n        width: this.options.width,\n        background: this.options.background.enabled,\n        backgroundColor: this.options.background.color,\n        backgroundSize: this.options.background.size,\n        backgroundDashes: this.options.background.dashes\n      };\n      if (this.selected || this.hover) {\n        if (this.chooser === true) {\n          if (this.selected) {\n            var selectedWidth = this.options.selectionWidth;\n            if (typeof selectedWidth === \"function\") {\n              values.width = selectedWidth(values.width);\n            } else if (typeof selectedWidth === \"number\") {\n              values.width += selectedWidth;\n            }\n            values.width = Math.max(values.width, 0.3 / this.body.view.scale);\n            values.color = this.options.color.highlight;\n            values.shadow = this.options.shadow.enabled;\n          } else if (this.hover) {\n            var hoverWidth = this.options.hoverWidth;\n            if (typeof hoverWidth === \"function\") {\n              values.width = hoverWidth(values.width);\n            } else if (typeof hoverWidth === \"number\") {\n              values.width += hoverWidth;\n            }\n            values.width = Math.max(values.width, 0.3 / this.body.view.scale);\n            values.color = this.options.color.hover;\n            values.shadow = this.options.shadow.enabled;\n          }\n        } else if (typeof this.chooser === \"function\") {\n          this.chooser(values, this.options.id, this.selected, this.hover);\n          if (values.color !== undefined) {\n            values.inheritsColor = false;\n          }\n          if (values.shadow === false) {\n            if (values.shadowColor !== this.options.shadow.color || values.shadowSize !== this.options.shadow.size || values.shadowX !== this.options.shadow.x || values.shadowY !== this.options.shadow.y) {\n              values.shadow = true;\n            }\n          }\n        }\n      } else {\n        values.shadow = this.options.shadow.enabled;\n        values.width = Math.max(values.width, 0.3 / this.body.view.scale);\n      }\n      return values;\n    }\n\n    /**\n     * update the options in the label module\n     *\n     * @param {object} options\n     */\n  }, {\n    key: \"updateLabelModule\",\n    value: function updateLabelModule(options) {\n      var pile = [options, this.options, this.globalOptions,\n      // Currently set global edge options\n      this.defaultOptions];\n      this.labelModule.update(this.options, pile);\n      if (this.labelModule.baseSize !== undefined) {\n        this.baseFontSize = this.labelModule.baseSize;\n      }\n    }\n\n    /**\n     * update the edge type, set the options\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"updateEdgeType\",\n    value: function updateEdgeType() {\n      var smooth = this.options.smooth;\n      var dataChanged = false;\n      var changeInType = true;\n      if (this.edgeType !== undefined) {\n        if (this.edgeType instanceof BezierEdgeDynamic && smooth.enabled === true && smooth.type === \"dynamic\" || this.edgeType instanceof CubicBezierEdge && smooth.enabled === true && smooth.type === \"cubicBezier\" || this.edgeType instanceof BezierEdgeStatic && smooth.enabled === true && smooth.type !== \"dynamic\" && smooth.type !== \"cubicBezier\" || this.edgeType instanceof StraightEdge && smooth.type.enabled === false) {\n          changeInType = false;\n        }\n        if (changeInType === true) {\n          dataChanged = this.cleanup();\n        }\n      }\n      if (changeInType === true) {\n        if (smooth.enabled === true) {\n          if (smooth.type === \"dynamic\") {\n            dataChanged = true;\n            this.edgeType = new BezierEdgeDynamic(this.options, this.body, this.labelModule);\n          } else if (smooth.type === \"cubicBezier\") {\n            this.edgeType = new CubicBezierEdge(this.options, this.body, this.labelModule);\n          } else {\n            this.edgeType = new BezierEdgeStatic(this.options, this.body, this.labelModule);\n          }\n        } else {\n          this.edgeType = new StraightEdge(this.options, this.body, this.labelModule);\n        }\n      } else {\n        // if nothing changes, we just set the options.\n        this.edgeType.setOptions(this.options);\n      }\n      return dataChanged;\n    }\n\n    /**\n     * Connect an edge to its nodes\n     */\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      this.disconnect();\n      this.from = this.body.nodes[this.fromId] || undefined;\n      this.to = this.body.nodes[this.toId] || undefined;\n      this.connected = this.from !== undefined && this.to !== undefined;\n      if (this.connected === true) {\n        this.from.attachEdge(this);\n        this.to.attachEdge(this);\n      } else {\n        if (this.from) {\n          this.from.detachEdge(this);\n        }\n        if (this.to) {\n          this.to.detachEdge(this);\n        }\n      }\n      this.edgeType.connect();\n    }\n\n    /**\n     * Disconnect an edge from its nodes\n     */\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      if (this.from) {\n        this.from.detachEdge(this);\n        this.from = undefined;\n      }\n      if (this.to) {\n        this.to.detachEdge(this);\n        this.to = undefined;\n      }\n      this.connected = false;\n    }\n\n    /**\n     * get the title of this edge.\n     *\n     * @returns {string} title    The title of the edge, or undefined when no title\n     *                           has been set.\n     */\n  }, {\n    key: \"getTitle\",\n    value: function getTitle() {\n      return this.title;\n    }\n\n    /**\n     * check if this node is selecte\n     *\n     * @returns {boolean} selected   True if node is selected, else false\n     */\n  }, {\n    key: \"isSelected\",\n    value: function isSelected() {\n      return this.selected;\n    }\n\n    /**\n     * Retrieve the value of the edge. Can be undefined\n     *\n     * @returns {number} value\n     */\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.options.value;\n    }\n\n    /**\n     * Adjust the value range of the edge. The edge will adjust it's width\n     * based on its value.\n     *\n     * @param {number} min\n     * @param {number} max\n     * @param {number} total\n     */\n  }, {\n    key: \"setValueRange\",\n    value: function setValueRange(min, max, total) {\n      if (this.options.value !== undefined) {\n        var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);\n        var widthDiff = this.options.scaling.max - this.options.scaling.min;\n        if (this.options.scaling.label.enabled === true) {\n          var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;\n          this.options.font.size = this.options.scaling.label.min + scale * fontDiff;\n        }\n        this.options.width = this.options.scaling.min + scale * widthDiff;\n      } else {\n        this.options.width = this.baseWidth;\n        this.options.font.size = this.baseFontSize;\n      }\n      this._setInteractionWidths();\n      this.updateLabelModule();\n    }\n\n    /**\n     *\n     * @private\n     */\n  }, {\n    key: \"_setInteractionWidths\",\n    value: function _setInteractionWidths() {\n      if (typeof this.options.hoverWidth === \"function\") {\n        this.edgeType.hoverWidth = this.options.hoverWidth(this.options.width);\n      } else {\n        this.edgeType.hoverWidth = this.options.hoverWidth + this.options.width;\n      }\n      if (typeof this.options.selectionWidth === \"function\") {\n        this.edgeType.selectionWidth = this.options.selectionWidth(this.options.width);\n      } else {\n        this.edgeType.selectionWidth = this.options.selectionWidth + this.options.width;\n      }\n    }\n\n    /**\n     * Redraw a edge\n     * Draw this edge in the given canvas\n     * The 2d context of a HTML canvas can be retrieved by canvas.getContext(\"2d\");\n     *\n     * @param {CanvasRenderingContext2D}   ctx\n     */\n  }, {\n    key: \"draw\",\n    value: function draw(ctx) {\n      var values = this.getFormattingValues();\n      if (values.hidden) {\n        return;\n      }\n\n      // get the via node from the edge type\n      var viaNode = this.edgeType.getViaNode();\n\n      // draw line and label\n      this.edgeType.drawLine(ctx, values, this.selected, this.hover, viaNode);\n      this.drawLabel(ctx, viaNode);\n    }\n\n    /**\n     * Redraw arrows\n     * Draw this arrows in the given canvas\n     * The 2d context of a HTML canvas can be retrieved by canvas.getContext(\"2d\");\n     *\n     * @param {CanvasRenderingContext2D}   ctx\n     */\n  }, {\n    key: \"drawArrows\",\n    value: function drawArrows(ctx) {\n      var values = this.getFormattingValues();\n      if (values.hidden) {\n        return;\n      }\n\n      // get the via node from the edge type\n      var viaNode = this.edgeType.getViaNode();\n      var arrowData = {};\n\n      // restore edge targets to defaults\n      this.edgeType.fromPoint = this.edgeType.from;\n      this.edgeType.toPoint = this.edgeType.to;\n\n      // from and to arrows give a different end point for edges. we set them here\n      if (values.fromArrow) {\n        arrowData.from = this.edgeType.getArrowData(ctx, \"from\", viaNode, this.selected, this.hover, values);\n        if (values.arrowStrikethrough === false) this.edgeType.fromPoint = arrowData.from.core;\n        if (values.fromArrowSrc) {\n          arrowData.from.image = this.imagelist.load(values.fromArrowSrc);\n        }\n        if (values.fromArrowImageWidth) {\n          arrowData.from.imageWidth = values.fromArrowImageWidth;\n        }\n        if (values.fromArrowImageHeight) {\n          arrowData.from.imageHeight = values.fromArrowImageHeight;\n        }\n      }\n      if (values.toArrow) {\n        arrowData.to = this.edgeType.getArrowData(ctx, \"to\", viaNode, this.selected, this.hover, values);\n        if (values.arrowStrikethrough === false) this.edgeType.toPoint = arrowData.to.core;\n        if (values.toArrowSrc) {\n          arrowData.to.image = this.imagelist.load(values.toArrowSrc);\n        }\n        if (values.toArrowImageWidth) {\n          arrowData.to.imageWidth = values.toArrowImageWidth;\n        }\n        if (values.toArrowImageHeight) {\n          arrowData.to.imageHeight = values.toArrowImageHeight;\n        }\n      }\n\n      // the middle arrow depends on the line, which can depend on the to and from arrows so we do this one lastly.\n      if (values.middleArrow) {\n        arrowData.middle = this.edgeType.getArrowData(ctx, \"middle\", viaNode, this.selected, this.hover, values);\n        if (values.middleArrowSrc) {\n          arrowData.middle.image = this.imagelist.load(values.middleArrowSrc);\n        }\n        if (values.middleArrowImageWidth) {\n          arrowData.middle.imageWidth = values.middleArrowImageWidth;\n        }\n        if (values.middleArrowImageHeight) {\n          arrowData.middle.imageHeight = values.middleArrowImageHeight;\n        }\n      }\n      if (values.fromArrow) {\n        this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.from);\n      }\n      if (values.middleArrow) {\n        this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.middle);\n      }\n      if (values.toArrow) {\n        this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.to);\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {Node} viaNode\n     */\n  }, {\n    key: \"drawLabel\",\n    value: function drawLabel(ctx, viaNode) {\n      if (this.options.label !== undefined) {\n        // set style\n        var node1 = this.from;\n        var node2 = this.to;\n        if (this.labelModule.differentState(this.selected, this.hover)) {\n          this.labelModule.getTextSize(ctx, this.selected, this.hover);\n        }\n        var point;\n        if (node1.id != node2.id) {\n          this.labelModule.pointToSelf = false;\n          point = this.edgeType.getPoint(0.5, viaNode);\n          ctx.save();\n          var rotationPoint = this._getRotation(ctx);\n          if (rotationPoint.angle != 0) {\n            ctx.translate(rotationPoint.x, rotationPoint.y);\n            ctx.rotate(rotationPoint.angle);\n          }\n\n          // draw the label\n          this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);\n\n          /*\n          // Useful debug code: draw a border around the label\n          // This should **not** be enabled in production!\n          var size = this.labelModule.getSize();; // ;; intentional so lint catches it\n          ctx.strokeStyle = \"#ff0000\";\n          ctx.strokeRect(size.left, size.top, size.width, size.height);\n          // End  debug code\n          */\n\n          ctx.restore();\n        } else {\n          // Ignore the orientations.\n          this.labelModule.pointToSelf = true;\n\n          // get circle coordinates\n          var coordinates = getSelfRefCoordinates(ctx, this.options.selfReference.angle, this.options.selfReference.size, node1);\n          point = this._pointOnCircle(coordinates.x, coordinates.y, this.options.selfReference.size, this.options.selfReference.angle);\n          this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);\n        }\n      }\n    }\n\n    /**\n     * Determine all visual elements of this edge instance, in which the given\n     * point falls within the bounding shape.\n     *\n     * @param {point} point\n     * @returns {Array.<edgeClickItem|edgeLabelClickItem>} list with the items which are on the point\n     */\n  }, {\n    key: \"getItemsOnPoint\",\n    value: function getItemsOnPoint(point) {\n      var ret = [];\n      if (this.labelModule.visible()) {\n        var rotationPoint = this._getRotation();\n        if (pointInRect(this.labelModule.getSize(), point, rotationPoint)) {\n          ret.push({\n            edgeId: this.id,\n            labelId: 0\n          });\n        }\n      }\n      var obj = {\n        left: point.x,\n        top: point.y\n      };\n      if (this.isOverlappingWith(obj)) {\n        ret.push({\n          edgeId: this.id\n        });\n      }\n      return ret;\n    }\n\n    /**\n     * Check if this object is overlapping with the provided object\n     *\n     * @param {object} obj   an object with parameters left, top\n     * @returns {boolean}     True if location is located on the edge\n     */\n  }, {\n    key: \"isOverlappingWith\",\n    value: function isOverlappingWith(obj) {\n      if (this.connected) {\n        var distMax = 10;\n        var xFrom = this.from.x;\n        var yFrom = this.from.y;\n        var xTo = this.to.x;\n        var yTo = this.to.y;\n        var xObj = obj.left;\n        var yObj = obj.top;\n        var dist = this.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, xObj, yObj);\n        return dist < distMax;\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Determine the rotation point, if any.\n     *\n     * @param {CanvasRenderingContext2D} [ctx] if passed, do a recalculation of the label size\n     * @returns {rotationPoint} the point to rotate around and the angle in radians to rotate\n     * @private\n     */\n  }, {\n    key: \"_getRotation\",\n    value: function _getRotation(ctx) {\n      var viaNode = this.edgeType.getViaNode();\n      var point = this.edgeType.getPoint(0.5, viaNode);\n      if (ctx !== undefined) {\n        this.labelModule.calculateLabelSize(ctx, this.selected, this.hover, point.x, point.y);\n      }\n      var ret = {\n        x: point.x,\n        y: this.labelModule.size.yLine,\n        angle: 0\n      };\n      if (!this.labelModule.visible()) {\n        return ret; // Don't even bother doing the atan2, there's nothing to draw\n      }\n\n      if (this.options.font.align === \"horizontal\") {\n        return ret; // No need to calculate angle\n      }\n\n      var dy = this.from.y - this.to.y;\n      var dx = this.from.x - this.to.x;\n      var angle = Math.atan2(dy, dx); // radians\n\n      // rotate so that label is readable\n      if (angle < -1 && dx < 0 || angle > 0 && dx < 0) {\n        angle += Math.PI;\n      }\n      ret.angle = angle;\n      return ret;\n    }\n\n    /**\n     * Get a point on a circle\n     *\n     * @param {number} x\n     * @param {number} y\n     * @param {number} radius\n     * @param {number} angle\n     * @returns {object} point\n     * @private\n     */\n  }, {\n    key: \"_pointOnCircle\",\n    value: function _pointOnCircle(x, y, radius, angle) {\n      return {\n        x: x + radius * Math.cos(angle),\n        y: y - radius * Math.sin(angle)\n      };\n    }\n\n    /**\n     * Sets selected state to true\n     */\n  }, {\n    key: \"select\",\n    value: function select() {\n      this.selected = true;\n    }\n\n    /**\n     * Sets selected state to false\n     */\n  }, {\n    key: \"unselect\",\n    value: function unselect() {\n      this.selected = false;\n    }\n\n    /**\n     * cleans all required things on delete\n     *\n     * @returns {*}\n     */\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      return this.edgeType.cleanup();\n    }\n\n    /**\n     * Remove edge from the list and perform necessary cleanup.\n     */\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      this.cleanup();\n      this.disconnect();\n      delete this.body.edges[this.id];\n    }\n\n    /**\n     * Check if both connecting nodes exist\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"endPointsValid\",\n    value: function endPointsValid() {\n      return this.body.nodes[this.fromId] !== undefined && this.body.nodes[this.toId] !== undefined;\n    }\n  }], [{\n    key: \"parseOptions\",\n    value: function parseOptions(parentOptions, newOptions) {\n      var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var copyFromGlobals = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var fields = [\"endPointOffset\", \"arrowStrikethrough\", \"id\", \"from\", \"hidden\", \"hoverWidth\", \"labelHighlightBold\", \"length\", \"line\", \"opacity\", \"physics\", \"scaling\", \"selectionWidth\", \"selfReferenceSize\", \"selfReference\", \"to\", \"title\", \"value\", \"width\", \"font\", \"chosen\", \"widthConstraint\"];\n\n      // only deep extend the items in the field array. These do not have shorthand.\n      selectiveDeepExtend(fields, parentOptions, newOptions, allowDeletion);\n\n      // Only use endPointOffset values (from and to) if it's valid values\n      if (newOptions.endPointOffset !== undefined && newOptions.endPointOffset.from !== undefined) {\n        if (_Number$isFinite(newOptions.endPointOffset.from)) {\n          parentOptions.endPointOffset.from = newOptions.endPointOffset.from;\n        } else {\n          parentOptions.endPointOffset.from = globalOptions.endPointOffset.from !== undefined ? globalOptions.endPointOffset.from : 0;\n          console.error(\"endPointOffset.from is not a valid number\");\n        }\n      }\n      if (newOptions.endPointOffset !== undefined && newOptions.endPointOffset.to !== undefined) {\n        if (_Number$isFinite(newOptions.endPointOffset.to)) {\n          parentOptions.endPointOffset.to = newOptions.endPointOffset.to;\n        } else {\n          parentOptions.endPointOffset.to = globalOptions.endPointOffset.to !== undefined ? globalOptions.endPointOffset.to : 0;\n          console.error(\"endPointOffset.to is not a valid number\");\n        }\n      }\n\n      // Only copy label if it's a legal value.\n      if (isValidLabel(newOptions.label)) {\n        parentOptions.label = newOptions.label;\n      } else if (!isValidLabel(parentOptions.label)) {\n        parentOptions.label = undefined;\n      }\n      mergeOptions(parentOptions, newOptions, \"smooth\", globalOptions);\n      mergeOptions(parentOptions, newOptions, \"shadow\", globalOptions);\n      mergeOptions(parentOptions, newOptions, \"background\", globalOptions);\n      if (newOptions.dashes !== undefined && newOptions.dashes !== null) {\n        parentOptions.dashes = newOptions.dashes;\n      } else if (allowDeletion === true && newOptions.dashes === null) {\n        parentOptions.dashes = _Object$create$1(globalOptions.dashes); // this sets the pointer of the option back to the global option.\n      }\n\n      // set the scaling newOptions\n      if (newOptions.scaling !== undefined && newOptions.scaling !== null) {\n        if (newOptions.scaling.min !== undefined) {\n          parentOptions.scaling.min = newOptions.scaling.min;\n        }\n        if (newOptions.scaling.max !== undefined) {\n          parentOptions.scaling.max = newOptions.scaling.max;\n        }\n        mergeOptions(parentOptions.scaling, newOptions.scaling, \"label\", globalOptions.scaling);\n      } else if (allowDeletion === true && newOptions.scaling === null) {\n        parentOptions.scaling = _Object$create$1(globalOptions.scaling); // this sets the pointer of the option back to the global option.\n      }\n\n      // handle multiple input cases for arrows\n      if (newOptions.arrows !== undefined && newOptions.arrows !== null) {\n        if (typeof newOptions.arrows === \"string\") {\n          var arrows = newOptions.arrows.toLowerCase();\n          parentOptions.arrows.to.enabled = _indexOfInstanceProperty(arrows).call(arrows, \"to\") != -1;\n          parentOptions.arrows.middle.enabled = _indexOfInstanceProperty(arrows).call(arrows, \"middle\") != -1;\n          parentOptions.arrows.from.enabled = _indexOfInstanceProperty(arrows).call(arrows, \"from\") != -1;\n        } else if (_typeof(newOptions.arrows) === \"object\") {\n          mergeOptions(parentOptions.arrows, newOptions.arrows, \"to\", globalOptions.arrows);\n          mergeOptions(parentOptions.arrows, newOptions.arrows, \"middle\", globalOptions.arrows);\n          mergeOptions(parentOptions.arrows, newOptions.arrows, \"from\", globalOptions.arrows);\n        } else {\n          throw new Error(\"The arrow newOptions can only be an object or a string. Refer to the documentation. You used:\" + _JSON$stringify(newOptions.arrows));\n        }\n      } else if (allowDeletion === true && newOptions.arrows === null) {\n        parentOptions.arrows = _Object$create$1(globalOptions.arrows); // this sets the pointer of the option back to the global option.\n      }\n\n      // handle multiple input cases for color\n      if (newOptions.color !== undefined && newOptions.color !== null) {\n        var fromColor = isString(newOptions.color) ? {\n          color: newOptions.color,\n          highlight: newOptions.color,\n          hover: newOptions.color,\n          inherit: false,\n          opacity: 1\n        } : newOptions.color;\n        var toColor = parentOptions.color;\n\n        // If passed, fill in values from default options - required in the case of no prototype bridging\n        if (copyFromGlobals) {\n          deepExtend(toColor, globalOptions.color, false, allowDeletion);\n        } else {\n          // Clear local properties - need to do it like this in order to retain prototype bridges\n          for (var i in toColor) {\n            if (Object.prototype.hasOwnProperty.call(toColor, i)) {\n              delete toColor[i];\n            }\n          }\n        }\n        if (isString(toColor)) {\n          toColor.color = toColor;\n          toColor.highlight = toColor;\n          toColor.hover = toColor;\n          toColor.inherit = false;\n          if (fromColor.opacity === undefined) {\n            toColor.opacity = 1.0; // set default\n          }\n        } else {\n          var colorsDefined = false;\n          if (fromColor.color !== undefined) {\n            toColor.color = fromColor.color;\n            colorsDefined = true;\n          }\n          if (fromColor.highlight !== undefined) {\n            toColor.highlight = fromColor.highlight;\n            colorsDefined = true;\n          }\n          if (fromColor.hover !== undefined) {\n            toColor.hover = fromColor.hover;\n            colorsDefined = true;\n          }\n          if (fromColor.inherit !== undefined) {\n            toColor.inherit = fromColor.inherit;\n          }\n          if (fromColor.opacity !== undefined) {\n            toColor.opacity = Math.min(1, Math.max(0, fromColor.opacity));\n          }\n          if (colorsDefined === true) {\n            toColor.inherit = false;\n          } else {\n            if (toColor.inherit === undefined) {\n              toColor.inherit = \"from\"; // Set default\n            }\n          }\n        }\n      } else if (allowDeletion === true && newOptions.color === null) {\n        parentOptions.color = bridgeObject(globalOptions.color); // set the object back to the global options\n      }\n\n      if (allowDeletion === true && newOptions.font === null) {\n        parentOptions.font = bridgeObject(globalOptions.font); // set the object back to the global options\n      }\n\n      if (Object.prototype.hasOwnProperty.call(newOptions, \"selfReferenceSize\")) {\n        console.warn(\"The selfReferenceSize property has been deprecated. Please use selfReference property instead. The selfReference can be set like thise selfReference:{size:30, angle:Math.PI / 4}\");\n        parentOptions.selfReference.size = newOptions.selfReferenceSize;\n      }\n    }\n  }]);\n  return Edge;\n}();\n\n/**\n * Handler for Edges\n */\nvar EdgesHandler = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {Array.<Image>} images\n   * @param {Array.<Group>} groups\n   */\n  function EdgesHandler(body, images, groups) {\n    var _context,\n      _this = this;\n    _classCallCheck(this, EdgesHandler);\n    this.body = body;\n    this.images = images;\n    this.groups = groups;\n\n    // create the edge API in the body container\n    this.body.functions.createEdge = _bindInstanceProperty$1(_context = this.create).call(_context, this);\n    this.edgesListeners = {\n      add: function add(event, params) {\n        _this.add(params.items);\n      },\n      update: function update(event, params) {\n        _this.update(params.items);\n      },\n      remove: function remove(event, params) {\n        _this.remove(params.items);\n      }\n    };\n    this.options = {};\n    this.defaultOptions = {\n      arrows: {\n        to: {\n          enabled: false,\n          scaleFactor: 1,\n          type: \"arrow\"\n        },\n        // boolean / {arrowScaleFactor:1} / {enabled: false, arrowScaleFactor:1}\n        middle: {\n          enabled: false,\n          scaleFactor: 1,\n          type: \"arrow\"\n        },\n        from: {\n          enabled: false,\n          scaleFactor: 1,\n          type: \"arrow\"\n        }\n      },\n      endPointOffset: {\n        from: 0,\n        to: 0\n      },\n      arrowStrikethrough: true,\n      color: {\n        color: \"#848484\",\n        highlight: \"#848484\",\n        hover: \"#848484\",\n        inherit: \"from\",\n        opacity: 1.0\n      },\n      dashes: false,\n      font: {\n        color: \"#343434\",\n        size: 14,\n        // px\n        face: \"arial\",\n        background: \"none\",\n        strokeWidth: 2,\n        // px\n        strokeColor: \"#ffffff\",\n        align: \"horizontal\",\n        multi: false,\n        vadjust: 0,\n        bold: {\n          mod: \"bold\"\n        },\n        boldital: {\n          mod: \"bold italic\"\n        },\n        ital: {\n          mod: \"italic\"\n        },\n        mono: {\n          mod: \"\",\n          size: 15,\n          // px\n          face: \"courier new\",\n          vadjust: 2\n        }\n      },\n      hidden: false,\n      hoverWidth: 1.5,\n      label: undefined,\n      labelHighlightBold: true,\n      length: undefined,\n      physics: true,\n      scaling: {\n        min: 1,\n        max: 15,\n        label: {\n          enabled: true,\n          min: 14,\n          max: 30,\n          maxVisible: 30,\n          drawThreshold: 5\n        },\n        customScalingFunction: function customScalingFunction(min, max, total, value) {\n          if (max === min) {\n            return 0.5;\n          } else {\n            var scale = 1 / (max - min);\n            return Math.max(0, (value - min) * scale);\n          }\n        }\n      },\n      selectionWidth: 1.5,\n      selfReference: {\n        size: 20,\n        angle: Math.PI / 4,\n        renderBehindTheNode: true\n      },\n      shadow: {\n        enabled: false,\n        color: \"rgba(0,0,0,0.5)\",\n        size: 10,\n        x: 5,\n        y: 5\n      },\n      background: {\n        enabled: false,\n        color: \"rgba(111,111,111,1)\",\n        size: 10,\n        dashes: false\n      },\n      smooth: {\n        enabled: true,\n        type: \"dynamic\",\n        forceDirection: \"none\",\n        roundness: 0.5\n      },\n      title: undefined,\n      width: 1,\n      value: undefined\n    };\n    deepExtend(this.options, this.defaultOptions);\n    this.bindEventListeners();\n  }\n\n  /**\n   * Binds event listeners\n   */\n  _createClass(EdgesHandler, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _this2 = this,\n        _context2,\n        _context3;\n      // this allows external modules to force all dynamic curves to turn static.\n      this.body.emitter.on(\"_forceDisableDynamicCurves\", function (type) {\n        var emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        if (type === \"dynamic\") {\n          type = \"continuous\";\n        }\n        var dataChanged = false;\n        for (var edgeId in _this2.body.edges) {\n          if (Object.prototype.hasOwnProperty.call(_this2.body.edges, edgeId)) {\n            var edge = _this2.body.edges[edgeId];\n            var edgeData = _this2.body.data.edges.get(edgeId);\n\n            // only forcibly remove the smooth curve if the data has been set of the edge has the smooth curves defined.\n            // this is because a change in the global would not affect these curves.\n            if (edgeData != null) {\n              var smoothOptions = edgeData.smooth;\n              if (smoothOptions !== undefined) {\n                if (smoothOptions.enabled === true && smoothOptions.type === \"dynamic\") {\n                  if (type === undefined) {\n                    edge.setOptions({\n                      smooth: false\n                    });\n                  } else {\n                    edge.setOptions({\n                      smooth: {\n                        type: type\n                      }\n                    });\n                  }\n                  dataChanged = true;\n                }\n              }\n            }\n          }\n        }\n        if (emit === true && dataChanged === true) {\n          _this2.body.emitter.emit(\"_dataChanged\");\n        }\n      });\n\n      // this is called when options of EXISTING nodes or edges have changed.\n      //\n      // NOTE: Not true, called when options have NOT changed, for both existing as well as new nodes.\n      //       See update() for logic.\n      // TODO: Verify and examine the consequences of this. It might still trigger when\n      //       non-option fields have changed, but then reconnecting edges is still useless.\n      //       Alternatively, it might also be called when edges are removed.\n      //\n      this.body.emitter.on(\"_dataUpdated\", function () {\n        _this2.reconnectEdges();\n      });\n\n      // refresh the edges. Used when reverting from hierarchical layout\n      this.body.emitter.on(\"refreshEdges\", _bindInstanceProperty$1(_context2 = this.refresh).call(_context2, this));\n      this.body.emitter.on(\"refresh\", _bindInstanceProperty$1(_context3 = this.refresh).call(_context3, this));\n      this.body.emitter.on(\"destroy\", function () {\n        forEach$1(_this2.edgesListeners, function (callback, event) {\n          if (_this2.body.data.edges) _this2.body.data.edges.off(event, callback);\n        });\n        delete _this2.body.functions.createEdge;\n        delete _this2.edgesListeners.add;\n        delete _this2.edgesListeners.update;\n        delete _this2.edgesListeners.remove;\n        delete _this2.edgesListeners;\n      });\n    }\n\n    /**\n     *\n     * @param {object} options\n     */\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        // use the parser from the Edge class to fill in all shorthand notations\n        Edge.parseOptions(this.options, options, true, this.defaultOptions, true);\n\n        // update smooth settings in all edges\n        var dataChanged = false;\n        if (options.smooth !== undefined) {\n          for (var edgeId in this.body.edges) {\n            if (Object.prototype.hasOwnProperty.call(this.body.edges, edgeId)) {\n              dataChanged = this.body.edges[edgeId].updateEdgeType() || dataChanged;\n            }\n          }\n        }\n\n        // update fonts in all edges\n        if (options.font !== undefined) {\n          for (var _edgeId in this.body.edges) {\n            if (Object.prototype.hasOwnProperty.call(this.body.edges, _edgeId)) {\n              this.body.edges[_edgeId].updateLabelModule();\n            }\n          }\n        }\n\n        // update the state of the variables if needed\n        if (options.hidden !== undefined || options.physics !== undefined || dataChanged === true) {\n          this.body.emitter.emit(\"_dataChanged\");\n        }\n      }\n    }\n\n    /**\n     * Load edges by reading the data table\n     *\n     * @param {Array | DataSet | DataView} edges    The data containing the edges.\n     * @param {boolean} [doNotEmit=false] - Suppress data changed event.\n     * @private\n     */\n  }, {\n    key: \"setData\",\n    value: function setData(edges) {\n      var _this3 = this;\n      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var oldEdgesData = this.body.data.edges;\n      if ((0,vis_data_peer_esm_vis_data_js__WEBPACK_IMPORTED_MODULE_0__.isDataViewLike)(\"id\", edges)) {\n        this.body.data.edges = edges;\n      } else if (_Array$isArray(edges)) {\n        this.body.data.edges = new vis_data_peer_esm_vis_data_js__WEBPACK_IMPORTED_MODULE_0__.DataSet();\n        this.body.data.edges.add(edges);\n      } else if (!edges) {\n        this.body.data.edges = new vis_data_peer_esm_vis_data_js__WEBPACK_IMPORTED_MODULE_0__.DataSet();\n      } else {\n        throw new TypeError(\"Array or DataSet expected\");\n      }\n\n      // TODO: is this null or undefined or false?\n      if (oldEdgesData) {\n        // unsubscribe from old dataset\n        forEach$1(this.edgesListeners, function (callback, event) {\n          oldEdgesData.off(event, callback);\n        });\n      }\n\n      // remove drawn edges\n      this.body.edges = {};\n\n      // TODO: is this null or undefined or false?\n      if (this.body.data.edges) {\n        // subscribe to new dataset\n        forEach$1(this.edgesListeners, function (callback, event) {\n          _this3.body.data.edges.on(event, callback);\n        });\n\n        // draw all new nodes\n        var ids = this.body.data.edges.getIds();\n        this.add(ids, true);\n      }\n      this.body.emitter.emit(\"_adjustEdgesForHierarchicalLayout\");\n      if (doNotEmit === false) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n\n    /**\n     * Add edges\n     *\n     * @param {number[] | string[]} ids\n     * @param {boolean} [doNotEmit=false]\n     * @private\n     */\n  }, {\n    key: \"add\",\n    value: function add(ids) {\n      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var edges = this.body.edges;\n      var edgesData = this.body.data.edges;\n      for (var i = 0; i < ids.length; i++) {\n        var id = ids[i];\n        var oldEdge = edges[id];\n        if (oldEdge) {\n          oldEdge.disconnect();\n        }\n        var data = edgesData.get(id, {\n          showInternalIds: true\n        });\n        edges[id] = this.create(data);\n      }\n      this.body.emitter.emit(\"_adjustEdgesForHierarchicalLayout\");\n      if (doNotEmit === false) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n\n    /**\n     * Update existing edges, or create them when not yet existing\n     *\n     * @param {number[] | string[]} ids\n     * @private\n     */\n  }, {\n    key: \"update\",\n    value: function update(ids) {\n      var edges = this.body.edges;\n      var edgesData = this.body.data.edges;\n      var dataChanged = false;\n      for (var i = 0; i < ids.length; i++) {\n        var id = ids[i];\n        var data = edgesData.get(id);\n        var edge = edges[id];\n        if (edge !== undefined) {\n          // update edge\n          edge.disconnect();\n          dataChanged = edge.setOptions(data) || dataChanged; // if a support node is added, data can be changed.\n          edge.connect();\n        } else {\n          // create edge\n          this.body.edges[id] = this.create(data);\n          dataChanged = true;\n        }\n      }\n      if (dataChanged === true) {\n        this.body.emitter.emit(\"_adjustEdgesForHierarchicalLayout\");\n        this.body.emitter.emit(\"_dataChanged\");\n      } else {\n        this.body.emitter.emit(\"_dataUpdated\");\n      }\n    }\n\n    /**\n     * Remove existing edges. Non existing ids will be ignored\n     *\n     * @param {number[] | string[]} ids\n     * @param {boolean} [emit=true]\n     * @private\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(ids) {\n      var emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (ids.length === 0) return; // early out\n\n      var edges = this.body.edges;\n      forEach$1(ids, function (id) {\n        var edge = edges[id];\n        if (edge !== undefined) {\n          edge.remove();\n        }\n      });\n      if (emit) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n\n    /**\n     * Refreshes Edge Handler\n     */\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var _this4 = this;\n      forEach$1(this.body.edges, function (edge, edgeId) {\n        var data = _this4.body.data.edges.get(edgeId);\n        if (data !== undefined) {\n          edge.setOptions(data);\n        }\n      });\n    }\n\n    /**\n     *\n     * @param {object} properties\n     * @returns {Edge}\n     */\n  }, {\n    key: \"create\",\n    value: function create(properties) {\n      return new Edge(properties, this.body, this.images, this.options, this.defaultOptions);\n    }\n\n    /**\n     * Reconnect all edges\n     *\n     * @private\n     */\n  }, {\n    key: \"reconnectEdges\",\n    value: function reconnectEdges() {\n      var id;\n      var nodes = this.body.nodes;\n      var edges = this.body.edges;\n      for (id in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, id)) {\n          nodes[id].edges = [];\n        }\n      }\n      for (id in edges) {\n        if (Object.prototype.hasOwnProperty.call(edges, id)) {\n          var edge = edges[id];\n          edge.from = null;\n          edge.to = null;\n          edge.connect();\n        }\n      }\n    }\n\n    /**\n     *\n     * @param {Edge.id} edgeId\n     * @returns {Array}\n     */\n  }, {\n    key: \"getConnectedNodes\",\n    value: function getConnectedNodes(edgeId) {\n      var nodeList = [];\n      if (this.body.edges[edgeId] !== undefined) {\n        var edge = this.body.edges[edgeId];\n        if (edge.fromId !== undefined) {\n          nodeList.push(edge.fromId);\n        }\n        if (edge.toId !== undefined) {\n          nodeList.push(edge.toId);\n        }\n      }\n      return nodeList;\n    }\n\n    /**\n     * There is no direct relation between the nodes and the edges DataSet,\n     * so the right place to do call this is in the handler for event `_dataUpdated`.\n     */\n  }, {\n    key: \"_updateState\",\n    value: function _updateState() {\n      this._addMissingEdges();\n      this._removeInvalidEdges();\n    }\n\n    /**\n     * Scan for missing nodes and remove corresponding edges, if any.\n     *\n     * @private\n     */\n  }, {\n    key: \"_removeInvalidEdges\",\n    value: function _removeInvalidEdges() {\n      var _this5 = this;\n      var edgesToDelete = [];\n      forEach$1(this.body.edges, function (edge, id) {\n        var toNode = _this5.body.nodes[edge.toId];\n        var fromNode = _this5.body.nodes[edge.fromId];\n\n        // Skip clustering edges here, let the Clustering module handle those\n        if (toNode !== undefined && toNode.isCluster === true || fromNode !== undefined && fromNode.isCluster === true) {\n          return;\n        }\n        if (toNode === undefined || fromNode === undefined) {\n          edgesToDelete.push(id);\n        }\n      });\n      this.remove(edgesToDelete, false);\n    }\n\n    /**\n     * add all edges from dataset that are not in the cached state\n     *\n     * @private\n     */\n  }, {\n    key: \"_addMissingEdges\",\n    value: function _addMissingEdges() {\n      var edgesData = this.body.data.edges;\n      if (edgesData === undefined || edgesData === null) {\n        return; // No edges DataSet yet; can happen on startup\n      }\n\n      var edges = this.body.edges;\n      var addIds = [];\n      _forEachInstanceProperty(edgesData).call(edgesData, function (edgeData, edgeId) {\n        var edge = edges[edgeId];\n        if (edge === undefined) {\n          addIds.push(edgeId);\n        }\n      });\n      this.add(addIds, true);\n    }\n  }]);\n  return EdgesHandler;\n}();\n\n/**\n * Barnes Hut Solver\n */\nvar BarnesHutSolver = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {object} options\n   */\n  function BarnesHutSolver(body, physicsBody, options) {\n    _classCallCheck(this, BarnesHutSolver);\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.barnesHutTree;\n    this.setOptions(options);\n    this._rng = Alea(\"BARNES HUT SOLVER\");\n\n    // debug: show grid\n    // this.body.emitter.on(\"afterDrawing\", (ctx) => {this._debug(ctx,'#ff0000')})\n  }\n\n  /**\n   *\n   * @param {object} options\n   */\n  _createClass(BarnesHutSolver, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n      this.thetaInversed = 1 / this.options.theta;\n\n      // if 1 then min distance = 0.5, if 0.5 then min distance = 0.5 + 0.5*node.shape.radius\n      this.overlapAvoidanceFactor = 1 - Math.max(0, Math.min(1, this.options.avoidOverlap));\n    }\n\n    /**\n     * This function calculates the forces the nodes apply on each other based on a gravitational model.\n     * The Barnes Hut method is used to speed up this N-body simulation.\n     *\n     * @private\n     */\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      if (this.options.gravitationalConstant !== 0 && this.physicsBody.physicsNodeIndices.length > 0) {\n        var node;\n        var nodes = this.body.nodes;\n        var nodeIndices = this.physicsBody.physicsNodeIndices;\n        var nodeCount = nodeIndices.length;\n\n        // create the tree\n        var barnesHutTree = this._formBarnesHutTree(nodes, nodeIndices);\n\n        // for debugging\n        this.barnesHutTree = barnesHutTree;\n\n        // place the nodes one by one recursively\n        for (var i = 0; i < nodeCount; i++) {\n          node = nodes[nodeIndices[i]];\n          if (node.options.mass > 0) {\n            // starting with root is irrelevant, it never passes the BarnesHutSolver condition\n            this._getForceContributions(barnesHutTree.root, node);\n          }\n        }\n      }\n    }\n\n    /**\n     * @param {object} parentBranch\n     * @param {Node} node\n     * @private\n     */\n  }, {\n    key: \"_getForceContributions\",\n    value: function _getForceContributions(parentBranch, node) {\n      this._getForceContribution(parentBranch.children.NW, node);\n      this._getForceContribution(parentBranch.children.NE, node);\n      this._getForceContribution(parentBranch.children.SW, node);\n      this._getForceContribution(parentBranch.children.SE, node);\n    }\n\n    /**\n     * This function traverses the barnesHutTree. It checks when it can approximate distant nodes with their center of mass.\n     * If a region contains a single node, we check if it is not itself, then we apply the force.\n     *\n     * @param {object} parentBranch\n     * @param {Node} node\n     * @private\n     */\n  }, {\n    key: \"_getForceContribution\",\n    value: function _getForceContribution(parentBranch, node) {\n      // we get no force contribution from an empty region\n      if (parentBranch.childrenCount > 0) {\n        // get the distance from the center of mass to the node.\n        var dx = parentBranch.centerOfMass.x - node.x;\n        var dy = parentBranch.centerOfMass.y - node.y;\n        var distance = Math.sqrt(dx * dx + dy * dy);\n\n        // BarnesHutSolver condition\n        // original condition : s/d < theta = passed  ===  d/s > 1/theta = passed\n        // calcSize = 1/s --> d * 1/s > 1/theta = passed\n        if (distance * parentBranch.calcSize > this.thetaInversed) {\n          this._calculateForces(distance, dx, dy, node, parentBranch);\n        } else {\n          // Did not pass the condition, go into children if available\n          if (parentBranch.childrenCount === 4) {\n            this._getForceContributions(parentBranch, node);\n          } else {\n            // parentBranch must have only one node, if it was empty we wouldnt be here\n            if (parentBranch.children.data.id != node.id) {\n              // if it is not self\n              this._calculateForces(distance, dx, dy, node, parentBranch);\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * Calculate the forces based on the distance.\n     *\n     * @param {number} distance\n     * @param {number} dx\n     * @param {number} dy\n     * @param {Node} node\n     * @param {object} parentBranch\n     * @private\n     */\n  }, {\n    key: \"_calculateForces\",\n    value: function _calculateForces(distance, dx, dy, node, parentBranch) {\n      if (distance === 0) {\n        distance = 0.1;\n        dx = distance;\n      }\n      if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {\n        distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);\n      }\n\n      // the dividing by the distance cubed instead of squared allows us to get the fx and fy components without sines and cosines\n      // it is shorthand for gravityforce with distance squared and fx = dx/distance * gravityForce\n      var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass / Math.pow(distance, 3);\n      var fx = dx * gravityForce;\n      var fy = dy * gravityForce;\n      this.physicsBody.forces[node.id].x += fx;\n      this.physicsBody.forces[node.id].y += fy;\n    }\n\n    /**\n     * This function constructs the barnesHut tree recursively. It creates the root, splits it and starts placing the nodes.\n     *\n     * @param {Array.<Node>} nodes\n     * @param {Array.<number>} nodeIndices\n     * @returns {{root: {centerOfMass: {x: number, y: number}, mass: number, range: {minX: number, maxX: number, minY: number, maxY: number}, size: number, calcSize: number, children: {data: null}, maxWidth: number, level: number, childrenCount: number}}} BarnesHutTree\n     * @private\n     */\n  }, {\n    key: \"_formBarnesHutTree\",\n    value: function _formBarnesHutTree(nodes, nodeIndices) {\n      var node;\n      var nodeCount = nodeIndices.length;\n      var minX = nodes[nodeIndices[0]].x;\n      var minY = nodes[nodeIndices[0]].y;\n      var maxX = nodes[nodeIndices[0]].x;\n      var maxY = nodes[nodeIndices[0]].y;\n\n      // get the range of the nodes\n      for (var i = 1; i < nodeCount; i++) {\n        var _node = nodes[nodeIndices[i]];\n        var x = _node.x;\n        var y = _node.y;\n        if (_node.options.mass > 0) {\n          if (x < minX) {\n            minX = x;\n          }\n          if (x > maxX) {\n            maxX = x;\n          }\n          if (y < minY) {\n            minY = y;\n          }\n          if (y > maxY) {\n            maxY = y;\n          }\n        }\n      }\n      // make the range a square\n      var sizeDiff = Math.abs(maxX - minX) - Math.abs(maxY - minY); // difference between X and Y\n      if (sizeDiff > 0) {\n        minY -= 0.5 * sizeDiff;\n        maxY += 0.5 * sizeDiff;\n      } // xSize > ySize\n      else {\n        minX += 0.5 * sizeDiff;\n        maxX -= 0.5 * sizeDiff;\n      } // xSize < ySize\n\n      var minimumTreeSize = 1e-5;\n      var rootSize = Math.max(minimumTreeSize, Math.abs(maxX - minX));\n      var halfRootSize = 0.5 * rootSize;\n      var centerX = 0.5 * (minX + maxX),\n        centerY = 0.5 * (minY + maxY);\n\n      // construct the barnesHutTree\n      var barnesHutTree = {\n        root: {\n          centerOfMass: {\n            x: 0,\n            y: 0\n          },\n          mass: 0,\n          range: {\n            minX: centerX - halfRootSize,\n            maxX: centerX + halfRootSize,\n            minY: centerY - halfRootSize,\n            maxY: centerY + halfRootSize\n          },\n          size: rootSize,\n          calcSize: 1 / rootSize,\n          children: {\n            data: null\n          },\n          maxWidth: 0,\n          level: 0,\n          childrenCount: 4\n        }\n      };\n      this._splitBranch(barnesHutTree.root);\n\n      // place the nodes one by one recursively\n      for (var _i = 0; _i < nodeCount; _i++) {\n        node = nodes[nodeIndices[_i]];\n        if (node.options.mass > 0) {\n          this._placeInTree(barnesHutTree.root, node);\n        }\n      }\n\n      // make global\n      return barnesHutTree;\n    }\n\n    /**\n     * this updates the mass of a branch. this is increased by adding a node.\n     *\n     * @param {object} parentBranch\n     * @param {Node} node\n     * @private\n     */\n  }, {\n    key: \"_updateBranchMass\",\n    value: function _updateBranchMass(parentBranch, node) {\n      var centerOfMass = parentBranch.centerOfMass;\n      var totalMass = parentBranch.mass + node.options.mass;\n      var totalMassInv = 1 / totalMass;\n      centerOfMass.x = centerOfMass.x * parentBranch.mass + node.x * node.options.mass;\n      centerOfMass.x *= totalMassInv;\n      centerOfMass.y = centerOfMass.y * parentBranch.mass + node.y * node.options.mass;\n      centerOfMass.y *= totalMassInv;\n      parentBranch.mass = totalMass;\n      var biggestSize = Math.max(Math.max(node.height, node.radius), node.width);\n      parentBranch.maxWidth = parentBranch.maxWidth < biggestSize ? biggestSize : parentBranch.maxWidth;\n    }\n\n    /**\n     * determine in which branch the node will be placed.\n     *\n     * @param {object} parentBranch\n     * @param {Node} node\n     * @param {boolean} skipMassUpdate\n     * @private\n     */\n  }, {\n    key: \"_placeInTree\",\n    value: function _placeInTree(parentBranch, node, skipMassUpdate) {\n      if (skipMassUpdate != true || skipMassUpdate === undefined) {\n        // update the mass of the branch.\n        this._updateBranchMass(parentBranch, node);\n      }\n      var range = parentBranch.children.NW.range;\n      var region;\n      if (range.maxX > node.x) {\n        // in NW or SW\n        if (range.maxY > node.y) {\n          region = \"NW\";\n        } else {\n          region = \"SW\";\n        }\n      } else {\n        // in NE or SE\n        if (range.maxY > node.y) {\n          region = \"NE\";\n        } else {\n          region = \"SE\";\n        }\n      }\n      this._placeInRegion(parentBranch, node, region);\n    }\n\n    /**\n     * actually place the node in a region (or branch)\n     *\n     * @param {object} parentBranch\n     * @param {Node} node\n     * @param {'NW'| 'NE' | 'SW' | 'SE'} region\n     * @private\n     */\n  }, {\n    key: \"_placeInRegion\",\n    value: function _placeInRegion(parentBranch, node, region) {\n      var children = parentBranch.children[region];\n      switch (children.childrenCount) {\n        case 0:\n          // place node here\n          children.children.data = node;\n          children.childrenCount = 1;\n          this._updateBranchMass(children, node);\n          break;\n        case 1:\n          // convert into children\n          // if there are two nodes exactly overlapping (on init, on opening of cluster etc.)\n          // we move one node a little bit and we do not put it in the tree.\n          if (children.children.data.x === node.x && children.children.data.y === node.y) {\n            node.x += this._rng();\n            node.y += this._rng();\n          } else {\n            this._splitBranch(children);\n            this._placeInTree(children, node);\n          }\n          break;\n        case 4:\n          // place in branch\n          this._placeInTree(children, node);\n          break;\n      }\n    }\n\n    /**\n     * this function splits a branch into 4 sub branches. If the branch contained a node, we place it in the subbranch\n     * after the split is complete.\n     *\n     * @param {object} parentBranch\n     * @private\n     */\n  }, {\n    key: \"_splitBranch\",\n    value: function _splitBranch(parentBranch) {\n      // if the branch is shaded with a node, replace the node in the new subset.\n      var containedNode = null;\n      if (parentBranch.childrenCount === 1) {\n        containedNode = parentBranch.children.data;\n        parentBranch.mass = 0;\n        parentBranch.centerOfMass.x = 0;\n        parentBranch.centerOfMass.y = 0;\n      }\n      parentBranch.childrenCount = 4;\n      parentBranch.children.data = null;\n      this._insertRegion(parentBranch, \"NW\");\n      this._insertRegion(parentBranch, \"NE\");\n      this._insertRegion(parentBranch, \"SW\");\n      this._insertRegion(parentBranch, \"SE\");\n      if (containedNode != null) {\n        this._placeInTree(parentBranch, containedNode);\n      }\n    }\n\n    /**\n     * This function subdivides the region into four new segments.\n     * Specifically, this inserts a single new segment.\n     * It fills the children section of the parentBranch\n     *\n     * @param {object} parentBranch\n     * @param {'NW'| 'NE' | 'SW' | 'SE'} region\n     * @private\n     */\n  }, {\n    key: \"_insertRegion\",\n    value: function _insertRegion(parentBranch, region) {\n      var minX, maxX, minY, maxY;\n      var childSize = 0.5 * parentBranch.size;\n      switch (region) {\n        case \"NW\":\n          minX = parentBranch.range.minX;\n          maxX = parentBranch.range.minX + childSize;\n          minY = parentBranch.range.minY;\n          maxY = parentBranch.range.minY + childSize;\n          break;\n        case \"NE\":\n          minX = parentBranch.range.minX + childSize;\n          maxX = parentBranch.range.maxX;\n          minY = parentBranch.range.minY;\n          maxY = parentBranch.range.minY + childSize;\n          break;\n        case \"SW\":\n          minX = parentBranch.range.minX;\n          maxX = parentBranch.range.minX + childSize;\n          minY = parentBranch.range.minY + childSize;\n          maxY = parentBranch.range.maxY;\n          break;\n        case \"SE\":\n          minX = parentBranch.range.minX + childSize;\n          maxX = parentBranch.range.maxX;\n          minY = parentBranch.range.minY + childSize;\n          maxY = parentBranch.range.maxY;\n          break;\n      }\n      parentBranch.children[region] = {\n        centerOfMass: {\n          x: 0,\n          y: 0\n        },\n        mass: 0,\n        range: {\n          minX: minX,\n          maxX: maxX,\n          minY: minY,\n          maxY: maxY\n        },\n        size: 0.5 * parentBranch.size,\n        calcSize: 2 * parentBranch.calcSize,\n        children: {\n          data: null\n        },\n        maxWidth: 0,\n        level: parentBranch.level + 1,\n        childrenCount: 0\n      };\n    }\n\n    //---------------------------  DEBUGGING BELOW  ---------------------------//\n\n    /**\n     * This function is for debugging purposed, it draws the tree.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {string} color\n     * @private\n     */\n  }, {\n    key: \"_debug\",\n    value: function _debug(ctx, color) {\n      if (this.barnesHutTree !== undefined) {\n        ctx.lineWidth = 1;\n        this._drawBranch(this.barnesHutTree.root, ctx, color);\n      }\n    }\n\n    /**\n     * This function is for debugging purposes. It draws the branches recursively.\n     *\n     * @param {object} branch\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {string} color\n     * @private\n     */\n  }, {\n    key: \"_drawBranch\",\n    value: function _drawBranch(branch, ctx, color) {\n      if (color === undefined) {\n        color = \"#FF0000\";\n      }\n      if (branch.childrenCount === 4) {\n        this._drawBranch(branch.children.NW, ctx);\n        this._drawBranch(branch.children.NE, ctx);\n        this._drawBranch(branch.children.SE, ctx);\n        this._drawBranch(branch.children.SW, ctx);\n      }\n      ctx.strokeStyle = color;\n      ctx.beginPath();\n      ctx.moveTo(branch.range.minX, branch.range.minY);\n      ctx.lineTo(branch.range.maxX, branch.range.minY);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(branch.range.maxX, branch.range.minY);\n      ctx.lineTo(branch.range.maxX, branch.range.maxY);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(branch.range.maxX, branch.range.maxY);\n      ctx.lineTo(branch.range.minX, branch.range.maxY);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(branch.range.minX, branch.range.maxY);\n      ctx.lineTo(branch.range.minX, branch.range.minY);\n      ctx.stroke();\n\n      /*\n       if (branch.mass > 0) {\n       ctx.circle(branch.centerOfMass.x, branch.centerOfMass.y, 3*branch.mass);\n       ctx.stroke();\n       }\n       */\n    }\n  }]);\n  return BarnesHutSolver;\n}();\n\n/**\n * Repulsion Solver\n */\nvar RepulsionSolver = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {object} options\n   */\n  function RepulsionSolver(body, physicsBody, options) {\n    _classCallCheck(this, RepulsionSolver);\n    this._rng = Alea(\"REPULSION SOLVER\");\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options);\n  }\n\n  /**\n   *\n   * @param {object} options\n   */\n  _createClass(RepulsionSolver, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n    }\n\n    /**\n     * Calculate the forces the nodes apply on each other based on a repulsion field.\n     * This field is linearly approximated.\n     *\n     * @private\n     */\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var dx, dy, distance, fx, fy, repulsingForce, node1, node2;\n      var nodes = this.body.nodes;\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var forces = this.physicsBody.forces;\n\n      // repulsing forces between nodes\n      var nodeDistance = this.options.nodeDistance;\n\n      // approximation constants\n      var a = -2 / 3 / nodeDistance;\n      var b = 4 / 3;\n\n      // we loop from i over all but the last entree in the array\n      // j loops from i+1 to the last. This way we do not double count any of the indices, nor i === j\n      for (var i = 0; i < nodeIndices.length - 1; i++) {\n        node1 = nodes[nodeIndices[i]];\n        for (var j = i + 1; j < nodeIndices.length; j++) {\n          node2 = nodes[nodeIndices[j]];\n          dx = node2.x - node1.x;\n          dy = node2.y - node1.y;\n          distance = Math.sqrt(dx * dx + dy * dy);\n\n          // same condition as BarnesHutSolver, making sure nodes are never 100% overlapping.\n          if (distance === 0) {\n            distance = 0.1 * this._rng();\n            dx = distance;\n          }\n          if (distance < 2 * nodeDistance) {\n            if (distance < 0.5 * nodeDistance) {\n              repulsingForce = 1.0;\n            } else {\n              repulsingForce = a * distance + b; // linear approx of  1 / (1 + Math.exp((distance / nodeDistance - 1) * steepness))\n            }\n\n            repulsingForce = repulsingForce / distance;\n            fx = dx * repulsingForce;\n            fy = dy * repulsingForce;\n            forces[node1.id].x -= fx;\n            forces[node1.id].y -= fy;\n            forces[node2.id].x += fx;\n            forces[node2.id].y += fy;\n          }\n        }\n      }\n    }\n  }]);\n  return RepulsionSolver;\n}();\n\n/**\n * Hierarchical Repulsion Solver\n */\nvar HierarchicalRepulsionSolver = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {object} options\n   */\n  function HierarchicalRepulsionSolver(body, physicsBody, options) {\n    _classCallCheck(this, HierarchicalRepulsionSolver);\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options);\n  }\n\n  /**\n   *\n   * @param {object} options\n   */\n  _createClass(HierarchicalRepulsionSolver, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n      this.overlapAvoidanceFactor = Math.max(0, Math.min(1, this.options.avoidOverlap || 0));\n    }\n\n    /**\n     * Calculate the forces the nodes apply on each other based on a repulsion field.\n     * This field is linearly approximated.\n     *\n     * @private\n     */\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var nodes = this.body.nodes;\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var forces = this.physicsBody.forces;\n\n      // repulsing forces between nodes\n      var nodeDistance = this.options.nodeDistance;\n\n      // we loop from i over all but the last entree in the array\n      // j loops from i+1 to the last. This way we do not double count any of the indices, nor i === j\n      for (var i = 0; i < nodeIndices.length - 1; i++) {\n        var node1 = nodes[nodeIndices[i]];\n        for (var j = i + 1; j < nodeIndices.length; j++) {\n          var node2 = nodes[nodeIndices[j]];\n\n          // nodes only affect nodes on their level\n          if (node1.level === node2.level) {\n            var theseNodesDistance = nodeDistance + this.overlapAvoidanceFactor * ((node1.shape.radius || 0) / 2 + (node2.shape.radius || 0) / 2);\n            var dx = node2.x - node1.x;\n            var dy = node2.y - node1.y;\n            var distance = Math.sqrt(dx * dx + dy * dy);\n            var steepness = 0.05;\n            var repulsingForce = void 0;\n            if (distance < theseNodesDistance) {\n              repulsingForce = -Math.pow(steepness * distance, 2) + Math.pow(steepness * theseNodesDistance, 2);\n            } else {\n              repulsingForce = 0;\n            }\n            // normalize force with\n            if (distance !== 0) {\n              repulsingForce = repulsingForce / distance;\n            }\n            var fx = dx * repulsingForce;\n            var fy = dy * repulsingForce;\n            forces[node1.id].x -= fx;\n            forces[node1.id].y -= fy;\n            forces[node2.id].x += fx;\n            forces[node2.id].y += fy;\n          }\n        }\n      }\n    }\n  }]);\n  return HierarchicalRepulsionSolver;\n}();\n\n/**\n * Spring Solver\n */\nvar SpringSolver = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {object} options\n   */\n  function SpringSolver(body, physicsBody, options) {\n    _classCallCheck(this, SpringSolver);\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options);\n  }\n\n  /**\n   *\n   * @param {object} options\n   */\n  _createClass(SpringSolver, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n    }\n\n    /**\n     * This function calculates the springforces on the nodes, accounting for the support nodes.\n     *\n     * @private\n     */\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var edgeLength, edge;\n      var edgeIndices = this.physicsBody.physicsEdgeIndices;\n      var edges = this.body.edges;\n      var node1, node2, node3;\n\n      // forces caused by the edges, modelled as springs\n      for (var i = 0; i < edgeIndices.length; i++) {\n        edge = edges[edgeIndices[i]];\n        if (edge.connected === true && edge.toId !== edge.fromId) {\n          // only calculate forces if nodes are in the same sector\n          if (this.body.nodes[edge.toId] !== undefined && this.body.nodes[edge.fromId] !== undefined) {\n            if (edge.edgeType.via !== undefined) {\n              edgeLength = edge.options.length === undefined ? this.options.springLength : edge.options.length;\n              node1 = edge.to;\n              node2 = edge.edgeType.via;\n              node3 = edge.from;\n              this._calculateSpringForce(node1, node2, 0.5 * edgeLength);\n              this._calculateSpringForce(node2, node3, 0.5 * edgeLength);\n            } else {\n              // the * 1.5 is here so the edge looks as large as a smooth edge. It does not initially because the smooth edges use\n              // the support nodes which exert a repulsive force on the to and from nodes, making the edge appear larger.\n              edgeLength = edge.options.length === undefined ? this.options.springLength * 1.5 : edge.options.length;\n              this._calculateSpringForce(edge.from, edge.to, edgeLength);\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * This is the code actually performing the calculation for the function above.\n     *\n     * @param {Node} node1\n     * @param {Node} node2\n     * @param {number} edgeLength\n     * @private\n     */\n  }, {\n    key: \"_calculateSpringForce\",\n    value: function _calculateSpringForce(node1, node2, edgeLength) {\n      var dx = node1.x - node2.x;\n      var dy = node1.y - node2.y;\n      var distance = Math.max(Math.sqrt(dx * dx + dy * dy), 0.01);\n\n      // the 1/distance is so the fx and fy can be calculated without sine or cosine.\n      var springForce = this.options.springConstant * (edgeLength - distance) / distance;\n      var fx = dx * springForce;\n      var fy = dy * springForce;\n\n      // handle the case where one node is not part of the physcis\n      if (this.physicsBody.forces[node1.id] !== undefined) {\n        this.physicsBody.forces[node1.id].x += fx;\n        this.physicsBody.forces[node1.id].y += fy;\n      }\n      if (this.physicsBody.forces[node2.id] !== undefined) {\n        this.physicsBody.forces[node2.id].x -= fx;\n        this.physicsBody.forces[node2.id].y -= fy;\n      }\n    }\n  }]);\n  return SpringSolver;\n}();\n\n/**\n * Hierarchical Spring Solver\n */\nvar HierarchicalSpringSolver = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {object} options\n   */\n  function HierarchicalSpringSolver(body, physicsBody, options) {\n    _classCallCheck(this, HierarchicalSpringSolver);\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options);\n  }\n\n  /**\n   *\n   * @param {object} options\n   */\n  _createClass(HierarchicalSpringSolver, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n    }\n\n    /**\n     * This function calculates the springforces on the nodes, accounting for the support nodes.\n     *\n     * @private\n     */\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var edgeLength, edge;\n      var dx, dy, fx, fy, springForce, distance;\n      var edges = this.body.edges;\n      var factor = 0.5;\n      var edgeIndices = this.physicsBody.physicsEdgeIndices;\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var forces = this.physicsBody.forces;\n\n      // initialize the spring force counters\n      for (var i = 0; i < nodeIndices.length; i++) {\n        var nodeId = nodeIndices[i];\n        forces[nodeId].springFx = 0;\n        forces[nodeId].springFy = 0;\n      }\n\n      // forces caused by the edges, modelled as springs\n      for (var _i = 0; _i < edgeIndices.length; _i++) {\n        edge = edges[edgeIndices[_i]];\n        if (edge.connected === true) {\n          edgeLength = edge.options.length === undefined ? this.options.springLength : edge.options.length;\n          dx = edge.from.x - edge.to.x;\n          dy = edge.from.y - edge.to.y;\n          distance = Math.sqrt(dx * dx + dy * dy);\n          distance = distance === 0 ? 0.01 : distance;\n\n          // the 1/distance is so the fx and fy can be calculated without sine or cosine.\n          springForce = this.options.springConstant * (edgeLength - distance) / distance;\n          fx = dx * springForce;\n          fy = dy * springForce;\n          if (edge.to.level != edge.from.level) {\n            if (forces[edge.toId] !== undefined) {\n              forces[edge.toId].springFx -= fx;\n              forces[edge.toId].springFy -= fy;\n            }\n            if (forces[edge.fromId] !== undefined) {\n              forces[edge.fromId].springFx += fx;\n              forces[edge.fromId].springFy += fy;\n            }\n          } else {\n            if (forces[edge.toId] !== undefined) {\n              forces[edge.toId].x -= factor * fx;\n              forces[edge.toId].y -= factor * fy;\n            }\n            if (forces[edge.fromId] !== undefined) {\n              forces[edge.fromId].x += factor * fx;\n              forces[edge.fromId].y += factor * fy;\n            }\n          }\n        }\n      }\n\n      // normalize spring forces\n      springForce = 1;\n      var springFx, springFy;\n      for (var _i2 = 0; _i2 < nodeIndices.length; _i2++) {\n        var _nodeId = nodeIndices[_i2];\n        springFx = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFx));\n        springFy = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFy));\n        forces[_nodeId].x += springFx;\n        forces[_nodeId].y += springFy;\n      }\n\n      // retain energy balance\n      var totalFx = 0;\n      var totalFy = 0;\n      for (var _i3 = 0; _i3 < nodeIndices.length; _i3++) {\n        var _nodeId2 = nodeIndices[_i3];\n        totalFx += forces[_nodeId2].x;\n        totalFy += forces[_nodeId2].y;\n      }\n      var correctionFx = totalFx / nodeIndices.length;\n      var correctionFy = totalFy / nodeIndices.length;\n      for (var _i4 = 0; _i4 < nodeIndices.length; _i4++) {\n        var _nodeId3 = nodeIndices[_i4];\n        forces[_nodeId3].x -= correctionFx;\n        forces[_nodeId3].y -= correctionFy;\n      }\n    }\n  }]);\n  return HierarchicalSpringSolver;\n}();\n\n/**\n * Central Gravity Solver\n */\nvar CentralGravitySolver = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {object} options\n   */\n  function CentralGravitySolver(body, physicsBody, options) {\n    _classCallCheck(this, CentralGravitySolver);\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options);\n  }\n\n  /**\n   *\n   * @param {object} options\n   */\n  _createClass(CentralGravitySolver, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n    }\n\n    /**\n     * Calculates forces for each node\n     */\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var dx, dy, distance, node;\n      var nodes = this.body.nodes;\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var forces = this.physicsBody.forces;\n      for (var i = 0; i < nodeIndices.length; i++) {\n        var nodeId = nodeIndices[i];\n        node = nodes[nodeId];\n        dx = -node.x;\n        dy = -node.y;\n        distance = Math.sqrt(dx * dx + dy * dy);\n        this._calculateForces(distance, dx, dy, forces, node);\n      }\n    }\n\n    /**\n     * Calculate the forces based on the distance.\n     *\n     * @param {number} distance\n     * @param {number} dx\n     * @param {number} dy\n     * @param {Object<Node.id, vis.Node>} forces\n     * @param {Node} node\n     * @private\n     */\n  }, {\n    key: \"_calculateForces\",\n    value: function _calculateForces(distance, dx, dy, forces, node) {\n      var gravityForce = distance === 0 ? 0 : this.options.centralGravity / distance;\n      forces[node.id].x = dx * gravityForce;\n      forces[node.id].y = dy * gravityForce;\n    }\n  }]);\n  return CentralGravitySolver;\n}();\n\nfunction _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$3() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * @augments BarnesHutSolver\n */\nvar ForceAtlas2BasedRepulsionSolver = /*#__PURE__*/function (_BarnesHutSolver) {\n  _inherits(ForceAtlas2BasedRepulsionSolver, _BarnesHutSolver);\n  var _super = _createSuper$3(ForceAtlas2BasedRepulsionSolver);\n  /**\n   * @param {object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {object} options\n   */\n  function ForceAtlas2BasedRepulsionSolver(body, physicsBody, options) {\n    var _this;\n    _classCallCheck(this, ForceAtlas2BasedRepulsionSolver);\n    _this = _super.call(this, body, physicsBody, options);\n    _this._rng = Alea(\"FORCE ATLAS 2 BASED REPULSION SOLVER\");\n    return _this;\n  }\n\n  /**\n   * Calculate the forces based on the distance.\n   *\n   * @param {number} distance\n   * @param {number} dx\n   * @param {number} dy\n   * @param {Node} node\n   * @param {object} parentBranch\n   * @private\n   */\n  _createClass(ForceAtlas2BasedRepulsionSolver, [{\n    key: \"_calculateForces\",\n    value: function _calculateForces(distance, dx, dy, node, parentBranch) {\n      if (distance === 0) {\n        distance = 0.1 * this._rng();\n        dx = distance;\n      }\n      if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {\n        distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);\n      }\n      var degree = node.edges.length + 1;\n      // the dividing by the distance cubed instead of squared allows us to get the fx and fy components without sines and cosines\n      // it is shorthand for gravityforce with distance squared and fx = dx/distance * gravityForce\n      var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass * degree / Math.pow(distance, 2);\n      var fx = dx * gravityForce;\n      var fy = dy * gravityForce;\n      this.physicsBody.forces[node.id].x += fx;\n      this.physicsBody.forces[node.id].y += fy;\n    }\n  }]);\n  return ForceAtlas2BasedRepulsionSolver;\n}(BarnesHutSolver);\n\nfunction _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$2() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * @augments CentralGravitySolver\n */\nvar ForceAtlas2BasedCentralGravitySolver = /*#__PURE__*/function (_CentralGravitySolver) {\n  _inherits(ForceAtlas2BasedCentralGravitySolver, _CentralGravitySolver);\n  var _super = _createSuper$2(ForceAtlas2BasedCentralGravitySolver);\n  /**\n   * @param {object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {object} options\n   */\n  function ForceAtlas2BasedCentralGravitySolver(body, physicsBody, options) {\n    _classCallCheck(this, ForceAtlas2BasedCentralGravitySolver);\n    return _super.call(this, body, physicsBody, options);\n  }\n\n  /**\n   * Calculate the forces based on the distance.\n   *\n   * @param {number} distance\n   * @param {number} dx\n   * @param {number} dy\n   * @param {Object<Node.id, Node>} forces\n   * @param {Node} node\n   * @private\n   */\n  _createClass(ForceAtlas2BasedCentralGravitySolver, [{\n    key: \"_calculateForces\",\n    value: function _calculateForces(distance, dx, dy, forces, node) {\n      if (distance > 0) {\n        var degree = node.edges.length + 1;\n        var gravityForce = this.options.centralGravity * degree * node.options.mass;\n        forces[node.id].x = dx * gravityForce;\n        forces[node.id].y = dy * gravityForce;\n      }\n    }\n  }]);\n  return ForceAtlas2BasedCentralGravitySolver;\n}(CentralGravitySolver);\n\n/**\n * The physics engine\n */\nvar PhysicsEngine = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   */\n  function PhysicsEngine(body) {\n    _classCallCheck(this, PhysicsEngine);\n    this.body = body;\n    this.physicsBody = {\n      physicsNodeIndices: [],\n      physicsEdgeIndices: [],\n      forces: {},\n      velocities: {}\n    };\n    this.physicsEnabled = true;\n    this.simulationInterval = 1000 / 60;\n    this.requiresTimeout = true;\n    this.previousStates = {};\n    this.referenceState = {};\n    this.freezeCache = {};\n    this.renderTimer = undefined;\n\n    // parameters for the adaptive timestep\n    this.adaptiveTimestep = false;\n    this.adaptiveTimestepEnabled = false;\n    this.adaptiveCounter = 0;\n    this.adaptiveInterval = 3;\n    this.stabilized = false;\n    this.startedStabilization = false;\n    this.stabilizationIterations = 0;\n    this.ready = false; // will be set to true if the stabilize\n\n    // default options\n    this.options = {};\n    this.defaultOptions = {\n      enabled: true,\n      barnesHut: {\n        theta: 0.5,\n        gravitationalConstant: -2000,\n        centralGravity: 0.3,\n        springLength: 95,\n        springConstant: 0.04,\n        damping: 0.09,\n        avoidOverlap: 0\n      },\n      forceAtlas2Based: {\n        theta: 0.5,\n        gravitationalConstant: -50,\n        centralGravity: 0.01,\n        springConstant: 0.08,\n        springLength: 100,\n        damping: 0.4,\n        avoidOverlap: 0\n      },\n      repulsion: {\n        centralGravity: 0.2,\n        springLength: 200,\n        springConstant: 0.05,\n        nodeDistance: 100,\n        damping: 0.09,\n        avoidOverlap: 0\n      },\n      hierarchicalRepulsion: {\n        centralGravity: 0.0,\n        springLength: 100,\n        springConstant: 0.01,\n        nodeDistance: 120,\n        damping: 0.09\n      },\n      maxVelocity: 50,\n      minVelocity: 0.75,\n      // px/s\n      solver: \"barnesHut\",\n      stabilization: {\n        enabled: true,\n        iterations: 1000,\n        // maximum number of iteration to stabilize\n        updateInterval: 50,\n        onlyDynamicEdges: false,\n        fit: true\n      },\n      timestep: 0.5,\n      adaptiveTimestep: true,\n      wind: {\n        x: 0,\n        y: 0\n      }\n    };\n    _Object$assign(this.options, this.defaultOptions);\n    this.timestep = 0.5;\n    this.layoutFailed = false;\n    this.bindEventListeners();\n  }\n\n  /**\n   * Binds event listeners\n   */\n  _createClass(PhysicsEngine, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _this = this;\n      this.body.emitter.on(\"initPhysics\", function () {\n        _this.initPhysics();\n      });\n      this.body.emitter.on(\"_layoutFailed\", function () {\n        _this.layoutFailed = true;\n      });\n      this.body.emitter.on(\"resetPhysics\", function () {\n        _this.stopSimulation();\n        _this.ready = false;\n      });\n      this.body.emitter.on(\"disablePhysics\", function () {\n        _this.physicsEnabled = false;\n        _this.stopSimulation();\n      });\n      this.body.emitter.on(\"restorePhysics\", function () {\n        _this.setOptions(_this.options);\n        if (_this.ready === true) {\n          _this.startSimulation();\n        }\n      });\n      this.body.emitter.on(\"startSimulation\", function () {\n        if (_this.ready === true) {\n          _this.startSimulation();\n        }\n      });\n      this.body.emitter.on(\"stopSimulation\", function () {\n        _this.stopSimulation();\n      });\n      this.body.emitter.on(\"destroy\", function () {\n        _this.stopSimulation(false);\n        _this.body.emitter.off();\n      });\n      this.body.emitter.on(\"_dataChanged\", function () {\n        // Nodes and/or edges have been added or removed, update shortcut lists.\n        _this.updatePhysicsData();\n      });\n\n      // debug: show forces\n      // this.body.emitter.on(\"afterDrawing\", (ctx) => {this._drawForces(ctx);});\n    }\n\n    /**\n     * set the physics options\n     *\n     * @param {object} options\n     */\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        if (options === false) {\n          this.options.enabled = false;\n          this.physicsEnabled = false;\n          this.stopSimulation();\n        } else if (options === true) {\n          this.options.enabled = true;\n          this.physicsEnabled = true;\n          this.startSimulation();\n        } else {\n          this.physicsEnabled = true;\n          selectiveNotDeepExtend([\"stabilization\"], this.options, options);\n          mergeOptions(this.options, options, \"stabilization\");\n          if (options.enabled === undefined) {\n            this.options.enabled = true;\n          }\n          if (this.options.enabled === false) {\n            this.physicsEnabled = false;\n            this.stopSimulation();\n          }\n          var wind = this.options.wind;\n          if (wind) {\n            if (typeof wind.x !== \"number\" || _Number$isNaN(wind.x)) {\n              wind.x = 0;\n            }\n            if (typeof wind.y !== \"number\" || _Number$isNaN(wind.y)) {\n              wind.y = 0;\n            }\n          }\n\n          // set the timestep\n          this.timestep = this.options.timestep;\n        }\n      }\n      this.init();\n    }\n\n    /**\n     * configure the engine.\n     */\n  }, {\n    key: \"init\",\n    value: function init() {\n      var options;\n      if (this.options.solver === \"forceAtlas2Based\") {\n        options = this.options.forceAtlas2Based;\n        this.nodesSolver = new ForceAtlas2BasedRepulsionSolver(this.body, this.physicsBody, options);\n        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);\n        this.gravitySolver = new ForceAtlas2BasedCentralGravitySolver(this.body, this.physicsBody, options);\n      } else if (this.options.solver === \"repulsion\") {\n        options = this.options.repulsion;\n        this.nodesSolver = new RepulsionSolver(this.body, this.physicsBody, options);\n        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);\n        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);\n      } else if (this.options.solver === \"hierarchicalRepulsion\") {\n        options = this.options.hierarchicalRepulsion;\n        this.nodesSolver = new HierarchicalRepulsionSolver(this.body, this.physicsBody, options);\n        this.edgesSolver = new HierarchicalSpringSolver(this.body, this.physicsBody, options);\n        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);\n      } else {\n        // barnesHut\n        options = this.options.barnesHut;\n        this.nodesSolver = new BarnesHutSolver(this.body, this.physicsBody, options);\n        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);\n        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);\n      }\n      this.modelOptions = options;\n    }\n\n    /**\n     * initialize the engine\n     */\n  }, {\n    key: \"initPhysics\",\n    value: function initPhysics() {\n      if (this.physicsEnabled === true && this.options.enabled === true) {\n        if (this.options.stabilization.enabled === true) {\n          this.stabilize();\n        } else {\n          this.stabilized = false;\n          this.ready = true;\n          this.body.emitter.emit(\"fit\", {}, this.layoutFailed); // if the layout failed, we use the approximation for the zoom\n          this.startSimulation();\n        }\n      } else {\n        this.ready = true;\n        this.body.emitter.emit(\"fit\");\n      }\n    }\n\n    /**\n     * Start the simulation\n     */\n  }, {\n    key: \"startSimulation\",\n    value: function startSimulation() {\n      if (this.physicsEnabled === true && this.options.enabled === true) {\n        this.stabilized = false;\n\n        // when visible, adaptivity is disabled.\n        this.adaptiveTimestep = false;\n\n        // this sets the width of all nodes initially which could be required for the avoidOverlap\n        this.body.emitter.emit(\"_resizeNodes\");\n        if (this.viewFunction === undefined) {\n          var _context;\n          this.viewFunction = _bindInstanceProperty$1(_context = this.simulationStep).call(_context, this);\n          this.body.emitter.on(\"initRedraw\", this.viewFunction);\n          this.body.emitter.emit(\"_startRendering\");\n        }\n      } else {\n        this.body.emitter.emit(\"_redraw\");\n      }\n    }\n\n    /**\n     * Stop the simulation, force stabilization.\n     *\n     * @param {boolean} [emit=true]\n     */\n  }, {\n    key: \"stopSimulation\",\n    value: function stopSimulation() {\n      var emit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.stabilized = true;\n      if (emit === true) {\n        this._emitStabilized();\n      }\n      if (this.viewFunction !== undefined) {\n        this.body.emitter.off(\"initRedraw\", this.viewFunction);\n        this.viewFunction = undefined;\n        if (emit === true) {\n          this.body.emitter.emit(\"_stopRendering\");\n        }\n      }\n    }\n\n    /**\n     * The viewFunction inserts this step into each render loop. It calls the physics tick and handles the cleanup at stabilized.\n     *\n     */\n  }, {\n    key: \"simulationStep\",\n    value: function simulationStep() {\n      // check if the physics have settled\n      var startTime = _Date$now();\n      this.physicsTick();\n      var physicsTime = _Date$now() - startTime;\n\n      // run double speed if it is a little graph\n      if ((physicsTime < 0.4 * this.simulationInterval || this.runDoubleSpeed === true) && this.stabilized === false) {\n        this.physicsTick();\n\n        // this makes sure there is no jitter. The decision is taken once to run it at double speed.\n        this.runDoubleSpeed = true;\n      }\n      if (this.stabilized === true) {\n        this.stopSimulation();\n      }\n    }\n\n    /**\n     * trigger the stabilized event.\n     *\n     * @param {number} [amountOfIterations=this.stabilizationIterations]\n     * @private\n     */\n  }, {\n    key: \"_emitStabilized\",\n    value: function _emitStabilized() {\n      var _this2 = this;\n      var amountOfIterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.stabilizationIterations;\n      if (this.stabilizationIterations > 1 || this.startedStabilization === true) {\n        _setTimeout(function () {\n          _this2.body.emitter.emit(\"stabilized\", {\n            iterations: amountOfIterations\n          });\n          _this2.startedStabilization = false;\n          _this2.stabilizationIterations = 0;\n        }, 0);\n      }\n    }\n\n    /**\n     * Calculate the forces for one physics iteration and move the nodes.\n     *\n     * @private\n     */\n  }, {\n    key: \"physicsStep\",\n    value: function physicsStep() {\n      this.gravitySolver.solve();\n      this.nodesSolver.solve();\n      this.edgesSolver.solve();\n      this.moveNodes();\n    }\n\n    /**\n     * Make dynamic adjustments to the timestep, based on current state.\n     *\n     * Helper function for physicsTick().\n     *\n     * @private\n     */\n  }, {\n    key: \"adjustTimeStep\",\n    value: function adjustTimeStep() {\n      var factor = 1.2; // Factor for increasing the timestep on success.\n\n      // we compare the two steps. if it is acceptable we double the step.\n      if (this._evaluateStepQuality() === true) {\n        this.timestep = factor * this.timestep;\n      } else {\n        // if not, we decrease the step to a minimum of the options timestep.\n        // if the decreased timestep is smaller than the options step, we do not reset the counter\n        // we assume that the options timestep is stable enough.\n        if (this.timestep / factor < this.options.timestep) {\n          this.timestep = this.options.timestep;\n        } else {\n          // if the timestep was larger than 2 times the option one we check the adaptivity again to ensure\n          // that large instabilities do not form.\n          this.adaptiveCounter = -1; // check again next iteration\n          this.timestep = Math.max(this.options.timestep, this.timestep / factor);\n        }\n      }\n    }\n\n    /**\n     * A single simulation step (or 'tick') in the physics simulation\n     *\n     * @private\n     */\n  }, {\n    key: \"physicsTick\",\n    value: function physicsTick() {\n      this._startStabilizing(); // this ensures that there is no start event when the network is already stable.\n      if (this.stabilized === true) return;\n\n      // adaptivity means the timestep adapts to the situation, only applicable for stabilization\n      if (this.adaptiveTimestep === true && this.adaptiveTimestepEnabled === true) {\n        // timestep remains stable for \"interval\" iterations.\n        var doAdaptive = this.adaptiveCounter % this.adaptiveInterval === 0;\n        if (doAdaptive) {\n          // first the big step and revert.\n          this.timestep = 2 * this.timestep;\n          this.physicsStep();\n          this.revert(); // saves the reference state\n\n          // now the normal step. Since this is the last step, it is the more stable one and we will take this.\n          this.timestep = 0.5 * this.timestep;\n\n          // since it's half the step, we do it twice.\n          this.physicsStep();\n          this.physicsStep();\n          this.adjustTimeStep();\n        } else {\n          this.physicsStep(); // normal step, keeping timestep constant\n        }\n\n        this.adaptiveCounter += 1;\n      } else {\n        // case for the static timestep, we reset it to the one in options and take a normal step.\n        this.timestep = this.options.timestep;\n        this.physicsStep();\n      }\n      if (this.stabilized === true) this.revert();\n      this.stabilizationIterations++;\n    }\n\n    /**\n     * Nodes and edges can have the physics toggles on or off. A collection of indices is created here so we can skip the check all the time.\n     *\n     * @private\n     */\n  }, {\n    key: \"updatePhysicsData\",\n    value: function updatePhysicsData() {\n      this.physicsBody.forces = {};\n      this.physicsBody.physicsNodeIndices = [];\n      this.physicsBody.physicsEdgeIndices = [];\n      var nodes = this.body.nodes;\n      var edges = this.body.edges;\n\n      // get node indices for physics\n      for (var nodeId in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {\n          if (nodes[nodeId].options.physics === true) {\n            this.physicsBody.physicsNodeIndices.push(nodes[nodeId].id);\n          }\n        }\n      }\n\n      // get edge indices for physics\n      for (var edgeId in edges) {\n        if (Object.prototype.hasOwnProperty.call(edges, edgeId)) {\n          if (edges[edgeId].options.physics === true) {\n            this.physicsBody.physicsEdgeIndices.push(edges[edgeId].id);\n          }\n        }\n      }\n\n      // get the velocity and the forces vector\n      for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {\n        var _nodeId = this.physicsBody.physicsNodeIndices[i];\n        this.physicsBody.forces[_nodeId] = {\n          x: 0,\n          y: 0\n        };\n\n        // forces can be reset because they are recalculated. Velocities have to persist.\n        if (this.physicsBody.velocities[_nodeId] === undefined) {\n          this.physicsBody.velocities[_nodeId] = {\n            x: 0,\n            y: 0\n          };\n        }\n      }\n\n      // clean deleted nodes from the velocity vector\n      for (var _nodeId2 in this.physicsBody.velocities) {\n        if (nodes[_nodeId2] === undefined) {\n          delete this.physicsBody.velocities[_nodeId2];\n        }\n      }\n    }\n\n    /**\n     * Revert the simulation one step. This is done so after stabilization, every new start of the simulation will also say stabilized.\n     */\n  }, {\n    key: \"revert\",\n    value: function revert() {\n      var nodeIds = _Object$keys(this.previousStates);\n      var nodes = this.body.nodes;\n      var velocities = this.physicsBody.velocities;\n      this.referenceState = {};\n      for (var i = 0; i < nodeIds.length; i++) {\n        var nodeId = nodeIds[i];\n        if (nodes[nodeId] !== undefined) {\n          if (nodes[nodeId].options.physics === true) {\n            this.referenceState[nodeId] = {\n              positions: {\n                x: nodes[nodeId].x,\n                y: nodes[nodeId].y\n              }\n            };\n            velocities[nodeId].x = this.previousStates[nodeId].vx;\n            velocities[nodeId].y = this.previousStates[nodeId].vy;\n            nodes[nodeId].x = this.previousStates[nodeId].x;\n            nodes[nodeId].y = this.previousStates[nodeId].y;\n          }\n        } else {\n          delete this.previousStates[nodeId];\n        }\n      }\n    }\n\n    /**\n     * This compares the reference state to the current state\n     *\n     * @returns {boolean}\n     * @private\n     */\n  }, {\n    key: \"_evaluateStepQuality\",\n    value: function _evaluateStepQuality() {\n      var dx, dy, dpos;\n      var nodes = this.body.nodes;\n      var reference = this.referenceState;\n      var posThreshold = 0.3;\n      for (var nodeId in this.referenceState) {\n        if (Object.prototype.hasOwnProperty.call(this.referenceState, nodeId) && nodes[nodeId] !== undefined) {\n          dx = nodes[nodeId].x - reference[nodeId].positions.x;\n          dy = nodes[nodeId].y - reference[nodeId].positions.y;\n          dpos = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n          if (dpos > posThreshold) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    /**\n     * move the nodes one timestep and check if they are stabilized\n     */\n  }, {\n    key: \"moveNodes\",\n    value: function moveNodes() {\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var maxNodeVelocity = 0;\n      var averageNodeVelocity = 0;\n\n      // the velocity threshold (energy in the system) for the adaptivity toggle\n      var velocityAdaptiveThreshold = 5;\n      for (var i = 0; i < nodeIndices.length; i++) {\n        var nodeId = nodeIndices[i];\n        var nodeVelocity = this._performStep(nodeId);\n        // stabilized is true if stabilized is true and velocity is smaller than vmin --> all nodes must be stabilized\n        maxNodeVelocity = Math.max(maxNodeVelocity, nodeVelocity);\n        averageNodeVelocity += nodeVelocity;\n      }\n\n      // evaluating the stabilized and adaptiveTimestepEnabled conditions\n      this.adaptiveTimestepEnabled = averageNodeVelocity / nodeIndices.length < velocityAdaptiveThreshold;\n      this.stabilized = maxNodeVelocity < this.options.minVelocity;\n    }\n\n    /**\n     * Calculate new velocity for a coordinate direction\n     *\n     * @param {number} v  velocity for current coordinate\n     * @param {number} f  regular force for current coordinate\n     * @param {number} m  mass of current node\n     * @returns {number} new velocity for current coordinate\n     * @private\n     */\n  }, {\n    key: \"calculateComponentVelocity\",\n    value: function calculateComponentVelocity(v, f, m) {\n      var df = this.modelOptions.damping * v; // damping force\n      var a = (f - df) / m; // acceleration\n\n      v += a * this.timestep;\n\n      // Put a limit on the velocities if it is really high\n      var maxV = this.options.maxVelocity || 1e9;\n      if (Math.abs(v) > maxV) {\n        v = v > 0 ? maxV : -maxV;\n      }\n      return v;\n    }\n\n    /**\n     * Perform the actual step\n     *\n     * @param {Node.id} nodeId\n     * @returns {number} the new velocity of given node\n     * @private\n     */\n  }, {\n    key: \"_performStep\",\n    value: function _performStep(nodeId) {\n      var node = this.body.nodes[nodeId];\n      var force = this.physicsBody.forces[nodeId];\n      if (this.options.wind) {\n        force.x += this.options.wind.x;\n        force.y += this.options.wind.y;\n      }\n      var velocity = this.physicsBody.velocities[nodeId];\n\n      // store the state so we can revert\n      this.previousStates[nodeId] = {\n        x: node.x,\n        y: node.y,\n        vx: velocity.x,\n        vy: velocity.y\n      };\n      if (node.options.fixed.x === false) {\n        velocity.x = this.calculateComponentVelocity(velocity.x, force.x, node.options.mass);\n        node.x += velocity.x * this.timestep;\n      } else {\n        force.x = 0;\n        velocity.x = 0;\n      }\n      if (node.options.fixed.y === false) {\n        velocity.y = this.calculateComponentVelocity(velocity.y, force.y, node.options.mass);\n        node.y += velocity.y * this.timestep;\n      } else {\n        force.y = 0;\n        velocity.y = 0;\n      }\n      var totalVelocity = Math.sqrt(Math.pow(velocity.x, 2) + Math.pow(velocity.y, 2));\n      return totalVelocity;\n    }\n\n    /**\n     * When initializing and stabilizing, we can freeze nodes with a predefined position.\n     * This greatly speeds up stabilization because only the supportnodes for the smoothCurves have to settle.\n     *\n     * @private\n     */\n  }, {\n    key: \"_freezeNodes\",\n    value: function _freezeNodes() {\n      var nodes = this.body.nodes;\n      for (var id in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, id)) {\n          if (nodes[id].x && nodes[id].y) {\n            var fixed = nodes[id].options.fixed;\n            this.freezeCache[id] = {\n              x: fixed.x,\n              y: fixed.y\n            };\n            fixed.x = true;\n            fixed.y = true;\n          }\n        }\n      }\n    }\n\n    /**\n     * Unfreezes the nodes that have been frozen by _freezeDefinedNodes.\n     *\n     * @private\n     */\n  }, {\n    key: \"_restoreFrozenNodes\",\n    value: function _restoreFrozenNodes() {\n      var nodes = this.body.nodes;\n      for (var id in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, id)) {\n          if (this.freezeCache[id] !== undefined) {\n            nodes[id].options.fixed.x = this.freezeCache[id].x;\n            nodes[id].options.fixed.y = this.freezeCache[id].y;\n          }\n        }\n      }\n      this.freezeCache = {};\n    }\n\n    /**\n     * Find a stable position for all nodes\n     *\n     * @param {number} [iterations=this.options.stabilization.iterations]\n     */\n  }, {\n    key: \"stabilize\",\n    value: function stabilize() {\n      var _this3 = this;\n      var iterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.stabilization.iterations;\n      if (typeof iterations !== \"number\") {\n        iterations = this.options.stabilization.iterations;\n        console.error(\"The stabilize method needs a numeric amount of iterations. Switching to default: \", iterations);\n      }\n      if (this.physicsBody.physicsNodeIndices.length === 0) {\n        this.ready = true;\n        return;\n      }\n\n      // enable adaptive timesteps\n      this.adaptiveTimestep = this.options.adaptiveTimestep;\n\n      // this sets the width of all nodes initially which could be required for the avoidOverlap\n      this.body.emitter.emit(\"_resizeNodes\");\n      this.stopSimulation(); // stop the render loop\n      this.stabilized = false;\n\n      // block redraw requests\n      this.body.emitter.emit(\"_blockRedraw\");\n      this.targetIterations = iterations;\n\n      // start the stabilization\n      if (this.options.stabilization.onlyDynamicEdges === true) {\n        this._freezeNodes();\n      }\n      this.stabilizationIterations = 0;\n      _setTimeout(function () {\n        return _this3._stabilizationBatch();\n      }, 0);\n    }\n\n    /**\n     * If not already stabilizing, start it and emit a start event.\n     *\n     * @returns {boolean} true if stabilization started with this call\n     * @private\n     */\n  }, {\n    key: \"_startStabilizing\",\n    value: function _startStabilizing() {\n      if (this.startedStabilization === true) return false;\n      this.body.emitter.emit(\"startStabilizing\");\n      this.startedStabilization = true;\n      return true;\n    }\n\n    /**\n     * One batch of stabilization\n     *\n     * @private\n     */\n  }, {\n    key: \"_stabilizationBatch\",\n    value: function _stabilizationBatch() {\n      var _this4 = this;\n      var running = function running() {\n        return _this4.stabilized === false && _this4.stabilizationIterations < _this4.targetIterations;\n      };\n      var sendProgress = function sendProgress() {\n        _this4.body.emitter.emit(\"stabilizationProgress\", {\n          iterations: _this4.stabilizationIterations,\n          total: _this4.targetIterations\n        });\n      };\n      if (this._startStabilizing()) {\n        sendProgress(); // Ensure that there is at least one start event.\n      }\n\n      var count = 0;\n      while (running() && count < this.options.stabilization.updateInterval) {\n        this.physicsTick();\n        count++;\n      }\n      sendProgress();\n      if (running()) {\n        var _context2;\n        _setTimeout(_bindInstanceProperty$1(_context2 = this._stabilizationBatch).call(_context2, this), 0);\n      } else {\n        this._finalizeStabilization();\n      }\n    }\n\n    /**\n     * Wrap up the stabilization, fit and emit the events.\n     *\n     * @private\n     */\n  }, {\n    key: \"_finalizeStabilization\",\n    value: function _finalizeStabilization() {\n      this.body.emitter.emit(\"_allowRedraw\");\n      if (this.options.stabilization.fit === true) {\n        this.body.emitter.emit(\"fit\");\n      }\n      if (this.options.stabilization.onlyDynamicEdges === true) {\n        this._restoreFrozenNodes();\n      }\n      this.body.emitter.emit(\"stabilizationIterationsDone\");\n      this.body.emitter.emit(\"_requestRedraw\");\n      if (this.stabilized === true) {\n        this._emitStabilized();\n      } else {\n        this.startSimulation();\n      }\n      this.ready = true;\n    }\n\n    //---------------------------  DEBUGGING BELOW  ---------------------------//\n\n    /**\n     * Debug function that display arrows for the forces currently active in the network.\n     *\n     * Use this when debugging only.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @private\n     */\n  }, {\n    key: \"_drawForces\",\n    value: function _drawForces(ctx) {\n      for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {\n        var index = this.physicsBody.physicsNodeIndices[i];\n        var node = this.body.nodes[index];\n        var force = this.physicsBody.forces[index];\n        var factor = 20;\n        var colorFactor = 0.03;\n        var forceSize = Math.sqrt(Math.pow(force.x, 2) + Math.pow(force.x, 2));\n        var size = Math.min(Math.max(5, forceSize), 15);\n        var arrowSize = 3 * size;\n        var color = HSVToHex((180 - Math.min(1, Math.max(0, colorFactor * forceSize)) * 180) / 360, 1, 1);\n        var point = {\n          x: node.x + factor * force.x,\n          y: node.y + factor * force.y\n        };\n        ctx.lineWidth = size;\n        ctx.strokeStyle = color;\n        ctx.beginPath();\n        ctx.moveTo(node.x, node.y);\n        ctx.lineTo(point.x, point.y);\n        ctx.stroke();\n        var angle = Math.atan2(force.y, force.x);\n        ctx.fillStyle = color;\n        EndPoints.draw(ctx, {\n          type: \"arrow\",\n          point: point,\n          angle: angle,\n          length: arrowSize\n        });\n        _fillInstanceProperty(ctx).call(ctx);\n      }\n    }\n  }]);\n  return PhysicsEngine;\n}();\n\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nconst randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nvar native = {\n  randomUUID\n};\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\n/**\n * Utility Class\n */\nvar NetworkUtil = /*#__PURE__*/function () {\n  /**\n   * @ignore\n   */\n  function NetworkUtil() {\n    _classCallCheck(this, NetworkUtil);\n  }\n\n  /**\n   * Find the center position of the network considering the bounding boxes\n   *\n   * @param {Array.<Node>} allNodes\n   * @param {Array.<Node>} [specificNodes=[]]\n   * @returns {{minX: number, maxX: number, minY: number, maxY: number}}\n   * @static\n   */\n  _createClass(NetworkUtil, null, [{\n    key: \"getRange\",\n    value: function getRange(allNodes) {\n      var specificNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var minY = 1e9,\n        maxY = -1e9,\n        minX = 1e9,\n        maxX = -1e9,\n        node;\n      if (specificNodes.length > 0) {\n        for (var i = 0; i < specificNodes.length; i++) {\n          node = allNodes[specificNodes[i]];\n          if (minX > node.shape.boundingBox.left) {\n            minX = node.shape.boundingBox.left;\n          }\n          if (maxX < node.shape.boundingBox.right) {\n            maxX = node.shape.boundingBox.right;\n          }\n          if (minY > node.shape.boundingBox.top) {\n            minY = node.shape.boundingBox.top;\n          } // top is negative, bottom is positive\n          if (maxY < node.shape.boundingBox.bottom) {\n            maxY = node.shape.boundingBox.bottom;\n          } // top is negative, bottom is positive\n        }\n      }\n\n      if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {\n        minY = 0, maxY = 0, minX = 0, maxX = 0;\n      }\n      return {\n        minX: minX,\n        maxX: maxX,\n        minY: minY,\n        maxY: maxY\n      };\n    }\n\n    /**\n     * Find the center position of the network\n     *\n     * @param {Array.<Node>} allNodes\n     * @param {Array.<Node>} [specificNodes=[]]\n     * @returns {{minX: number, maxX: number, minY: number, maxY: number}}\n     * @static\n     */\n  }, {\n    key: \"getRangeCore\",\n    value: function getRangeCore(allNodes) {\n      var specificNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var minY = 1e9,\n        maxY = -1e9,\n        minX = 1e9,\n        maxX = -1e9,\n        node;\n      if (specificNodes.length > 0) {\n        for (var i = 0; i < specificNodes.length; i++) {\n          node = allNodes[specificNodes[i]];\n          if (minX > node.x) {\n            minX = node.x;\n          }\n          if (maxX < node.x) {\n            maxX = node.x;\n          }\n          if (minY > node.y) {\n            minY = node.y;\n          } // top is negative, bottom is positive\n          if (maxY < node.y) {\n            maxY = node.y;\n          } // top is negative, bottom is positive\n        }\n      }\n\n      if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {\n        minY = 0, maxY = 0, minX = 0, maxX = 0;\n      }\n      return {\n        minX: minX,\n        maxX: maxX,\n        minY: minY,\n        maxY: maxY\n      };\n    }\n\n    /**\n     * @param {object} range = {minX: minX, maxX: maxX, minY: minY, maxY: maxY};\n     * @returns {{x: number, y: number}}\n     * @static\n     */\n  }, {\n    key: \"findCenter\",\n    value: function findCenter(range) {\n      return {\n        x: 0.5 * (range.maxX + range.minX),\n        y: 0.5 * (range.maxY + range.minY)\n      };\n    }\n\n    /**\n     * This returns a clone of the options or options of the edge or node to be used for construction of new edges or check functions for new nodes.\n     *\n     * @param {vis.Item} item\n     * @param {'node'|undefined} type\n     * @returns {{}}\n     * @static\n     */\n  }, {\n    key: \"cloneOptions\",\n    value: function cloneOptions(item, type) {\n      var clonedOptions = {};\n      if (type === undefined || type === \"node\") {\n        deepExtend(clonedOptions, item.options, true);\n        clonedOptions.x = item.x;\n        clonedOptions.y = item.y;\n        clonedOptions.amountOfConnections = item.edges.length;\n      } else {\n        deepExtend(clonedOptions, item.options, true);\n      }\n      return clonedOptions;\n    }\n  }]);\n  return NetworkUtil;\n}();\n\nfunction _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$1() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A Cluster is a special Node that allows a group of Nodes positioned closely together\n * to be represented by a single Cluster Node.\n *\n * @augments Node\n */\nvar Cluster = /*#__PURE__*/function (_Node) {\n  _inherits(Cluster, _Node);\n  var _super = _createSuper$1(Cluster);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Array.<HTMLImageElement>}imagelist\n   * @param {Array} grouplist\n   * @param {object} globalOptions\n   * @param {object} defaultOptions     Global default options for nodes\n   */\n  function Cluster(options, body, imagelist, grouplist, globalOptions, defaultOptions) {\n    var _this;\n    _classCallCheck(this, Cluster);\n    _this = _super.call(this, options, body, imagelist, grouplist, globalOptions, defaultOptions);\n    _this.isCluster = true;\n    _this.containedNodes = {};\n    _this.containedEdges = {};\n    return _this;\n  }\n\n  /**\n   * Transfer child cluster data to current and disconnect the child cluster.\n   *\n   * Please consult the header comment in 'Clustering.js' for the fields set here.\n   *\n   * @param {string|number} childClusterId  id of child cluster to open\n   */\n  _createClass(Cluster, [{\n    key: \"_openChildCluster\",\n    value: function _openChildCluster(childClusterId) {\n      var _this2 = this;\n      var childCluster = this.body.nodes[childClusterId];\n      if (this.containedNodes[childClusterId] === undefined) {\n        throw new Error(\"node with id: \" + childClusterId + \" not in current cluster\");\n      }\n      if (!childCluster.isCluster) {\n        throw new Error(\"node with id: \" + childClusterId + \" is not a cluster\");\n      }\n\n      // Disconnect child cluster from current cluster\n      delete this.containedNodes[childClusterId];\n      forEach$1(childCluster.edges, function (edge) {\n        delete _this2.containedEdges[edge.id];\n      });\n\n      // Transfer nodes and edges\n      forEach$1(childCluster.containedNodes, function (node, nodeId) {\n        _this2.containedNodes[nodeId] = node;\n      });\n      childCluster.containedNodes = {};\n      forEach$1(childCluster.containedEdges, function (edge, edgeId) {\n        _this2.containedEdges[edgeId] = edge;\n      });\n      childCluster.containedEdges = {};\n\n      // Transfer edges within cluster edges which are clustered\n      forEach$1(childCluster.edges, function (clusterEdge) {\n        forEach$1(_this2.edges, function (parentClusterEdge) {\n          var _context, _context2;\n          // Assumption: a clustered edge can only be present in a single clustering edge\n          // Not tested here\n          var index = _indexOfInstanceProperty(_context = parentClusterEdge.clusteringEdgeReplacingIds).call(_context, clusterEdge.id);\n          if (index === -1) return;\n          forEach$1(clusterEdge.clusteringEdgeReplacingIds, function (srcId) {\n            parentClusterEdge.clusteringEdgeReplacingIds.push(srcId);\n\n            // Maintain correct bookkeeping for transferred edge\n            _this2.body.edges[srcId].edgeReplacedById = parentClusterEdge.id;\n          });\n\n          // Remove cluster edge from parent cluster edge\n          _spliceInstanceProperty(_context2 = parentClusterEdge.clusteringEdgeReplacingIds).call(_context2, index, 1);\n        });\n      });\n      childCluster.edges = [];\n    }\n  }]);\n  return Cluster;\n}(Node);\n\n/**\n * The clustering engine\n */\nvar ClusterEngine = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   */\n  function ClusterEngine(body) {\n    var _this = this;\n    _classCallCheck(this, ClusterEngine);\n    this.body = body;\n    this.clusteredNodes = {}; // key: node id, value: { clusterId: <id of cluster>, node: <node instance>}\n    this.clusteredEdges = {}; // key: edge id, value: restore information for given edge\n\n    this.options = {};\n    this.defaultOptions = {};\n    _Object$assign(this.options, this.defaultOptions);\n    this.body.emitter.on(\"_resetData\", function () {\n      _this.clusteredNodes = {};\n      _this.clusteredEdges = {};\n    });\n  }\n\n  /**\n   *\n   * @param {number} hubsize\n   * @param {object} options\n   */\n  _createClass(ClusterEngine, [{\n    key: \"clusterByHubsize\",\n    value: function clusterByHubsize(hubsize, options) {\n      if (hubsize === undefined) {\n        hubsize = this._getHubSize();\n      } else if (_typeof(hubsize) === \"object\") {\n        options = this._checkOptions(hubsize);\n        hubsize = this._getHubSize();\n      }\n      var nodesToCluster = [];\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        var node = this.body.nodes[this.body.nodeIndices[i]];\n        if (node.edges.length >= hubsize) {\n          nodesToCluster.push(node.id);\n        }\n      }\n      for (var _i = 0; _i < nodesToCluster.length; _i++) {\n        this.clusterByConnection(nodesToCluster[_i], options, true);\n      }\n      this.body.emitter.emit(\"_dataChanged\");\n    }\n\n    /**\n     * loop over all nodes, check if they adhere to the condition and cluster if needed.\n     *\n     * @param {object} options\n     * @param {boolean} [refreshData=true]\n     */\n  }, {\n    key: \"cluster\",\n    value: function cluster() {\n      var _this2 = this;\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (options.joinCondition === undefined) {\n        throw new Error(\"Cannot call clusterByNodeData without a joinCondition function in the options.\");\n      }\n\n      // check if the options object is fine, append if needed\n      options = this._checkOptions(options);\n      var childNodesObj = {};\n      var childEdgesObj = {};\n\n      // collect the nodes that will be in the cluster\n      forEach$1(this.body.nodes, function (node, nodeId) {\n        if (node.options && options.joinCondition(node.options) === true) {\n          childNodesObj[nodeId] = node;\n\n          // collect the edges that will be in the cluster\n          forEach$1(node.edges, function (edge) {\n            if (_this2.clusteredEdges[edge.id] === undefined) {\n              childEdgesObj[edge.id] = edge;\n            }\n          });\n        }\n      });\n      this._cluster(childNodesObj, childEdgesObj, options, refreshData);\n    }\n\n    /**\n     * Cluster all nodes in the network that have only X edges\n     *\n     * @param {number} edgeCount\n     * @param {object} options\n     * @param {boolean} [refreshData=true]\n     */\n  }, {\n    key: \"clusterByEdgeCount\",\n    value: function clusterByEdgeCount(edgeCount, options) {\n      var _this3 = this;\n      var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      options = this._checkOptions(options);\n      var clusters = [];\n      var usedNodes = {};\n      var edge, edges, relevantEdgeCount;\n      // collect the nodes that will be in the cluster\n      var _loop = function _loop() {\n        var childNodesObj = {};\n        var childEdgesObj = {};\n        var nodeId = _this3.body.nodeIndices[i];\n        var node = _this3.body.nodes[nodeId];\n\n        // if this node is already used in another cluster this session, we do not have to re-evaluate it.\n        if (usedNodes[nodeId] === undefined) {\n          relevantEdgeCount = 0;\n          edges = [];\n          for (var j = 0; j < node.edges.length; j++) {\n            edge = node.edges[j];\n            if (_this3.clusteredEdges[edge.id] === undefined) {\n              if (edge.toId !== edge.fromId) {\n                relevantEdgeCount++;\n              }\n              edges.push(edge);\n            }\n          }\n\n          // this node qualifies, we collect its neighbours to start the clustering process.\n          if (relevantEdgeCount === edgeCount) {\n            var checkJoinCondition = function checkJoinCondition(node) {\n              if (options.joinCondition === undefined || options.joinCondition === null) {\n                return true;\n              }\n              var clonedOptions = NetworkUtil.cloneOptions(node);\n              return options.joinCondition(clonedOptions);\n            };\n            var gatheringSuccessful = true;\n            for (var _j = 0; _j < edges.length; _j++) {\n              edge = edges[_j];\n              var childNodeId = _this3._getConnectedId(edge, nodeId);\n              // add the nodes to the list by the join condition.\n              if (checkJoinCondition(node)) {\n                childEdgesObj[edge.id] = edge;\n                childNodesObj[nodeId] = node;\n                childNodesObj[childNodeId] = _this3.body.nodes[childNodeId];\n                usedNodes[nodeId] = true;\n              } else {\n                // this node does not qualify after all.\n                gatheringSuccessful = false;\n                break;\n              }\n            }\n\n            // add to the cluster queue\n            if (_Object$keys(childNodesObj).length > 0 && _Object$keys(childEdgesObj).length > 0 && gatheringSuccessful === true) {\n              /**\n               * Search for cluster data that contains any of the node id's\n               *\n               * @returns {boolean} true if no joinCondition, otherwise return value of joinCondition\n               */\n              var findClusterData = function findClusterData() {\n                for (var n = 0; n < clusters.length; ++n) {\n                  // Search for a cluster containing any of the node id's\n                  for (var m in childNodesObj) {\n                    if (clusters[n].nodes[m] !== undefined) {\n                      return clusters[n];\n                    }\n                  }\n                }\n                return undefined;\n              };\n\n              // If any of the found nodes is part of a cluster found in this method,\n              // add the current values to that cluster\n              var foundCluster = findClusterData();\n              if (foundCluster !== undefined) {\n                // Add nodes to found cluster if not present\n                for (var m in childNodesObj) {\n                  if (foundCluster.nodes[m] === undefined) {\n                    foundCluster.nodes[m] = childNodesObj[m];\n                  }\n                }\n\n                // Add edges to found cluster, if not present\n                for (var _m in childEdgesObj) {\n                  if (foundCluster.edges[_m] === undefined) {\n                    foundCluster.edges[_m] = childEdgesObj[_m];\n                  }\n                }\n              } else {\n                // Create a new cluster group\n                clusters.push({\n                  nodes: childNodesObj,\n                  edges: childEdgesObj\n                });\n              }\n            }\n          }\n        }\n      };\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        _loop();\n      }\n      for (var _i2 = 0; _i2 < clusters.length; _i2++) {\n        this._cluster(clusters[_i2].nodes, clusters[_i2].edges, options, false);\n      }\n      if (refreshData === true) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n\n    /**\n     * Cluster all nodes in the network that have only 1 edge\n     *\n     * @param {object} options\n     * @param {boolean} [refreshData=true]\n     */\n  }, {\n    key: \"clusterOutliers\",\n    value: function clusterOutliers(options) {\n      var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      this.clusterByEdgeCount(1, options, refreshData);\n    }\n\n    /**\n     * Cluster all nodes in the network that have only 2 edge\n     *\n     * @param {object} options\n     * @param {boolean} [refreshData=true]\n     */\n  }, {\n    key: \"clusterBridges\",\n    value: function clusterBridges(options) {\n      var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      this.clusterByEdgeCount(2, options, refreshData);\n    }\n\n    /**\n     * suck all connected nodes of a node into the node.\n     *\n     * @param {Node.id} nodeId\n     * @param {object} options\n     * @param {boolean} [refreshData=true]\n     */\n  }, {\n    key: \"clusterByConnection\",\n    value: function clusterByConnection(nodeId, options) {\n      var _context;\n      var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      // kill conditions\n      if (nodeId === undefined) {\n        throw new Error(\"No nodeId supplied to clusterByConnection!\");\n      }\n      if (this.body.nodes[nodeId] === undefined) {\n        throw new Error(\"The nodeId given to clusterByConnection does not exist!\");\n      }\n      var node = this.body.nodes[nodeId];\n      options = this._checkOptions(options, node);\n      if (options.clusterNodeProperties.x === undefined) {\n        options.clusterNodeProperties.x = node.x;\n      }\n      if (options.clusterNodeProperties.y === undefined) {\n        options.clusterNodeProperties.y = node.y;\n      }\n      if (options.clusterNodeProperties.fixed === undefined) {\n        options.clusterNodeProperties.fixed = {};\n        options.clusterNodeProperties.fixed.x = node.options.fixed.x;\n        options.clusterNodeProperties.fixed.y = node.options.fixed.y;\n      }\n      var childNodesObj = {};\n      var childEdgesObj = {};\n      var parentNodeId = node.id;\n      var parentClonedOptions = NetworkUtil.cloneOptions(node);\n      childNodesObj[parentNodeId] = node;\n\n      // collect the nodes that will be in the cluster\n      for (var i = 0; i < node.edges.length; i++) {\n        var edge = node.edges[i];\n        if (this.clusteredEdges[edge.id] === undefined) {\n          var childNodeId = this._getConnectedId(edge, parentNodeId);\n\n          // if the child node is not in a cluster\n          if (this.clusteredNodes[childNodeId] === undefined) {\n            if (childNodeId !== parentNodeId) {\n              if (options.joinCondition === undefined) {\n                childEdgesObj[edge.id] = edge;\n                childNodesObj[childNodeId] = this.body.nodes[childNodeId];\n              } else {\n                // clone the options and insert some additional parameters that could be interesting.\n                var childClonedOptions = NetworkUtil.cloneOptions(this.body.nodes[childNodeId]);\n                if (options.joinCondition(parentClonedOptions, childClonedOptions) === true) {\n                  childEdgesObj[edge.id] = edge;\n                  childNodesObj[childNodeId] = this.body.nodes[childNodeId];\n                }\n              }\n            } else {\n              // swallow the edge if it is self-referencing.\n              childEdgesObj[edge.id] = edge;\n            }\n          }\n        }\n      }\n      var childNodeIDs = _mapInstanceProperty(_context = _Object$keys(childNodesObj)).call(_context, function (childNode) {\n        return childNodesObj[childNode].id;\n      });\n      for (var childNodeKey in childNodesObj) {\n        if (!Object.prototype.hasOwnProperty.call(childNodesObj, childNodeKey)) continue;\n        var childNode = childNodesObj[childNodeKey];\n        for (var y = 0; y < childNode.edges.length; y++) {\n          var childEdge = childNode.edges[y];\n          if (_indexOfInstanceProperty(childNodeIDs).call(childNodeIDs, this._getConnectedId(childEdge, childNode.id)) > -1) {\n            childEdgesObj[childEdge.id] = childEdge;\n          }\n        }\n      }\n      this._cluster(childNodesObj, childEdgesObj, options, refreshData);\n    }\n\n    /**\n     * This function creates the edges that will be attached to the cluster\n     * It looks for edges that are connected to the nodes from the \"outside' of the cluster.\n     *\n     * @param {{Node.id: vis.Node}} childNodesObj\n     * @param {{vis.Edge.id: vis.Edge}} childEdgesObj\n     * @param {object} clusterNodeProperties\n     * @param {object} clusterEdgeProperties\n     * @private\n     */\n  }, {\n    key: \"_createClusterEdges\",\n    value: function _createClusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, clusterEdgeProperties) {\n      var edge, childNodeId, childNode, toId, fromId, otherNodeId;\n\n      // loop over all child nodes and their edges to find edges going out of the cluster\n      // these edges will be replaced by clusterEdges.\n      var childKeys = _Object$keys(childNodesObj);\n      var createEdges = [];\n      for (var i = 0; i < childKeys.length; i++) {\n        childNodeId = childKeys[i];\n        childNode = childNodesObj[childNodeId];\n\n        // construct new edges from the cluster to others\n        for (var j = 0; j < childNode.edges.length; j++) {\n          edge = childNode.edges[j];\n          // we only handle edges that are visible to the system, not the disabled ones from the clustering process.\n          if (this.clusteredEdges[edge.id] === undefined) {\n            // self-referencing edges will be added to the \"hidden\" list\n            if (edge.toId == edge.fromId) {\n              childEdgesObj[edge.id] = edge;\n            } else {\n              // set up the from and to.\n              if (edge.toId == childNodeId) {\n                // this is a double equals because ints and strings can be interchanged here.\n                toId = clusterNodeProperties.id;\n                fromId = edge.fromId;\n                otherNodeId = fromId;\n              } else {\n                toId = edge.toId;\n                fromId = clusterNodeProperties.id;\n                otherNodeId = toId;\n              }\n            }\n\n            // Only edges from the cluster outwards are being replaced.\n            if (childNodesObj[otherNodeId] === undefined) {\n              createEdges.push({\n                edge: edge,\n                fromId: fromId,\n                toId: toId\n              });\n            }\n          }\n        }\n      }\n\n      //\n      // Here we actually create the replacement edges.\n      //\n      // We could not do this in the loop above as the creation process\n      // would add an edge to the edges array we are iterating over.\n      //\n      // NOTE: a clustered edge can have multiple base edges!\n      //\n      var newEdges = [];\n\n      /**\n       * Find a cluster edge which matches the given created edge.\n       *\n       * @param {vis.Edge} createdEdge\n       * @returns {vis.Edge}\n       */\n      var getNewEdge = function getNewEdge(createdEdge) {\n        for (var _j2 = 0; _j2 < newEdges.length; _j2++) {\n          var newEdge = newEdges[_j2];\n\n          // We replace both to and from edges with a single cluster edge\n          var matchToDirection = createdEdge.fromId === newEdge.fromId && createdEdge.toId === newEdge.toId;\n          var matchFromDirection = createdEdge.fromId === newEdge.toId && createdEdge.toId === newEdge.fromId;\n          if (matchToDirection || matchFromDirection) {\n            return newEdge;\n          }\n        }\n        return null;\n      };\n      for (var _j3 = 0; _j3 < createEdges.length; _j3++) {\n        var createdEdge = createEdges[_j3];\n        var _edge = createdEdge.edge;\n        var newEdge = getNewEdge(createdEdge);\n        if (newEdge === null) {\n          // Create a clustered edge for this connection\n          newEdge = this._createClusteredEdge(createdEdge.fromId, createdEdge.toId, _edge, clusterEdgeProperties);\n          newEdges.push(newEdge);\n        } else {\n          newEdge.clusteringEdgeReplacingIds.push(_edge.id);\n        }\n\n        // also reference the new edge in the old edge\n        this.body.edges[_edge.id].edgeReplacedById = newEdge.id;\n\n        // hide the replaced edge\n        this._backupEdgeOptions(_edge);\n        _edge.setOptions({\n          physics: false\n        });\n      }\n    }\n\n    /**\n     * This function checks the options that can be supplied to the different cluster functions\n     * for certain fields and inserts defaults if needed\n     *\n     * @param {object} options\n     * @returns {*}\n     * @private\n     */\n  }, {\n    key: \"_checkOptions\",\n    value: function _checkOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (options.clusterEdgeProperties === undefined) {\n        options.clusterEdgeProperties = {};\n      }\n      if (options.clusterNodeProperties === undefined) {\n        options.clusterNodeProperties = {};\n      }\n      return options;\n    }\n\n    /**\n     *\n     * @param {object}    childNodesObj         | object with node objects, id as keys, same as childNodes except it also contains a source node\n     * @param {object}    childEdgesObj         | object with edge objects, id as keys\n     * @param {Array}     options               | object with {clusterNodeProperties, clusterEdgeProperties, processProperties}\n     * @param {boolean}   refreshData | when true, do not wrap up\n     * @private\n     */\n  }, {\n    key: \"_cluster\",\n    value: function _cluster(childNodesObj, childEdgesObj, options) {\n      var refreshData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      // Remove nodes which are already clustered\n      var tmpNodesToRemove = [];\n      for (var nodeId in childNodesObj) {\n        if (Object.prototype.hasOwnProperty.call(childNodesObj, nodeId)) {\n          if (this.clusteredNodes[nodeId] !== undefined) {\n            tmpNodesToRemove.push(nodeId);\n          }\n        }\n      }\n      for (var n = 0; n < tmpNodesToRemove.length; ++n) {\n        delete childNodesObj[tmpNodesToRemove[n]];\n      }\n\n      // kill condition: no nodes don't bother\n      if (_Object$keys(childNodesObj).length == 0) {\n        return;\n      }\n\n      // allow clusters of 1 if options allow\n      if (_Object$keys(childNodesObj).length == 1 && options.clusterNodeProperties.allowSingleNodeCluster != true) {\n        return;\n      }\n      var clusterNodeProperties = deepExtend({}, options.clusterNodeProperties);\n\n      // construct the clusterNodeProperties\n      if (options.processProperties !== undefined) {\n        // get the childNode options\n        var childNodesOptions = [];\n        for (var _nodeId in childNodesObj) {\n          if (Object.prototype.hasOwnProperty.call(childNodesObj, _nodeId)) {\n            var clonedOptions = NetworkUtil.cloneOptions(childNodesObj[_nodeId]);\n            childNodesOptions.push(clonedOptions);\n          }\n        }\n\n        // get cluster properties based on childNodes\n        var childEdgesOptions = [];\n        for (var edgeId in childEdgesObj) {\n          if (Object.prototype.hasOwnProperty.call(childEdgesObj, edgeId)) {\n            // these cluster edges will be removed on creation of the cluster.\n            if (edgeId.substr(0, 12) !== \"clusterEdge:\") {\n              var _clonedOptions = NetworkUtil.cloneOptions(childEdgesObj[edgeId], \"edge\");\n              childEdgesOptions.push(_clonedOptions);\n            }\n          }\n        }\n        clusterNodeProperties = options.processProperties(clusterNodeProperties, childNodesOptions, childEdgesOptions);\n        if (!clusterNodeProperties) {\n          throw new Error(\"The processProperties function does not return properties!\");\n        }\n      }\n\n      // check if we have an unique id;\n      if (clusterNodeProperties.id === undefined) {\n        clusterNodeProperties.id = \"cluster:\" + v4();\n      }\n      var clusterId = clusterNodeProperties.id;\n      if (clusterNodeProperties.label === undefined) {\n        clusterNodeProperties.label = \"cluster\";\n      }\n\n      // give the clusterNode a position if it does not have one.\n      var pos = undefined;\n      if (clusterNodeProperties.x === undefined) {\n        pos = this._getClusterPosition(childNodesObj);\n        clusterNodeProperties.x = pos.x;\n      }\n      if (clusterNodeProperties.y === undefined) {\n        if (pos === undefined) {\n          pos = this._getClusterPosition(childNodesObj);\n        }\n        clusterNodeProperties.y = pos.y;\n      }\n\n      // force the ID to remain the same\n      clusterNodeProperties.id = clusterId;\n\n      // create the cluster Node\n      // Note that allowSingleNodeCluster, if present, is stored in the options as well\n      var clusterNode = this.body.functions.createNode(clusterNodeProperties, Cluster);\n      clusterNode.containedNodes = childNodesObj;\n      clusterNode.containedEdges = childEdgesObj;\n      // cache a copy from the cluster edge properties if we have to reconnect others later on\n      clusterNode.clusterEdgeProperties = options.clusterEdgeProperties;\n\n      // finally put the cluster node into global\n      this.body.nodes[clusterNodeProperties.id] = clusterNode;\n      this._clusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, options.clusterEdgeProperties);\n\n      // set ID to undefined so no duplicates arise\n      clusterNodeProperties.id = undefined;\n\n      // wrap up\n      if (refreshData === true) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n\n    /**\n     *\n     * @param {Edge} edge\n     * @private\n     */\n  }, {\n    key: \"_backupEdgeOptions\",\n    value: function _backupEdgeOptions(edge) {\n      if (this.clusteredEdges[edge.id] === undefined) {\n        this.clusteredEdges[edge.id] = {\n          physics: edge.options.physics\n        };\n      }\n    }\n\n    /**\n     *\n     * @param {Edge} edge\n     * @private\n     */\n  }, {\n    key: \"_restoreEdge\",\n    value: function _restoreEdge(edge) {\n      var originalOptions = this.clusteredEdges[edge.id];\n      if (originalOptions !== undefined) {\n        edge.setOptions({\n          physics: originalOptions.physics\n        });\n        delete this.clusteredEdges[edge.id];\n      }\n    }\n\n    /**\n     * Check if a node is a cluster.\n     *\n     * @param {Node.id} nodeId\n     * @returns {*}\n     */\n  }, {\n    key: \"isCluster\",\n    value: function isCluster(nodeId) {\n      if (this.body.nodes[nodeId] !== undefined) {\n        return this.body.nodes[nodeId].isCluster === true;\n      } else {\n        console.error(\"Node does not exist.\");\n        return false;\n      }\n    }\n\n    /**\n     * get the position of the cluster node based on what's inside\n     *\n     * @param {object} childNodesObj    | object with node objects, id as keys\n     * @returns {{x: number, y: number}}\n     * @private\n     */\n  }, {\n    key: \"_getClusterPosition\",\n    value: function _getClusterPosition(childNodesObj) {\n      var childKeys = _Object$keys(childNodesObj);\n      var minX = childNodesObj[childKeys[0]].x;\n      var maxX = childNodesObj[childKeys[0]].x;\n      var minY = childNodesObj[childKeys[0]].y;\n      var maxY = childNodesObj[childKeys[0]].y;\n      var node;\n      for (var i = 1; i < childKeys.length; i++) {\n        node = childNodesObj[childKeys[i]];\n        minX = node.x < minX ? node.x : minX;\n        maxX = node.x > maxX ? node.x : maxX;\n        minY = node.y < minY ? node.y : minY;\n        maxY = node.y > maxY ? node.y : maxY;\n      }\n      return {\n        x: 0.5 * (minX + maxX),\n        y: 0.5 * (minY + maxY)\n      };\n    }\n\n    /**\n     * Open a cluster by calling this function.\n     *\n     * @param {vis.Edge.id}  clusterNodeId | the ID of the cluster node\n     * @param {object} options\n     * @param {boolean} refreshData | wrap up afterwards if not true\n     */\n  }, {\n    key: \"openCluster\",\n    value: function openCluster(clusterNodeId, options) {\n      var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      // kill conditions\n      if (clusterNodeId === undefined) {\n        throw new Error(\"No clusterNodeId supplied to openCluster.\");\n      }\n      var clusterNode = this.body.nodes[clusterNodeId];\n      if (clusterNode === undefined) {\n        throw new Error(\"The clusterNodeId supplied to openCluster does not exist.\");\n      }\n      if (clusterNode.isCluster !== true || clusterNode.containedNodes === undefined || clusterNode.containedEdges === undefined) {\n        throw new Error(\"The node:\" + clusterNodeId + \" is not a valid cluster.\");\n      }\n\n      // Check if current cluster is clustered itself\n      var stack = this.findNode(clusterNodeId);\n      var parentIndex = _indexOfInstanceProperty(stack).call(stack, clusterNodeId) - 1;\n      if (parentIndex >= 0) {\n        // Current cluster is clustered; transfer contained nodes and edges to parent\n        var parentClusterNodeId = stack[parentIndex];\n        var parentClusterNode = this.body.nodes[parentClusterNodeId];\n\n        // clustering.clusteredNodes and clustering.clusteredEdges remain unchanged\n        parentClusterNode._openChildCluster(clusterNodeId);\n\n        // All components of child cluster node have been transferred. It can die now.\n        delete this.body.nodes[clusterNodeId];\n        if (refreshData === true) {\n          this.body.emitter.emit(\"_dataChanged\");\n        }\n        return;\n      }\n\n      // main body\n      var containedNodes = clusterNode.containedNodes;\n      var containedEdges = clusterNode.containedEdges;\n\n      // allow the user to position the nodes after release.\n      if (options !== undefined && options.releaseFunction !== undefined && typeof options.releaseFunction === \"function\") {\n        var positions = {};\n        var clusterPosition = {\n          x: clusterNode.x,\n          y: clusterNode.y\n        };\n        for (var nodeId in containedNodes) {\n          if (Object.prototype.hasOwnProperty.call(containedNodes, nodeId)) {\n            var containedNode = this.body.nodes[nodeId];\n            positions[nodeId] = {\n              x: containedNode.x,\n              y: containedNode.y\n            };\n          }\n        }\n        var newPositions = options.releaseFunction(clusterPosition, positions);\n        for (var _nodeId2 in containedNodes) {\n          if (Object.prototype.hasOwnProperty.call(containedNodes, _nodeId2)) {\n            var _containedNode = this.body.nodes[_nodeId2];\n            if (newPositions[_nodeId2] !== undefined) {\n              _containedNode.x = newPositions[_nodeId2].x === undefined ? clusterNode.x : newPositions[_nodeId2].x;\n              _containedNode.y = newPositions[_nodeId2].y === undefined ? clusterNode.y : newPositions[_nodeId2].y;\n            }\n          }\n        }\n      } else {\n        // copy the position from the cluster\n        forEach$1(containedNodes, function (containedNode) {\n          // inherit position\n          if (containedNode.options.fixed.x === false) {\n            containedNode.x = clusterNode.x;\n          }\n          if (containedNode.options.fixed.y === false) {\n            containedNode.y = clusterNode.y;\n          }\n        });\n      }\n\n      // release nodes\n      for (var _nodeId3 in containedNodes) {\n        if (Object.prototype.hasOwnProperty.call(containedNodes, _nodeId3)) {\n          var _containedNode2 = this.body.nodes[_nodeId3];\n\n          // inherit speed\n          _containedNode2.vx = clusterNode.vx;\n          _containedNode2.vy = clusterNode.vy;\n          _containedNode2.setOptions({\n            physics: true\n          });\n          delete this.clusteredNodes[_nodeId3];\n        }\n      }\n\n      // copy the clusterNode edges because we cannot iterate over an object that we add or remove from.\n      var edgesToBeDeleted = [];\n      for (var i = 0; i < clusterNode.edges.length; i++) {\n        edgesToBeDeleted.push(clusterNode.edges[i]);\n      }\n\n      // actually handling the deleting.\n      for (var _i3 = 0; _i3 < edgesToBeDeleted.length; _i3++) {\n        var edge = edgesToBeDeleted[_i3];\n        var otherNodeId = this._getConnectedId(edge, clusterNodeId);\n        var otherNode = this.clusteredNodes[otherNodeId];\n        for (var j = 0; j < edge.clusteringEdgeReplacingIds.length; j++) {\n          var transferId = edge.clusteringEdgeReplacingIds[j];\n          var transferEdge = this.body.edges[transferId];\n          if (transferEdge === undefined) continue;\n\n          // if the other node is in another cluster, we transfer ownership of this edge to the other cluster\n          if (otherNode !== undefined) {\n            // transfer ownership:\n            var otherCluster = this.body.nodes[otherNode.clusterId];\n            otherCluster.containedEdges[transferEdge.id] = transferEdge;\n\n            // delete local reference\n            delete containedEdges[transferEdge.id];\n\n            // get to and from\n            var fromId = transferEdge.fromId;\n            var toId = transferEdge.toId;\n            if (transferEdge.toId == otherNodeId) {\n              toId = otherNode.clusterId;\n            } else {\n              fromId = otherNode.clusterId;\n            }\n\n            // create new cluster edge from the otherCluster\n            this._createClusteredEdge(fromId, toId, transferEdge, otherCluster.clusterEdgeProperties, {\n              hidden: false,\n              physics: true\n            });\n          } else {\n            this._restoreEdge(transferEdge);\n          }\n        }\n        edge.remove();\n      }\n\n      // handle the releasing of the edges\n      for (var edgeId in containedEdges) {\n        if (Object.prototype.hasOwnProperty.call(containedEdges, edgeId)) {\n          this._restoreEdge(containedEdges[edgeId]);\n        }\n      }\n\n      // remove clusterNode\n      delete this.body.nodes[clusterNodeId];\n      if (refreshData === true) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n\n    /**\n     *\n     * @param {Cluster.id} clusterId\n     * @returns {Array.<Node.id>}\n     */\n  }, {\n    key: \"getNodesInCluster\",\n    value: function getNodesInCluster(clusterId) {\n      var nodesArray = [];\n      if (this.isCluster(clusterId) === true) {\n        var containedNodes = this.body.nodes[clusterId].containedNodes;\n        for (var nodeId in containedNodes) {\n          if (Object.prototype.hasOwnProperty.call(containedNodes, nodeId)) {\n            nodesArray.push(this.body.nodes[nodeId].id);\n          }\n        }\n      }\n      return nodesArray;\n    }\n\n    /**\n     * Get the stack clusterId's that a certain node resides in. cluster A -> cluster B -> cluster C -> node\n     *\n     * If a node can't be found in the chain, return an empty array.\n     *\n     * @param {string|number} nodeId\n     * @returns {Array}\n     */\n  }, {\n    key: \"findNode\",\n    value: function findNode(nodeId) {\n      var stack = [];\n      var max = 100;\n      var counter = 0;\n      var node;\n      while (this.clusteredNodes[nodeId] !== undefined && counter < max) {\n        node = this.body.nodes[nodeId];\n        if (node === undefined) return [];\n        stack.push(node.id);\n        nodeId = this.clusteredNodes[nodeId].clusterId;\n        counter++;\n      }\n      node = this.body.nodes[nodeId];\n      if (node === undefined) return [];\n      stack.push(node.id);\n      _reverseInstanceProperty(stack).call(stack);\n      return stack;\n    }\n\n    /**\n     * Using a clustered nodeId, update with the new options\n     *\n     * @param {Node.id} clusteredNodeId\n     * @param {object} newOptions\n     */\n  }, {\n    key: \"updateClusteredNode\",\n    value: function updateClusteredNode(clusteredNodeId, newOptions) {\n      if (clusteredNodeId === undefined) {\n        throw new Error(\"No clusteredNodeId supplied to updateClusteredNode.\");\n      }\n      if (newOptions === undefined) {\n        throw new Error(\"No newOptions supplied to updateClusteredNode.\");\n      }\n      if (this.body.nodes[clusteredNodeId] === undefined) {\n        throw new Error(\"The clusteredNodeId supplied to updateClusteredNode does not exist.\");\n      }\n      this.body.nodes[clusteredNodeId].setOptions(newOptions);\n      this.body.emitter.emit(\"_dataChanged\");\n    }\n\n    /**\n     * Using a base edgeId, update all related clustered edges with the new options\n     *\n     * @param {vis.Edge.id} startEdgeId\n     * @param {object} newOptions\n     */\n  }, {\n    key: \"updateEdge\",\n    value: function updateEdge(startEdgeId, newOptions) {\n      if (startEdgeId === undefined) {\n        throw new Error(\"No startEdgeId supplied to updateEdge.\");\n      }\n      if (newOptions === undefined) {\n        throw new Error(\"No newOptions supplied to updateEdge.\");\n      }\n      if (this.body.edges[startEdgeId] === undefined) {\n        throw new Error(\"The startEdgeId supplied to updateEdge does not exist.\");\n      }\n      var allEdgeIds = this.getClusteredEdges(startEdgeId);\n      for (var i = 0; i < allEdgeIds.length; i++) {\n        var edge = this.body.edges[allEdgeIds[i]];\n        edge.setOptions(newOptions);\n      }\n      this.body.emitter.emit(\"_dataChanged\");\n    }\n\n    /**\n     * Get a stack of clusterEdgeId's (+base edgeid) that a base edge is the same as. cluster edge C -> cluster edge B -> cluster edge A -> base edge(edgeId)\n     *\n     * @param {vis.Edge.id} edgeId\n     * @returns {Array.<vis.Edge.id>}\n     */\n  }, {\n    key: \"getClusteredEdges\",\n    value: function getClusteredEdges(edgeId) {\n      var stack = [];\n      var max = 100;\n      var counter = 0;\n      while (edgeId !== undefined && this.body.edges[edgeId] !== undefined && counter < max) {\n        stack.push(this.body.edges[edgeId].id);\n        edgeId = this.body.edges[edgeId].edgeReplacedById;\n        counter++;\n      }\n      _reverseInstanceProperty(stack).call(stack);\n      return stack;\n    }\n\n    /**\n     * Get the base edge id of clusterEdgeId. cluster edge (clusteredEdgeId) -> cluster edge B -> cluster edge C -> base edge\n     *\n     * @param {vis.Edge.id} clusteredEdgeId\n     * @returns {vis.Edge.id} baseEdgeId\n     *\n     * TODO: deprecate in 5.0.0. Method getBaseEdges() is the correct one to use.\n     */\n  }, {\n    key: \"getBaseEdge\",\n    value: function getBaseEdge(clusteredEdgeId) {\n      // Just kludge this by returning the first base edge id found\n      return this.getBaseEdges(clusteredEdgeId)[0];\n    }\n\n    /**\n     * Get all regular edges for this clustered edge id.\n     *\n     * @param {vis.Edge.id} clusteredEdgeId\n     * @returns {Array.<vis.Edge.id>} all baseEdgeId's under this clustered edge\n     */\n  }, {\n    key: \"getBaseEdges\",\n    value: function getBaseEdges(clusteredEdgeId) {\n      var IdsToHandle = [clusteredEdgeId];\n      var doneIds = [];\n      var foundIds = [];\n      var max = 100;\n      var counter = 0;\n      while (IdsToHandle.length > 0 && counter < max) {\n        var nextId = IdsToHandle.pop();\n        if (nextId === undefined) continue; // Paranoia here and onwards\n        var nextEdge = this.body.edges[nextId];\n        if (nextEdge === undefined) continue;\n        counter++;\n        var replacingIds = nextEdge.clusteringEdgeReplacingIds;\n        if (replacingIds === undefined) {\n          // nextId is a base id\n          foundIds.push(nextId);\n        } else {\n          // Another cluster edge, unravel this one as well\n          for (var i = 0; i < replacingIds.length; ++i) {\n            var replacingId = replacingIds[i];\n\n            // Don't add if already handled\n            // TODO: never triggers; find a test-case which does\n            if (_indexOfInstanceProperty(IdsToHandle).call(IdsToHandle, replacingIds) !== -1 || _indexOfInstanceProperty(doneIds).call(doneIds, replacingIds) !== -1) {\n              continue;\n            }\n            IdsToHandle.push(replacingId);\n          }\n        }\n        doneIds.push(nextId);\n      }\n      return foundIds;\n    }\n\n    /**\n     * Get the Id the node is connected to\n     *\n     * @param {vis.Edge} edge\n     * @param {Node.id} nodeId\n     * @returns {*}\n     * @private\n     */\n  }, {\n    key: \"_getConnectedId\",\n    value: function _getConnectedId(edge, nodeId) {\n      if (edge.toId != nodeId) {\n        return edge.toId;\n      } else if (edge.fromId != nodeId) {\n        return edge.fromId;\n      } else {\n        return edge.fromId;\n      }\n    }\n\n    /**\n     * We determine how many connections denote an important hub.\n     * We take the mean + 2*std as the important hub size. (Assuming a normal distribution of data, ~2.2%)\n     *\n     * @returns {number}\n     * @private\n     */\n  }, {\n    key: \"_getHubSize\",\n    value: function _getHubSize() {\n      var average = 0;\n      var averageSquared = 0;\n      var hubCounter = 0;\n      var largestHub = 0;\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        var node = this.body.nodes[this.body.nodeIndices[i]];\n        if (node.edges.length > largestHub) {\n          largestHub = node.edges.length;\n        }\n        average += node.edges.length;\n        averageSquared += Math.pow(node.edges.length, 2);\n        hubCounter += 1;\n      }\n      average = average / hubCounter;\n      averageSquared = averageSquared / hubCounter;\n      var variance = averageSquared - Math.pow(average, 2);\n      var standardDeviation = Math.sqrt(variance);\n      var hubThreshold = Math.floor(average + 2 * standardDeviation);\n\n      // always have at least one to cluster\n      if (hubThreshold > largestHub) {\n        hubThreshold = largestHub;\n      }\n      return hubThreshold;\n    }\n\n    /**\n     * Create an edge for the cluster representation.\n     *\n     * @param {Node.id} fromId\n     * @param {Node.id} toId\n     * @param {vis.Edge} baseEdge\n     * @param {object} clusterEdgeProperties\n     * @param {object} extraOptions\n     * @returns {Edge} newly created clustered edge\n     * @private\n     */\n  }, {\n    key: \"_createClusteredEdge\",\n    value: function _createClusteredEdge(fromId, toId, baseEdge, clusterEdgeProperties, extraOptions) {\n      // copy the options of the edge we will replace\n      var clonedOptions = NetworkUtil.cloneOptions(baseEdge, \"edge\");\n      // make sure the properties of clusterEdges are superimposed on it\n      deepExtend(clonedOptions, clusterEdgeProperties);\n\n      // set up the edge\n      clonedOptions.from = fromId;\n      clonedOptions.to = toId;\n      clonedOptions.id = \"clusterEdge:\" + v4();\n\n      // apply the edge specific options to it if specified\n      if (extraOptions !== undefined) {\n        deepExtend(clonedOptions, extraOptions);\n      }\n      var newEdge = this.body.functions.createEdge(clonedOptions);\n      newEdge.clusteringEdgeReplacingIds = [baseEdge.id];\n      newEdge.connect();\n\n      // Register the new edge\n      this.body.edges[newEdge.id] = newEdge;\n      return newEdge;\n    }\n\n    /**\n     * Add the passed child nodes and edges to the given cluster node.\n     *\n     * @param {object | Node} childNodes  hash of nodes or single node to add in cluster\n     * @param {object | Edge} childEdges  hash of edges or single edge to take into account when clustering\n     * @param {Node} clusterNode  cluster node to add nodes and edges to\n     * @param {object} [clusterEdgeProperties]\n     * @private\n     */\n  }, {\n    key: \"_clusterEdges\",\n    value: function _clusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties) {\n      if (childEdges instanceof Edge) {\n        var edge = childEdges;\n        var obj = {};\n        obj[edge.id] = edge;\n        childEdges = obj;\n      }\n      if (childNodes instanceof Node) {\n        var node = childNodes;\n        var _obj = {};\n        _obj[node.id] = node;\n        childNodes = _obj;\n      }\n      if (clusterNode === undefined || clusterNode === null) {\n        throw new Error(\"_clusterEdges: parameter clusterNode required\");\n      }\n      if (clusterEdgeProperties === undefined) {\n        // Take the required properties from the cluster node\n        clusterEdgeProperties = clusterNode.clusterEdgeProperties;\n      }\n\n      // create the new edges that will connect to the cluster.\n      // All self-referencing edges will be added to childEdges here.\n      this._createClusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties);\n\n      // disable the childEdges\n      for (var edgeId in childEdges) {\n        if (Object.prototype.hasOwnProperty.call(childEdges, edgeId)) {\n          if (this.body.edges[edgeId] !== undefined) {\n            var _edge2 = this.body.edges[edgeId];\n            // cache the options before changing\n            this._backupEdgeOptions(_edge2);\n            // disable physics and hide the edge\n            _edge2.setOptions({\n              physics: false\n            });\n          }\n        }\n      }\n\n      // disable the childNodes\n      for (var nodeId in childNodes) {\n        if (Object.prototype.hasOwnProperty.call(childNodes, nodeId)) {\n          this.clusteredNodes[nodeId] = {\n            clusterId: clusterNode.id,\n            node: this.body.nodes[nodeId]\n          };\n          this.body.nodes[nodeId].setOptions({\n            physics: false\n          });\n        }\n      }\n    }\n\n    /**\n     * Determine in which cluster given nodeId resides.\n     *\n     * If not in cluster, return undefined.\n     *\n     * NOTE: If you know a cleaner way to do this, please enlighten me (wimrijnders).\n     *\n     * @param {Node.id} nodeId\n     * @returns {Node|undefined} Node instance for cluster, if present\n     * @private\n     */\n  }, {\n    key: \"_getClusterNodeForNode\",\n    value: function _getClusterNodeForNode(nodeId) {\n      if (nodeId === undefined) return undefined;\n      var clusteredNode = this.clusteredNodes[nodeId];\n\n      // NOTE: If no cluster info found, it should actually be an error\n      if (clusteredNode === undefined) return undefined;\n      var clusterId = clusteredNode.clusterId;\n      if (clusterId === undefined) return undefined;\n      return this.body.nodes[clusterId];\n    }\n\n    /**\n     * Internal helper function for conditionally removing items in array\n     *\n     * Done like this because Array.filter() is not fully supported by all IE's.\n     *\n     * @param {Array} arr\n     * @param {Function} callback\n     * @returns {Array}\n     * @private\n     */\n  }, {\n    key: \"_filter\",\n    value: function _filter(arr, callback) {\n      var ret = [];\n      forEach$1(arr, function (item) {\n        if (callback(item)) {\n          ret.push(item);\n        }\n      });\n      return ret;\n    }\n\n    /**\n     * Scan all edges for changes in clustering and adjust this if necessary.\n     *\n     * Call this (internally) after there has been a change in node or edge data.\n     *\n     * Pre: States of this.body.nodes and this.body.edges consistent\n     * Pre: this.clusteredNodes and this.clusteredEdge consistent with containedNodes and containedEdges\n     *      of cluster nodes.\n     */\n  }, {\n    key: \"_updateState\",\n    value: function _updateState() {\n      var _this4 = this;\n      var nodeId;\n      var deletedNodeIds = [];\n      var deletedEdgeIds = {};\n\n      /**\n       * Utility function to iterate over clustering nodes only\n       *\n       * @param {Function} callback  function to call for each cluster node\n       */\n      var eachClusterNode = function eachClusterNode(callback) {\n        forEach$1(_this4.body.nodes, function (node) {\n          if (node.isCluster === true) {\n            callback(node);\n          }\n        });\n      };\n\n      //\n      // Remove deleted regular nodes from clustering\n      //\n\n      // Determine the deleted nodes\n      for (nodeId in this.clusteredNodes) {\n        if (!Object.prototype.hasOwnProperty.call(this.clusteredNodes, nodeId)) continue;\n        var node = this.body.nodes[nodeId];\n        if (node === undefined) {\n          deletedNodeIds.push(nodeId);\n        }\n      }\n\n      // Remove nodes from cluster nodes\n      eachClusterNode(function (clusterNode) {\n        for (var n = 0; n < deletedNodeIds.length; n++) {\n          delete clusterNode.containedNodes[deletedNodeIds[n]];\n        }\n      });\n\n      // Remove nodes from cluster list\n      for (var n = 0; n < deletedNodeIds.length; n++) {\n        delete this.clusteredNodes[deletedNodeIds[n]];\n      }\n\n      //\n      // Remove deleted edges from clustering\n      //\n\n      // Add the deleted clustered edges to the list\n      forEach$1(this.clusteredEdges, function (edgeId) {\n        var edge = _this4.body.edges[edgeId];\n        if (edge === undefined || !edge.endPointsValid()) {\n          deletedEdgeIds[edgeId] = edgeId;\n        }\n      });\n\n      // Cluster nodes can also contain edges which are not clustered,\n      // i.e. nodes 1-2 within cluster with an edge in between.\n      // So the cluster nodes also need to be scanned for invalid edges\n      eachClusterNode(function (clusterNode) {\n        forEach$1(clusterNode.containedEdges, function (edge, edgeId) {\n          if (!edge.endPointsValid() && !deletedEdgeIds[edgeId]) {\n            deletedEdgeIds[edgeId] = edgeId;\n          }\n        });\n      });\n\n      // Also scan for cluster edges which need to be removed in the active list.\n      // Regular edges have been removed beforehand, so this only picks up the cluster edges.\n      forEach$1(this.body.edges, function (edge, edgeId) {\n        // Explicitly scan the contained edges for validity\n        var isValid = true;\n        var replacedIds = edge.clusteringEdgeReplacingIds;\n        if (replacedIds !== undefined) {\n          var numValid = 0;\n          forEach$1(replacedIds, function (containedEdgeId) {\n            var containedEdge = _this4.body.edges[containedEdgeId];\n            if (containedEdge !== undefined && containedEdge.endPointsValid()) {\n              numValid += 1;\n            }\n          });\n          isValid = numValid > 0;\n        }\n        if (!edge.endPointsValid() || !isValid) {\n          deletedEdgeIds[edgeId] = edgeId;\n        }\n      });\n\n      // Remove edges from cluster nodes\n      eachClusterNode(function (clusterNode) {\n        forEach$1(deletedEdgeIds, function (deletedEdgeId) {\n          delete clusterNode.containedEdges[deletedEdgeId];\n          forEach$1(clusterNode.edges, function (edge, m) {\n            if (edge.id === deletedEdgeId) {\n              clusterNode.edges[m] = null; // Don't want to directly delete here, because in the loop\n              return;\n            }\n            edge.clusteringEdgeReplacingIds = _this4._filter(edge.clusteringEdgeReplacingIds, function (id) {\n              return !deletedEdgeIds[id];\n            });\n          });\n\n          // Clean up the nulls\n          clusterNode.edges = _this4._filter(clusterNode.edges, function (item) {\n            return item !== null;\n          });\n        });\n      });\n\n      // Remove from cluster list\n      forEach$1(deletedEdgeIds, function (edgeId) {\n        delete _this4.clusteredEdges[edgeId];\n      });\n\n      // Remove cluster edges from active list (this.body.edges).\n      // deletedEdgeIds still contains id of regular edges, but these should all\n      // be gone when you reach here.\n      forEach$1(deletedEdgeIds, function (edgeId) {\n        delete _this4.body.edges[edgeId];\n      });\n\n      //\n      // Check changed cluster state of edges\n      //\n\n      // Iterating over keys here, because edges may be removed in the loop\n      var ids = _Object$keys(this.body.edges);\n      forEach$1(ids, function (edgeId) {\n        var edge = _this4.body.edges[edgeId];\n        var shouldBeClustered = _this4._isClusteredNode(edge.fromId) || _this4._isClusteredNode(edge.toId);\n        if (shouldBeClustered === _this4._isClusteredEdge(edge.id)) {\n          return; // all is well\n        }\n\n        if (shouldBeClustered) {\n          // add edge to clustering\n          var clusterFrom = _this4._getClusterNodeForNode(edge.fromId);\n          if (clusterFrom !== undefined) {\n            _this4._clusterEdges(_this4.body.nodes[edge.fromId], edge, clusterFrom);\n          }\n          var clusterTo = _this4._getClusterNodeForNode(edge.toId);\n          if (clusterTo !== undefined) {\n            _this4._clusterEdges(_this4.body.nodes[edge.toId], edge, clusterTo);\n          }\n\n          // TODO: check that it works for both edges clustered\n          //       (This might be paranoia)\n        } else {\n          delete _this4._clusterEdges[edgeId];\n          _this4._restoreEdge(edge);\n          // This should not be happening, the state should\n          // be properly updated at this point.\n          //\n          // If it *is* reached during normal operation, then we have to implement\n          // undo clustering for this edge here.\n          // throw new Error('remove edge from clustering not implemented!')\n        }\n      });\n\n      // Clusters may be nested to any level. Keep on opening until nothing to open\n      var changed = false;\n      var continueLoop = true;\n      var _loop2 = function _loop2() {\n        var clustersToOpen = [];\n\n        // Determine the id's of clusters that need opening\n        eachClusterNode(function (clusterNode) {\n          var numNodes = _Object$keys(clusterNode.containedNodes).length;\n          var allowSingle = clusterNode.options.allowSingleNodeCluster === true;\n          if (allowSingle && numNodes < 1 || !allowSingle && numNodes < 2) {\n            clustersToOpen.push(clusterNode.id);\n          }\n        });\n\n        // Open them\n        for (var _n = 0; _n < clustersToOpen.length; ++_n) {\n          _this4.openCluster(clustersToOpen[_n], {}, false /* Don't refresh, we're in an refresh/update already */);\n        }\n\n        continueLoop = clustersToOpen.length > 0;\n        changed = changed || continueLoop;\n      };\n      while (continueLoop) {\n        _loop2();\n      }\n      if (changed) {\n        this._updateState(); // Redo this method (recursion possible! should be safe)\n      }\n    }\n\n    /**\n     * Determine if node with given id is part of a cluster.\n     *\n     * @param {Node.id} nodeId\n     * @returns {boolean} true if part of a cluster.\n     */\n  }, {\n    key: \"_isClusteredNode\",\n    value: function _isClusteredNode(nodeId) {\n      return this.clusteredNodes[nodeId] !== undefined;\n    }\n\n    /**\n     * Determine if edge with given id is not visible due to clustering.\n     *\n     * An edge is considered clustered if:\n     * - it is directly replaced by a clustering edge\n     * - any of its connecting nodes is in a cluster\n     *\n     * @param {vis.Edge.id} edgeId\n     * @returns {boolean} true if part of a cluster.\n     */\n  }, {\n    key: \"_isClusteredEdge\",\n    value: function _isClusteredEdge(edgeId) {\n      return this.clusteredEdges[edgeId] !== undefined;\n    }\n  }]);\n  return ClusterEngine;\n}();\n\n/**\n * Initializes window.requestAnimationFrame() to a usable form.\n *\n * Specifically, set up this method for the case of running on node.js with jsdom enabled.\n *\n * NOTES:\n *\n * On node.js, when calling this directly outside of this class, `window` is not defined.\n *   This happens even if jsdom is used.\n * For node.js + jsdom, `window` is available at the moment the constructor is called.\n *   For this reason, the called is placed within the constructor.\n * Even then, `window.requestAnimationFrame()` is not defined, so it still needs to be added.\n * During unit testing, it happens that the window object is reset during execution, causing\n *   a runtime error due to missing `requestAnimationFrame()`. This needs to be compensated for,\n *   see `_requestNextFrame()`.\n * Since this is a global object, it may affect other modules besides `Network`. With normal\n *   usage, this does not cause any problems. During unit testing, errors may occur. These have\n *   been compensated for, see comment block in _requestNextFrame().\n *\n * @private\n */\nfunction _initRequestAnimationFrame() {\n  var func;\n  if (window !== undefined) {\n    func = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n  }\n  if (func === undefined) {\n    // window or method not present, setting mock requestAnimationFrame\n    window.requestAnimationFrame = function (callback) {\n      //console.log(\"Called mock requestAnimationFrame\");\n      callback();\n    };\n  } else {\n    window.requestAnimationFrame = func;\n  }\n}\n\n/**\n * The canvas renderer\n */\nvar CanvasRenderer = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {Canvas} canvas\n   */\n  function CanvasRenderer(body, canvas) {\n    _classCallCheck(this, CanvasRenderer);\n    _initRequestAnimationFrame();\n    this.body = body;\n    this.canvas = canvas;\n    this.redrawRequested = false;\n    this.renderTimer = undefined;\n    this.requiresTimeout = true;\n    this.renderingActive = false;\n    this.renderRequests = 0;\n    this.allowRedraw = true;\n    this.dragging = false;\n    this.zooming = false;\n    this.options = {};\n    this.defaultOptions = {\n      hideEdgesOnDrag: false,\n      hideEdgesOnZoom: false,\n      hideNodesOnDrag: false\n    };\n    _Object$assign(this.options, this.defaultOptions);\n    this._determineBrowserMethod();\n    this.bindEventListeners();\n  }\n\n  /**\n   * Binds event listeners\n   */\n  _createClass(CanvasRenderer, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _this = this,\n        _context2;\n      this.body.emitter.on(\"dragStart\", function () {\n        _this.dragging = true;\n      });\n      this.body.emitter.on(\"dragEnd\", function () {\n        _this.dragging = false;\n      });\n      this.body.emitter.on(\"zoom\", function () {\n        _this.zooming = true;\n        window.clearTimeout(_this.zoomTimeoutId);\n        _this.zoomTimeoutId = _setTimeout(function () {\n          var _context;\n          _this.zooming = false;\n          _bindInstanceProperty$1(_context = _this._requestRedraw).call(_context, _this)();\n        }, 250);\n      });\n      this.body.emitter.on(\"_resizeNodes\", function () {\n        _this._resizeNodes();\n      });\n      this.body.emitter.on(\"_redraw\", function () {\n        if (_this.renderingActive === false) {\n          _this._redraw();\n        }\n      });\n      this.body.emitter.on(\"_blockRedraw\", function () {\n        _this.allowRedraw = false;\n      });\n      this.body.emitter.on(\"_allowRedraw\", function () {\n        _this.allowRedraw = true;\n        _this.redrawRequested = false;\n      });\n      this.body.emitter.on(\"_requestRedraw\", _bindInstanceProperty$1(_context2 = this._requestRedraw).call(_context2, this));\n      this.body.emitter.on(\"_startRendering\", function () {\n        _this.renderRequests += 1;\n        _this.renderingActive = true;\n        _this._startRendering();\n      });\n      this.body.emitter.on(\"_stopRendering\", function () {\n        _this.renderRequests -= 1;\n        _this.renderingActive = _this.renderRequests > 0;\n        _this.renderTimer = undefined;\n      });\n      this.body.emitter.on(\"destroy\", function () {\n        _this.renderRequests = 0;\n        _this.allowRedraw = false;\n        _this.renderingActive = false;\n        if (_this.requiresTimeout === true) {\n          clearTimeout(_this.renderTimer);\n        } else {\n          window.cancelAnimationFrame(_this.renderTimer);\n        }\n        _this.body.emitter.off();\n      });\n    }\n\n    /**\n     *\n     * @param {object} options\n     */\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        var fields = [\"hideEdgesOnDrag\", \"hideEdgesOnZoom\", \"hideNodesOnDrag\"];\n        selectiveDeepExtend(fields, this.options, options);\n      }\n    }\n\n    /**\n     * Prepare the drawing of the next frame.\n     *\n     * Calls the callback when the next frame can or will be drawn.\n     *\n     * @param {Function} callback\n     * @param {number} delay - timeout case only, wait this number of milliseconds\n     * @returns {Function | undefined}\n     * @private\n     */\n  }, {\n    key: \"_requestNextFrame\",\n    value: function _requestNextFrame(callback, delay) {\n      // During unit testing, it happens that the mock window object is reset while\n      // the next frame is still pending. Then, either 'window' is not present, or\n      // 'requestAnimationFrame()' is not present because it is not defined on the\n      // mock window object.\n      //\n      // As a consequence, unrelated unit tests may appear to fail, even if the problem\n      // described happens in the current unit test.\n      //\n      // This is not something that will happen in normal operation, but we still need\n      // to take it into account.\n      //\n      if (typeof window === \"undefined\") return; // Doing `if (window === undefined)` does not work here!\n\n      var timer;\n      var myWindow = window; // Grab a reference to reduce the possibility that 'window' is reset\n      // while running this method.\n\n      if (this.requiresTimeout === true) {\n        // wait given number of milliseconds and perform the animation step function\n        timer = _setTimeout(callback, delay);\n      } else {\n        if (myWindow.requestAnimationFrame) {\n          timer = myWindow.requestAnimationFrame(callback);\n        }\n      }\n      return timer;\n    }\n\n    /**\n     *\n     * @private\n     */\n  }, {\n    key: \"_startRendering\",\n    value: function _startRendering() {\n      if (this.renderingActive === true) {\n        if (this.renderTimer === undefined) {\n          var _context3;\n          this.renderTimer = this._requestNextFrame(_bindInstanceProperty$1(_context3 = this._renderStep).call(_context3, this), this.simulationInterval);\n        }\n      }\n    }\n\n    /**\n     *\n     * @private\n     */\n  }, {\n    key: \"_renderStep\",\n    value: function _renderStep() {\n      if (this.renderingActive === true) {\n        // reset the renderTimer so a new scheduled animation step can be set\n        this.renderTimer = undefined;\n        if (this.requiresTimeout === true) {\n          // this schedules a new simulation step\n          this._startRendering();\n        }\n        this._redraw();\n        if (this.requiresTimeout === false) {\n          // this schedules a new simulation step\n          this._startRendering();\n        }\n      }\n    }\n\n    /**\n     * Redraw the network with the current data\n     * chart will be resized too.\n     */\n  }, {\n    key: \"redraw\",\n    value: function redraw() {\n      this.body.emitter.emit(\"setSize\");\n      this._redraw();\n    }\n\n    /**\n     * Redraw the network with the current data\n     *\n     * @private\n     */\n  }, {\n    key: \"_requestRedraw\",\n    value: function _requestRedraw() {\n      var _this2 = this;\n      if (this.redrawRequested !== true && this.renderingActive === false && this.allowRedraw === true) {\n        this.redrawRequested = true;\n        this._requestNextFrame(function () {\n          _this2._redraw(false);\n        }, 0);\n      }\n    }\n\n    /**\n     * Redraw the network with the current data\n     *\n     * @param {boolean} [hidden=false] | Used to get the first estimate of the node sizes.\n     *                                   Only the nodes are drawn after which they are quickly drawn over.\n     * @private\n     */\n  }, {\n    key: \"_redraw\",\n    value: function _redraw() {\n      var hidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (this.allowRedraw === true) {\n        this.body.emitter.emit(\"initRedraw\");\n        this.redrawRequested = false;\n        var drawLater = {\n          drawExternalLabels: null\n        };\n\n        // when the container div was hidden, this fixes it back up!\n        if (this.canvas.frame.canvas.width === 0 || this.canvas.frame.canvas.height === 0) {\n          this.canvas.setSize();\n        }\n        this.canvas.setTransform();\n        var ctx = this.canvas.getContext();\n\n        // clear the canvas\n        var w = this.canvas.frame.canvas.clientWidth;\n        var h = this.canvas.frame.canvas.clientHeight;\n        ctx.clearRect(0, 0, w, h);\n\n        // if the div is hidden, we stop the redraw here for performance.\n        if (this.canvas.frame.clientWidth === 0) {\n          return;\n        }\n\n        // set scaling and translation\n        ctx.save();\n        ctx.translate(this.body.view.translation.x, this.body.view.translation.y);\n        ctx.scale(this.body.view.scale, this.body.view.scale);\n        ctx.beginPath();\n        this.body.emitter.emit(\"beforeDrawing\", ctx);\n        ctx.closePath();\n        if (hidden === false) {\n          if ((this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) && (this.zooming === false || this.zooming === true && this.options.hideEdgesOnZoom === false)) {\n            this._drawEdges(ctx);\n          }\n        }\n        if (this.dragging === false || this.dragging === true && this.options.hideNodesOnDrag === false) {\n          var _this$_drawNodes = this._drawNodes(ctx, hidden),\n            drawExternalLabels = _this$_drawNodes.drawExternalLabels;\n          drawLater.drawExternalLabels = drawExternalLabels;\n        }\n\n        // draw the arrows last so they will be at the top\n        if (hidden === false) {\n          if ((this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) && (this.zooming === false || this.zooming === true && this.options.hideEdgesOnZoom === false)) {\n            this._drawArrows(ctx);\n          }\n        }\n        if (drawLater.drawExternalLabels != null) {\n          drawLater.drawExternalLabels();\n        }\n        if (hidden === false) {\n          this._drawSelectionBox(ctx);\n        }\n        ctx.beginPath();\n        this.body.emitter.emit(\"afterDrawing\", ctx);\n        ctx.closePath();\n\n        // restore original scaling and translation\n        ctx.restore();\n        if (hidden === true) {\n          ctx.clearRect(0, 0, w, h);\n        }\n      }\n    }\n\n    /**\n     * Redraw all nodes\n     *\n     * @param {CanvasRenderingContext2D}   ctx\n     * @param {boolean} [alwaysShow]\n     * @private\n     */\n  }, {\n    key: \"_resizeNodes\",\n    value: function _resizeNodes() {\n      this.canvas.setTransform();\n      var ctx = this.canvas.getContext();\n      ctx.save();\n      ctx.translate(this.body.view.translation.x, this.body.view.translation.y);\n      ctx.scale(this.body.view.scale, this.body.view.scale);\n      var nodes = this.body.nodes;\n      var node;\n\n      // resize all nodes\n      for (var nodeId in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {\n          node = nodes[nodeId];\n          node.resize(ctx);\n          node.updateBoundingBox(ctx, node.selected);\n        }\n      }\n\n      // restore original scaling and translation\n      ctx.restore();\n    }\n\n    /**\n     * Redraw all nodes\n     *\n     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas\n     * @param {boolean} [alwaysShow]\n     * @private\n     * @returns {object} Callbacks to draw later on higher layers.\n     */\n  }, {\n    key: \"_drawNodes\",\n    value: function _drawNodes(ctx) {\n      var alwaysShow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var nodes = this.body.nodes;\n      var nodeIndices = this.body.nodeIndices;\n      var node;\n      var selected = [];\n      var hovered = [];\n      var margin = 20;\n      var topLeft = this.canvas.DOMtoCanvas({\n        x: -margin,\n        y: -margin\n      });\n      var bottomRight = this.canvas.DOMtoCanvas({\n        x: this.canvas.frame.canvas.clientWidth + margin,\n        y: this.canvas.frame.canvas.clientHeight + margin\n      });\n      var viewableArea = {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x\n      };\n      var _drawExternalLabels = [];\n\n      // draw unselected nodes;\n      for (var _i = 0; _i < nodeIndices.length; _i++) {\n        node = nodes[nodeIndices[_i]];\n        // set selected and hovered nodes aside\n        if (node.hover) {\n          hovered.push(nodeIndices[_i]);\n        } else if (node.isSelected()) {\n          selected.push(nodeIndices[_i]);\n        } else {\n          if (alwaysShow === true) {\n            var drawLater = node.draw(ctx);\n            if (drawLater.drawExternalLabel != null) {\n              _drawExternalLabels.push(drawLater.drawExternalLabel);\n            }\n          } else if (node.isBoundingBoxOverlappingWith(viewableArea) === true) {\n            var _drawLater = node.draw(ctx);\n            if (_drawLater.drawExternalLabel != null) {\n              _drawExternalLabels.push(_drawLater.drawExternalLabel);\n            }\n          } else {\n            node.updateBoundingBox(ctx, node.selected);\n          }\n        }\n      }\n      var i;\n      var selectedLength = selected.length;\n      var hoveredLength = hovered.length;\n\n      // draw the selected nodes on top\n      for (i = 0; i < selectedLength; i++) {\n        node = nodes[selected[i]];\n        var _drawLater2 = node.draw(ctx);\n        if (_drawLater2.drawExternalLabel != null) {\n          _drawExternalLabels.push(_drawLater2.drawExternalLabel);\n        }\n      }\n\n      // draw hovered nodes above everything else: fixes https://github.com/visjs/vis-network/issues/226\n      for (i = 0; i < hoveredLength; i++) {\n        node = nodes[hovered[i]];\n        var _drawLater3 = node.draw(ctx);\n        if (_drawLater3.drawExternalLabel != null) {\n          _drawExternalLabels.push(_drawLater3.drawExternalLabel);\n        }\n      }\n      return {\n        drawExternalLabels: function drawExternalLabels() {\n          for (var _i2 = 0, _drawExternalLabels2 = _drawExternalLabels; _i2 < _drawExternalLabels2.length; _i2++) {\n            var draw = _drawExternalLabels2[_i2];\n            draw();\n          }\n        }\n      };\n    }\n\n    /**\n     * Redraw all edges\n     *\n     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas\n     * @private\n     */\n  }, {\n    key: \"_drawEdges\",\n    value: function _drawEdges(ctx) {\n      var edges = this.body.edges;\n      var edgeIndices = this.body.edgeIndices;\n      for (var i = 0; i < edgeIndices.length; i++) {\n        var edge = edges[edgeIndices[i]];\n        if (edge.connected === true) {\n          edge.draw(ctx);\n        }\n      }\n    }\n\n    /**\n     * Redraw all arrows\n     *\n     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas\n     * @private\n     */\n  }, {\n    key: \"_drawArrows\",\n    value: function _drawArrows(ctx) {\n      var edges = this.body.edges;\n      var edgeIndices = this.body.edgeIndices;\n      for (var i = 0; i < edgeIndices.length; i++) {\n        var edge = edges[edgeIndices[i]];\n        if (edge.connected === true) {\n          edge.drawArrows(ctx);\n        }\n      }\n    }\n\n    /**\n     * Determine if the browser requires a setTimeout or a requestAnimationFrame. This was required because\n     * some implementations (safari and IE9) did not support requestAnimationFrame\n     *\n     * @private\n     */\n  }, {\n    key: \"_determineBrowserMethod\",\n    value: function _determineBrowserMethod() {\n      if (typeof window !== \"undefined\") {\n        var browserType = navigator.userAgent.toLowerCase();\n        this.requiresTimeout = false;\n        if (_indexOfInstanceProperty(browserType).call(browserType, \"msie 9.0\") != -1) {\n          // IE 9\n          this.requiresTimeout = true;\n        } else if (_indexOfInstanceProperty(browserType).call(browserType, \"safari\") != -1) {\n          // safari\n          if (_indexOfInstanceProperty(browserType).call(browserType, \"chrome\") <= -1) {\n            this.requiresTimeout = true;\n          }\n        }\n      } else {\n        this.requiresTimeout = true;\n      }\n    }\n\n    /**\n     * Redraw selection box\n     *\n     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas\n     * @private\n     */\n  }, {\n    key: \"_drawSelectionBox\",\n    value: function _drawSelectionBox(ctx) {\n      if (this.body.selectionBox.show) {\n        ctx.beginPath();\n        var width = this.body.selectionBox.position.end.x - this.body.selectionBox.position.start.x;\n        var height = this.body.selectionBox.position.end.y - this.body.selectionBox.position.start.y;\n        ctx.rect(this.body.selectionBox.position.start.x, this.body.selectionBox.position.start.y, width, height);\n        ctx.fillStyle = \"rgba(151, 194, 252, 0.2)\";\n        ctx.fillRect(this.body.selectionBox.position.start.x, this.body.selectionBox.position.start.y, width, height);\n        ctx.strokeStyle = \"rgba(151, 194, 252, 1)\";\n        ctx.stroke();\n      } else {\n        ctx.closePath();\n      }\n    }\n  }]);\n  return CanvasRenderer;\n}();\n\nvar path$2 = path$w;\n\nvar setInterval$1 = path$2.setInterval;\n\nvar setInterval = setInterval$1;\n\nvar _setInterval = /*@__PURE__*/getDefaultExportFromCjs(setInterval);\n\n/**\n * Register a touch event, taking place before a gesture\n *\n * @param {Hammer} hammer       A hammer instance\n * @param {Function} callback   Callback, called as callback(event)\n */\nfunction onTouch(hammer, callback) {\n  callback.inputHandler = function (event) {\n    if (event.isFirst) {\n      callback(event);\n    }\n  };\n  hammer.on(\"hammer.input\", callback.inputHandler);\n}\n\n/**\n * Register a release event, taking place after a gesture\n *\n * @param {Hammer} hammer       A hammer instance\n * @param {Function} callback   Callback, called as callback(event)\n * @returns {*}\n */\nfunction onRelease(hammer, callback) {\n  callback.inputHandler = function (event) {\n    if (event.isFinal) {\n      callback(event);\n    }\n  };\n  return hammer.on(\"hammer.input\", callback.inputHandler);\n}\n\n/**\n * Create the main frame for the Network.\n * This function is executed once when a Network object is created. The frame\n * contains a canvas, and this canvas contains all objects like the axis and\n * nodes.\n */\nvar Canvas = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   */\n  function Canvas(body) {\n    _classCallCheck(this, Canvas);\n    this.body = body;\n    this.pixelRatio = 1;\n    this.cameraState = {};\n    this.initialized = false;\n    this.canvasViewCenter = {};\n    this._cleanupCallbacks = [];\n    this.options = {};\n    this.defaultOptions = {\n      autoResize: true,\n      height: \"100%\",\n      width: \"100%\"\n    };\n    _Object$assign(this.options, this.defaultOptions);\n    this.bindEventListeners();\n  }\n\n  /**\n   * Binds event listeners\n   */\n  _createClass(Canvas, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _this = this,\n        _context;\n      // bind the events\n      this.body.emitter.once(\"resize\", function (obj) {\n        if (obj.width !== 0) {\n          _this.body.view.translation.x = obj.width * 0.5;\n        }\n        if (obj.height !== 0) {\n          _this.body.view.translation.y = obj.height * 0.5;\n        }\n      });\n      this.body.emitter.on(\"setSize\", _bindInstanceProperty$1(_context = this.setSize).call(_context, this));\n      this.body.emitter.on(\"destroy\", function () {\n        _this.hammerFrame.destroy();\n        _this.hammer.destroy();\n        _this._cleanUp();\n      });\n    }\n\n    /**\n     * @param {object} options\n     */\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      var _this2 = this;\n      if (options !== undefined) {\n        var fields = [\"width\", \"height\", \"autoResize\"];\n        selectiveDeepExtend(fields, this.options, options);\n      }\n\n      // Automatically adapt to changing size of the container element.\n      this._cleanUp();\n      if (this.options.autoResize === true) {\n        var _context2;\n        if (window.ResizeObserver) {\n          // decent browsers, immediate reactions\n          var observer = new ResizeObserver(function () {\n            var changed = _this2.setSize();\n            if (changed === true) {\n              _this2.body.emitter.emit(\"_requestRedraw\");\n            }\n          });\n          var frame = this.frame;\n          observer.observe(frame);\n          this._cleanupCallbacks.push(function () {\n            observer.unobserve(frame);\n          });\n        } else {\n          // IE11, continous polling\n          var resizeTimer = _setInterval(function () {\n            var changed = _this2.setSize();\n            if (changed === true) {\n              _this2.body.emitter.emit(\"_requestRedraw\");\n            }\n          }, 1000);\n          this._cleanupCallbacks.push(function () {\n            clearInterval(resizeTimer);\n          });\n        }\n\n        // Automatically adapt to changing size of the browser.\n        var resizeFunction = _bindInstanceProperty$1(_context2 = this._onResize).call(_context2, this);\n        window.addEventListener(\"resize\", resizeFunction);\n        this._cleanupCallbacks.push(function () {\n          window.removeEventListener(\"resize\", resizeFunction);\n        });\n      }\n    }\n\n    /**\n     * @private\n     */\n  }, {\n    key: \"_cleanUp\",\n    value: function _cleanUp() {\n      var _context3, _context4, _context5;\n      _forEachInstanceProperty(_context3 = _reverseInstanceProperty(_context4 = _spliceInstanceProperty(_context5 = this._cleanupCallbacks).call(_context5, 0)).call(_context4)).call(_context3, function (callback) {\n        try {\n          callback();\n        } catch (error) {\n          console.error(error);\n        }\n      });\n    }\n\n    /**\n     * @private\n     */\n  }, {\n    key: \"_onResize\",\n    value: function _onResize() {\n      this.setSize();\n      this.body.emitter.emit(\"_redraw\");\n    }\n\n    /**\n     * Get and store the cameraState\n     *\n     * @param {number} [pixelRatio=this.pixelRatio]\n     * @private\n     */\n  }, {\n    key: \"_getCameraState\",\n    value: function _getCameraState() {\n      var pixelRatio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.pixelRatio;\n      if (this.initialized === true) {\n        this.cameraState.previousWidth = this.frame.canvas.width / pixelRatio;\n        this.cameraState.previousHeight = this.frame.canvas.height / pixelRatio;\n        this.cameraState.scale = this.body.view.scale;\n        this.cameraState.position = this.DOMtoCanvas({\n          x: 0.5 * this.frame.canvas.width / pixelRatio,\n          y: 0.5 * this.frame.canvas.height / pixelRatio\n        });\n      }\n    }\n\n    /**\n     * Set the cameraState\n     *\n     * @private\n     */\n  }, {\n    key: \"_setCameraState\",\n    value: function _setCameraState() {\n      if (this.cameraState.scale !== undefined && this.frame.canvas.clientWidth !== 0 && this.frame.canvas.clientHeight !== 0 && this.pixelRatio !== 0 && this.cameraState.previousWidth > 0 && this.cameraState.previousHeight > 0) {\n        var widthRatio = this.frame.canvas.width / this.pixelRatio / this.cameraState.previousWidth;\n        var heightRatio = this.frame.canvas.height / this.pixelRatio / this.cameraState.previousHeight;\n        var newScale = this.cameraState.scale;\n        if (widthRatio != 1 && heightRatio != 1) {\n          newScale = this.cameraState.scale * 0.5 * (widthRatio + heightRatio);\n        } else if (widthRatio != 1) {\n          newScale = this.cameraState.scale * widthRatio;\n        } else if (heightRatio != 1) {\n          newScale = this.cameraState.scale * heightRatio;\n        }\n        this.body.view.scale = newScale;\n        // this comes from the view module.\n        var currentViewCenter = this.DOMtoCanvas({\n          x: 0.5 * this.frame.canvas.clientWidth,\n          y: 0.5 * this.frame.canvas.clientHeight\n        });\n        var distanceFromCenter = {\n          // offset from view, distance view has to change by these x and y to center the node\n          x: currentViewCenter.x - this.cameraState.position.x,\n          y: currentViewCenter.y - this.cameraState.position.y\n        };\n        this.body.view.translation.x += distanceFromCenter.x * this.body.view.scale;\n        this.body.view.translation.y += distanceFromCenter.y * this.body.view.scale;\n      }\n    }\n\n    /**\n     *\n     * @param {number|string} value\n     * @returns {string}\n     * @private\n     */\n  }, {\n    key: \"_prepareValue\",\n    value: function _prepareValue(value) {\n      if (typeof value === \"number\") {\n        return value + \"px\";\n      } else if (typeof value === \"string\") {\n        if (_indexOfInstanceProperty(value).call(value, \"%\") !== -1 || _indexOfInstanceProperty(value).call(value, \"px\") !== -1) {\n          return value;\n        } else if (_indexOfInstanceProperty(value).call(value, \"%\") === -1) {\n          return value + \"px\";\n        }\n      }\n      throw new Error(\"Could not use the value supplied for width or height:\" + value);\n    }\n\n    /**\n     * Create the HTML\n     */\n  }, {\n    key: \"_create\",\n    value: function _create() {\n      // remove all elements from the container element.\n      while (this.body.container.hasChildNodes()) {\n        this.body.container.removeChild(this.body.container.firstChild);\n      }\n      this.frame = document.createElement(\"div\");\n      this.frame.className = \"vis-network\";\n      this.frame.style.position = \"relative\";\n      this.frame.style.overflow = \"hidden\";\n      this.frame.tabIndex = 0; // tab index is required for keycharm to bind keystrokes to the div instead of the window\n\n      //////////////////////////////////////////////////////////////////\n\n      this.frame.canvas = document.createElement(\"canvas\");\n      this.frame.canvas.style.position = \"relative\";\n      this.frame.appendChild(this.frame.canvas);\n      if (!this.frame.canvas.getContext) {\n        var noCanvas = document.createElement(\"DIV\");\n        noCanvas.style.color = \"red\";\n        noCanvas.style.fontWeight = \"bold\";\n        noCanvas.style.padding = \"10px\";\n        noCanvas.innerText = \"Error: your browser does not support HTML canvas\";\n        this.frame.canvas.appendChild(noCanvas);\n      } else {\n        this._setPixelRatio();\n        this.setTransform();\n      }\n\n      // add the frame to the container element\n      this.body.container.appendChild(this.frame);\n      this.body.view.scale = 1;\n      this.body.view.translation = {\n        x: 0.5 * this.frame.canvas.clientWidth,\n        y: 0.5 * this.frame.canvas.clientHeight\n      };\n      this._bindHammer();\n    }\n\n    /**\n     * This function binds hammer, it can be repeated over and over due to the uniqueness check.\n     *\n     * @private\n     */\n  }, {\n    key: \"_bindHammer\",\n    value: function _bindHammer() {\n      var _this3 = this;\n      if (this.hammer !== undefined) {\n        this.hammer.destroy();\n      }\n      this.drag = {};\n      this.pinch = {};\n\n      // init hammer\n      this.hammer = new Hammer(this.frame.canvas);\n      this.hammer.get(\"pinch\").set({\n        enable: true\n      });\n      // enable to get better response, todo: test on mobile.\n      this.hammer.get(\"pan\").set({\n        threshold: 5,\n        direction: Hammer.DIRECTION_ALL\n      });\n      onTouch(this.hammer, function (event) {\n        _this3.body.eventListeners.onTouch(event);\n      });\n      this.hammer.on(\"tap\", function (event) {\n        _this3.body.eventListeners.onTap(event);\n      });\n      this.hammer.on(\"doubletap\", function (event) {\n        _this3.body.eventListeners.onDoubleTap(event);\n      });\n      this.hammer.on(\"press\", function (event) {\n        _this3.body.eventListeners.onHold(event);\n      });\n      this.hammer.on(\"panstart\", function (event) {\n        _this3.body.eventListeners.onDragStart(event);\n      });\n      this.hammer.on(\"panmove\", function (event) {\n        _this3.body.eventListeners.onDrag(event);\n      });\n      this.hammer.on(\"panend\", function (event) {\n        _this3.body.eventListeners.onDragEnd(event);\n      });\n      this.hammer.on(\"pinch\", function (event) {\n        _this3.body.eventListeners.onPinch(event);\n      });\n\n      // TODO: neatly cleanup these handlers when re-creating the Canvas, IF these are done with hammer, event.stopPropagation will not work?\n      this.frame.canvas.addEventListener(\"wheel\", function (event) {\n        _this3.body.eventListeners.onMouseWheel(event);\n      });\n      this.frame.canvas.addEventListener(\"mousemove\", function (event) {\n        _this3.body.eventListeners.onMouseMove(event);\n      });\n      this.frame.canvas.addEventListener(\"contextmenu\", function (event) {\n        _this3.body.eventListeners.onContext(event);\n      });\n      this.hammerFrame = new Hammer(this.frame);\n      onRelease(this.hammerFrame, function (event) {\n        _this3.body.eventListeners.onRelease(event);\n      });\n    }\n\n    /**\n     * Set a new size for the network\n     *\n     * @param {string} width   Width in pixels or percentage (for example '800px'\n     *                         or '50%')\n     * @param {string} height  Height in pixels or percentage  (for example '400px'\n     *                         or '30%')\n     * @returns {boolean}\n     */\n  }, {\n    key: \"setSize\",\n    value: function setSize() {\n      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.width;\n      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.height;\n      width = this._prepareValue(width);\n      height = this._prepareValue(height);\n      var emitEvent = false;\n      var oldWidth = this.frame.canvas.width;\n      var oldHeight = this.frame.canvas.height;\n\n      // update the pixel ratio\n      //\n      // NOTE: Comment in following is rather inconsistent; this is the ONLY place in the code\n      //       where it is assumed that the pixel ratio could change at runtime.\n      //       The only way I can think of this happening is a rotating screen or tablet; but then\n      //       there should be a mechanism for reloading the data (TODO: check if this is present).\n      //\n      //       If the assumption is true (i.e. pixel ratio can change at runtime), then *all* usage\n      //       of pixel ratio must be overhauled for this.\n      //\n      //       For the time being, I will humor the assumption here, and in the rest of the code assume it is\n      //       constant.\n      var previousRatio = this.pixelRatio; // we cache this because the camera state storage needs the old value\n      this._setPixelRatio();\n      if (width != this.options.width || height != this.options.height || this.frame.style.width != width || this.frame.style.height != height) {\n        this._getCameraState(previousRatio);\n        this.frame.style.width = width;\n        this.frame.style.height = height;\n        this.frame.canvas.style.width = \"100%\";\n        this.frame.canvas.style.height = \"100%\";\n        this.frame.canvas.width = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);\n        this.frame.canvas.height = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);\n        this.options.width = width;\n        this.options.height = height;\n        this.canvasViewCenter = {\n          x: 0.5 * this.frame.clientWidth,\n          y: 0.5 * this.frame.clientHeight\n        };\n        emitEvent = true;\n      } else {\n        // this would adapt the width of the canvas to the width from 100% if and only if\n        // there is a change.\n\n        var newWidth = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);\n        var newHeight = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);\n\n        // store the camera if there is a change in size.\n        if (this.frame.canvas.width !== newWidth || this.frame.canvas.height !== newHeight) {\n          this._getCameraState(previousRatio);\n        }\n        if (this.frame.canvas.width !== newWidth) {\n          this.frame.canvas.width = newWidth;\n          emitEvent = true;\n        }\n        if (this.frame.canvas.height !== newHeight) {\n          this.frame.canvas.height = newHeight;\n          emitEvent = true;\n        }\n      }\n      if (emitEvent === true) {\n        this.body.emitter.emit(\"resize\", {\n          width: Math.round(this.frame.canvas.width / this.pixelRatio),\n          height: Math.round(this.frame.canvas.height / this.pixelRatio),\n          oldWidth: Math.round(oldWidth / this.pixelRatio),\n          oldHeight: Math.round(oldHeight / this.pixelRatio)\n        });\n\n        // restore the camera on change.\n        this._setCameraState();\n      }\n\n      // set initialized so the get and set camera will work from now on.\n      this.initialized = true;\n      return emitEvent;\n    }\n\n    /**\n     *\n     * @returns {CanvasRenderingContext2D}\n     */\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.frame.canvas.getContext(\"2d\");\n    }\n\n    /**\n     * Determine the pixel ratio for various browsers.\n     *\n     * @returns {number}\n     * @private\n     */\n  }, {\n    key: \"_determinePixelRatio\",\n    value: function _determinePixelRatio() {\n      var ctx = this.getContext();\n      if (ctx === undefined) {\n        throw new Error(\"Could not get canvax context\");\n      }\n      var numerator = 1;\n      if (typeof window !== \"undefined\") {\n        // (window !== undefined) doesn't work here!\n        // Protection during unit tests, where 'window' can be missing\n        numerator = window.devicePixelRatio || 1;\n      }\n      var denominator = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;\n      return numerator / denominator;\n    }\n\n    /**\n     * Lazy determination of pixel ratio.\n     *\n     * @private\n     */\n  }, {\n    key: \"_setPixelRatio\",\n    value: function _setPixelRatio() {\n      this.pixelRatio = this._determinePixelRatio();\n    }\n\n    /**\n     * Set the transform in the contained context, based on its pixelRatio\n     */\n  }, {\n    key: \"setTransform\",\n    value: function setTransform() {\n      var ctx = this.getContext();\n      if (ctx === undefined) {\n        throw new Error(\"Could not get canvax context\");\n      }\n      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n    }\n\n    /**\n     * Convert the X coordinate in DOM-space (coordinate point in browser relative to the container div) to\n     * the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon)\n     *\n     * @param {number} x\n     * @returns {number}\n     * @private\n     */\n  }, {\n    key: \"_XconvertDOMtoCanvas\",\n    value: function _XconvertDOMtoCanvas(x) {\n      return (x - this.body.view.translation.x) / this.body.view.scale;\n    }\n\n    /**\n     * Convert the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to\n     * the X coordinate in DOM-space (coordinate point in browser relative to the container div)\n     *\n     * @param {number} x\n     * @returns {number}\n     * @private\n     */\n  }, {\n    key: \"_XconvertCanvasToDOM\",\n    value: function _XconvertCanvasToDOM(x) {\n      return x * this.body.view.scale + this.body.view.translation.x;\n    }\n\n    /**\n     * Convert the Y coordinate in DOM-space (coordinate point in browser relative to the container div) to\n     * the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon)\n     *\n     * @param {number} y\n     * @returns {number}\n     * @private\n     */\n  }, {\n    key: \"_YconvertDOMtoCanvas\",\n    value: function _YconvertDOMtoCanvas(y) {\n      return (y - this.body.view.translation.y) / this.body.view.scale;\n    }\n\n    /**\n     * Convert the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to\n     * the Y coordinate in DOM-space (coordinate point in browser relative to the container div)\n     *\n     * @param {number} y\n     * @returns {number}\n     * @private\n     */\n  }, {\n    key: \"_YconvertCanvasToDOM\",\n    value: function _YconvertCanvasToDOM(y) {\n      return y * this.body.view.scale + this.body.view.translation.y;\n    }\n\n    /**\n     * @param {point} pos\n     * @returns {point}\n     */\n  }, {\n    key: \"canvasToDOM\",\n    value: function canvasToDOM(pos) {\n      return {\n        x: this._XconvertCanvasToDOM(pos.x),\n        y: this._YconvertCanvasToDOM(pos.y)\n      };\n    }\n\n    /**\n     *\n     * @param {point} pos\n     * @returns {point}\n     */\n  }, {\n    key: \"DOMtoCanvas\",\n    value: function DOMtoCanvas(pos) {\n      return {\n        x: this._XconvertDOMtoCanvas(pos.x),\n        y: this._YconvertDOMtoCanvas(pos.y)\n      };\n    }\n  }]);\n  return Canvas;\n}();\n\n/**\r\n * Validate the fit options, replace missing optional values by defaults etc.\r\n *\r\n * @param rawOptions - The raw options.\r\n * @param allNodeIds - All node ids that will be used if nodes are omitted in\r\n * the raw options.\r\n * @returns Options with everything filled in and validated.\r\n */\nfunction normalizeFitOptions(rawOptions, allNodeIds) {\n  var options = _Object$assign({\n    nodes: allNodeIds,\n    minZoomLevel: Number.MIN_VALUE,\n    maxZoomLevel: 1\n  }, rawOptions !== null && rawOptions !== void 0 ? rawOptions : {});\n  if (!_Array$isArray(options.nodes)) {\n    throw new TypeError(\"Nodes has to be an array of ids.\");\n  }\n  if (options.nodes.length === 0) {\n    options.nodes = allNodeIds;\n  }\n  if (!(typeof options.minZoomLevel === \"number\" && options.minZoomLevel > 0)) {\n    throw new TypeError(\"Min zoom level has to be a number higher than zero.\");\n  }\n  if (!(typeof options.maxZoomLevel === \"number\" && options.minZoomLevel <= options.maxZoomLevel)) {\n    throw new TypeError(\"Max zoom level has to be a number higher than min zoom level.\");\n  }\n  return options;\n}\n\n/**\n * The view\n */\nvar View = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {Canvas} canvas\n   */\n  function View(body, canvas) {\n    var _context,\n      _this = this,\n      _context2;\n    _classCallCheck(this, View);\n    this.body = body;\n    this.canvas = canvas;\n    this.animationSpeed = 1 / this.renderRefreshRate;\n    this.animationEasingFunction = \"easeInOutQuint\";\n    this.easingTime = 0;\n    this.sourceScale = 0;\n    this.targetScale = 0;\n    this.sourceTranslation = 0;\n    this.targetTranslation = 0;\n    this.lockedOnNodeId = undefined;\n    this.lockedOnNodeOffset = undefined;\n    this.touchTime = 0;\n    this.viewFunction = undefined;\n    this.body.emitter.on(\"fit\", _bindInstanceProperty$1(_context = this.fit).call(_context, this));\n    this.body.emitter.on(\"animationFinished\", function () {\n      _this.body.emitter.emit(\"_stopRendering\");\n    });\n    this.body.emitter.on(\"unlockNode\", _bindInstanceProperty$1(_context2 = this.releaseNode).call(_context2, this));\n  }\n\n  /**\n   *\n   * @param {object} [options={}]\n   */\n  _createClass(View, [{\n    key: \"setOptions\",\n    value: function setOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.options = options;\n    }\n\n    /**\n     * This function zooms out to fit all data on screen based on amount of nodes\n     *\n     * @param {object} [options={{nodes=Array}}]\n     * @param options\n     * @param {boolean} [initialZoom=false]  | zoom based on fitted formula or range, true = fitted, default = false;\n     */\n  }, {\n    key: \"fit\",\n    value: function fit(options) {\n      var initialZoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      options = normalizeFitOptions(options, this.body.nodeIndices);\n      var canvasWidth = this.canvas.frame.canvas.clientWidth;\n      var canvasHeight = this.canvas.frame.canvas.clientHeight;\n      var range;\n      var zoomLevel;\n      if (canvasWidth === 0 || canvasHeight === 0) {\n        // There's no point in trying to fit into zero sized canvas. This could\n        // potentially even result in invalid values being computed. For example\n        // for network without nodes and zero sized canvas the zoom level would\n        // end up being computed as 0/0 which results in NaN. In any other case\n        // this would be 0/something which is again pointless to compute.\n        zoomLevel = 1;\n        range = NetworkUtil.getRange(this.body.nodes, options.nodes);\n      } else if (initialZoom === true) {\n        // check if more than half of the nodes have a predefined position. If so, we use the range, not the approximation.\n        var positionDefined = 0;\n        for (var nodeId in this.body.nodes) {\n          if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {\n            var node = this.body.nodes[nodeId];\n            if (node.predefinedPosition === true) {\n              positionDefined += 1;\n            }\n          }\n        }\n        if (positionDefined > 0.5 * this.body.nodeIndices.length) {\n          this.fit(options, false);\n          return;\n        }\n        range = NetworkUtil.getRange(this.body.nodes, options.nodes);\n        var numberOfNodes = this.body.nodeIndices.length;\n        zoomLevel = 12.662 / (numberOfNodes + 7.4147) + 0.0964822; // this is obtained from fitting a dataset from 5 points with scale levels that looked good.\n\n        // correct for larger canvasses.\n        var factor = Math.min(canvasWidth / 600, canvasHeight / 600);\n        zoomLevel *= factor;\n      } else {\n        this.body.emitter.emit(\"_resizeNodes\");\n        range = NetworkUtil.getRange(this.body.nodes, options.nodes);\n        var xDistance = Math.abs(range.maxX - range.minX) * 1.1;\n        var yDistance = Math.abs(range.maxY - range.minY) * 1.1;\n        var xZoomLevel = canvasWidth / xDistance;\n        var yZoomLevel = canvasHeight / yDistance;\n        zoomLevel = xZoomLevel <= yZoomLevel ? xZoomLevel : yZoomLevel;\n      }\n      if (zoomLevel > options.maxZoomLevel) {\n        zoomLevel = options.maxZoomLevel;\n      } else if (zoomLevel < options.minZoomLevel) {\n        zoomLevel = options.minZoomLevel;\n      }\n      var center = NetworkUtil.findCenter(range);\n      var animationOptions = {\n        position: center,\n        scale: zoomLevel,\n        animation: options.animation\n      };\n      this.moveTo(animationOptions);\n    }\n\n    // animation\n\n    /**\n     * Center a node in view.\n     *\n     * @param {number} nodeId\n     * @param {number} [options]\n     */\n  }, {\n    key: \"focus\",\n    value: function focus(nodeId) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (this.body.nodes[nodeId] !== undefined) {\n        var nodePosition = {\n          x: this.body.nodes[nodeId].x,\n          y: this.body.nodes[nodeId].y\n        };\n        options.position = nodePosition;\n        options.lockedOnNode = nodeId;\n        this.moveTo(options);\n      } else {\n        console.error(\"Node: \" + nodeId + \" cannot be found.\");\n      }\n    }\n\n    /**\n     *\n     * @param {object} options  |  options.offset   = {x:number, y:number}   // offset from the center in DOM pixels\n     *                          |  options.scale    = number                 // scale to move to\n     *                          |  options.position = {x:number, y:number}   // position to move to\n     *                          |  options.animation = {duration:number, easingFunction:String} || Boolean   // position to move to\n     */\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(options) {\n      if (options === undefined) {\n        options = {};\n        return;\n      }\n      if (options.offset != null) {\n        if (options.offset.x != null) {\n          // Coerce and verify that x is valid.\n          options.offset.x = +options.offset.x;\n          if (!_Number$isFinite(options.offset.x)) {\n            throw new TypeError('The option \"offset.x\" has to be a finite number.');\n          }\n        } else {\n          options.offset.x = 0;\n        }\n        if (options.offset.y != null) {\n          // Coerce and verify that y is valid.\n          options.offset.y = +options.offset.y;\n          if (!_Number$isFinite(options.offset.y)) {\n            throw new TypeError('The option \"offset.y\" has to be a finite number.');\n          }\n        } else {\n          options.offset.x = 0;\n        }\n      } else {\n        options.offset = {\n          x: 0,\n          y: 0\n        };\n      }\n      if (options.position != null) {\n        if (options.position.x != null) {\n          // Coerce and verify that x is valid.\n          options.position.x = +options.position.x;\n          if (!_Number$isFinite(options.position.x)) {\n            throw new TypeError('The option \"position.x\" has to be a finite number.');\n          }\n        } else {\n          options.position.x = 0;\n        }\n        if (options.position.y != null) {\n          // Coerce and verify that y is valid.\n          options.position.y = +options.position.y;\n          if (!_Number$isFinite(options.position.y)) {\n            throw new TypeError('The option \"position.y\" has to be a finite number.');\n          }\n        } else {\n          options.position.x = 0;\n        }\n      } else {\n        options.position = this.getViewPosition();\n      }\n      if (options.scale != null) {\n        // Coerce and verify that the scale is valid.\n        options.scale = +options.scale;\n        if (!(options.scale > 0)) {\n          throw new TypeError('The option \"scale\" has to be a number greater than zero.');\n        }\n      } else {\n        options.scale = this.body.view.scale;\n      }\n      if (options.animation === undefined) {\n        options.animation = {\n          duration: 0\n        };\n      }\n      if (options.animation === false) {\n        options.animation = {\n          duration: 0\n        };\n      }\n      if (options.animation === true) {\n        options.animation = {};\n      }\n      if (options.animation.duration === undefined) {\n        options.animation.duration = 1000;\n      } // default duration\n      if (options.animation.easingFunction === undefined) {\n        options.animation.easingFunction = \"easeInOutQuad\";\n      } // default easing function\n\n      this.animateView(options);\n    }\n\n    /**\n     *\n     * @param {object} options  |  options.offset   = {x:number, y:number}   // offset from the center in DOM pixels\n     *                          |  options.time     = number                 // animation time in milliseconds\n     *                          |  options.scale    = number                 // scale to animate to\n     *                          |  options.position = {x:number, y:number}   // position to animate to\n     *                          |  options.easingFunction = String           // linear, easeInQuad, easeOutQuad, easeInOutQuad,\n     *                                                                       // easeInCubic, easeOutCubic, easeInOutCubic,\n     *                                                                       // easeInQuart, easeOutQuart, easeInOutQuart,\n     *                                                                       // easeInQuint, easeOutQuint, easeInOutQuint\n     */\n  }, {\n    key: \"animateView\",\n    value: function animateView(options) {\n      if (options === undefined) {\n        return;\n      }\n      this.animationEasingFunction = options.animation.easingFunction;\n      // release if something focussed on the node\n      this.releaseNode();\n      if (options.locked === true) {\n        this.lockedOnNodeId = options.lockedOnNode;\n        this.lockedOnNodeOffset = options.offset;\n      }\n\n      // forcefully complete the old animation if it was still running\n      if (this.easingTime != 0) {\n        this._transitionRedraw(true); // by setting easingtime to 1, we finish the animation.\n      }\n\n      this.sourceScale = this.body.view.scale;\n      this.sourceTranslation = this.body.view.translation;\n      this.targetScale = options.scale;\n\n      // set the scale so the viewCenter is based on the correct zoom level. This is overridden in the transitionRedraw\n      // but at least then we'll have the target transition\n      this.body.view.scale = this.targetScale;\n      var viewCenter = this.canvas.DOMtoCanvas({\n        x: 0.5 * this.canvas.frame.canvas.clientWidth,\n        y: 0.5 * this.canvas.frame.canvas.clientHeight\n      });\n      var distanceFromCenter = {\n        // offset from view, distance view has to change by these x and y to center the node\n        x: viewCenter.x - options.position.x,\n        y: viewCenter.y - options.position.y\n      };\n      this.targetTranslation = {\n        x: this.sourceTranslation.x + distanceFromCenter.x * this.targetScale + options.offset.x,\n        y: this.sourceTranslation.y + distanceFromCenter.y * this.targetScale + options.offset.y\n      };\n\n      // if the time is set to 0, don't do an animation\n      if (options.animation.duration === 0) {\n        if (this.lockedOnNodeId != undefined) {\n          var _context3;\n          this.viewFunction = _bindInstanceProperty$1(_context3 = this._lockedRedraw).call(_context3, this);\n          this.body.emitter.on(\"initRedraw\", this.viewFunction);\n        } else {\n          this.body.view.scale = this.targetScale;\n          this.body.view.translation = this.targetTranslation;\n          this.body.emitter.emit(\"_requestRedraw\");\n        }\n      } else {\n        var _context4;\n        this.animationSpeed = 1 / (60 * options.animation.duration * 0.001) || 1 / 60; // 60 for 60 seconds, 0.001 for milli's\n        this.animationEasingFunction = options.animation.easingFunction;\n        this.viewFunction = _bindInstanceProperty$1(_context4 = this._transitionRedraw).call(_context4, this);\n        this.body.emitter.on(\"initRedraw\", this.viewFunction);\n        this.body.emitter.emit(\"_startRendering\");\n      }\n    }\n\n    /**\n     * used to animate smoothly by hijacking the redraw function.\n     *\n     * @private\n     */\n  }, {\n    key: \"_lockedRedraw\",\n    value: function _lockedRedraw() {\n      var nodePosition = {\n        x: this.body.nodes[this.lockedOnNodeId].x,\n        y: this.body.nodes[this.lockedOnNodeId].y\n      };\n      var viewCenter = this.canvas.DOMtoCanvas({\n        x: 0.5 * this.canvas.frame.canvas.clientWidth,\n        y: 0.5 * this.canvas.frame.canvas.clientHeight\n      });\n      var distanceFromCenter = {\n        // offset from view, distance view has to change by these x and y to center the node\n        x: viewCenter.x - nodePosition.x,\n        y: viewCenter.y - nodePosition.y\n      };\n      var sourceTranslation = this.body.view.translation;\n      var targetTranslation = {\n        x: sourceTranslation.x + distanceFromCenter.x * this.body.view.scale + this.lockedOnNodeOffset.x,\n        y: sourceTranslation.y + distanceFromCenter.y * this.body.view.scale + this.lockedOnNodeOffset.y\n      };\n      this.body.view.translation = targetTranslation;\n    }\n\n    /**\n     * Resets state of a locked on Node\n     */\n  }, {\n    key: \"releaseNode\",\n    value: function releaseNode() {\n      if (this.lockedOnNodeId !== undefined && this.viewFunction !== undefined) {\n        this.body.emitter.off(\"initRedraw\", this.viewFunction);\n        this.lockedOnNodeId = undefined;\n        this.lockedOnNodeOffset = undefined;\n      }\n    }\n\n    /**\n     * @param {boolean} [finished=false]\n     * @private\n     */\n  }, {\n    key: \"_transitionRedraw\",\n    value: function _transitionRedraw() {\n      var finished = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this.easingTime += this.animationSpeed;\n      this.easingTime = finished === true ? 1.0 : this.easingTime;\n      var progress = easingFunctions[this.animationEasingFunction](this.easingTime);\n      this.body.view.scale = this.sourceScale + (this.targetScale - this.sourceScale) * progress;\n      this.body.view.translation = {\n        x: this.sourceTranslation.x + (this.targetTranslation.x - this.sourceTranslation.x) * progress,\n        y: this.sourceTranslation.y + (this.targetTranslation.y - this.sourceTranslation.y) * progress\n      };\n\n      // cleanup\n      if (this.easingTime >= 1.0) {\n        this.body.emitter.off(\"initRedraw\", this.viewFunction);\n        this.easingTime = 0;\n        if (this.lockedOnNodeId != undefined) {\n          var _context5;\n          this.viewFunction = _bindInstanceProperty$1(_context5 = this._lockedRedraw).call(_context5, this);\n          this.body.emitter.on(\"initRedraw\", this.viewFunction);\n        }\n        this.body.emitter.emit(\"animationFinished\");\n      }\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getScale\",\n    value: function getScale() {\n      return this.body.view.scale;\n    }\n\n    /**\n     *\n     * @returns {{x: number, y: number}}\n     */\n  }, {\n    key: \"getViewPosition\",\n    value: function getViewPosition() {\n      return this.canvas.DOMtoCanvas({\n        x: 0.5 * this.canvas.frame.canvas.clientWidth,\n        y: 0.5 * this.canvas.frame.canvas.clientHeight\n      });\n    }\n  }]);\n  return View;\n}();\n\n/**\r\n * Created by Alex on 11/6/2014.\r\n */\r\nfunction keycharm(options) {\r\n  var preventDefault = options && options.preventDefault || false;\r\n\r\n  var container = options && options.container || window;\r\n\r\n  var _exportFunctions = {};\r\n  var _bound = {keydown:{}, keyup:{}};\r\n  var _keys = {};\r\n  var i;\r\n\r\n  // a - z\r\n  for (i = 97; i <= 122; i++) {_keys[String.fromCharCode(i)] = {code:65 + (i - 97), shift: false};}\r\n  // A - Z\r\n  for (i = 65; i <= 90; i++) {_keys[String.fromCharCode(i)] = {code:i, shift: true};}\r\n  // 0 - 9\r\n  for (i = 0;  i <= 9;   i++) {_keys['' + i] = {code:48 + i, shift: false};}\r\n  // F1 - F12\r\n  for (i = 1;  i <= 12;   i++) {_keys['F' + i] = {code:111 + i, shift: false};}\r\n  // num0 - num9\r\n  for (i = 0;  i <= 9;   i++) {_keys['num' + i] = {code:96 + i, shift: false};}\r\n\r\n  // numpad misc\r\n  _keys['num*'] = {code:106, shift: false};\r\n  _keys['num+'] = {code:107, shift: false};\r\n  _keys['num-'] = {code:109, shift: false};\r\n  _keys['num/'] = {code:111, shift: false};\r\n  _keys['num.'] = {code:110, shift: false};\r\n  // arrows\r\n  _keys['left']  = {code:37, shift: false};\r\n  _keys['up']    = {code:38, shift: false};\r\n  _keys['right'] = {code:39, shift: false};\r\n  _keys['down']  = {code:40, shift: false};\r\n  // extra keys\r\n  _keys['space'] = {code:32, shift: false};\r\n  _keys['enter'] = {code:13, shift: false};\r\n  _keys['shift'] = {code:16, shift: undefined};\r\n  _keys['esc']   = {code:27, shift: false};\r\n  _keys['backspace'] = {code:8, shift: false};\r\n  _keys['tab']       = {code:9, shift: false};\r\n  _keys['ctrl']      = {code:17, shift: false};\r\n  _keys['alt']       = {code:18, shift: false};\r\n  _keys['delete']    = {code:46, shift: false};\r\n  _keys['pageup']    = {code:33, shift: false};\r\n  _keys['pagedown']  = {code:34, shift: false};\r\n  // symbols\r\n  _keys['=']     = {code:187, shift: false};\r\n  _keys['-']     = {code:189, shift: false};\r\n  _keys[']']     = {code:221, shift: false};\r\n  _keys['[']     = {code:219, shift: false};\r\n\r\n\r\n\r\n  var down = function(event) {handleEvent(event,'keydown');};\r\n  var up = function(event) {handleEvent(event,'keyup');};\r\n\r\n  // handle the actualy bound key with the event\r\n  var handleEvent = function(event,type) {\r\n    if (_bound[type][event.keyCode] !== undefined) {\r\n      var bound = _bound[type][event.keyCode];\r\n      for (var i = 0; i < bound.length; i++) {\r\n        if (bound[i].shift === undefined) {\r\n          bound[i].fn(event);\r\n        }\r\n        else if (bound[i].shift == true && event.shiftKey == true) {\r\n          bound[i].fn(event);\r\n        }\r\n        else if (bound[i].shift == false && event.shiftKey == false) {\r\n          bound[i].fn(event);\r\n        }\r\n      }\r\n\r\n      if (preventDefault == true) {\r\n        event.preventDefault();\r\n      }\r\n    }\r\n  };\r\n\r\n  // bind a key to a callback\r\n  _exportFunctions.bind = function(key, callback, type) {\r\n    if (type === undefined) {\r\n      type = 'keydown';\r\n    }\r\n    if (_keys[key] === undefined) {\r\n      throw new Error(\"unsupported key: \" + key);\r\n    }\r\n    if (_bound[type][_keys[key].code] === undefined) {\r\n      _bound[type][_keys[key].code] = [];\r\n    }\r\n    _bound[type][_keys[key].code].push({fn:callback, shift:_keys[key].shift});\r\n  };\r\n\r\n\r\n  // bind all keys to a call back (demo purposes)\r\n  _exportFunctions.bindAll = function(callback, type) {\r\n    if (type === undefined) {\r\n      type = 'keydown';\r\n    }\r\n    for (var key in _keys) {\r\n      if (_keys.hasOwnProperty(key)) {\r\n        _exportFunctions.bind(key,callback,type);\r\n      }\r\n    }\r\n  };\r\n\r\n  // get the key label from an event\r\n  _exportFunctions.getKey = function(event) {\r\n    for (var key in _keys) {\r\n      if (_keys.hasOwnProperty(key)) {\r\n        if (event.shiftKey == true && _keys[key].shift == true && event.keyCode == _keys[key].code) {\r\n          return key;\r\n        }\r\n        else if (event.shiftKey == false && _keys[key].shift == false && event.keyCode == _keys[key].code) {\r\n          return key;\r\n        }\r\n        else if (event.keyCode == _keys[key].code && key == 'shift') {\r\n          return key;\r\n        }\r\n      }\r\n    }\r\n    return \"unknown key, currently not supported\";\r\n  };\r\n\r\n  // unbind either a specific callback from a key or all of them (by leaving callback undefined)\r\n  _exportFunctions.unbind = function(key, callback, type) {\r\n    if (type === undefined) {\r\n      type = 'keydown';\r\n    }\r\n    if (_keys[key] === undefined) {\r\n      throw new Error(\"unsupported key: \" + key);\r\n    }\r\n    if (callback !== undefined) {\r\n      var newBindings = [];\r\n      var bound = _bound[type][_keys[key].code];\r\n      if (bound !== undefined) {\r\n        for (var i = 0; i < bound.length; i++) {\r\n          if (!(bound[i].fn == callback && bound[i].shift == _keys[key].shift)) {\r\n            newBindings.push(_bound[type][_keys[key].code][i]);\r\n          }\r\n        }\r\n      }\r\n      _bound[type][_keys[key].code] = newBindings;\r\n    }\r\n    else {\r\n      _bound[type][_keys[key].code] = [];\r\n    }\r\n  };\r\n\r\n  // reset all bound variables.\r\n  _exportFunctions.reset = function() {\r\n    _bound = {keydown:{}, keyup:{}};\r\n  };\r\n\r\n  // unbind all listeners and reset all variables.\r\n  _exportFunctions.destroy = function() {\r\n    _bound = {keydown:{}, keyup:{}};\r\n    container.removeEventListener('keydown', down, true);\r\n    container.removeEventListener('keyup', up, true);\r\n  };\r\n\r\n  // create listeners.\r\n  container.addEventListener('keydown',down,true);\r\n  container.addEventListener('keyup',up,true);\r\n\r\n  // return the public functions.\r\n  return _exportFunctions;\r\n}\n\n/**\n * Navigation Handler\n */\nvar NavigationHandler = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {Canvas} canvas\n   */\n  function NavigationHandler(body, canvas) {\n    var _this = this;\n    _classCallCheck(this, NavigationHandler);\n    this.body = body;\n    this.canvas = canvas;\n    this.iconsCreated = false;\n    this.navigationHammers = [];\n    this.boundFunctions = {};\n    this.touchTime = 0;\n    this.activated = false;\n    this.body.emitter.on(\"activate\", function () {\n      _this.activated = true;\n      _this.configureKeyboardBindings();\n    });\n    this.body.emitter.on(\"deactivate\", function () {\n      _this.activated = false;\n      _this.configureKeyboardBindings();\n    });\n    this.body.emitter.on(\"destroy\", function () {\n      if (_this.keycharm !== undefined) {\n        _this.keycharm.destroy();\n      }\n    });\n    this.options = {};\n  }\n\n  /**\n   *\n   * @param {object} options\n   */\n  _createClass(NavigationHandler, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        this.options = options;\n        this.create();\n      }\n    }\n\n    /**\n     * Creates or refreshes navigation and sets key bindings\n     */\n  }, {\n    key: \"create\",\n    value: function create() {\n      if (this.options.navigationButtons === true) {\n        if (this.iconsCreated === false) {\n          this.loadNavigationElements();\n        }\n      } else if (this.iconsCreated === true) {\n        this.cleanNavigation();\n      }\n      this.configureKeyboardBindings();\n    }\n\n    /**\n     * Cleans up previous navigation items\n     */\n  }, {\n    key: \"cleanNavigation\",\n    value: function cleanNavigation() {\n      // clean hammer bindings\n      if (this.navigationHammers.length != 0) {\n        for (var i = 0; i < this.navigationHammers.length; i++) {\n          this.navigationHammers[i].destroy();\n        }\n        this.navigationHammers = [];\n      }\n\n      // clean up previous navigation items\n      if (this.navigationDOM && this.navigationDOM[\"wrapper\"] && this.navigationDOM[\"wrapper\"].parentNode) {\n        this.navigationDOM[\"wrapper\"].parentNode.removeChild(this.navigationDOM[\"wrapper\"]);\n      }\n      this.iconsCreated = false;\n    }\n\n    /**\n     * Creation of the navigation controls nodes. They are drawn over the rest of the nodes and are not affected by scale and translation\n     * they have a triggerFunction which is called on click. If the position of the navigation controls is dependent\n     * on this.frame.canvas.clientWidth or this.frame.canvas.clientHeight, we flag horizontalAlignLeft and verticalAlignTop false.\n     * This means that the location will be corrected by the _relocateNavigation function on a size change of the canvas.\n     *\n     * @private\n     */\n  }, {\n    key: \"loadNavigationElements\",\n    value: function loadNavigationElements() {\n      var _this2 = this;\n      this.cleanNavigation();\n      this.navigationDOM = {};\n      var navigationDivs = [\"up\", \"down\", \"left\", \"right\", \"zoomIn\", \"zoomOut\", \"zoomExtends\"];\n      var navigationDivActions = [\"_moveUp\", \"_moveDown\", \"_moveLeft\", \"_moveRight\", \"_zoomIn\", \"_zoomOut\", \"_fit\"];\n      this.navigationDOM[\"wrapper\"] = document.createElement(\"div\");\n      this.navigationDOM[\"wrapper\"].className = \"vis-navigation\";\n      this.canvas.frame.appendChild(this.navigationDOM[\"wrapper\"]);\n      for (var i = 0; i < navigationDivs.length; i++) {\n        this.navigationDOM[navigationDivs[i]] = document.createElement(\"div\");\n        this.navigationDOM[navigationDivs[i]].className = \"vis-button vis-\" + navigationDivs[i];\n        this.navigationDOM[\"wrapper\"].appendChild(this.navigationDOM[navigationDivs[i]]);\n        var hammer = new Hammer(this.navigationDOM[navigationDivs[i]]);\n        if (navigationDivActions[i] === \"_fit\") {\n          var _context;\n          onTouch(hammer, _bindInstanceProperty$1(_context = this._fit).call(_context, this));\n        } else {\n          var _context2;\n          onTouch(hammer, _bindInstanceProperty$1(_context2 = this.bindToRedraw).call(_context2, this, navigationDivActions[i]));\n        }\n        this.navigationHammers.push(hammer);\n      }\n\n      // use a hammer for the release so we do not require the one used in the rest of the network\n      // the one the rest uses can be overloaded by the manipulation system.\n      var hammerFrame = new Hammer(this.canvas.frame);\n      onRelease(hammerFrame, function () {\n        _this2._stopMovement();\n      });\n      this.navigationHammers.push(hammerFrame);\n      this.iconsCreated = true;\n    }\n\n    /**\n     *\n     * @param {string} action\n     */\n  }, {\n    key: \"bindToRedraw\",\n    value: function bindToRedraw(action) {\n      if (this.boundFunctions[action] === undefined) {\n        var _context3;\n        this.boundFunctions[action] = _bindInstanceProperty$1(_context3 = this[action]).call(_context3, this);\n        this.body.emitter.on(\"initRedraw\", this.boundFunctions[action]);\n        this.body.emitter.emit(\"_startRendering\");\n      }\n    }\n\n    /**\n     *\n     * @param {string} action\n     */\n  }, {\n    key: \"unbindFromRedraw\",\n    value: function unbindFromRedraw(action) {\n      if (this.boundFunctions[action] !== undefined) {\n        this.body.emitter.off(\"initRedraw\", this.boundFunctions[action]);\n        this.body.emitter.emit(\"_stopRendering\");\n        delete this.boundFunctions[action];\n      }\n    }\n\n    /**\n     * this stops all movement induced by the navigation buttons\n     *\n     * @private\n     */\n  }, {\n    key: \"_fit\",\n    value: function _fit() {\n      if (new Date().valueOf() - this.touchTime > 700) {\n        // TODO: fix ugly hack to avoid hammer's double fireing of event (because we use release?)\n        this.body.emitter.emit(\"fit\", {\n          duration: 700\n        });\n        this.touchTime = new Date().valueOf();\n      }\n    }\n\n    /**\n     * this stops all movement induced by the navigation buttons\n     *\n     * @private\n     */\n  }, {\n    key: \"_stopMovement\",\n    value: function _stopMovement() {\n      for (var boundAction in this.boundFunctions) {\n        if (Object.prototype.hasOwnProperty.call(this.boundFunctions, boundAction)) {\n          this.body.emitter.off(\"initRedraw\", this.boundFunctions[boundAction]);\n          this.body.emitter.emit(\"_stopRendering\");\n        }\n      }\n      this.boundFunctions = {};\n    }\n    /**\n     *\n     * @private\n     */\n  }, {\n    key: \"_moveUp\",\n    value: function _moveUp() {\n      this.body.view.translation.y += this.options.keyboard.speed.y;\n    }\n    /**\n     *\n     * @private\n     */\n  }, {\n    key: \"_moveDown\",\n    value: function _moveDown() {\n      this.body.view.translation.y -= this.options.keyboard.speed.y;\n    }\n    /**\n     *\n     * @private\n     */\n  }, {\n    key: \"_moveLeft\",\n    value: function _moveLeft() {\n      this.body.view.translation.x += this.options.keyboard.speed.x;\n    }\n    /**\n     *\n     * @private\n     */\n  }, {\n    key: \"_moveRight\",\n    value: function _moveRight() {\n      this.body.view.translation.x -= this.options.keyboard.speed.x;\n    }\n    /**\n     *\n     * @private\n     */\n  }, {\n    key: \"_zoomIn\",\n    value: function _zoomIn() {\n      var scaleOld = this.body.view.scale;\n      var scale = this.body.view.scale * (1 + this.options.keyboard.speed.zoom);\n      var translation = this.body.view.translation;\n      var scaleFrac = scale / scaleOld;\n      var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;\n      var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;\n      this.body.view.scale = scale;\n      this.body.view.translation = {\n        x: tx,\n        y: ty\n      };\n      this.body.emitter.emit(\"zoom\", {\n        direction: \"+\",\n        scale: this.body.view.scale,\n        pointer: null\n      });\n    }\n\n    /**\n     *\n     * @private\n     */\n  }, {\n    key: \"_zoomOut\",\n    value: function _zoomOut() {\n      var scaleOld = this.body.view.scale;\n      var scale = this.body.view.scale / (1 + this.options.keyboard.speed.zoom);\n      var translation = this.body.view.translation;\n      var scaleFrac = scale / scaleOld;\n      var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;\n      var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;\n      this.body.view.scale = scale;\n      this.body.view.translation = {\n        x: tx,\n        y: ty\n      };\n      this.body.emitter.emit(\"zoom\", {\n        direction: \"-\",\n        scale: this.body.view.scale,\n        pointer: null\n      });\n    }\n\n    /**\n     * bind all keys using keycharm.\n     */\n  }, {\n    key: \"configureKeyboardBindings\",\n    value: function configureKeyboardBindings() {\n      var _this3 = this;\n      if (this.keycharm !== undefined) {\n        this.keycharm.destroy();\n      }\n      if (this.options.keyboard.enabled === true) {\n        if (this.options.keyboard.bindToWindow === true) {\n          this.keycharm = keycharm({\n            container: window,\n            preventDefault: true\n          });\n        } else {\n          this.keycharm = keycharm({\n            container: this.canvas.frame,\n            preventDefault: true\n          });\n        }\n        this.keycharm.reset();\n        if (this.activated === true) {\n          var _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12, _context13, _context14, _context15, _context16, _context17, _context18, _context19, _context20, _context21, _context22, _context23, _context24, _context25, _context26, _context27;\n          _bindInstanceProperty$1(_context4 = this.keycharm).call(_context4, \"up\", function () {\n            _this3.bindToRedraw(\"_moveUp\");\n          }, \"keydown\");\n          _bindInstanceProperty$1(_context5 = this.keycharm).call(_context5, \"down\", function () {\n            _this3.bindToRedraw(\"_moveDown\");\n          }, \"keydown\");\n          _bindInstanceProperty$1(_context6 = this.keycharm).call(_context6, \"left\", function () {\n            _this3.bindToRedraw(\"_moveLeft\");\n          }, \"keydown\");\n          _bindInstanceProperty$1(_context7 = this.keycharm).call(_context7, \"right\", function () {\n            _this3.bindToRedraw(\"_moveRight\");\n          }, \"keydown\");\n          _bindInstanceProperty$1(_context8 = this.keycharm).call(_context8, \"=\", function () {\n            _this3.bindToRedraw(\"_zoomIn\");\n          }, \"keydown\");\n          _bindInstanceProperty$1(_context9 = this.keycharm).call(_context9, \"num+\", function () {\n            _this3.bindToRedraw(\"_zoomIn\");\n          }, \"keydown\");\n          _bindInstanceProperty$1(_context10 = this.keycharm).call(_context10, \"num-\", function () {\n            _this3.bindToRedraw(\"_zoomOut\");\n          }, \"keydown\");\n          _bindInstanceProperty$1(_context11 = this.keycharm).call(_context11, \"-\", function () {\n            _this3.bindToRedraw(\"_zoomOut\");\n          }, \"keydown\");\n          _bindInstanceProperty$1(_context12 = this.keycharm).call(_context12, \"[\", function () {\n            _this3.bindToRedraw(\"_zoomOut\");\n          }, \"keydown\");\n          _bindInstanceProperty$1(_context13 = this.keycharm).call(_context13, \"]\", function () {\n            _this3.bindToRedraw(\"_zoomIn\");\n          }, \"keydown\");\n          _bindInstanceProperty$1(_context14 = this.keycharm).call(_context14, \"pageup\", function () {\n            _this3.bindToRedraw(\"_zoomIn\");\n          }, \"keydown\");\n          _bindInstanceProperty$1(_context15 = this.keycharm).call(_context15, \"pagedown\", function () {\n            _this3.bindToRedraw(\"_zoomOut\");\n          }, \"keydown\");\n          _bindInstanceProperty$1(_context16 = this.keycharm).call(_context16, \"up\", function () {\n            _this3.unbindFromRedraw(\"_moveUp\");\n          }, \"keyup\");\n          _bindInstanceProperty$1(_context17 = this.keycharm).call(_context17, \"down\", function () {\n            _this3.unbindFromRedraw(\"_moveDown\");\n          }, \"keyup\");\n          _bindInstanceProperty$1(_context18 = this.keycharm).call(_context18, \"left\", function () {\n            _this3.unbindFromRedraw(\"_moveLeft\");\n          }, \"keyup\");\n          _bindInstanceProperty$1(_context19 = this.keycharm).call(_context19, \"right\", function () {\n            _this3.unbindFromRedraw(\"_moveRight\");\n          }, \"keyup\");\n          _bindInstanceProperty$1(_context20 = this.keycharm).call(_context20, \"=\", function () {\n            _this3.unbindFromRedraw(\"_zoomIn\");\n          }, \"keyup\");\n          _bindInstanceProperty$1(_context21 = this.keycharm).call(_context21, \"num+\", function () {\n            _this3.unbindFromRedraw(\"_zoomIn\");\n          }, \"keyup\");\n          _bindInstanceProperty$1(_context22 = this.keycharm).call(_context22, \"num-\", function () {\n            _this3.unbindFromRedraw(\"_zoomOut\");\n          }, \"keyup\");\n          _bindInstanceProperty$1(_context23 = this.keycharm).call(_context23, \"-\", function () {\n            _this3.unbindFromRedraw(\"_zoomOut\");\n          }, \"keyup\");\n          _bindInstanceProperty$1(_context24 = this.keycharm).call(_context24, \"[\", function () {\n            _this3.unbindFromRedraw(\"_zoomOut\");\n          }, \"keyup\");\n          _bindInstanceProperty$1(_context25 = this.keycharm).call(_context25, \"]\", function () {\n            _this3.unbindFromRedraw(\"_zoomIn\");\n          }, \"keyup\");\n          _bindInstanceProperty$1(_context26 = this.keycharm).call(_context26, \"pageup\", function () {\n            _this3.unbindFromRedraw(\"_zoomIn\");\n          }, \"keyup\");\n          _bindInstanceProperty$1(_context27 = this.keycharm).call(_context27, \"pagedown\", function () {\n            _this3.unbindFromRedraw(\"_zoomOut\");\n          }, \"keyup\");\n        }\n      }\n    }\n  }]);\n  return NavigationHandler;\n}();\n\nfunction _createForOfIteratorHelper$4(o, allowArrayLike) { var it = typeof _Symbol !== \"undefined\" && _getIteratorMethod(o) || o[\"@@iterator\"]; if (!it) { if (_Array$isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$4(o, minLen) { var _context15; if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$4(o, minLen); var n = _sliceInstanceProperty(_context15 = Object.prototype.toString.call(o)).call(_context15, 8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return _Array$from$1(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }\nfunction _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n/**\n * Handler for interactions\n */\nvar InteractionHandler = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {Canvas} canvas\n   * @param {SelectionHandler} selectionHandler\n   */\n  function InteractionHandler(body, canvas, selectionHandler) {\n    var _context, _context2, _context3, _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12, _context13;\n    _classCallCheck(this, InteractionHandler);\n    this.body = body;\n    this.canvas = canvas;\n    this.selectionHandler = selectionHandler;\n    this.navigationHandler = new NavigationHandler(body, canvas);\n\n    // bind the events from hammer to functions in this object\n    this.body.eventListeners.onTap = _bindInstanceProperty$1(_context = this.onTap).call(_context, this);\n    this.body.eventListeners.onTouch = _bindInstanceProperty$1(_context2 = this.onTouch).call(_context2, this);\n    this.body.eventListeners.onDoubleTap = _bindInstanceProperty$1(_context3 = this.onDoubleTap).call(_context3, this);\n    this.body.eventListeners.onHold = _bindInstanceProperty$1(_context4 = this.onHold).call(_context4, this);\n    this.body.eventListeners.onDragStart = _bindInstanceProperty$1(_context5 = this.onDragStart).call(_context5, this);\n    this.body.eventListeners.onDrag = _bindInstanceProperty$1(_context6 = this.onDrag).call(_context6, this);\n    this.body.eventListeners.onDragEnd = _bindInstanceProperty$1(_context7 = this.onDragEnd).call(_context7, this);\n    this.body.eventListeners.onMouseWheel = _bindInstanceProperty$1(_context8 = this.onMouseWheel).call(_context8, this);\n    this.body.eventListeners.onPinch = _bindInstanceProperty$1(_context9 = this.onPinch).call(_context9, this);\n    this.body.eventListeners.onMouseMove = _bindInstanceProperty$1(_context10 = this.onMouseMove).call(_context10, this);\n    this.body.eventListeners.onRelease = _bindInstanceProperty$1(_context11 = this.onRelease).call(_context11, this);\n    this.body.eventListeners.onContext = _bindInstanceProperty$1(_context12 = this.onContext).call(_context12, this);\n    this.touchTime = 0;\n    this.drag = {};\n    this.pinch = {};\n    this.popup = undefined;\n    this.popupObj = undefined;\n    this.popupTimer = undefined;\n    this.body.functions.getPointer = _bindInstanceProperty$1(_context13 = this.getPointer).call(_context13, this);\n    this.options = {};\n    this.defaultOptions = {\n      dragNodes: true,\n      dragView: true,\n      hover: false,\n      keyboard: {\n        enabled: false,\n        speed: {\n          x: 10,\n          y: 10,\n          zoom: 0.02\n        },\n        bindToWindow: true,\n        autoFocus: true\n      },\n      navigationButtons: false,\n      tooltipDelay: 300,\n      zoomView: true,\n      zoomSpeed: 1\n    };\n    _Object$assign(this.options, this.defaultOptions);\n    this.bindEventListeners();\n  }\n\n  /**\n   * Binds event listeners\n   */\n  _createClass(InteractionHandler, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _this = this;\n      this.body.emitter.on(\"destroy\", function () {\n        clearTimeout(_this.popupTimer);\n        delete _this.body.functions.getPointer;\n      });\n    }\n\n    /**\n     *\n     * @param {object} options\n     */\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        // extend all but the values in fields\n        var fields = [\"hideEdgesOnDrag\", \"hideEdgesOnZoom\", \"hideNodesOnDrag\", \"keyboard\", \"multiselect\", \"selectable\", \"selectConnectedEdges\"];\n        selectiveNotDeepExtend(fields, this.options, options);\n\n        // merge the keyboard options in.\n        mergeOptions(this.options, options, \"keyboard\");\n        if (options.tooltip) {\n          _Object$assign(this.options.tooltip, options.tooltip);\n          if (options.tooltip.color) {\n            this.options.tooltip.color = parseColor(options.tooltip.color);\n          }\n        }\n      }\n      this.navigationHandler.setOptions(this.options);\n    }\n\n    /**\n     * Get the pointer location from a touch location\n     *\n     * @param {{x: number, y: number}} touch\n     * @returns {{x: number, y: number}} pointer\n     * @private\n     */\n  }, {\n    key: \"getPointer\",\n    value: function getPointer(touch) {\n      return {\n        x: touch.x - getAbsoluteLeft(this.canvas.frame.canvas),\n        y: touch.y - getAbsoluteTop(this.canvas.frame.canvas)\n      };\n    }\n\n    /**\n     * On start of a touch gesture, store the pointer\n     *\n     * @param {Event}  event   The event\n     * @private\n     */\n  }, {\n    key: \"onTouch\",\n    value: function onTouch(event) {\n      if (new Date().valueOf() - this.touchTime > 50) {\n        this.drag.pointer = this.getPointer(event.center);\n        this.drag.pinched = false;\n        this.pinch.scale = this.body.view.scale;\n        // to avoid double fireing of this event because we have two hammer instances. (on canvas and on frame)\n        this.touchTime = new Date().valueOf();\n      }\n    }\n\n    /**\n     * handle tap/click event: select/unselect a node\n     *\n     * @param {Event} event\n     * @private\n     */\n  }, {\n    key: \"onTap\",\n    value: function onTap(event) {\n      var pointer = this.getPointer(event.center);\n      var multiselect = this.selectionHandler.options.multiselect && (event.changedPointers[0].ctrlKey || event.changedPointers[0].metaKey);\n      this.checkSelectionChanges(pointer, multiselect);\n      this.selectionHandler.commitAndEmit(pointer, event);\n      this.selectionHandler.generateClickEvent(\"click\", event, pointer);\n    }\n\n    /**\n     * handle doubletap event\n     *\n     * @param {Event} event\n     * @private\n     */\n  }, {\n    key: \"onDoubleTap\",\n    value: function onDoubleTap(event) {\n      var pointer = this.getPointer(event.center);\n      this.selectionHandler.generateClickEvent(\"doubleClick\", event, pointer);\n    }\n\n    /**\n     * handle long tap event: multi select nodes\n     *\n     * @param {Event} event\n     * @private\n     */\n  }, {\n    key: \"onHold\",\n    value: function onHold(event) {\n      var pointer = this.getPointer(event.center);\n      var multiselect = this.selectionHandler.options.multiselect;\n      this.checkSelectionChanges(pointer, multiselect);\n      this.selectionHandler.commitAndEmit(pointer, event);\n      this.selectionHandler.generateClickEvent(\"click\", event, pointer);\n      this.selectionHandler.generateClickEvent(\"hold\", event, pointer);\n    }\n\n    /**\n     * handle the release of the screen\n     *\n     * @param {Event} event\n     * @private\n     */\n  }, {\n    key: \"onRelease\",\n    value: function onRelease(event) {\n      if (new Date().valueOf() - this.touchTime > 10) {\n        var pointer = this.getPointer(event.center);\n        this.selectionHandler.generateClickEvent(\"release\", event, pointer);\n        // to avoid double fireing of this event because we have two hammer instances. (on canvas and on frame)\n        this.touchTime = new Date().valueOf();\n      }\n    }\n\n    /**\n     *\n     * @param {Event} event\n     */\n  }, {\n    key: \"onContext\",\n    value: function onContext(event) {\n      var pointer = this.getPointer({\n        x: event.clientX,\n        y: event.clientY\n      });\n      this.selectionHandler.generateClickEvent(\"oncontext\", event, pointer);\n    }\n\n    /**\n     * Select and deselect nodes depending current selection change.\n     *\n     * @param {{x: number, y: number}} pointer\n     * @param {boolean} [add=false]\n     */\n  }, {\n    key: \"checkSelectionChanges\",\n    value: function checkSelectionChanges(pointer) {\n      var add = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (add === true) {\n        this.selectionHandler.selectAdditionalOnPoint(pointer);\n      } else {\n        this.selectionHandler.selectOnPoint(pointer);\n      }\n    }\n\n    /**\n     * Remove all node and edge id's from the first set that are present in the second one.\n     *\n     * @param {{nodes: Array.<Node>, edges: Array.<vis.Edge>}} firstSet\n     * @param {{nodes: Array.<Node>, edges: Array.<vis.Edge>}} secondSet\n     * @returns {{nodes: Array.<Node>, edges: Array.<vis.Edge>}}\n     * @private\n     */\n  }, {\n    key: \"_determineDifference\",\n    value: function _determineDifference(firstSet, secondSet) {\n      var arrayDiff = function arrayDiff(firstArr, secondArr) {\n        var result = [];\n        for (var i = 0; i < firstArr.length; i++) {\n          var value = firstArr[i];\n          if (_indexOfInstanceProperty(secondArr).call(secondArr, value) === -1) {\n            result.push(value);\n          }\n        }\n        return result;\n      };\n      return {\n        nodes: arrayDiff(firstSet.nodes, secondSet.nodes),\n        edges: arrayDiff(firstSet.edges, secondSet.edges)\n      };\n    }\n\n    /**\n     * This function is called by onDragStart.\n     * It is separated out because we can then overload it for the datamanipulation system.\n     *\n     * @param {Event} event\n     * @private\n     */\n  }, {\n    key: \"onDragStart\",\n    value: function onDragStart(event) {\n      // if already dragging, do not start\n      // this can happen on touch screens with multiple fingers\n      if (this.drag.dragging) {\n        return;\n      }\n\n      //in case the touch event was triggered on an external div, do the initial touch now.\n      if (this.drag.pointer === undefined) {\n        this.onTouch(event);\n      }\n\n      // note: drag.pointer is set in onTouch to get the initial touch location\n      var node = this.selectionHandler.getNodeAt(this.drag.pointer);\n      this.drag.dragging = true;\n      this.drag.selection = [];\n      this.drag.translation = _Object$assign({}, this.body.view.translation); // copy the object\n      this.drag.nodeId = undefined;\n      if (event.srcEvent.shiftKey) {\n        this.body.selectionBox.show = true;\n        var pointer = this.getPointer(event.center);\n        this.body.selectionBox.position.start = {\n          x: this.canvas._XconvertDOMtoCanvas(pointer.x),\n          y: this.canvas._YconvertDOMtoCanvas(pointer.y)\n        };\n        this.body.selectionBox.position.end = {\n          x: this.canvas._XconvertDOMtoCanvas(pointer.x),\n          y: this.canvas._YconvertDOMtoCanvas(pointer.y)\n        };\n      } else if (node !== undefined && this.options.dragNodes === true) {\n        this.drag.nodeId = node.id;\n        // select the clicked node if not yet selected\n        if (node.isSelected() === false) {\n          this.selectionHandler.setSelection({\n            nodes: [node.id]\n          });\n        }\n\n        // after select to contain the node\n        this.selectionHandler.generateClickEvent(\"dragStart\", event, this.drag.pointer);\n\n        // create an array with the selected nodes and their original location and status\n        var _iterator = _createForOfIteratorHelper$4(this.selectionHandler.getSelectedNodes()),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _node = _step.value;\n            var s = {\n              id: _node.id,\n              node: _node,\n              // store original x, y, xFixed and yFixed, make the node temporarily Fixed\n              x: _node.x,\n              y: _node.y,\n              xFixed: _node.options.fixed.x,\n              yFixed: _node.options.fixed.y\n            };\n            _node.options.fixed.x = true;\n            _node.options.fixed.y = true;\n            this.drag.selection.push(s);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        // fallback if no node is selected and thus the view is dragged.\n        this.selectionHandler.generateClickEvent(\"dragStart\", event, this.drag.pointer, undefined, true);\n      }\n    }\n\n    /**\n     * handle drag event\n     *\n     * @param {Event} event\n     * @private\n     */\n  }, {\n    key: \"onDrag\",\n    value: function onDrag(event) {\n      var _this2 = this;\n      if (this.drag.pinched === true) {\n        return;\n      }\n\n      // remove the focus on node if it is focussed on by the focusOnNode\n      this.body.emitter.emit(\"unlockNode\");\n      var pointer = this.getPointer(event.center);\n      var selection = this.drag.selection;\n      if (selection && selection.length && this.options.dragNodes === true) {\n        this.selectionHandler.generateClickEvent(\"dragging\", event, pointer);\n\n        // calculate delta's and new location\n        var deltaX = pointer.x - this.drag.pointer.x;\n        var deltaY = pointer.y - this.drag.pointer.y;\n\n        // update position of all selected nodes\n        _forEachInstanceProperty(selection).call(selection, function (selection) {\n          var node = selection.node;\n          // only move the node if it was not fixed initially\n          if (selection.xFixed === false) {\n            node.x = _this2.canvas._XconvertDOMtoCanvas(_this2.canvas._XconvertCanvasToDOM(selection.x) + deltaX);\n          }\n          // only move the node if it was not fixed initially\n          if (selection.yFixed === false) {\n            node.y = _this2.canvas._YconvertDOMtoCanvas(_this2.canvas._YconvertCanvasToDOM(selection.y) + deltaY);\n          }\n        });\n\n        // start the simulation of the physics\n        this.body.emitter.emit(\"startSimulation\");\n      } else {\n        // create selection box\n        if (event.srcEvent.shiftKey) {\n          this.selectionHandler.generateClickEvent(\"dragging\", event, pointer, undefined, true);\n\n          // if the drag was not started properly because the click started outside the network div, start it now.\n          if (this.drag.pointer === undefined) {\n            this.onDragStart(event);\n            return;\n          }\n          this.body.selectionBox.position.end = {\n            x: this.canvas._XconvertDOMtoCanvas(pointer.x),\n            y: this.canvas._YconvertDOMtoCanvas(pointer.y)\n          };\n          this.body.emitter.emit(\"_requestRedraw\");\n        }\n\n        // move the network\n        if (this.options.dragView === true && !event.srcEvent.shiftKey) {\n          this.selectionHandler.generateClickEvent(\"dragging\", event, pointer, undefined, true);\n\n          // if the drag was not started properly because the click started outside the network div, start it now.\n          if (this.drag.pointer === undefined) {\n            this.onDragStart(event);\n            return;\n          }\n          var diffX = pointer.x - this.drag.pointer.x;\n          var diffY = pointer.y - this.drag.pointer.y;\n          this.body.view.translation = {\n            x: this.drag.translation.x + diffX,\n            y: this.drag.translation.y + diffY\n          };\n          this.body.emitter.emit(\"_requestRedraw\");\n        }\n      }\n    }\n\n    /**\n     * handle drag start event\n     *\n     * @param {Event} event\n     * @private\n     */\n  }, {\n    key: \"onDragEnd\",\n    value: function onDragEnd(event) {\n      var _this3 = this;\n      this.drag.dragging = false;\n      if (this.body.selectionBox.show) {\n        var _context14;\n        this.body.selectionBox.show = false;\n        var selectionBoxPosition = this.body.selectionBox.position;\n        var selectionBoxPositionMinMax = {\n          minX: Math.min(selectionBoxPosition.start.x, selectionBoxPosition.end.x),\n          minY: Math.min(selectionBoxPosition.start.y, selectionBoxPosition.end.y),\n          maxX: Math.max(selectionBoxPosition.start.x, selectionBoxPosition.end.x),\n          maxY: Math.max(selectionBoxPosition.start.y, selectionBoxPosition.end.y)\n        };\n        var toBeSelectedNodes = _filterInstanceProperty(_context14 = this.body.nodeIndices).call(_context14, function (nodeId) {\n          var node = _this3.body.nodes[nodeId];\n          return node.x >= selectionBoxPositionMinMax.minX && node.x <= selectionBoxPositionMinMax.maxX && node.y >= selectionBoxPositionMinMax.minY && node.y <= selectionBoxPositionMinMax.maxY;\n        });\n        _forEachInstanceProperty(toBeSelectedNodes).call(toBeSelectedNodes, function (nodeId) {\n          return _this3.selectionHandler.selectObject(_this3.body.nodes[nodeId]);\n        });\n        var pointer = this.getPointer(event.center);\n        this.selectionHandler.commitAndEmit(pointer, event);\n        this.selectionHandler.generateClickEvent(\"dragEnd\", event, this.getPointer(event.center), undefined, true);\n        this.body.emitter.emit(\"_requestRedraw\");\n      } else {\n        var selection = this.drag.selection;\n        if (selection && selection.length) {\n          _forEachInstanceProperty(selection).call(selection, function (s) {\n            // restore original xFixed and yFixed\n            s.node.options.fixed.x = s.xFixed;\n            s.node.options.fixed.y = s.yFixed;\n          });\n          this.selectionHandler.generateClickEvent(\"dragEnd\", event, this.getPointer(event.center));\n          this.body.emitter.emit(\"startSimulation\");\n        } else {\n          this.selectionHandler.generateClickEvent(\"dragEnd\", event, this.getPointer(event.center), undefined, true);\n          this.body.emitter.emit(\"_requestRedraw\");\n        }\n      }\n    }\n\n    /**\n     * Handle pinch event\n     *\n     * @param {Event}  event   The event\n     * @private\n     */\n  }, {\n    key: \"onPinch\",\n    value: function onPinch(event) {\n      var pointer = this.getPointer(event.center);\n      this.drag.pinched = true;\n      if (this.pinch[\"scale\"] === undefined) {\n        this.pinch.scale = 1;\n      }\n\n      // TODO: enabled moving while pinching?\n      var scale = this.pinch.scale * event.scale;\n      this.zoom(scale, pointer);\n    }\n\n    /**\n     * Zoom the network in or out\n     *\n     * @param {number} scale a number around 1, and between 0.01 and 10\n     * @param {{x: number, y: number}} pointer    Position on screen\n     * @private\n     */\n  }, {\n    key: \"zoom\",\n    value: function zoom(scale, pointer) {\n      if (this.options.zoomView === true) {\n        var scaleOld = this.body.view.scale;\n        if (scale < 0.00001) {\n          scale = 0.00001;\n        }\n        if (scale > 10) {\n          scale = 10;\n        }\n        var preScaleDragPointer = undefined;\n        if (this.drag !== undefined) {\n          if (this.drag.dragging === true) {\n            preScaleDragPointer = this.canvas.DOMtoCanvas(this.drag.pointer);\n          }\n        }\n        // + this.canvas.frame.canvas.clientHeight / 2\n        var translation = this.body.view.translation;\n        var scaleFrac = scale / scaleOld;\n        var tx = (1 - scaleFrac) * pointer.x + translation.x * scaleFrac;\n        var ty = (1 - scaleFrac) * pointer.y + translation.y * scaleFrac;\n        this.body.view.scale = scale;\n        this.body.view.translation = {\n          x: tx,\n          y: ty\n        };\n        if (preScaleDragPointer != undefined) {\n          var postScaleDragPointer = this.canvas.canvasToDOM(preScaleDragPointer);\n          this.drag.pointer.x = postScaleDragPointer.x;\n          this.drag.pointer.y = postScaleDragPointer.y;\n        }\n        this.body.emitter.emit(\"_requestRedraw\");\n        if (scaleOld < scale) {\n          this.body.emitter.emit(\"zoom\", {\n            direction: \"+\",\n            scale: this.body.view.scale,\n            pointer: pointer\n          });\n        } else {\n          this.body.emitter.emit(\"zoom\", {\n            direction: \"-\",\n            scale: this.body.view.scale,\n            pointer: pointer\n          });\n        }\n      }\n    }\n\n    /**\n     * Event handler for mouse wheel event, used to zoom the timeline\n     * See http://adomas.org/javascript-mouse-wheel/\n     *     https://github.com/EightMedia/hammer.js/issues/256\n     *\n     * @param {MouseEvent}  event\n     * @private\n     */\n  }, {\n    key: \"onMouseWheel\",\n    value: function onMouseWheel(event) {\n      if (this.options.zoomView === true) {\n        // If delta is nonzero, handle it.\n        // Basically, delta is now positive if wheel was scrolled up,\n        // and negative, if wheel was scrolled down.\n        if (event.deltaY !== 0) {\n          // calculate the new scale\n          var scale = this.body.view.scale;\n          scale *= 1 + (event.deltaY < 0 ? 1 : -1) * (this.options.zoomSpeed * 0.1);\n\n          // calculate the pointer location\n          var pointer = this.getPointer({\n            x: event.clientX,\n            y: event.clientY\n          });\n\n          // apply the new scale\n          this.zoom(scale, pointer);\n        }\n\n        // Prevent default actions caused by mouse wheel.\n        event.preventDefault();\n      }\n    }\n\n    /**\n     * Mouse move handler for checking whether the title moves over a node with a title.\n     *\n     * @param  {Event} event\n     * @private\n     */\n  }, {\n    key: \"onMouseMove\",\n    value: function onMouseMove(event) {\n      var _this4 = this;\n      var pointer = this.getPointer({\n        x: event.clientX,\n        y: event.clientY\n      });\n      var popupVisible = false;\n\n      // check if the previously selected node is still selected\n      if (this.popup !== undefined) {\n        if (this.popup.hidden === false) {\n          this._checkHidePopup(pointer);\n        }\n\n        // if the popup was not hidden above\n        if (this.popup.hidden === false) {\n          popupVisible = true;\n          this.popup.setPosition(pointer.x + 3, pointer.y - 5);\n          this.popup.show();\n        }\n      }\n\n      // if we bind the keyboard to the div, we have to highlight it to use it. This highlights it on mouse over.\n      if (this.options.keyboard.autoFocus && this.options.keyboard.bindToWindow === false && this.options.keyboard.enabled === true) {\n        this.canvas.frame.focus();\n      }\n\n      // start a timeout that will check if the mouse is positioned above an element\n      if (popupVisible === false) {\n        if (this.popupTimer !== undefined) {\n          clearInterval(this.popupTimer); // stop any running calculationTimer\n          this.popupTimer = undefined;\n        }\n        if (!this.drag.dragging) {\n          this.popupTimer = _setTimeout(function () {\n            return _this4._checkShowPopup(pointer);\n          }, this.options.tooltipDelay);\n        }\n      }\n\n      // adding hover highlights\n      if (this.options.hover === true) {\n        this.selectionHandler.hoverObject(event, pointer);\n      }\n    }\n\n    /**\n     * Check if there is an element on the given position in the network\n     * (a node or edge). If so, and if this element has a title,\n     * show a popup window with its title.\n     *\n     * @param {{x:number, y:number}} pointer\n     * @private\n     */\n  }, {\n    key: \"_checkShowPopup\",\n    value: function _checkShowPopup(pointer) {\n      var x = this.canvas._XconvertDOMtoCanvas(pointer.x);\n      var y = this.canvas._YconvertDOMtoCanvas(pointer.y);\n      var pointerObj = {\n        left: x,\n        top: y,\n        right: x,\n        bottom: y\n      };\n      var previousPopupObjId = this.popupObj === undefined ? undefined : this.popupObj.id;\n      var nodeUnderCursor = false;\n      var popupType = \"node\";\n\n      // check if a node is under the cursor.\n      if (this.popupObj === undefined) {\n        // search the nodes for overlap, select the top one in case of multiple nodes\n        var nodeIndices = this.body.nodeIndices;\n        var nodes = this.body.nodes;\n        var node;\n        var overlappingNodes = [];\n        for (var i = 0; i < nodeIndices.length; i++) {\n          node = nodes[nodeIndices[i]];\n          if (node.isOverlappingWith(pointerObj) === true) {\n            nodeUnderCursor = true;\n            if (node.getTitle() !== undefined) {\n              overlappingNodes.push(nodeIndices[i]);\n            }\n          }\n        }\n        if (overlappingNodes.length > 0) {\n          // if there are overlapping nodes, select the last one, this is the one which is drawn on top of the others\n          this.popupObj = nodes[overlappingNodes[overlappingNodes.length - 1]];\n          // if you hover over a node, the title of the edge is not supposed to be shown.\n          nodeUnderCursor = true;\n        }\n      }\n      if (this.popupObj === undefined && nodeUnderCursor === false) {\n        // search the edges for overlap\n        var edgeIndices = this.body.edgeIndices;\n        var edges = this.body.edges;\n        var edge;\n        var overlappingEdges = [];\n        for (var _i = 0; _i < edgeIndices.length; _i++) {\n          edge = edges[edgeIndices[_i]];\n          if (edge.isOverlappingWith(pointerObj) === true) {\n            if (edge.connected === true && edge.getTitle() !== undefined) {\n              overlappingEdges.push(edgeIndices[_i]);\n            }\n          }\n        }\n        if (overlappingEdges.length > 0) {\n          this.popupObj = edges[overlappingEdges[overlappingEdges.length - 1]];\n          popupType = \"edge\";\n        }\n      }\n      if (this.popupObj !== undefined) {\n        // show popup message window\n        if (this.popupObj.id !== previousPopupObjId) {\n          if (this.popup === undefined) {\n            this.popup = new Popup(this.canvas.frame);\n          }\n          this.popup.popupTargetType = popupType;\n          this.popup.popupTargetId = this.popupObj.id;\n\n          // adjust a small offset such that the mouse cursor is located in the\n          // bottom left location of the popup, and you can easily move over the\n          // popup area\n          this.popup.setPosition(pointer.x + 3, pointer.y - 5);\n          this.popup.setText(this.popupObj.getTitle());\n          this.popup.show();\n          this.body.emitter.emit(\"showPopup\", this.popupObj.id);\n        }\n      } else {\n        if (this.popup !== undefined) {\n          this.popup.hide();\n          this.body.emitter.emit(\"hidePopup\");\n        }\n      }\n    }\n\n    /**\n     * Check if the popup must be hidden, which is the case when the mouse is no\n     * longer hovering on the object\n     *\n     * @param {{x:number, y:number}} pointer\n     * @private\n     */\n  }, {\n    key: \"_checkHidePopup\",\n    value: function _checkHidePopup(pointer) {\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);\n      var stillOnObj = false;\n      if (this.popup.popupTargetType === \"node\") {\n        if (this.body.nodes[this.popup.popupTargetId] !== undefined) {\n          stillOnObj = this.body.nodes[this.popup.popupTargetId].isOverlappingWith(pointerObj);\n\n          // if the mouse is still one the node, we have to check if it is not also on one that is drawn on top of it.\n          // we initially only check stillOnObj because this is much faster.\n          if (stillOnObj === true) {\n            var overNode = this.selectionHandler.getNodeAt(pointer);\n            stillOnObj = overNode === undefined ? false : overNode.id === this.popup.popupTargetId;\n          }\n        }\n      } else {\n        if (this.selectionHandler.getNodeAt(pointer) === undefined) {\n          if (this.body.edges[this.popup.popupTargetId] !== undefined) {\n            stillOnObj = this.body.edges[this.popup.popupTargetId].isOverlappingWith(pointerObj);\n          }\n        }\n      }\n      if (stillOnObj === false) {\n        this.popupObj = undefined;\n        this.popup.hide();\n        this.body.emitter.emit(\"hidePopup\");\n      }\n    }\n  }]);\n  return InteractionHandler;\n}();\n\nvar collection$1 = collection$3;\nvar collectionStrong = collectionStrong$2;\n\n// `Set` constructor\n// https://tc39.es/ecma262/#sec-set-objects\ncollection$1('Set', function (init) {\n  return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };\n}, collectionStrong);\n\nvar path$1 = path$w;\n\nvar set$2 = path$1.Set;\n\nvar parent$4 = set$2;\n\n\nvar set$1 = parent$4;\n\nvar set = set$1;\n\nvar _Set = /*@__PURE__*/getDefaultExportFromCjs(set);\n\nvar uncurryThis$2 = functionUncurryThis;\nvar defineBuiltIns$1 = defineBuiltIns$3;\nvar getWeakData = internalMetadataExports.getWeakData;\nvar anInstance = anInstance$3;\nvar anObject = anObject$d;\nvar isNullOrUndefined = isNullOrUndefined$6;\nvar isObject$1 = isObject$j;\nvar iterate = iterate$3;\nvar ArrayIterationModule = arrayIteration;\nvar hasOwn = hasOwnProperty_1;\nvar InternalStateModule = internalState;\n\nvar setInternalState = InternalStateModule.set;\nvar internalStateGetterFor = InternalStateModule.getterFor;\nvar find = ArrayIterationModule.find;\nvar findIndex = ArrayIterationModule.findIndex;\nvar splice = uncurryThis$2([].splice);\nvar id = 0;\n\n// fallback for uncaught frozen keys\nvar uncaughtFrozenStore = function (state) {\n  return state.frozen || (state.frozen = new UncaughtFrozenStore());\n};\n\nvar UncaughtFrozenStore = function () {\n  this.entries = [];\n};\n\nvar findUncaughtFrozen = function (store, key) {\n  return find(store.entries, function (it) {\n    return it[0] === key;\n  });\n};\n\nUncaughtFrozenStore.prototype = {\n  get: function (key) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) return entry[1];\n  },\n  has: function (key) {\n    return !!findUncaughtFrozen(this, key);\n  },\n  set: function (key, value) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) entry[1] = value;\n    else this.entries.push([key, value]);\n  },\n  'delete': function (key) {\n    var index = findIndex(this.entries, function (it) {\n      return it[0] === key;\n    });\n    if (~index) splice(this.entries, index, 1);\n    return !!~index;\n  }\n};\n\nvar collectionWeak$1 = {\n  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {\n    var Constructor = wrapper(function (that, iterable) {\n      anInstance(that, Prototype);\n      setInternalState(that, {\n        type: CONSTRUCTOR_NAME,\n        id: id++,\n        frozen: undefined\n      });\n      if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });\n    });\n\n    var Prototype = Constructor.prototype;\n\n    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);\n\n    var define = function (that, key, value) {\n      var state = getInternalState(that);\n      var data = getWeakData(anObject(key), true);\n      if (data === true) uncaughtFrozenStore(state).set(key, value);\n      else data[state.id] = value;\n      return that;\n    };\n\n    defineBuiltIns$1(Prototype, {\n      // `{ WeakMap, WeakSet }.prototype.delete(key)` methods\n      // https://tc39.es/ecma262/#sec-weakmap.prototype.delete\n      // https://tc39.es/ecma262/#sec-weakset.prototype.delete\n      'delete': function (key) {\n        var state = getInternalState(this);\n        if (!isObject$1(key)) return false;\n        var data = getWeakData(key);\n        if (data === true) return uncaughtFrozenStore(state)['delete'](key);\n        return data && hasOwn(data, state.id) && delete data[state.id];\n      },\n      // `{ WeakMap, WeakSet }.prototype.has(key)` methods\n      // https://tc39.es/ecma262/#sec-weakmap.prototype.has\n      // https://tc39.es/ecma262/#sec-weakset.prototype.has\n      has: function has(key) {\n        var state = getInternalState(this);\n        if (!isObject$1(key)) return false;\n        var data = getWeakData(key);\n        if (data === true) return uncaughtFrozenStore(state).has(key);\n        return data && hasOwn(data, state.id);\n      }\n    });\n\n    defineBuiltIns$1(Prototype, IS_MAP ? {\n      // `WeakMap.prototype.get(key)` method\n      // https://tc39.es/ecma262/#sec-weakmap.prototype.get\n      get: function get(key) {\n        var state = getInternalState(this);\n        if (isObject$1(key)) {\n          var data = getWeakData(key);\n          if (data === true) return uncaughtFrozenStore(state).get(key);\n          return data ? data[state.id] : undefined;\n        }\n      },\n      // `WeakMap.prototype.set(key, value)` method\n      // https://tc39.es/ecma262/#sec-weakmap.prototype.set\n      set: function set(key, value) {\n        return define(this, key, value);\n      }\n    } : {\n      // `WeakSet.prototype.add(value)` method\n      // https://tc39.es/ecma262/#sec-weakset.prototype.add\n      add: function add(value) {\n        return define(this, value, true);\n      }\n    });\n\n    return Constructor;\n  }\n};\n\nvar FREEZING = freezing;\nvar global$2 = global$n;\nvar uncurryThis$1 = functionUncurryThis;\nvar defineBuiltIns = defineBuiltIns$3;\nvar InternalMetadataModule = internalMetadataExports;\nvar collection = collection$3;\nvar collectionWeak = collectionWeak$1;\nvar isObject = isObject$j;\nvar enforceInternalState = internalState.enforce;\nvar fails$1 = fails$w;\nvar NATIVE_WEAK_MAP = weakMapBasicDetection;\n\nvar $Object = Object;\n// eslint-disable-next-line es/no-array-isarray -- safe\nvar isArray = Array.isArray;\n// eslint-disable-next-line es/no-object-isextensible -- safe\nvar isExtensible = $Object.isExtensible;\n// eslint-disable-next-line es/no-object-isfrozen -- safe\nvar isFrozen = $Object.isFrozen;\n// eslint-disable-next-line es/no-object-issealed -- safe\nvar isSealed = $Object.isSealed;\n// eslint-disable-next-line es/no-object-freeze -- safe\nvar freeze = $Object.freeze;\n// eslint-disable-next-line es/no-object-seal -- safe\nvar seal = $Object.seal;\n\nvar FROZEN = {};\nvar SEALED = {};\nvar IS_IE11 = !global$2.ActiveXObject && 'ActiveXObject' in global$2;\nvar InternalWeakMap;\n\nvar wrapper = function (init) {\n  return function WeakMap() {\n    return init(this, arguments.length ? arguments[0] : undefined);\n  };\n};\n\n// `WeakMap` constructor\n// https://tc39.es/ecma262/#sec-weakmap-constructor\nvar $WeakMap = collection('WeakMap', wrapper, collectionWeak);\nvar WeakMapPrototype = $WeakMap.prototype;\nvar nativeSet = uncurryThis$1(WeakMapPrototype.set);\n\n// Chakra Edge bug: adding frozen arrays to WeakMap unfreeze them\nvar hasMSEdgeFreezingBug = function () {\n  return FREEZING && fails$1(function () {\n    var frozenArray = freeze([]);\n    nativeSet(new $WeakMap(), frozenArray, 1);\n    return !isFrozen(frozenArray);\n  });\n};\n\n// IE11 WeakMap frozen keys fix\n// We can't use feature detection because it crash some old IE builds\n// https://github.com/zloirock/core-js/issues/485\nif (NATIVE_WEAK_MAP) if (IS_IE11) {\n  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);\n  InternalMetadataModule.enable();\n  var nativeDelete = uncurryThis$1(WeakMapPrototype['delete']);\n  var nativeHas = uncurryThis$1(WeakMapPrototype.has);\n  var nativeGet = uncurryThis$1(WeakMapPrototype.get);\n  defineBuiltIns(WeakMapPrototype, {\n    'delete': function (key) {\n      if (isObject(key) && !isExtensible(key)) {\n        var state = enforceInternalState(this);\n        if (!state.frozen) state.frozen = new InternalWeakMap();\n        return nativeDelete(this, key) || state.frozen['delete'](key);\n      } return nativeDelete(this, key);\n    },\n    has: function has(key) {\n      if (isObject(key) && !isExtensible(key)) {\n        var state = enforceInternalState(this);\n        if (!state.frozen) state.frozen = new InternalWeakMap();\n        return nativeHas(this, key) || state.frozen.has(key);\n      } return nativeHas(this, key);\n    },\n    get: function get(key) {\n      if (isObject(key) && !isExtensible(key)) {\n        var state = enforceInternalState(this);\n        if (!state.frozen) state.frozen = new InternalWeakMap();\n        return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);\n      } return nativeGet(this, key);\n    },\n    set: function set(key, value) {\n      if (isObject(key) && !isExtensible(key)) {\n        var state = enforceInternalState(this);\n        if (!state.frozen) state.frozen = new InternalWeakMap();\n        nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);\n      } else nativeSet(this, key, value);\n      return this;\n    }\n  });\n// Chakra Edge frozen keys fix\n} else if (hasMSEdgeFreezingBug()) {\n  defineBuiltIns(WeakMapPrototype, {\n    set: function set(key, value) {\n      var arrayIntegrityLevel;\n      if (isArray(key)) {\n        if (isFrozen(key)) arrayIntegrityLevel = FROZEN;\n        else if (isSealed(key)) arrayIntegrityLevel = SEALED;\n      }\n      nativeSet(this, key, value);\n      if (arrayIntegrityLevel === FROZEN) freeze(key);\n      if (arrayIntegrityLevel === SEALED) seal(key);\n      return this;\n    }\n  });\n}\n\nvar path = path$w;\n\nvar weakMap$2 = path.WeakMap;\n\nvar parent$3 = weakMap$2;\n\n\nvar weakMap$1 = parent$3;\n\nvar weakMap = weakMap$1;\n\nvar _WeakMap = /*@__PURE__*/getDefaultExportFromCjs(weakMap);\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nfunction _createForOfIteratorHelper$3(o, allowArrayLike) { var it = typeof _Symbol !== \"undefined\" && _getIteratorMethod(o) || o[\"@@iterator\"]; if (!it) { if (_Array$isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$3(o, minLen) { var _context2; if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$3(o, minLen); var n = _sliceInstanceProperty(_context2 = Object.prototype.toString.call(o)).call(_context2, 8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return _Array$from$1(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }\nfunction _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar _SingleTypeSelectionAccumulator_previousSelection, _SingleTypeSelectionAccumulator_selection, _SelectionAccumulator_nodes, _SelectionAccumulator_edges, _SelectionAccumulator_commitHandler;\n/**\r\n * @param prev\r\n * @param next\r\n */\nfunction diffSets(prev, next) {\n  var diff = new _Set();\n  var _iterator = _createForOfIteratorHelper$3(next),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n      if (!prev.has(item)) {\n        diff.add(item);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return diff;\n}\nvar SingleTypeSelectionAccumulator = /*#__PURE__*/function () {\n  function SingleTypeSelectionAccumulator() {\n    _classCallCheck(this, SingleTypeSelectionAccumulator);\n    _SingleTypeSelectionAccumulator_previousSelection.set(this, new _Set());\n    _SingleTypeSelectionAccumulator_selection.set(this, new _Set());\n  }\n  _createClass(SingleTypeSelectionAccumulator, [{\n    key: \"size\",\n    get: function get() {\n      return __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\").size;\n    }\n  }, {\n    key: \"add\",\n    value: function add() {\n      for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n        items[_key] = arguments[_key];\n      }\n      for (var _i = 0, _items = items; _i < _items.length; _i++) {\n        var item = _items[_i];\n        __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\").add(item);\n      }\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        items[_key2] = arguments[_key2];\n      }\n      for (var _i2 = 0, _items2 = items; _i2 < _items2.length; _i2++) {\n        var item = _items2[_i2];\n        __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\").delete(item);\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\").clear();\n    }\n  }, {\n    key: \"getSelection\",\n    value: function getSelection() {\n      return _toConsumableArray(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\"));\n    }\n  }, {\n    key: \"getChanges\",\n    value: function getChanges() {\n      return {\n        added: _toConsumableArray(diffSets(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, \"f\"), __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\"))),\n        deleted: _toConsumableArray(diffSets(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\"), __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, \"f\"))),\n        previous: _toConsumableArray(new _Set(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, \"f\"))),\n        current: _toConsumableArray(new _Set(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\")))\n      };\n    }\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      var changes = this.getChanges();\n      __classPrivateFieldSet(this, _SingleTypeSelectionAccumulator_previousSelection, __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\"), \"f\");\n      __classPrivateFieldSet(this, _SingleTypeSelectionAccumulator_selection, new _Set(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, \"f\")), \"f\");\n      var _iterator2 = _createForOfIteratorHelper$3(changes.added),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var item = _step2.value;\n          item.select();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var _iterator3 = _createForOfIteratorHelper$3(changes.deleted),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _item = _step3.value;\n          _item.unselect();\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return changes;\n    }\n  }]);\n  return SingleTypeSelectionAccumulator;\n}();\n_SingleTypeSelectionAccumulator_previousSelection = new _WeakMap(), _SingleTypeSelectionAccumulator_selection = new _WeakMap();\nvar SelectionAccumulator = /*#__PURE__*/function () {\n  function SelectionAccumulator() {\n    var commitHandler = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n    _classCallCheck(this, SelectionAccumulator);\n    _SelectionAccumulator_nodes.set(this, new SingleTypeSelectionAccumulator());\n    _SelectionAccumulator_edges.set(this, new SingleTypeSelectionAccumulator());\n    _SelectionAccumulator_commitHandler.set(this, void 0);\n    __classPrivateFieldSet(this, _SelectionAccumulator_commitHandler, commitHandler, \"f\");\n  }\n  _createClass(SelectionAccumulator, [{\n    key: \"sizeNodes\",\n    get: function get() {\n      return __classPrivateFieldGet(this, _SelectionAccumulator_nodes, \"f\").size;\n    }\n  }, {\n    key: \"sizeEdges\",\n    get: function get() {\n      return __classPrivateFieldGet(this, _SelectionAccumulator_edges, \"f\").size;\n    }\n  }, {\n    key: \"getNodes\",\n    value: function getNodes() {\n      return __classPrivateFieldGet(this, _SelectionAccumulator_nodes, \"f\").getSelection();\n    }\n  }, {\n    key: \"getEdges\",\n    value: function getEdges() {\n      return __classPrivateFieldGet(this, _SelectionAccumulator_edges, \"f\").getSelection();\n    }\n  }, {\n    key: \"addNodes\",\n    value: function addNodes() {\n      var _classPrivateFieldGe;\n      (_classPrivateFieldGe = __classPrivateFieldGet(this, _SelectionAccumulator_nodes, \"f\")).add.apply(_classPrivateFieldGe, arguments);\n    }\n  }, {\n    key: \"addEdges\",\n    value: function addEdges() {\n      var _classPrivateFieldGe2;\n      (_classPrivateFieldGe2 = __classPrivateFieldGet(this, _SelectionAccumulator_edges, \"f\")).add.apply(_classPrivateFieldGe2, arguments);\n    }\n  }, {\n    key: \"deleteNodes\",\n    value: function deleteNodes(node) {\n      __classPrivateFieldGet(this, _SelectionAccumulator_nodes, \"f\").delete(node);\n    }\n  }, {\n    key: \"deleteEdges\",\n    value: function deleteEdges(edge) {\n      __classPrivateFieldGet(this, _SelectionAccumulator_edges, \"f\").delete(edge);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      __classPrivateFieldGet(this, _SelectionAccumulator_nodes, \"f\").clear();\n      __classPrivateFieldGet(this, _SelectionAccumulator_edges, \"f\").clear();\n    }\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      var _classPrivateFieldGe3, _context;\n      var summary = {\n        nodes: __classPrivateFieldGet(this, _SelectionAccumulator_nodes, \"f\").commit(),\n        edges: __classPrivateFieldGet(this, _SelectionAccumulator_edges, \"f\").commit()\n      };\n      for (var _len3 = arguments.length, rest = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        rest[_key3] = arguments[_key3];\n      }\n      (_classPrivateFieldGe3 = __classPrivateFieldGet(this, _SelectionAccumulator_commitHandler, \"f\")).call.apply(_classPrivateFieldGe3, _concatInstanceProperty(_context = [this, summary]).call(_context, rest));\n      return summary;\n    }\n  }]);\n  return SelectionAccumulator;\n}();\n_SelectionAccumulator_nodes = new _WeakMap(), _SelectionAccumulator_edges = new _WeakMap(), _SelectionAccumulator_commitHandler = new _WeakMap();\n\nfunction _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof _Symbol !== \"undefined\" && _getIteratorMethod(o) || o[\"@@iterator\"]; if (!it) { if (_Array$isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$2(o, minLen) { var _context3; if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$2(o, minLen); var n = _sliceInstanceProperty(_context3 = Object.prototype.toString.call(o)).call(_context3, 8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return _Array$from$1(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }\nfunction _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n/**\n * The handler for selections\n */\nvar SelectionHandler = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {Canvas} canvas\n   */\n  function SelectionHandler(body, canvas) {\n    var _this = this;\n    _classCallCheck(this, SelectionHandler);\n    this.body = body;\n    this.canvas = canvas;\n    // TODO: Consider firing an event on any change to the selection, not\n    // only those caused by clicks and taps. It would be easy to implement\n    // now and (at least to me) it seems like something that could be\n    // quite useful.\n    this._selectionAccumulator = new SelectionAccumulator();\n    this.hoverObj = {\n      nodes: {},\n      edges: {}\n    };\n    this.options = {};\n    this.defaultOptions = {\n      multiselect: false,\n      selectable: true,\n      selectConnectedEdges: true,\n      hoverConnectedEdges: true\n    };\n    _Object$assign(this.options, this.defaultOptions);\n    this.body.emitter.on(\"_dataChanged\", function () {\n      _this.updateSelection();\n    });\n  }\n\n  /**\n   *\n   * @param {object} [options]\n   */\n  _createClass(SelectionHandler, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        var fields = [\"multiselect\", \"hoverConnectedEdges\", \"selectable\", \"selectConnectedEdges\"];\n        selectiveDeepExtend(fields, this.options, options);\n      }\n    }\n\n    /**\n     * handles the selection part of the tap;\n     *\n     * @param {{x: number, y: number}} pointer\n     * @returns {boolean}\n     */\n  }, {\n    key: \"selectOnPoint\",\n    value: function selectOnPoint(pointer) {\n      var selected = false;\n      if (this.options.selectable === true) {\n        var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);\n\n        // unselect after getting the objects in order to restore width and height.\n        this.unselectAll();\n        if (obj !== undefined) {\n          selected = this.selectObject(obj);\n        }\n        this.body.emitter.emit(\"_requestRedraw\");\n      }\n      return selected;\n    }\n\n    /**\n     *\n     * @param {{x: number, y: number}} pointer\n     * @returns {boolean}\n     */\n  }, {\n    key: \"selectAdditionalOnPoint\",\n    value: function selectAdditionalOnPoint(pointer) {\n      var selectionChanged = false;\n      if (this.options.selectable === true) {\n        var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);\n        if (obj !== undefined) {\n          selectionChanged = true;\n          if (obj.isSelected() === true) {\n            this.deselectObject(obj);\n          } else {\n            this.selectObject(obj);\n          }\n          this.body.emitter.emit(\"_requestRedraw\");\n        }\n      }\n      return selectionChanged;\n    }\n\n    /**\n     * Create an object containing the standard fields for an event.\n     *\n     * @param {Event} event\n     * @param {{x: number, y: number}} pointer Object with the x and y screen coordinates of the mouse\n     * @returns {{}}\n     * @private\n     */\n  }, {\n    key: \"_initBaseEvent\",\n    value: function _initBaseEvent(event, pointer) {\n      var properties = {};\n      properties[\"pointer\"] = {\n        DOM: {\n          x: pointer.x,\n          y: pointer.y\n        },\n        canvas: this.canvas.DOMtoCanvas(pointer)\n      };\n      properties[\"event\"] = event;\n      return properties;\n    }\n\n    /**\n     * Generate an event which the user can catch.\n     *\n     * This adds some extra data to the event with respect to cursor position and\n     * selected nodes and edges.\n     *\n     * @param {string} eventType                          Name of event to send\n     * @param {Event}  event\n     * @param {{x: number, y: number}} pointer            Object with the x and y screen coordinates of the mouse\n     * @param {object | undefined} oldSelection             If present, selection state before event occured\n     * @param {boolean|undefined} [emptySelection=false]  Indicate if selection data should be passed\n     */\n  }, {\n    key: \"generateClickEvent\",\n    value: function generateClickEvent(eventType, event, pointer, oldSelection) {\n      var emptySelection = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var properties = this._initBaseEvent(event, pointer);\n      if (emptySelection === true) {\n        properties.nodes = [];\n        properties.edges = [];\n      } else {\n        var tmp = this.getSelection();\n        properties.nodes = tmp.nodes;\n        properties.edges = tmp.edges;\n      }\n      if (oldSelection !== undefined) {\n        properties[\"previousSelection\"] = oldSelection;\n      }\n      if (eventType == \"click\") {\n        // For the time being, restrict this functionality to\n        // just the click event.\n        properties.items = this.getClickedItems(pointer);\n      }\n      if (event.controlEdge !== undefined) {\n        properties.controlEdge = event.controlEdge;\n      }\n      this.body.emitter.emit(eventType, properties);\n    }\n\n    /**\n     *\n     * @param {object} obj\n     * @param {boolean} [highlightEdges=this.options.selectConnectedEdges]\n     * @returns {boolean}\n     */\n  }, {\n    key: \"selectObject\",\n    value: function selectObject(obj) {\n      var highlightEdges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.selectConnectedEdges;\n      if (obj !== undefined) {\n        if (obj instanceof Node) {\n          if (highlightEdges === true) {\n            var _this$_selectionAccum;\n            (_this$_selectionAccum = this._selectionAccumulator).addEdges.apply(_this$_selectionAccum, _toConsumableArray(obj.edges));\n          }\n          this._selectionAccumulator.addNodes(obj);\n        } else {\n          this._selectionAccumulator.addEdges(obj);\n        }\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     *\n     * @param {object} obj\n     */\n  }, {\n    key: \"deselectObject\",\n    value: function deselectObject(obj) {\n      if (obj.isSelected() === true) {\n        obj.selected = false;\n        this._removeFromSelection(obj);\n      }\n    }\n\n    /**\n     * retrieve all nodes overlapping with given object\n     *\n     * @param {object} object  An object with parameters left, top, right, bottom\n     * @returns {number[]}   An array with id's of the overlapping nodes\n     * @private\n     */\n  }, {\n    key: \"_getAllNodesOverlappingWith\",\n    value: function _getAllNodesOverlappingWith(object) {\n      var overlappingNodes = [];\n      var nodes = this.body.nodes;\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        var nodeId = this.body.nodeIndices[i];\n        if (nodes[nodeId].isOverlappingWith(object)) {\n          overlappingNodes.push(nodeId);\n        }\n      }\n      return overlappingNodes;\n    }\n\n    /**\n     * Return a position object in canvasspace from a single point in screenspace\n     *\n     * @param {{x: number, y: number}} pointer\n     * @returns {{left: number, top: number, right: number, bottom: number}}\n     * @private\n     */\n  }, {\n    key: \"_pointerToPositionObject\",\n    value: function _pointerToPositionObject(pointer) {\n      var canvasPos = this.canvas.DOMtoCanvas(pointer);\n      return {\n        left: canvasPos.x - 1,\n        top: canvasPos.y + 1,\n        right: canvasPos.x + 1,\n        bottom: canvasPos.y - 1\n      };\n    }\n\n    /**\n     * Get the top node at the passed point (like a click)\n     *\n     * @param {{x: number, y: number}} pointer\n     * @param {boolean} [returnNode=true]\n     * @returns {Node | undefined} node\n     */\n  }, {\n    key: \"getNodeAt\",\n    value: function getNodeAt(pointer) {\n      var returnNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      // we first check if this is an navigation controls element\n      var positionObject = this._pointerToPositionObject(pointer);\n      var overlappingNodes = this._getAllNodesOverlappingWith(positionObject);\n      // if there are overlapping nodes, select the last one, this is the\n      // one which is drawn on top of the others\n      if (overlappingNodes.length > 0) {\n        if (returnNode === true) {\n          return this.body.nodes[overlappingNodes[overlappingNodes.length - 1]];\n        } else {\n          return overlappingNodes[overlappingNodes.length - 1];\n        }\n      } else {\n        return undefined;\n      }\n    }\n\n    /**\n     * retrieve all edges overlapping with given object, selector is around center\n     *\n     * @param {object} object  An object with parameters left, top, right, bottom\n     * @param {number[]} overlappingEdges An array with id's of the overlapping nodes\n     * @private\n     */\n  }, {\n    key: \"_getEdgesOverlappingWith\",\n    value: function _getEdgesOverlappingWith(object, overlappingEdges) {\n      var edges = this.body.edges;\n      for (var i = 0; i < this.body.edgeIndices.length; i++) {\n        var edgeId = this.body.edgeIndices[i];\n        if (edges[edgeId].isOverlappingWith(object)) {\n          overlappingEdges.push(edgeId);\n        }\n      }\n    }\n\n    /**\n     * retrieve all nodes overlapping with given object\n     *\n     * @param {object} object  An object with parameters left, top, right, bottom\n     * @returns {number[]}   An array with id's of the overlapping nodes\n     * @private\n     */\n  }, {\n    key: \"_getAllEdgesOverlappingWith\",\n    value: function _getAllEdgesOverlappingWith(object) {\n      var overlappingEdges = [];\n      this._getEdgesOverlappingWith(object, overlappingEdges);\n      return overlappingEdges;\n    }\n\n    /**\n     * Get the edges nearest to the passed point (like a click)\n     *\n     * @param {{x: number, y: number}} pointer\n     * @param {boolean} [returnEdge=true]\n     * @returns {Edge | undefined} node\n     */\n  }, {\n    key: \"getEdgeAt\",\n    value: function getEdgeAt(pointer) {\n      var returnEdge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      // Iterate over edges, pick closest within 10\n      var canvasPos = this.canvas.DOMtoCanvas(pointer);\n      var mindist = 10;\n      var overlappingEdge = null;\n      var edges = this.body.edges;\n      for (var i = 0; i < this.body.edgeIndices.length; i++) {\n        var edgeId = this.body.edgeIndices[i];\n        var edge = edges[edgeId];\n        if (edge.connected) {\n          var xFrom = edge.from.x;\n          var yFrom = edge.from.y;\n          var xTo = edge.to.x;\n          var yTo = edge.to.y;\n          var dist = edge.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, canvasPos.x, canvasPos.y);\n          if (dist < mindist) {\n            overlappingEdge = edgeId;\n            mindist = dist;\n          }\n        }\n      }\n      if (overlappingEdge !== null) {\n        if (returnEdge === true) {\n          return this.body.edges[overlappingEdge];\n        } else {\n          return overlappingEdge;\n        }\n      } else {\n        return undefined;\n      }\n    }\n\n    /**\n     * Add object to the selection array.\n     *\n     * @param {object} obj\n     * @private\n     */\n  }, {\n    key: \"_addToHover\",\n    value: function _addToHover(obj) {\n      if (obj instanceof Node) {\n        this.hoverObj.nodes[obj.id] = obj;\n      } else {\n        this.hoverObj.edges[obj.id] = obj;\n      }\n    }\n\n    /**\n     * Remove a single option from selection.\n     *\n     * @param {object} obj\n     * @private\n     */\n  }, {\n    key: \"_removeFromSelection\",\n    value: function _removeFromSelection(obj) {\n      if (obj instanceof Node) {\n        var _this$_selectionAccum2;\n        this._selectionAccumulator.deleteNodes(obj);\n        (_this$_selectionAccum2 = this._selectionAccumulator).deleteEdges.apply(_this$_selectionAccum2, _toConsumableArray(obj.edges));\n      } else {\n        this._selectionAccumulator.deleteEdges(obj);\n      }\n    }\n\n    /**\n     * Unselect all nodes and edges.\n     */\n  }, {\n    key: \"unselectAll\",\n    value: function unselectAll() {\n      this._selectionAccumulator.clear();\n    }\n\n    /**\n     * return the number of selected nodes\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getSelectedNodeCount\",\n    value: function getSelectedNodeCount() {\n      return this._selectionAccumulator.sizeNodes;\n    }\n\n    /**\n     * return the number of selected edges\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getSelectedEdgeCount\",\n    value: function getSelectedEdgeCount() {\n      return this._selectionAccumulator.sizeEdges;\n    }\n\n    /**\n     * select the edges connected to the node that is being selected\n     *\n     * @param {Node} node\n     * @private\n     */\n  }, {\n    key: \"_hoverConnectedEdges\",\n    value: function _hoverConnectedEdges(node) {\n      for (var i = 0; i < node.edges.length; i++) {\n        var edge = node.edges[i];\n        edge.hover = true;\n        this._addToHover(edge);\n      }\n    }\n\n    /**\n     * Remove the highlight from a node or edge, in response to mouse movement\n     *\n     * @param {Event}  event\n     * @param {{x: number, y: number}} pointer object with the x and y screen coordinates of the mouse\n     * @param {Node|vis.Edge} object\n     * @private\n     */\n  }, {\n    key: \"emitBlurEvent\",\n    value: function emitBlurEvent(event, pointer, object) {\n      var properties = this._initBaseEvent(event, pointer);\n      if (object.hover === true) {\n        object.hover = false;\n        if (object instanceof Node) {\n          properties.node = object.id;\n          this.body.emitter.emit(\"blurNode\", properties);\n        } else {\n          properties.edge = object.id;\n          this.body.emitter.emit(\"blurEdge\", properties);\n        }\n      }\n    }\n\n    /**\n     * Create the highlight for a node or edge, in response to mouse movement\n     *\n     * @param {Event}  event\n     * @param {{x: number, y: number}} pointer object with the x and y screen coordinates of the mouse\n     * @param {Node|vis.Edge} object\n     * @returns {boolean} hoverChanged\n     * @private\n     */\n  }, {\n    key: \"emitHoverEvent\",\n    value: function emitHoverEvent(event, pointer, object) {\n      var properties = this._initBaseEvent(event, pointer);\n      var hoverChanged = false;\n      if (object.hover === false) {\n        object.hover = true;\n        this._addToHover(object);\n        hoverChanged = true;\n        if (object instanceof Node) {\n          properties.node = object.id;\n          this.body.emitter.emit(\"hoverNode\", properties);\n        } else {\n          properties.edge = object.id;\n          this.body.emitter.emit(\"hoverEdge\", properties);\n        }\n      }\n      return hoverChanged;\n    }\n\n    /**\n     * Perform actions in response to a mouse movement.\n     *\n     * @param {Event}  event\n     * @param {{x: number, y: number}} pointer | object with the x and y screen coordinates of the mouse\n     */\n  }, {\n    key: \"hoverObject\",\n    value: function hoverObject(event, pointer) {\n      var object = this.getNodeAt(pointer);\n      if (object === undefined) {\n        object = this.getEdgeAt(pointer);\n      }\n      var hoverChanged = false;\n      // remove all node hover highlights\n      for (var nodeId in this.hoverObj.nodes) {\n        if (Object.prototype.hasOwnProperty.call(this.hoverObj.nodes, nodeId)) {\n          if (object === undefined || object instanceof Node && object.id != nodeId || object instanceof Edge) {\n            this.emitBlurEvent(event, pointer, this.hoverObj.nodes[nodeId]);\n            delete this.hoverObj.nodes[nodeId];\n            hoverChanged = true;\n          }\n        }\n      }\n\n      // removing all edge hover highlights\n      for (var edgeId in this.hoverObj.edges) {\n        if (Object.prototype.hasOwnProperty.call(this.hoverObj.edges, edgeId)) {\n          // if the hover has been changed here it means that the node has been hovered over or off\n          // we then do not use the emitBlurEvent method here.\n          if (hoverChanged === true) {\n            this.hoverObj.edges[edgeId].hover = false;\n            delete this.hoverObj.edges[edgeId];\n          }\n          // if the blur remains the same and the object is undefined (mouse off) or another\n          // edge has been hovered, or another node has been hovered we blur the edge.\n          else if (object === undefined || object instanceof Edge && object.id != edgeId || object instanceof Node && !object.hover) {\n            this.emitBlurEvent(event, pointer, this.hoverObj.edges[edgeId]);\n            delete this.hoverObj.edges[edgeId];\n            hoverChanged = true;\n          }\n        }\n      }\n      if (object !== undefined) {\n        var hoveredEdgesCount = _Object$keys(this.hoverObj.edges).length;\n        var hoveredNodesCount = _Object$keys(this.hoverObj.nodes).length;\n        var newOnlyHoveredEdge = object instanceof Edge && hoveredEdgesCount === 0 && hoveredNodesCount === 0;\n        var newOnlyHoveredNode = object instanceof Node && hoveredEdgesCount === 0 && hoveredNodesCount === 0;\n        if (hoverChanged || newOnlyHoveredEdge || newOnlyHoveredNode) {\n          hoverChanged = this.emitHoverEvent(event, pointer, object);\n        }\n        if (object instanceof Node && this.options.hoverConnectedEdges === true) {\n          this._hoverConnectedEdges(object);\n        }\n      }\n      if (hoverChanged === true) {\n        this.body.emitter.emit(\"_requestRedraw\");\n      }\n    }\n\n    /**\n     * Commit the selection changes but don't emit any events.\n     */\n  }, {\n    key: \"commitWithoutEmitting\",\n    value: function commitWithoutEmitting() {\n      this._selectionAccumulator.commit();\n    }\n\n    /**\n     * Select and deselect nodes depending current selection change.\n     *\n     * For changing nodes, select/deselect events are fired.\n     *\n     * NOTE: For a given edge, if one connecting node is deselected and with the\n     * same click the other node is selected, no events for the edge will fire. It\n     * was selected and it will remain selected.\n     *\n     * @param {{x: number, y: number}} pointer - The x and y coordinates of the\n     * click, tap, dragendâ¦ that triggered this.\n     * @param {UIEvent} event - The event that triggered this.\n     */\n  }, {\n    key: \"commitAndEmit\",\n    value: function commitAndEmit(pointer, event) {\n      var selected = false;\n      var selectionChanges = this._selectionAccumulator.commit();\n      var previousSelection = {\n        nodes: selectionChanges.nodes.previous,\n        edges: selectionChanges.edges.previous\n      };\n      if (selectionChanges.edges.deleted.length > 0) {\n        this.generateClickEvent(\"deselectEdge\", event, pointer, previousSelection);\n        selected = true;\n      }\n      if (selectionChanges.nodes.deleted.length > 0) {\n        this.generateClickEvent(\"deselectNode\", event, pointer, previousSelection);\n        selected = true;\n      }\n      if (selectionChanges.nodes.added.length > 0) {\n        this.generateClickEvent(\"selectNode\", event, pointer);\n        selected = true;\n      }\n      if (selectionChanges.edges.added.length > 0) {\n        this.generateClickEvent(\"selectEdge\", event, pointer);\n        selected = true;\n      }\n\n      // fire the select event if anything has been selected or deselected\n      if (selected === true) {\n        // select or unselect\n        this.generateClickEvent(\"select\", event, pointer);\n      }\n    }\n\n    /**\n     * Retrieve the currently selected node and edge ids.\n     *\n     * @returns {{nodes: Array.<string>, edges: Array.<string>}} Arrays with the\n     * ids of the selected nodes and edges.\n     */\n  }, {\n    key: \"getSelection\",\n    value: function getSelection() {\n      return {\n        nodes: this.getSelectedNodeIds(),\n        edges: this.getSelectedEdgeIds()\n      };\n    }\n\n    /**\n     * Retrieve the currently selected nodes.\n     *\n     * @returns {Array} An array with selected nodes.\n     */\n  }, {\n    key: \"getSelectedNodes\",\n    value: function getSelectedNodes() {\n      return this._selectionAccumulator.getNodes();\n    }\n\n    /**\n     * Retrieve the currently selected edges.\n     *\n     * @returns {Array} An array with selected edges.\n     */\n  }, {\n    key: \"getSelectedEdges\",\n    value: function getSelectedEdges() {\n      return this._selectionAccumulator.getEdges();\n    }\n\n    /**\n     * Retrieve the currently selected node ids.\n     *\n     * @returns {Array} An array with the ids of the selected nodes.\n     */\n  }, {\n    key: \"getSelectedNodeIds\",\n    value: function getSelectedNodeIds() {\n      var _context;\n      return _mapInstanceProperty(_context = this._selectionAccumulator.getNodes()).call(_context, function (node) {\n        return node.id;\n      });\n    }\n\n    /**\n     * Retrieve the currently selected edge ids.\n     *\n     * @returns {Array} An array with the ids of the selected edges.\n     */\n  }, {\n    key: \"getSelectedEdgeIds\",\n    value: function getSelectedEdgeIds() {\n      var _context2;\n      return _mapInstanceProperty(_context2 = this._selectionAccumulator.getEdges()).call(_context2, function (edge) {\n        return edge.id;\n      });\n    }\n\n    /**\n     * Updates the current selection\n     *\n     * @param {{nodes: Array.<string>, edges: Array.<string>}} selection\n     * @param {object} options                                 Options\n     */\n  }, {\n    key: \"setSelection\",\n    value: function setSelection(selection) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (!selection || !selection.nodes && !selection.edges) {\n        throw new TypeError(\"Selection must be an object with nodes and/or edges properties\");\n      }\n\n      // first unselect any selected node, if option is true or undefined\n      if (options.unselectAll || options.unselectAll === undefined) {\n        this.unselectAll();\n      }\n      if (selection.nodes) {\n        var _iterator = _createForOfIteratorHelper$2(selection.nodes),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var id = _step.value;\n            var node = this.body.nodes[id];\n            if (!node) {\n              throw new RangeError('Node with id \"' + id + '\" not found');\n            }\n            // don't select edges with it\n            this.selectObject(node, options.highlightEdges);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      if (selection.edges) {\n        var _iterator2 = _createForOfIteratorHelper$2(selection.edges),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _id = _step2.value;\n            var edge = this.body.edges[_id];\n            if (!edge) {\n              throw new RangeError('Edge with id \"' + _id + '\" not found');\n            }\n            this.selectObject(edge);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      this.body.emitter.emit(\"_requestRedraw\");\n      this._selectionAccumulator.commit();\n    }\n\n    /**\n     * select zero or more nodes with the option to highlight edges\n     *\n     * @param {number[] | string[]} selection     An array with the ids of the\n     *                                            selected nodes.\n     * @param {boolean} [highlightEdges]\n     */\n  }, {\n    key: \"selectNodes\",\n    value: function selectNodes(selection) {\n      var highlightEdges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (!selection || selection.length === undefined) throw \"Selection must be an array with ids\";\n      this.setSelection({\n        nodes: selection\n      }, {\n        highlightEdges: highlightEdges\n      });\n    }\n\n    /**\n     * select zero or more edges\n     *\n     * @param {number[] | string[]} selection     An array with the ids of the\n     *                                            selected nodes.\n     */\n  }, {\n    key: \"selectEdges\",\n    value: function selectEdges(selection) {\n      if (!selection || selection.length === undefined) throw \"Selection must be an array with ids\";\n      this.setSelection({\n        edges: selection\n      });\n    }\n\n    /**\n     * Validate the selection: remove ids of nodes which no longer exist\n     *\n     * @private\n     */\n  }, {\n    key: \"updateSelection\",\n    value: function updateSelection() {\n      for (var node in this._selectionAccumulator.getNodes()) {\n        if (!Object.prototype.hasOwnProperty.call(this.body.nodes, node.id)) {\n          this._selectionAccumulator.deleteNodes(node);\n        }\n      }\n      for (var edge in this._selectionAccumulator.getEdges()) {\n        if (!Object.prototype.hasOwnProperty.call(this.body.edges, edge.id)) {\n          this._selectionAccumulator.deleteEdges(edge);\n        }\n      }\n    }\n\n    /**\n     * Determine all the visual elements clicked which are on the given point.\n     *\n     * All elements are returned; this includes nodes, edges and their labels.\n     * The order returned is from highest to lowest, i.e. element 0 of the return\n     * value is the topmost item clicked on.\n     *\n     * The return value consists of an array of the following possible elements:\n     *\n     * - `{nodeId:number}`             - node with given id clicked on\n     * - `{nodeId:number, labelId:0}`  - label of node with given id clicked on\n     * - `{edgeId:number}`             - edge with given id clicked on\n     * - `{edge:number, labelId:0}`    - label of edge with given id clicked on\n     *\n     * ## NOTES\n     *\n     * - Currently, there is only one label associated with a node or an edge,\n     *   but this is expected to change somewhere in the future.\n     * - Since there is no z-indexing yet, it is not really possible to set the nodes and\n     *   edges in the correct order. For the time being, nodes come first.\n     *\n     * @param {point} pointer  mouse position in screen coordinates\n     * @returns {Array.<nodeClickItem|nodeLabelClickItem|edgeClickItem|edgeLabelClickItem>}\n     * @private\n     */\n  }, {\n    key: \"getClickedItems\",\n    value: function getClickedItems(pointer) {\n      var point = this.canvas.DOMtoCanvas(pointer);\n      var items = [];\n\n      // Note reverse order; we want the topmost clicked items to be first in the array\n      // Also note that selected nodes are disregarded here; these normally display on top\n      var nodeIndices = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n      for (var i = nodeIndices.length - 1; i >= 0; i--) {\n        var node = nodes[nodeIndices[i]];\n        var ret = node.getItemsOnPoint(point);\n        items.push.apply(items, ret); // Append the return value to the running list.\n      }\n\n      var edgeIndices = this.body.edgeIndices;\n      var edges = this.body.edges;\n      for (var _i = edgeIndices.length - 1; _i >= 0; _i--) {\n        var edge = edges[edgeIndices[_i]];\n        var _ret = edge.getItemsOnPoint(point);\n        items.push.apply(items, _ret); // Append the return value to the running list.\n      }\n\n      return items;\n    }\n  }]);\n  return SelectionHandler;\n}();\n\nvar arraySlice = arraySliceSimple;\n\nvar floor = Math.floor;\n\nvar mergeSort = function (array, comparefn) {\n  var length = array.length;\n  var middle = floor(length / 2);\n  return length < 8 ? insertionSort(array, comparefn) : merge(\n    array,\n    mergeSort(arraySlice(array, 0, middle), comparefn),\n    mergeSort(arraySlice(array, middle), comparefn),\n    comparefn\n  );\n};\n\nvar insertionSort = function (array, comparefn) {\n  var length = array.length;\n  var i = 1;\n  var element, j;\n\n  while (i < length) {\n    j = i;\n    element = array[i];\n    while (j && comparefn(array[j - 1], element) > 0) {\n      array[j] = array[--j];\n    }\n    if (j !== i++) array[j] = element;\n  } return array;\n};\n\nvar merge = function (array, left, right, comparefn) {\n  var llength = left.length;\n  var rlength = right.length;\n  var lindex = 0;\n  var rindex = 0;\n\n  while (lindex < llength || rindex < rlength) {\n    array[lindex + rindex] = (lindex < llength && rindex < rlength)\n      ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]\n      : lindex < llength ? left[lindex++] : right[rindex++];\n  } return array;\n};\n\nvar arraySort = mergeSort;\n\nvar userAgent$1 = engineUserAgent;\n\nvar firefox = userAgent$1.match(/firefox\\/(\\d+)/i);\n\nvar engineFfVersion = !!firefox && +firefox[1];\n\nvar UA = engineUserAgent;\n\nvar engineIsIeOrEdge = /MSIE|Trident/.test(UA);\n\nvar userAgent = engineUserAgent;\n\nvar webkit = userAgent.match(/AppleWebKit\\/(\\d+)\\./);\n\nvar engineWebkitVersion = !!webkit && +webkit[1];\n\nvar $$2 = _export;\nvar uncurryThis = functionUncurryThis;\nvar aCallable$1 = aCallable$7;\nvar toObject$1 = toObject$e;\nvar lengthOfArrayLike$1 = lengthOfArrayLike$c;\nvar deletePropertyOrThrow = deletePropertyOrThrow$2;\nvar toString = toString$a;\nvar fails = fails$w;\nvar internalSort = arraySort;\nvar arrayMethodIsStrict$2 = arrayMethodIsStrict$6;\nvar FF = engineFfVersion;\nvar IE_OR_EDGE = engineIsIeOrEdge;\nvar V8 = engineV8Version;\nvar WEBKIT = engineWebkitVersion;\n\nvar test = [];\nvar nativeSort = uncurryThis(test.sort);\nvar push = uncurryThis(test.push);\n\n// IE8-\nvar FAILS_ON_UNDEFINED = fails(function () {\n  test.sort(undefined);\n});\n// V8 bug\nvar FAILS_ON_NULL = fails(function () {\n  test.sort(null);\n});\n// Old WebKit\nvar STRICT_METHOD$1 = arrayMethodIsStrict$2('sort');\n\nvar STABLE_SORT = !fails(function () {\n  // feature detection can be too slow, so check engines versions\n  if (V8) return V8 < 70;\n  if (FF && FF > 3) return;\n  if (IE_OR_EDGE) return true;\n  if (WEBKIT) return WEBKIT < 603;\n\n  var result = '';\n  var code, chr, value, index;\n\n  // generate an array with more 512 elements (Chakra and old V8 fails only in this case)\n  for (code = 65; code < 76; code++) {\n    chr = String.fromCharCode(code);\n\n    switch (code) {\n      case 66: case 69: case 70: case 72: value = 3; break;\n      case 68: case 71: value = 4; break;\n      default: value = 2;\n    }\n\n    for (index = 0; index < 47; index++) {\n      test.push({ k: chr + index, v: value });\n    }\n  }\n\n  test.sort(function (a, b) { return b.v - a.v; });\n\n  for (index = 0; index < test.length; index++) {\n    chr = test[index].k.charAt(0);\n    if (result.charAt(result.length - 1) !== chr) result += chr;\n  }\n\n  return result !== 'DGBEFHACIJK';\n});\n\nvar FORCED$1 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$1 || !STABLE_SORT;\n\nvar getSortCompare = function (comparefn) {\n  return function (x, y) {\n    if (y === undefined) return -1;\n    if (x === undefined) return 1;\n    if (comparefn !== undefined) return +comparefn(x, y) || 0;\n    return toString(x) > toString(y) ? 1 : -1;\n  };\n};\n\n// `Array.prototype.sort` method\n// https://tc39.es/ecma262/#sec-array.prototype.sort\n$$2({ target: 'Array', proto: true, forced: FORCED$1 }, {\n  sort: function sort(comparefn) {\n    if (comparefn !== undefined) aCallable$1(comparefn);\n\n    var array = toObject$1(this);\n\n    if (STABLE_SORT) return comparefn === undefined ? nativeSort(array) : nativeSort(array, comparefn);\n\n    var items = [];\n    var arrayLength = lengthOfArrayLike$1(array);\n    var itemsLength, index;\n\n    for (index = 0; index < arrayLength; index++) {\n      if (index in array) push(items, array[index]);\n    }\n\n    internalSort(items, getSortCompare(comparefn));\n\n    itemsLength = lengthOfArrayLike$1(items);\n    index = 0;\n\n    while (index < itemsLength) array[index] = items[index++];\n    while (index < arrayLength) deletePropertyOrThrow(array, index++);\n\n    return array;\n  }\n});\n\nvar entryVirtual$2 = entryVirtual$i;\n\nvar sort$3 = entryVirtual$2('Array').sort;\n\nvar isPrototypeOf$2 = objectIsPrototypeOf;\nvar method$2 = sort$3;\n\nvar ArrayPrototype$2 = Array.prototype;\n\nvar sort$2 = function (it) {\n  var own = it.sort;\n  return it === ArrayPrototype$2 || (isPrototypeOf$2(ArrayPrototype$2, it) && own === ArrayPrototype$2.sort) ? method$2 : own;\n};\n\nvar parent$2 = sort$2;\n\nvar sort$1 = parent$2;\n\nvar sort = sort$1;\n\nvar _sortInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(sort);\n\nvar aCallable = aCallable$7;\nvar toObject = toObject$e;\nvar IndexedObject = indexedObject;\nvar lengthOfArrayLike = lengthOfArrayLike$c;\n\nvar $TypeError = TypeError;\n\n// `Array.prototype.{ reduce, reduceRight }` methods implementation\nvar createMethod = function (IS_RIGHT) {\n  return function (that, callbackfn, argumentsLength, memo) {\n    aCallable(callbackfn);\n    var O = toObject(that);\n    var self = IndexedObject(O);\n    var length = lengthOfArrayLike(O);\n    var index = IS_RIGHT ? length - 1 : 0;\n    var i = IS_RIGHT ? -1 : 1;\n    if (argumentsLength < 2) while (true) {\n      if (index in self) {\n        memo = self[index];\n        index += i;\n        break;\n      }\n      index += i;\n      if (IS_RIGHT ? index < 0 : length <= index) {\n        throw new $TypeError('Reduce of empty array with no initial value');\n      }\n    }\n    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {\n      memo = callbackfn(memo, self[index], index, O);\n    }\n    return memo;\n  };\n};\n\nvar arrayReduce = {\n  // `Array.prototype.reduce` method\n  // https://tc39.es/ecma262/#sec-array.prototype.reduce\n  left: createMethod(false),\n  // `Array.prototype.reduceRight` method\n  // https://tc39.es/ecma262/#sec-array.prototype.reduceright\n  right: createMethod(true)\n};\n\nvar global$1 = global$n;\nvar classof = classofRaw$2;\n\nvar engineIsNode = classof(global$1.process) === 'process';\n\nvar $$1 = _export;\nvar $reduce = arrayReduce.left;\nvar arrayMethodIsStrict$1 = arrayMethodIsStrict$6;\nvar CHROME_VERSION = engineV8Version;\nvar IS_NODE = engineIsNode;\n\n// Chrome 80-82 has a critical bug\n// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982\nvar CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;\nvar FORCED = CHROME_BUG || !arrayMethodIsStrict$1('reduce');\n\n// `Array.prototype.reduce` method\n// https://tc39.es/ecma262/#sec-array.prototype.reduce\n$$1({ target: 'Array', proto: true, forced: FORCED }, {\n  reduce: function reduce(callbackfn /* , initialValue */) {\n    var length = arguments.length;\n    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar entryVirtual$1 = entryVirtual$i;\n\nvar reduce$3 = entryVirtual$1('Array').reduce;\n\nvar isPrototypeOf$1 = objectIsPrototypeOf;\nvar method$1 = reduce$3;\n\nvar ArrayPrototype$1 = Array.prototype;\n\nvar reduce$2 = function (it) {\n  var own = it.reduce;\n  return it === ArrayPrototype$1 || (isPrototypeOf$1(ArrayPrototype$1, it) && own === ArrayPrototype$1.reduce) ? method$1 : own;\n};\n\nvar parent$1 = reduce$2;\n\nvar reduce$1 = parent$1;\n\nvar reduce = reduce$1;\n\nvar _reduceInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(reduce);\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n/**\n * Helper classes for LayoutEngine.\n *\n * Strategy pattern for usage of direction methods for hierarchical layouts.\n */\n/**\n * Interface definition for direction strategy classes.\n *\n * This class describes the interface for the Strategy\n * pattern classes used to differentiate horizontal and vertical\n * direction of hierarchical results.\n *\n * For a given direction, one coordinate will be 'fixed', meaning that it is\n * determined by level.\n * The other coordinate is 'unfixed', meaning that the nodes on a given level\n * can still move along that coordinate. So:\n *\n * - `vertical` layout: `x` unfixed, `y` fixed per level\n * - `horizontal` layout: `x` fixed per level, `y` unfixed\n *\n * The local methods are stubs and should be regarded as abstract.\n * Derived classes **must** implement all the methods themselves.\n *\n * @private\n */\nvar DirectionInterface = /*#__PURE__*/function () {\n  function DirectionInterface() {\n    _classCallCheck(this, DirectionInterface);\n  }\n  _createClass(DirectionInterface, [{\n    key: \"abstract\",\n    value:\n    /**\n     * @ignore\n     */\n    function abstract() {\n      throw new Error(\"Can't instantiate abstract class!\");\n    }\n\n    /**\n     * This is a dummy call which is used to suppress the jsdoc errors of type:\n     *\n     *   \"'param' is assigned a value but never used\"\n     *\n     * @ignore\n     */\n  }, {\n    key: \"fake_use\",\n    value: function fake_use() {\n      // Do nothing special\n    }\n\n    /**\n     * Type to use to translate dynamic curves to, in the case of hierarchical layout.\n     * Dynamic curves do not work for these.\n     *\n     * The value should be perpendicular to the actual direction of the layout.\n     *\n     * @returns {string} Direction, either 'vertical' or 'horizontal'\n     */\n  }, {\n    key: \"curveType\",\n    value: function curveType() {\n      return this.abstract();\n    }\n\n    /**\n     * Return the value of the coordinate that is not fixed for this direction.\n     *\n     * @param {Node} node The node to read\n     * @returns {number} Value of the unfixed coordinate\n     */\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(node) {\n      this.fake_use(node);\n      return this.abstract();\n    }\n\n    /**\n     * Set the value of the coordinate that is not fixed for this direction.\n     *\n     * @param {Node} node The node to adjust\n     * @param {number} position\n     * @param {number} [level] if specified, the hierarchy level that this node should be fixed to\n     */\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(node, position) {\n      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      this.fake_use(node, position, level);\n      this.abstract();\n    }\n\n    /**\n     * Get the width of a tree.\n     *\n     * A `tree` here is a subset of nodes within the network which are not connected to other nodes,\n     * only among themselves. In essence, it is a sub-network.\n     *\n     * @param {number} index The index number of a tree\n     * @returns {number} the width of a tree in the view coordinates\n     */\n  }, {\n    key: \"getTreeSize\",\n    value: function getTreeSize(index) {\n      this.fake_use(index);\n      return this.abstract();\n    }\n\n    /**\n     * Sort array of nodes on the unfixed coordinates.\n     *\n     * Note:** chrome has non-stable sorting implementation, which\n     * has a tendency to change the order of the array items,\n     * even if the custom sort function returns 0.\n     *\n     * For this reason, an external sort implementation is used,\n     * which has the added benefit of being faster than the standard\n     * platforms implementation. This has been verified on `node.js`,\n     * `firefox` and `chrome` (all linux).\n     *\n     * @param {Array.<Node>} nodeArray array of nodes to sort\n     */\n  }, {\n    key: \"sort\",\n    value: function sort(nodeArray) {\n      this.fake_use(nodeArray);\n      this.abstract();\n    }\n\n    /**\n     * Assign the fixed coordinate of the node to the given level\n     *\n     * @param {Node} node The node to adjust\n     * @param {number} level The level to fix to\n     */\n  }, {\n    key: \"fix\",\n    value: function fix(node, level) {\n      this.fake_use(node, level);\n      this.abstract();\n    }\n\n    /**\n     * Add an offset to the unfixed coordinate of the given node.\n     *\n     * @param {NodeId} nodeId Id of the node to adjust\n     * @param {number} diff Offset to add to the unfixed coordinate\n     */\n  }, {\n    key: \"shift\",\n    value: function shift(nodeId, diff) {\n      this.fake_use(nodeId, diff);\n      this.abstract();\n    }\n  }]);\n  return DirectionInterface;\n}();\n/**\n * Vertical Strategy\n *\n * Coordinate `y` is fixed on levels, coordinate `x` is unfixed.\n *\n * @augments DirectionInterface\n * @private\n */\nvar VerticalStrategy = /*#__PURE__*/function (_DirectionInterface) {\n  _inherits(VerticalStrategy, _DirectionInterface);\n  var _super = _createSuper(VerticalStrategy);\n  /**\n   * Constructor\n   *\n   * @param {object} layout reference to the parent LayoutEngine instance.\n   */\n  function VerticalStrategy(layout) {\n    var _this;\n    _classCallCheck(this, VerticalStrategy);\n    _this = _super.call(this);\n    _this.layout = layout;\n    return _this;\n  }\n\n  /** @inheritDoc */\n  _createClass(VerticalStrategy, [{\n    key: \"curveType\",\n    value: function curveType() {\n      return \"horizontal\";\n    }\n\n    /** @inheritDoc */\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(node) {\n      return node.x;\n    }\n\n    /** @inheritDoc */\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(node, position) {\n      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      if (level !== undefined) {\n        this.layout.hierarchical.addToOrdering(node, level);\n      }\n      node.x = position;\n    }\n\n    /** @inheritDoc */\n  }, {\n    key: \"getTreeSize\",\n    value: function getTreeSize(index) {\n      var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index);\n      return {\n        min: res.min_x,\n        max: res.max_x\n      };\n    }\n\n    /** @inheritDoc */\n  }, {\n    key: \"sort\",\n    value: function sort(nodeArray) {\n      _sortInstanceProperty(nodeArray).call(nodeArray, function (a, b) {\n        return a.x - b.x;\n      });\n    }\n\n    /** @inheritDoc */\n  }, {\n    key: \"fix\",\n    value: function fix(node, level) {\n      node.y = this.layout.options.hierarchical.levelSeparation * level;\n      node.options.fixed.y = true;\n    }\n\n    /** @inheritDoc */\n  }, {\n    key: \"shift\",\n    value: function shift(nodeId, diff) {\n      this.layout.body.nodes[nodeId].x += diff;\n    }\n  }]);\n  return VerticalStrategy;\n}(DirectionInterface);\n/**\n * Horizontal Strategy\n *\n * Coordinate `x` is fixed on levels, coordinate `y` is unfixed.\n *\n * @augments DirectionInterface\n * @private\n */\nvar HorizontalStrategy = /*#__PURE__*/function (_DirectionInterface2) {\n  _inherits(HorizontalStrategy, _DirectionInterface2);\n  var _super2 = _createSuper(HorizontalStrategy);\n  /**\n   * Constructor\n   *\n   * @param {object} layout reference to the parent LayoutEngine instance.\n   */\n  function HorizontalStrategy(layout) {\n    var _this2;\n    _classCallCheck(this, HorizontalStrategy);\n    _this2 = _super2.call(this);\n    _this2.layout = layout;\n    return _this2;\n  }\n\n  /** @inheritDoc */\n  _createClass(HorizontalStrategy, [{\n    key: \"curveType\",\n    value: function curveType() {\n      return \"vertical\";\n    }\n\n    /** @inheritDoc */\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(node) {\n      return node.y;\n    }\n\n    /** @inheritDoc */\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(node, position) {\n      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      if (level !== undefined) {\n        this.layout.hierarchical.addToOrdering(node, level);\n      }\n      node.y = position;\n    }\n\n    /** @inheritDoc */\n  }, {\n    key: \"getTreeSize\",\n    value: function getTreeSize(index) {\n      var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index);\n      return {\n        min: res.min_y,\n        max: res.max_y\n      };\n    }\n\n    /** @inheritDoc */\n  }, {\n    key: \"sort\",\n    value: function sort(nodeArray) {\n      _sortInstanceProperty(nodeArray).call(nodeArray, function (a, b) {\n        return a.y - b.y;\n      });\n    }\n\n    /** @inheritDoc */\n  }, {\n    key: \"fix\",\n    value: function fix(node, level) {\n      node.x = this.layout.options.hierarchical.levelSeparation * level;\n      node.options.fixed.x = true;\n    }\n\n    /** @inheritDoc */\n  }, {\n    key: \"shift\",\n    value: function shift(nodeId, diff) {\n      this.layout.body.nodes[nodeId].y += diff;\n    }\n  }]);\n  return HorizontalStrategy;\n}(DirectionInterface);\n\nvar $ = _export;\nvar $every = arrayIteration.every;\nvar arrayMethodIsStrict = arrayMethodIsStrict$6;\n\nvar STRICT_METHOD = arrayMethodIsStrict('every');\n\n// `Array.prototype.every` method\n// https://tc39.es/ecma262/#sec-array.prototype.every\n$({ target: 'Array', proto: true, forced: !STRICT_METHOD }, {\n  every: function every(callbackfn /* , thisArg */) {\n    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar entryVirtual = entryVirtual$i;\n\nvar every$3 = entryVirtual('Array').every;\n\nvar isPrototypeOf = objectIsPrototypeOf;\nvar method = every$3;\n\nvar ArrayPrototype = Array.prototype;\n\nvar every$2 = function (it) {\n  var own = it.every;\n  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.every) ? method : own;\n};\n\nvar parent = every$2;\n\nvar every$1 = parent;\n\nvar every = every$1;\n\nvar _everyInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(every);\n\nfunction _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof _Symbol !== \"undefined\" && _getIteratorMethod(o) || o[\"@@iterator\"]; if (!it) { if (_Array$isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$1(o, minLen) { var _context9; if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$1(o, minLen); var n = _sliceInstanceProperty(_context9 = Object.prototype.toString.call(o)).call(_context9, 8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return _Array$from$1(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }\nfunction _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/**\r\n * Try to assign levels to nodes according to their positions in the cyclic âhierarchyâ.\r\n *\r\n * @param nodes - Visible nodes of the graph.\r\n * @param levels - If present levels will be added to it, if not a new object will be created.\r\n * @returns Populated node levels.\r\n */\nfunction fillLevelsByDirectionCyclic(nodes, levels) {\n  var edges = new _Set();\n  _forEachInstanceProperty(nodes).call(nodes, function (node) {\n    var _context;\n    _forEachInstanceProperty(_context = node.edges).call(_context, function (edge) {\n      if (edge.connected) {\n        edges.add(edge);\n      }\n    });\n  });\n  _forEachInstanceProperty(edges).call(edges, function (edge) {\n    var fromId = edge.from.id;\n    var toId = edge.to.id;\n    if (levels[fromId] == null) {\n      levels[fromId] = 0;\n    }\n    if (levels[toId] == null || levels[fromId] >= levels[toId]) {\n      levels[toId] = levels[fromId] + 1;\n    }\n  });\n  return levels;\n}\n/**\r\n * Assign levels to nodes according to their positions in the hierarchy. Leaves will be lined up at the bottom and all other nodes as close to their children as possible.\r\n *\r\n * @param nodes - Visible nodes of the graph.\r\n * @returns Populated node levels.\r\n */\nfunction fillLevelsByDirectionLeaves(nodes) {\n  return fillLevelsByDirection(\n  // Pick only leaves (nodes without children).\n  function (node) {\n    var _context2, _context3;\n    return _everyInstanceProperty(_context2 = _filterInstanceProperty(_context3 = node.edges\n    // Take only visible nodes into account.\n    ).call(_context3, function (edge) {\n      return nodes.has(edge.toId);\n    })\n    // Check that all edges lead to this node (leaf).\n    ).call(_context2, function (edge) {\n      return edge.to === node;\n    });\n  },\n  // Use the lowest level.\n  function (newLevel, oldLevel) {\n    return oldLevel > newLevel;\n  },\n  // Go against the direction of the edges.\n  \"from\", nodes);\n}\n/**\r\n * Assign levels to nodes according to their positions in the hierarchy. Roots will be lined up at the top and all nodes as close to their parents as possible.\r\n *\r\n * @param nodes - Visible nodes of the graph.\r\n * @returns Populated node levels.\r\n */\nfunction fillLevelsByDirectionRoots(nodes) {\n  return fillLevelsByDirection(\n  // Pick only roots (nodes without parents).\n  function (node) {\n    var _context4, _context5;\n    return _everyInstanceProperty(_context4 = _filterInstanceProperty(_context5 = node.edges\n    // Take only visible nodes into account.\n    ).call(_context5, function (edge) {\n      return nodes.has(edge.toId);\n    })\n    // Check that all edges lead from this node (root).\n    ).call(_context4, function (edge) {\n      return edge.from === node;\n    });\n  },\n  // Use the highest level.\n  function (newLevel, oldLevel) {\n    return oldLevel < newLevel;\n  },\n  // Go in the direction of the edges.\n  \"to\", nodes);\n}\n/**\r\n * Assign levels to nodes according to their positions in the hierarchy.\r\n *\r\n * @param isEntryNode - Checks and return true if the graph should be traversed from this node.\r\n * @param shouldLevelBeReplaced - Checks and returns true if the level of given node should be updated to the new value.\r\n * @param direction - Wheter the graph should be traversed in the direction of the edges `\"to\"` or in the other way `\"from\"`.\r\n * @param nodes - Visible nodes of the graph.\r\n * @returns Populated node levels.\r\n */\nfunction fillLevelsByDirection(isEntryNode, shouldLevelBeReplaced, direction, nodes) {\n  var _context6;\n  var levels = _Object$create$1(null);\n  // If acyclic, the graph can be walked through with (most likely way) fewer\n  // steps than the number bellow. The exact value isn't too important as long\n  // as it's quick to compute (doesn't impact acyclic graphs too much), is\n  // higher than the number of steps actually needed (doesn't cut off before\n  // acyclic graph is walked through) and prevents infinite loops (cuts off for\n  // cyclic graphs).\n  var limit = _reduceInstanceProperty(_context6 = _toConsumableArray(_valuesInstanceProperty(nodes).call(nodes))).call(_context6, function (acc, node) {\n    return acc + 1 + node.edges.length;\n  }, 0);\n  var edgeIdProp = direction + \"Id\";\n  var newLevelDiff = direction === \"to\" ? 1 : -1;\n  var _iterator = _createForOfIteratorHelper$1(nodes),\n    _step;\n  try {\n    var _loop = function _loop() {\n        var _step$value = _slicedToArray(_step.value, 2),\n          entryNodeId = _step$value[0],\n          entryNode = _step$value[1];\n        if (\n        // Skip if the node is not visible.\n        !nodes.has(entryNodeId) ||\n        // Skip if the node is not an entry node.\n        !isEntryNode(entryNode)) {\n          return 0; // continue\n        }\n        // Line up all the entry nodes on level 0.\n        levels[entryNodeId] = 0;\n        var stack = [entryNode];\n        var done = 0;\n        var node;\n        var _loop2 = function _loop2() {\n            var _context7, _context8;\n            if (!nodes.has(entryNodeId)) {\n              // Skip if the node is not visible.\n              return 0; // continue\n            }\n            var newLevel = levels[node.id] + newLevelDiff;\n            _forEachInstanceProperty(_context7 = _filterInstanceProperty(_context8 = node.edges).call(_context8, function (edge) {\n              return (\n                // Ignore disconnected edges.\n                edge.connected &&\n                // Ignore circular edges.\n                edge.to !== edge.from &&\n                // Ignore edges leading to the node that's currently being processed.\n                edge[direction] !== node &&\n                // Ignore edges connecting to an invisible node.\n                nodes.has(edge.toId) &&\n                // Ignore edges connecting from an invisible node.\n                nodes.has(edge.fromId)\n              );\n            })).call(_context7, function (edge) {\n              var targetNodeId = edge[edgeIdProp];\n              var oldLevel = levels[targetNodeId];\n              if (oldLevel == null || shouldLevelBeReplaced(newLevel, oldLevel)) {\n                levels[targetNodeId] = newLevel;\n                stack.push(edge[direction]);\n              }\n            });\n            if (done > limit) {\n              // This would run forever on a cyclic graph.\n              return {\n                v: {\n                  v: fillLevelsByDirectionCyclic(nodes, levels)\n                }\n              };\n            } else {\n              ++done;\n            }\n          },\n          _ret2;\n        while (node = stack.pop()) {\n          _ret2 = _loop2();\n          if (_ret2 === 0) continue;\n          if (_ret2) return _ret2.v;\n        }\n      },\n      _ret;\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      _ret = _loop();\n      if (_ret === 0) continue;\n      if (_ret) return _ret.v;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return levels;\n}\n\n/**\n * There's a mix-up with terms in the code. Following are the formal definitions:\n *\n *   tree   - a strict hierarchical network, i.e. every node has at most one parent\n *   forest - a collection of trees. These distinct trees are thus not connected.\n *\n * So:\n * - in a network that is not a tree, there exist nodes with multiple parents.\n * - a network consisting of unconnected sub-networks, of which at least one\n *   is not a tree, is not a forest.\n *\n * In the code, the definitions are:\n *\n *   tree   - any disconnected sub-network, strict hierarchical or not.\n *   forest - a bunch of these sub-networks\n *\n * The difference between tree and not-tree is important in the code, notably within\n * to the block-shifting algorithm. The algorithm assumes formal trees and fails\n * for not-trees, often in a spectacular manner (search for 'exploding network' in the issues).\n *\n * In order to distinguish the definitions in the following code, the adjective 'formal' is\n * used. If 'formal' is absent, you must assume the non-formal definition.\n *\n * ----------------------------------------------------------------------------------\n * NOTES\n * =====\n *\n * A hierarchical layout is a different thing from a hierarchical network.\n * The layout is a way to arrange the nodes in the view; this can be done\n * on non-hierarchical networks as well. The converse is also possible.\n */\n\n/**\n * Container for derived data on current network, relating to hierarchy.\n *\n * @private\n */\nvar HierarchicalStatus = /*#__PURE__*/function () {\n  /**\n   * @ignore\n   */\n  function HierarchicalStatus() {\n    _classCallCheck(this, HierarchicalStatus);\n    this.childrenReference = {}; // child id's per node id\n    this.parentReference = {}; // parent id's per node id\n    this.trees = {}; // tree id per node id; i.e. to which tree does given node id belong\n\n    this.distributionOrdering = {}; // The nodes per level, in the display order\n    this.levels = {}; // hierarchy level per node id\n    this.distributionIndex = {}; // The position of the node in the level sorting order, per node id.\n\n    this.isTree = false; // True if current network is a formal tree\n    this.treeIndex = -1; // Highest tree id in current network.\n  }\n\n  /**\n   * Add the relation between given nodes to the current state.\n   *\n   * @param {Node.id} parentNodeId\n   * @param {Node.id} childNodeId\n   */\n  _createClass(HierarchicalStatus, [{\n    key: \"addRelation\",\n    value: function addRelation(parentNodeId, childNodeId) {\n      if (this.childrenReference[parentNodeId] === undefined) {\n        this.childrenReference[parentNodeId] = [];\n      }\n      this.childrenReference[parentNodeId].push(childNodeId);\n      if (this.parentReference[childNodeId] === undefined) {\n        this.parentReference[childNodeId] = [];\n      }\n      this.parentReference[childNodeId].push(parentNodeId);\n    }\n\n    /**\n     * Check if the current state is for a formal tree or formal forest.\n     *\n     * This is the case if every node has at most one parent.\n     *\n     * Pre: parentReference init'ed properly for current network\n     */\n  }, {\n    key: \"checkIfTree\",\n    value: function checkIfTree() {\n      for (var i in this.parentReference) {\n        if (this.parentReference[i].length > 1) {\n          this.isTree = false;\n          return;\n        }\n      }\n      this.isTree = true;\n    }\n\n    /**\n     * Return the number of separate trees in the current network.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"numTrees\",\n    value: function numTrees() {\n      return this.treeIndex + 1; // This assumes the indexes are assigned consecitively\n    }\n\n    /**\n     * Assign a tree id to a node\n     *\n     * @param {Node} node\n     * @param {string|number} treeId\n     */\n  }, {\n    key: \"setTreeIndex\",\n    value: function setTreeIndex(node, treeId) {\n      if (treeId === undefined) return; // Don't bother\n\n      if (this.trees[node.id] === undefined) {\n        this.trees[node.id] = treeId;\n        this.treeIndex = Math.max(treeId, this.treeIndex);\n      }\n    }\n\n    /**\n     * Ensure level for given id is defined.\n     *\n     * Sets level to zero for given node id if not already present\n     *\n     * @param {Node.id} nodeId\n     */\n  }, {\n    key: \"ensureLevel\",\n    value: function ensureLevel(nodeId) {\n      if (this.levels[nodeId] === undefined) {\n        this.levels[nodeId] = 0;\n      }\n    }\n\n    /**\n     * get the maximum level of a branch.\n     *\n     * TODO: Never entered; find a test case to test this!\n     *\n     * @param {Node.id} nodeId\n     * @returns {number}\n     */\n  }, {\n    key: \"getMaxLevel\",\n    value: function getMaxLevel(nodeId) {\n      var _this = this;\n      var accumulator = {};\n      var _getMaxLevel = function _getMaxLevel(nodeId) {\n        if (accumulator[nodeId] !== undefined) {\n          return accumulator[nodeId];\n        }\n        var level = _this.levels[nodeId];\n        if (_this.childrenReference[nodeId]) {\n          var children = _this.childrenReference[nodeId];\n          if (children.length > 0) {\n            for (var i = 0; i < children.length; i++) {\n              level = Math.max(level, _getMaxLevel(children[i]));\n            }\n          }\n        }\n        accumulator[nodeId] = level;\n        return level;\n      };\n      return _getMaxLevel(nodeId);\n    }\n\n    /**\n     *\n     * @param {Node} nodeA\n     * @param {Node} nodeB\n     */\n  }, {\n    key: \"levelDownstream\",\n    value: function levelDownstream(nodeA, nodeB) {\n      if (this.levels[nodeB.id] === undefined) {\n        // set initial level\n        if (this.levels[nodeA.id] === undefined) {\n          this.levels[nodeA.id] = 0;\n        }\n        // set level\n        this.levels[nodeB.id] = this.levels[nodeA.id] + 1;\n      }\n    }\n\n    /**\n     * Small util method to set the minimum levels of the nodes to zero.\n     *\n     * @param {Array.<Node>} nodes\n     */\n  }, {\n    key: \"setMinLevelToZero\",\n    value: function setMinLevelToZero(nodes) {\n      var minLevel = 1e9;\n      // get the minimum level\n      for (var nodeId in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {\n          if (this.levels[nodeId] !== undefined) {\n            minLevel = Math.min(this.levels[nodeId], minLevel);\n          }\n        }\n      }\n\n      // subtract the minimum from the set so we have a range starting from 0\n      for (var _nodeId in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, _nodeId)) {\n          if (this.levels[_nodeId] !== undefined) {\n            this.levels[_nodeId] -= minLevel;\n          }\n        }\n      }\n    }\n\n    /**\n     * Get the min and max xy-coordinates of a given tree\n     *\n     * @param {Array.<Node>} nodes\n     * @param {number} index\n     * @returns {{min_x: number, max_x: number, min_y: number, max_y: number}}\n     */\n  }, {\n    key: \"getTreeSize\",\n    value: function getTreeSize(nodes, index) {\n      var min_x = 1e9;\n      var max_x = -1e9;\n      var min_y = 1e9;\n      var max_y = -1e9;\n      for (var nodeId in this.trees) {\n        if (Object.prototype.hasOwnProperty.call(this.trees, nodeId)) {\n          if (this.trees[nodeId] === index) {\n            var node = nodes[nodeId];\n            min_x = Math.min(node.x, min_x);\n            max_x = Math.max(node.x, max_x);\n            min_y = Math.min(node.y, min_y);\n            max_y = Math.max(node.y, max_y);\n          }\n        }\n      }\n      return {\n        min_x: min_x,\n        max_x: max_x,\n        min_y: min_y,\n        max_y: max_y\n      };\n    }\n\n    /**\n     * Check if two nodes have the same parent(s)\n     *\n     * @param {Node} node1\n     * @param {Node} node2\n     * @returns {boolean} true if the two nodes have a same ancestor node, false otherwise\n     */\n  }, {\n    key: \"hasSameParent\",\n    value: function hasSameParent(node1, node2) {\n      var parents1 = this.parentReference[node1.id];\n      var parents2 = this.parentReference[node2.id];\n      if (parents1 === undefined || parents2 === undefined) {\n        return false;\n      }\n      for (var i = 0; i < parents1.length; i++) {\n        for (var j = 0; j < parents2.length; j++) {\n          if (parents1[i] == parents2[j]) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Check if two nodes are in the same tree.\n     *\n     * @param {Node} node1\n     * @param {Node} node2\n     * @returns {boolean} true if this is so, false otherwise\n     */\n  }, {\n    key: \"inSameSubNetwork\",\n    value: function inSameSubNetwork(node1, node2) {\n      return this.trees[node1.id] === this.trees[node2.id];\n    }\n\n    /**\n     * Get a list of the distinct levels in the current network\n     *\n     * @returns {Array}\n     */\n  }, {\n    key: \"getLevels\",\n    value: function getLevels() {\n      return _Object$keys(this.distributionOrdering);\n    }\n\n    /**\n     * Add a node to the ordering per level\n     *\n     * @param {Node} node\n     * @param {number} level\n     */\n  }, {\n    key: \"addToOrdering\",\n    value: function addToOrdering(node, level) {\n      if (this.distributionOrdering[level] === undefined) {\n        this.distributionOrdering[level] = [];\n      }\n      var isPresent = false;\n      var curLevel = this.distributionOrdering[level];\n      for (var n in curLevel) {\n        //if (curLevel[n].id === node.id) {\n        if (curLevel[n] === node) {\n          isPresent = true;\n          break;\n        }\n      }\n      if (!isPresent) {\n        this.distributionOrdering[level].push(node);\n        this.distributionIndex[node.id] = this.distributionOrdering[level].length - 1;\n      }\n    }\n  }]);\n  return HierarchicalStatus;\n}();\n/**\n * The Layout Engine\n */\nvar LayoutEngine = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   */\n  function LayoutEngine(body) {\n    _classCallCheck(this, LayoutEngine);\n    this.body = body;\n\n    // Make sure there always is some RNG because the setOptions method won't\n    // set it unless there's a seed for it.\n    this._resetRNG(Math.random() + \":\" + _Date$now());\n    this.setPhysics = false;\n    this.options = {};\n    this.optionsBackup = {\n      physics: {}\n    };\n    this.defaultOptions = {\n      randomSeed: undefined,\n      improvedLayout: true,\n      clusterThreshold: 150,\n      hierarchical: {\n        enabled: false,\n        levelSeparation: 150,\n        nodeSpacing: 100,\n        treeSpacing: 200,\n        blockShifting: true,\n        edgeMinimization: true,\n        parentCentralization: true,\n        direction: \"UD\",\n        // UD, DU, LR, RL\n        sortMethod: \"hubsize\" // hubsize, directed\n      }\n    };\n\n    _Object$assign(this.options, this.defaultOptions);\n    this.bindEventListeners();\n  }\n\n  /**\n   * Binds event listeners\n   */\n  _createClass(LayoutEngine, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _this2 = this;\n      this.body.emitter.on(\"_dataChanged\", function () {\n        _this2.setupHierarchicalLayout();\n      });\n      this.body.emitter.on(\"_dataLoaded\", function () {\n        _this2.layoutNetwork();\n      });\n      this.body.emitter.on(\"_resetHierarchicalLayout\", function () {\n        _this2.setupHierarchicalLayout();\n      });\n      this.body.emitter.on(\"_adjustEdgesForHierarchicalLayout\", function () {\n        if (_this2.options.hierarchical.enabled !== true) {\n          return;\n        }\n        // get the type of static smooth curve in case it is required\n        var type = _this2.direction.curveType();\n\n        // force all edges into static smooth curves.\n        _this2.body.emitter.emit(\"_forceDisableDynamicCurves\", type, false);\n      });\n    }\n\n    /**\n     *\n     * @param {object} options\n     * @param {object} allOptions\n     * @returns {object}\n     */\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options, allOptions) {\n      if (options !== undefined) {\n        var hierarchical = this.options.hierarchical;\n        var prevHierarchicalState = hierarchical.enabled;\n        selectiveDeepExtend([\"randomSeed\", \"improvedLayout\", \"clusterThreshold\"], this.options, options);\n        mergeOptions(this.options, options, \"hierarchical\");\n        if (options.randomSeed !== undefined) {\n          this._resetRNG(options.randomSeed);\n        }\n        if (hierarchical.enabled === true) {\n          if (prevHierarchicalState === true) {\n            // refresh the overridden options for nodes and edges.\n            this.body.emitter.emit(\"refresh\", true);\n          }\n\n          // make sure the level separation is the right way up\n          if (hierarchical.direction === \"RL\" || hierarchical.direction === \"DU\") {\n            if (hierarchical.levelSeparation > 0) {\n              hierarchical.levelSeparation *= -1;\n            }\n          } else {\n            if (hierarchical.levelSeparation < 0) {\n              hierarchical.levelSeparation *= -1;\n            }\n          }\n          this.setDirectionStrategy();\n          this.body.emitter.emit(\"_resetHierarchicalLayout\");\n          // because the hierarchical system needs it's own physics and smooth curve settings,\n          // we adapt the other options if needed.\n          return this.adaptAllOptionsForHierarchicalLayout(allOptions);\n        } else {\n          if (prevHierarchicalState === true) {\n            // refresh the overridden options for nodes and edges.\n            this.body.emitter.emit(\"refresh\");\n            return deepExtend(allOptions, this.optionsBackup);\n          }\n        }\n      }\n      return allOptions;\n    }\n\n    /**\n     * Reset the random number generator with given seed.\n     *\n     * @param {any} seed - The seed that will be forwarded the the RNG.\n     */\n  }, {\n    key: \"_resetRNG\",\n    value: function _resetRNG(seed) {\n      this.initialRandomSeed = seed;\n      this._rng = Alea(this.initialRandomSeed);\n    }\n\n    /**\n     *\n     * @param {object} allOptions\n     * @returns {object}\n     */\n  }, {\n    key: \"adaptAllOptionsForHierarchicalLayout\",\n    value: function adaptAllOptionsForHierarchicalLayout(allOptions) {\n      if (this.options.hierarchical.enabled === true) {\n        var backupPhysics = this.optionsBackup.physics;\n\n        // set the physics\n        if (allOptions.physics === undefined || allOptions.physics === true) {\n          allOptions.physics = {\n            enabled: backupPhysics.enabled === undefined ? true : backupPhysics.enabled,\n            solver: \"hierarchicalRepulsion\"\n          };\n          backupPhysics.enabled = backupPhysics.enabled === undefined ? true : backupPhysics.enabled;\n          backupPhysics.solver = backupPhysics.solver || \"barnesHut\";\n        } else if (_typeof(allOptions.physics) === \"object\") {\n          backupPhysics.enabled = allOptions.physics.enabled === undefined ? true : allOptions.physics.enabled;\n          backupPhysics.solver = allOptions.physics.solver || \"barnesHut\";\n          allOptions.physics.solver = \"hierarchicalRepulsion\";\n        } else if (allOptions.physics !== false) {\n          backupPhysics.solver = \"barnesHut\";\n          allOptions.physics = {\n            solver: \"hierarchicalRepulsion\"\n          };\n        }\n\n        // get the type of static smooth curve in case it is required\n        var type = this.direction.curveType();\n\n        // disable smooth curves if nothing is defined. If smooth curves have been turned on,\n        // turn them into static smooth curves.\n        if (allOptions.edges === undefined) {\n          this.optionsBackup.edges = {\n            smooth: {\n              enabled: true,\n              type: \"dynamic\"\n            }\n          };\n          allOptions.edges = {\n            smooth: false\n          };\n        } else if (allOptions.edges.smooth === undefined) {\n          this.optionsBackup.edges = {\n            smooth: {\n              enabled: true,\n              type: \"dynamic\"\n            }\n          };\n          allOptions.edges.smooth = false;\n        } else {\n          if (typeof allOptions.edges.smooth === \"boolean\") {\n            this.optionsBackup.edges = {\n              smooth: allOptions.edges.smooth\n            };\n            allOptions.edges.smooth = {\n              enabled: allOptions.edges.smooth,\n              type: type\n            };\n          } else {\n            var smooth = allOptions.edges.smooth;\n\n            // allow custom types except for dynamic\n            if (smooth.type !== undefined && smooth.type !== \"dynamic\") {\n              type = smooth.type;\n            }\n\n            // TODO: this is options merging; see if the standard routines can be used here.\n            this.optionsBackup.edges = {\n              smooth: {\n                enabled: smooth.enabled === undefined ? true : smooth.enabled,\n                type: smooth.type === undefined ? \"dynamic\" : smooth.type,\n                roundness: smooth.roundness === undefined ? 0.5 : smooth.roundness,\n                forceDirection: smooth.forceDirection === undefined ? false : smooth.forceDirection\n              }\n            };\n\n            // NOTE: Copying an object to self; this is basically setting defaults for undefined variables\n            allOptions.edges.smooth = {\n              enabled: smooth.enabled === undefined ? true : smooth.enabled,\n              type: type,\n              roundness: smooth.roundness === undefined ? 0.5 : smooth.roundness,\n              forceDirection: smooth.forceDirection === undefined ? false : smooth.forceDirection\n            };\n          }\n        }\n\n        // Force all edges into static smooth curves.\n        // Only applies to edges that do not use the global options for smooth.\n        this.body.emitter.emit(\"_forceDisableDynamicCurves\", type);\n      }\n      return allOptions;\n    }\n\n    /**\n     *\n     * @param {Array.<Node>} nodesArray\n     */\n  }, {\n    key: \"positionInitially\",\n    value: function positionInitially(nodesArray) {\n      if (this.options.hierarchical.enabled !== true) {\n        this._resetRNG(this.initialRandomSeed);\n        var radius = nodesArray.length + 50;\n        for (var i = 0; i < nodesArray.length; i++) {\n          var node = nodesArray[i];\n          var angle = 2 * Math.PI * this._rng();\n          if (node.x === undefined) {\n            node.x = radius * Math.cos(angle);\n          }\n          if (node.y === undefined) {\n            node.y = radius * Math.sin(angle);\n          }\n        }\n      }\n    }\n\n    /**\n     * Use Kamada Kawai to position nodes. This is quite a heavy algorithm so if there are a lot of nodes we\n     * cluster them first to reduce the amount.\n     */\n  }, {\n    key: \"layoutNetwork\",\n    value: function layoutNetwork() {\n      if (this.options.hierarchical.enabled !== true && this.options.improvedLayout === true) {\n        var indices = this.body.nodeIndices;\n\n        // first check if we should Kamada Kawai to layout. The threshold is if less than half of the visible\n        // nodes have predefined positions we use this.\n        var positionDefined = 0;\n        for (var i = 0; i < indices.length; i++) {\n          var node = this.body.nodes[indices[i]];\n          if (node.predefinedPosition === true) {\n            positionDefined += 1;\n          }\n        }\n\n        // if less than half of the nodes have a predefined position we continue\n        if (positionDefined < 0.5 * indices.length) {\n          var MAX_LEVELS = 10;\n          var level = 0;\n          var clusterThreshold = this.options.clusterThreshold;\n\n          //\n          // Define the options for the hidden cluster nodes\n          // These options don't propagate outside the clustering phase.\n          //\n          // Some options are explicitly disabled, because they may be set in group or default node options.\n          // The clusters are never displayed, so most explicit settings here serve as performance optimizations.\n          //\n          // The explicit setting of 'shape' is to avoid `shape: 'image'`; images are not passed to the hidden\n          // cluster nodes, leading to an exception on creation.\n          //\n          // All settings here are performance related, except when noted otherwise.\n          //\n          var clusterOptions = {\n            clusterNodeProperties: {\n              shape: \"ellipse\",\n              // Bugfix: avoid type 'image', no images supplied\n              label: \"\",\n              // avoid label handling\n              group: \"\",\n              // avoid group handling\n              font: {\n                multi: false\n              } // avoid font propagation\n            },\n\n            clusterEdgeProperties: {\n              label: \"\",\n              // avoid label handling\n              font: {\n                multi: false\n              },\n              // avoid font propagation\n              smooth: {\n                enabled: false // avoid drawing penalty for complex edges\n              }\n            }\n          };\n\n          // if there are a lot of nodes, we cluster before we run the algorithm.\n          // NOTE: this part fails to find clusters for large scale-free networks, which should\n          //       be easily clusterable.\n          // TODO: examine why this is so\n          if (indices.length > clusterThreshold) {\n            var startLength = indices.length;\n            while (indices.length > clusterThreshold && level <= MAX_LEVELS) {\n              //console.time(\"clustering\")\n              level += 1;\n              var before = indices.length;\n              // if there are many nodes we do a hubsize cluster\n              if (level % 3 === 0) {\n                this.body.modules.clustering.clusterBridges(clusterOptions);\n              } else {\n                this.body.modules.clustering.clusterOutliers(clusterOptions);\n              }\n              var after = indices.length;\n              if (before == after && level % 3 !== 0) {\n                this._declusterAll();\n                this.body.emitter.emit(\"_layoutFailed\");\n                console.info(\"This network could not be positioned by this version of the improved layout algorithm.\" + \" Please disable improvedLayout for better performance.\");\n                return;\n              }\n              //console.timeEnd(\"clustering\")\n              //console.log(before,level,after);\n            }\n            // increase the size of the edges\n            this.body.modules.kamadaKawai.setOptions({\n              springLength: Math.max(150, 2 * startLength)\n            });\n          }\n          if (level > MAX_LEVELS) {\n            console.info(\"The clustering didn't succeed within the amount of interations allowed,\" + \" progressing with partial result.\");\n          }\n\n          // position the system for these nodes and edges\n          this.body.modules.kamadaKawai.solve(indices, this.body.edgeIndices, true);\n\n          // shift to center point\n          this._shiftToCenter();\n\n          // perturb the nodes a little bit to force the physics to kick in\n          var offset = 70;\n          for (var _i = 0; _i < indices.length; _i++) {\n            // Only perturb the nodes that aren't fixed\n            var _node = this.body.nodes[indices[_i]];\n            if (_node.predefinedPosition === false) {\n              _node.x += (0.5 - this._rng()) * offset;\n              _node.y += (0.5 - this._rng()) * offset;\n            }\n          }\n\n          // uncluster all clusters\n          this._declusterAll();\n\n          // reposition all bezier nodes.\n          this.body.emitter.emit(\"_repositionBezierNodes\");\n        }\n      }\n    }\n\n    /**\n     * Move all the nodes towards to the center so gravitational pull wil not move the nodes away from view\n     *\n     * @private\n     */\n  }, {\n    key: \"_shiftToCenter\",\n    value: function _shiftToCenter() {\n      var range = NetworkUtil.getRangeCore(this.body.nodes, this.body.nodeIndices);\n      var center = NetworkUtil.findCenter(range);\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        var node = this.body.nodes[this.body.nodeIndices[i]];\n        node.x -= center.x;\n        node.y -= center.y;\n      }\n    }\n\n    /**\n     * Expands all clusters\n     *\n     * @private\n     */\n  }, {\n    key: \"_declusterAll\",\n    value: function _declusterAll() {\n      var clustersPresent = true;\n      while (clustersPresent === true) {\n        clustersPresent = false;\n        for (var i = 0; i < this.body.nodeIndices.length; i++) {\n          if (this.body.nodes[this.body.nodeIndices[i]].isCluster === true) {\n            clustersPresent = true;\n            this.body.modules.clustering.openCluster(this.body.nodeIndices[i], {}, false);\n          }\n        }\n        if (clustersPresent === true) {\n          this.body.emitter.emit(\"_dataChanged\");\n        }\n      }\n    }\n\n    /**\n     *\n     * @returns {number|*}\n     */\n  }, {\n    key: \"getSeed\",\n    value: function getSeed() {\n      return this.initialRandomSeed;\n    }\n\n    /**\n     * This is the main function to layout the nodes in a hierarchical way.\n     * It checks if the node details are supplied correctly\n     *\n     * @private\n     */\n  }, {\n    key: \"setupHierarchicalLayout\",\n    value: function setupHierarchicalLayout() {\n      if (this.options.hierarchical.enabled === true && this.body.nodeIndices.length > 0) {\n        // get the size of the largest hubs and check if the user has defined a level for a node.\n        var node, nodeId;\n        var definedLevel = false;\n        var undefinedLevel = false;\n        this.lastNodeOnLevel = {};\n        this.hierarchical = new HierarchicalStatus();\n        for (nodeId in this.body.nodes) {\n          if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {\n            node = this.body.nodes[nodeId];\n            if (node.options.level !== undefined) {\n              definedLevel = true;\n              this.hierarchical.levels[nodeId] = node.options.level;\n            } else {\n              undefinedLevel = true;\n            }\n          }\n        }\n\n        // if the user defined some levels but not all, alert and run without hierarchical layout\n        if (undefinedLevel === true && definedLevel === true) {\n          throw new Error(\"To use the hierarchical layout, nodes require either no predefined levels\" + \" or levels have to be defined for all nodes.\");\n        } else {\n          // define levels if undefined by the users. Based on hubsize.\n          if (undefinedLevel === true) {\n            var sortMethod = this.options.hierarchical.sortMethod;\n            if (sortMethod === \"hubsize\") {\n              this._determineLevelsByHubsize();\n            } else if (sortMethod === \"directed\") {\n              this._determineLevelsDirected();\n            } else if (sortMethod === \"custom\") {\n              this._determineLevelsCustomCallback();\n            }\n          }\n\n          // fallback for cases where there are nodes but no edges\n          for (var _nodeId2 in this.body.nodes) {\n            if (Object.prototype.hasOwnProperty.call(this.body.nodes, _nodeId2)) {\n              this.hierarchical.ensureLevel(_nodeId2);\n            }\n          }\n          // check the distribution of the nodes per level.\n          var distribution = this._getDistribution();\n\n          // get the parent children relations.\n          this._generateMap();\n\n          // place the nodes on the canvas.\n          this._placeNodesByHierarchy(distribution);\n\n          // condense the whitespace.\n          this._condenseHierarchy();\n\n          // shift to center so gravity does not have to do much\n          this._shiftToCenter();\n        }\n      }\n    }\n\n    /**\n     * @private\n     */\n  }, {\n    key: \"_condenseHierarchy\",\n    value: function _condenseHierarchy() {\n      var _this3 = this;\n      // Global var in this scope to define when the movement has stopped.\n      var stillShifting = false;\n      var branches = {};\n      // first we have some methods to help shifting trees around.\n      // the main method to shift the trees\n      var shiftTrees = function shiftTrees() {\n        var treeSizes = getTreeSizes();\n        var shiftBy = 0;\n        for (var i = 0; i < treeSizes.length - 1; i++) {\n          var diff = treeSizes[i].max - treeSizes[i + 1].min;\n          shiftBy += diff + _this3.options.hierarchical.treeSpacing;\n          shiftTree(i + 1, shiftBy);\n        }\n      };\n\n      // shift a single tree by an offset\n      var shiftTree = function shiftTree(index, offset) {\n        var trees = _this3.hierarchical.trees;\n        for (var nodeId in trees) {\n          if (Object.prototype.hasOwnProperty.call(trees, nodeId)) {\n            if (trees[nodeId] === index) {\n              _this3.direction.shift(nodeId, offset);\n            }\n          }\n        }\n      };\n\n      // get the width of all trees\n      var getTreeSizes = function getTreeSizes() {\n        var treeWidths = [];\n        for (var i = 0; i < _this3.hierarchical.numTrees(); i++) {\n          treeWidths.push(_this3.direction.getTreeSize(i));\n        }\n        return treeWidths;\n      };\n\n      // get a map of all nodes in this branch\n      var getBranchNodes = function getBranchNodes(source, map) {\n        if (map[source.id]) {\n          return;\n        }\n        map[source.id] = true;\n        if (_this3.hierarchical.childrenReference[source.id]) {\n          var children = _this3.hierarchical.childrenReference[source.id];\n          if (children.length > 0) {\n            for (var i = 0; i < children.length; i++) {\n              getBranchNodes(_this3.body.nodes[children[i]], map);\n            }\n          }\n        }\n      };\n\n      // get a min max width as well as the maximum movement space it has on either sides\n      // we use min max terminology because width and height can interchange depending on the direction of the layout\n      var getBranchBoundary = function getBranchBoundary(branchMap) {\n        var maxLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e9;\n        var minSpace = 1e9;\n        var maxSpace = 1e9;\n        var min = 1e9;\n        var max = -1e9;\n        for (var branchNode in branchMap) {\n          if (Object.prototype.hasOwnProperty.call(branchMap, branchNode)) {\n            var node = _this3.body.nodes[branchNode];\n            var level = _this3.hierarchical.levels[node.id];\n            var position = _this3.direction.getPosition(node);\n\n            // get the space around the node.\n            var _this3$_getSpaceAroun = _this3._getSpaceAroundNode(node, branchMap),\n              _this3$_getSpaceAroun2 = _slicedToArray(_this3$_getSpaceAroun, 2),\n              minSpaceNode = _this3$_getSpaceAroun2[0],\n              maxSpaceNode = _this3$_getSpaceAroun2[1];\n            minSpace = Math.min(minSpaceNode, minSpace);\n            maxSpace = Math.min(maxSpaceNode, maxSpace);\n\n            // the width is only relevant for the levels two nodes have in common. This is why we filter on this.\n            if (level <= maxLevel) {\n              min = Math.min(position, min);\n              max = Math.max(position, max);\n            }\n          }\n        }\n        return [min, max, minSpace, maxSpace];\n      };\n\n      // check what the maximum level is these nodes have in common.\n      var getCollisionLevel = function getCollisionLevel(node1, node2) {\n        var maxLevel1 = _this3.hierarchical.getMaxLevel(node1.id);\n        var maxLevel2 = _this3.hierarchical.getMaxLevel(node2.id);\n        return Math.min(maxLevel1, maxLevel2);\n      };\n\n      /**\n       * Condense elements. These can be nodes or branches depending on the callback.\n       *\n       * @param {Function} callback\n       * @param {Array.<number>} levels\n       * @param {*} centerParents\n       */\n      var shiftElementsCloser = function shiftElementsCloser(callback, levels, centerParents) {\n        var hier = _this3.hierarchical;\n        for (var i = 0; i < levels.length; i++) {\n          var level = levels[i];\n          var levelNodes = hier.distributionOrdering[level];\n          if (levelNodes.length > 1) {\n            for (var j = 0; j < levelNodes.length - 1; j++) {\n              var node1 = levelNodes[j];\n              var node2 = levelNodes[j + 1];\n\n              // NOTE: logic maintained as it was; if nodes have same ancestor,\n              //       then of course they are in the same sub-network.\n              if (hier.hasSameParent(node1, node2) && hier.inSameSubNetwork(node1, node2)) {\n                callback(node1, node2, centerParents);\n              }\n            }\n          }\n        }\n      };\n\n      // callback for shifting branches\n      var branchShiftCallback = function branchShiftCallback(node1, node2) {\n        var centerParent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        //window.CALLBACKS.push(() => {\n        var pos1 = _this3.direction.getPosition(node1);\n        var pos2 = _this3.direction.getPosition(node2);\n        var diffAbs = Math.abs(pos2 - pos1);\n        var nodeSpacing = _this3.options.hierarchical.nodeSpacing;\n        //console.log(\"NOW CHECKING:\", node1.id, node2.id, diffAbs);\n        if (diffAbs > nodeSpacing) {\n          var branchNodes1 = {};\n          var branchNodes2 = {};\n          getBranchNodes(node1, branchNodes1);\n          getBranchNodes(node2, branchNodes2);\n\n          // check the largest distance between the branches\n          var maxLevel = getCollisionLevel(node1, node2);\n          var branchNodeBoundary1 = getBranchBoundary(branchNodes1, maxLevel);\n          var branchNodeBoundary2 = getBranchBoundary(branchNodes2, maxLevel);\n          var max1 = branchNodeBoundary1[1];\n          var min2 = branchNodeBoundary2[0];\n          var minSpace2 = branchNodeBoundary2[2];\n\n          //console.log(node1.id, getBranchBoundary(branchNodes1, maxLevel), node2.id,\n          //            getBranchBoundary(branchNodes2, maxLevel), maxLevel);\n          var diffBranch = Math.abs(max1 - min2);\n          if (diffBranch > nodeSpacing) {\n            var offset = max1 - min2 + nodeSpacing;\n            if (offset < -minSpace2 + nodeSpacing) {\n              offset = -minSpace2 + nodeSpacing;\n              //console.log(\"RESETTING OFFSET\", max1 - min2 + this.options.hierarchical.nodeSpacing, -minSpace2, offset);\n            }\n\n            if (offset < 0) {\n              //console.log(\"SHIFTING\", node2.id, offset);\n              _this3._shiftBlock(node2.id, offset);\n              stillShifting = true;\n              if (centerParent === true) _this3._centerParent(node2);\n            }\n          }\n        }\n        //this.body.emitter.emit(\"_redraw\");})\n      };\n\n      var minimizeEdgeLength = function minimizeEdgeLength(iterations, node) {\n        //window.CALLBACKS.push(() => {\n        //  console.log(\"ts\",node.id);\n        var nodeId = node.id;\n        var allEdges = node.edges;\n        var nodeLevel = _this3.hierarchical.levels[node.id];\n\n        // gather constants\n        var C2 = _this3.options.hierarchical.levelSeparation * _this3.options.hierarchical.levelSeparation;\n        var referenceNodes = {};\n        var aboveEdges = [];\n        for (var i = 0; i < allEdges.length; i++) {\n          var edge = allEdges[i];\n          if (edge.toId != edge.fromId) {\n            var otherNode = edge.toId == nodeId ? edge.from : edge.to;\n            referenceNodes[allEdges[i].id] = otherNode;\n            if (_this3.hierarchical.levels[otherNode.id] < nodeLevel) {\n              aboveEdges.push(edge);\n            }\n          }\n        }\n\n        // differentiated sum of lengths based on only moving one node over one axis\n        var getFx = function getFx(point, edges) {\n          var sum = 0;\n          for (var _i2 = 0; _i2 < edges.length; _i2++) {\n            if (referenceNodes[edges[_i2].id] !== undefined) {\n              var a = _this3.direction.getPosition(referenceNodes[edges[_i2].id]) - point;\n              sum += a / Math.sqrt(a * a + C2);\n            }\n          }\n          return sum;\n        };\n\n        // doubly differentiated sum of lengths based on only moving one node over one axis\n        var getDFx = function getDFx(point, edges) {\n          var sum = 0;\n          for (var _i3 = 0; _i3 < edges.length; _i3++) {\n            if (referenceNodes[edges[_i3].id] !== undefined) {\n              var a = _this3.direction.getPosition(referenceNodes[edges[_i3].id]) - point;\n              sum -= C2 * Math.pow(a * a + C2, -1.5);\n            }\n          }\n          return sum;\n        };\n        var getGuess = function getGuess(iterations, edges) {\n          var guess = _this3.direction.getPosition(node);\n          // Newton's method for optimization\n          var guessMap = {};\n          for (var _i4 = 0; _i4 < iterations; _i4++) {\n            var fx = getFx(guess, edges);\n            var dfx = getDFx(guess, edges);\n\n            // we limit the movement to avoid instability.\n            var limit = 40;\n            var ratio = Math.max(-limit, Math.min(limit, Math.round(fx / dfx)));\n            guess = guess - ratio;\n            // reduce duplicates\n            if (guessMap[guess] !== undefined) {\n              break;\n            }\n            guessMap[guess] = _i4;\n          }\n          return guess;\n        };\n        var moveBranch = function moveBranch(guess) {\n          // position node if there is space\n          var nodePosition = _this3.direction.getPosition(node);\n\n          // check movable area of the branch\n          if (branches[node.id] === undefined) {\n            var branchNodes = {};\n            getBranchNodes(node, branchNodes);\n            branches[node.id] = branchNodes;\n          }\n          var branchBoundary = getBranchBoundary(branches[node.id]);\n          var minSpaceBranch = branchBoundary[2];\n          var maxSpaceBranch = branchBoundary[3];\n          var diff = guess - nodePosition;\n\n          // check if we are allowed to move the node:\n          var branchOffset = 0;\n          if (diff > 0) {\n            branchOffset = Math.min(diff, maxSpaceBranch - _this3.options.hierarchical.nodeSpacing);\n          } else if (diff < 0) {\n            branchOffset = -Math.min(-diff, minSpaceBranch - _this3.options.hierarchical.nodeSpacing);\n          }\n          if (branchOffset != 0) {\n            //console.log(\"moving branch:\",branchOffset, maxSpaceBranch, minSpaceBranch)\n            _this3._shiftBlock(node.id, branchOffset);\n            //this.body.emitter.emit(\"_redraw\");\n            stillShifting = true;\n          }\n        };\n        var moveNode = function moveNode(guess) {\n          var nodePosition = _this3.direction.getPosition(node);\n\n          // position node if there is space\n          var _this3$_getSpaceAroun3 = _this3._getSpaceAroundNode(node),\n            _this3$_getSpaceAroun4 = _slicedToArray(_this3$_getSpaceAroun3, 2),\n            minSpace = _this3$_getSpaceAroun4[0],\n            maxSpace = _this3$_getSpaceAroun4[1];\n          var diff = guess - nodePosition;\n          // check if we are allowed to move the node:\n          var newPosition = nodePosition;\n          if (diff > 0) {\n            newPosition = Math.min(nodePosition + (maxSpace - _this3.options.hierarchical.nodeSpacing), guess);\n          } else if (diff < 0) {\n            newPosition = Math.max(nodePosition - (minSpace - _this3.options.hierarchical.nodeSpacing), guess);\n          }\n          if (newPosition !== nodePosition) {\n            //console.log(\"moving Node:\",diff, minSpace, maxSpace);\n            _this3.direction.setPosition(node, newPosition);\n            //this.body.emitter.emit(\"_redraw\");\n            stillShifting = true;\n          }\n        };\n        var guess = getGuess(iterations, aboveEdges);\n        moveBranch(guess);\n        guess = getGuess(iterations, allEdges);\n        moveNode(guess);\n        //})\n      };\n\n      // method to remove whitespace between branches. Because we do bottom up, we can center the parents.\n      var minimizeEdgeLengthBottomUp = function minimizeEdgeLengthBottomUp(iterations) {\n        var levels = _this3.hierarchical.getLevels();\n        levels = _reverseInstanceProperty(levels).call(levels);\n        for (var i = 0; i < iterations; i++) {\n          stillShifting = false;\n          for (var j = 0; j < levels.length; j++) {\n            var level = levels[j];\n            var levelNodes = _this3.hierarchical.distributionOrdering[level];\n            for (var k = 0; k < levelNodes.length; k++) {\n              minimizeEdgeLength(1000, levelNodes[k]);\n            }\n          }\n          if (stillShifting !== true) {\n            //console.log(\"FINISHED minimizeEdgeLengthBottomUp IN \" + i);\n            break;\n          }\n        }\n      };\n\n      // method to remove whitespace between branches. Because we do bottom up, we can center the parents.\n      var shiftBranchesCloserBottomUp = function shiftBranchesCloserBottomUp(iterations) {\n        var levels = _this3.hierarchical.getLevels();\n        levels = _reverseInstanceProperty(levels).call(levels);\n        for (var i = 0; i < iterations; i++) {\n          stillShifting = false;\n          shiftElementsCloser(branchShiftCallback, levels, true);\n          if (stillShifting !== true) {\n            //console.log(\"FINISHED shiftBranchesCloserBottomUp IN \" + (i+1));\n            break;\n          }\n        }\n      };\n\n      // center all parents\n      var centerAllParents = function centerAllParents() {\n        for (var nodeId in _this3.body.nodes) {\n          if (Object.prototype.hasOwnProperty.call(_this3.body.nodes, nodeId)) _this3._centerParent(_this3.body.nodes[nodeId]);\n        }\n      };\n\n      // center all parents\n      var centerAllParentsBottomUp = function centerAllParentsBottomUp() {\n        var levels = _this3.hierarchical.getLevels();\n        levels = _reverseInstanceProperty(levels).call(levels);\n        for (var i = 0; i < levels.length; i++) {\n          var level = levels[i];\n          var levelNodes = _this3.hierarchical.distributionOrdering[level];\n          for (var j = 0; j < levelNodes.length; j++) {\n            _this3._centerParent(levelNodes[j]);\n          }\n        }\n      };\n\n      // the actual work is done here.\n      if (this.options.hierarchical.blockShifting === true) {\n        shiftBranchesCloserBottomUp(5);\n        centerAllParents();\n      }\n\n      // minimize edge length\n      if (this.options.hierarchical.edgeMinimization === true) {\n        minimizeEdgeLengthBottomUp(20);\n      }\n      if (this.options.hierarchical.parentCentralization === true) {\n        centerAllParentsBottomUp();\n      }\n      shiftTrees();\n    }\n\n    /**\n     * This gives the space around the node. IF a map is supplied, it will only check against nodes NOT in the map.\n     * This is used to only get the distances to nodes outside of a branch.\n     *\n     * @param {Node} node\n     * @param {{Node.id: vis.Node}} map\n     * @returns {number[]}\n     * @private\n     */\n  }, {\n    key: \"_getSpaceAroundNode\",\n    value: function _getSpaceAroundNode(node, map) {\n      var useMap = true;\n      if (map === undefined) {\n        useMap = false;\n      }\n      var level = this.hierarchical.levels[node.id];\n      if (level !== undefined) {\n        var index = this.hierarchical.distributionIndex[node.id];\n        var position = this.direction.getPosition(node);\n        var ordering = this.hierarchical.distributionOrdering[level];\n        var minSpace = 1e9;\n        var maxSpace = 1e9;\n        if (index !== 0) {\n          var prevNode = ordering[index - 1];\n          if (useMap === true && map[prevNode.id] === undefined || useMap === false) {\n            var prevPos = this.direction.getPosition(prevNode);\n            minSpace = position - prevPos;\n          }\n        }\n        if (index != ordering.length - 1) {\n          var nextNode = ordering[index + 1];\n          if (useMap === true && map[nextNode.id] === undefined || useMap === false) {\n            var nextPos = this.direction.getPosition(nextNode);\n            maxSpace = Math.min(maxSpace, nextPos - position);\n          }\n        }\n        return [minSpace, maxSpace];\n      } else {\n        return [0, 0];\n      }\n    }\n\n    /**\n     * We use this method to center a parent node and check if it does not cross other nodes when it does.\n     *\n     * @param {Node} node\n     * @private\n     */\n  }, {\n    key: \"_centerParent\",\n    value: function _centerParent(node) {\n      if (this.hierarchical.parentReference[node.id]) {\n        var parents = this.hierarchical.parentReference[node.id];\n        for (var i = 0; i < parents.length; i++) {\n          var parentId = parents[i];\n          var parentNode = this.body.nodes[parentId];\n          var children = this.hierarchical.childrenReference[parentId];\n          if (children !== undefined) {\n            // get the range of the children\n            var newPosition = this._getCenterPosition(children);\n            var position = this.direction.getPosition(parentNode);\n            var _this$_getSpaceAround = this._getSpaceAroundNode(parentNode),\n              _this$_getSpaceAround2 = _slicedToArray(_this$_getSpaceAround, 2),\n              minSpace = _this$_getSpaceAround2[0],\n              maxSpace = _this$_getSpaceAround2[1];\n            var diff = position - newPosition;\n            if (diff < 0 && Math.abs(diff) < maxSpace - this.options.hierarchical.nodeSpacing || diff > 0 && Math.abs(diff) < minSpace - this.options.hierarchical.nodeSpacing) {\n              this.direction.setPosition(parentNode, newPosition);\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * This function places the nodes on the canvas based on the hierarchial distribution.\n     *\n     * @param {object} distribution | obtained by the function this._getDistribution()\n     * @private\n     */\n  }, {\n    key: \"_placeNodesByHierarchy\",\n    value: function _placeNodesByHierarchy(distribution) {\n      this.positionedNodes = {};\n      // start placing all the level 0 nodes first. Then recursively position their branches.\n      for (var level in distribution) {\n        if (Object.prototype.hasOwnProperty.call(distribution, level)) {\n          var _context;\n          // sort nodes in level by position:\n          var nodeArray = _Object$keys(distribution[level]);\n          nodeArray = this._indexArrayToNodes(nodeArray);\n          _sortInstanceProperty(_context = this.direction).call(_context, nodeArray);\n          var handledNodeCount = 0;\n          for (var i = 0; i < nodeArray.length; i++) {\n            var node = nodeArray[i];\n            if (this.positionedNodes[node.id] === undefined) {\n              var spacing = this.options.hierarchical.nodeSpacing;\n              var pos = spacing * handledNodeCount;\n              // We get the X or Y values we need and store them in pos and previousPos.\n              // The get and set make sure we get X or Y\n              if (handledNodeCount > 0) {\n                pos = this.direction.getPosition(nodeArray[i - 1]) + spacing;\n              }\n              this.direction.setPosition(node, pos, level);\n              this._validatePositionAndContinue(node, level, pos);\n              handledNodeCount++;\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * This is a recursively called function to enumerate the branches from the largest hubs and place the nodes\n     * on a X position that ensures there will be no overlap.\n     *\n     * @param {Node.id} parentId\n     * @param {number} parentLevel\n     * @private\n     */\n  }, {\n    key: \"_placeBranchNodes\",\n    value: function _placeBranchNodes(parentId, parentLevel) {\n      var _context2;\n      var childRef = this.hierarchical.childrenReference[parentId];\n\n      // if this is not a parent, cancel the placing. This can happen with multiple parents to one child.\n      if (childRef === undefined) {\n        return;\n      }\n\n      // get a list of childNodes\n      var childNodes = [];\n      for (var i = 0; i < childRef.length; i++) {\n        childNodes.push(this.body.nodes[childRef[i]]);\n      }\n\n      // use the positions to order the nodes.\n      _sortInstanceProperty(_context2 = this.direction).call(_context2, childNodes);\n\n      // position the childNodes\n      for (var _i5 = 0; _i5 < childNodes.length; _i5++) {\n        var childNode = childNodes[_i5];\n        var childNodeLevel = this.hierarchical.levels[childNode.id];\n        // check if the child node is below the parent node and if it has already been positioned.\n        if (childNodeLevel > parentLevel && this.positionedNodes[childNode.id] === undefined) {\n          // get the amount of space required for this node. If parent the width is based on the amount of children.\n          var spacing = this.options.hierarchical.nodeSpacing;\n          var pos = void 0;\n\n          // we get the X or Y values we need and store them in pos and previousPos.\n          // The get and set make sure we get X or Y\n          if (_i5 === 0) {\n            pos = this.direction.getPosition(this.body.nodes[parentId]);\n          } else {\n            pos = this.direction.getPosition(childNodes[_i5 - 1]) + spacing;\n          }\n          this.direction.setPosition(childNode, pos, childNodeLevel);\n          this._validatePositionAndContinue(childNode, childNodeLevel, pos);\n        } else {\n          return;\n        }\n      }\n\n      // center the parent nodes.\n      var center = this._getCenterPosition(childNodes);\n      this.direction.setPosition(this.body.nodes[parentId], center, parentLevel);\n    }\n\n    /**\n     * This method checks for overlap and if required shifts the branch. It also keeps records of positioned nodes.\n     * Finally it will call _placeBranchNodes to place the branch nodes.\n     *\n     * @param {Node} node\n     * @param {number} level\n     * @param {number} pos\n     * @private\n     */\n  }, {\n    key: \"_validatePositionAndContinue\",\n    value: function _validatePositionAndContinue(node, level, pos) {\n      // This method only works for formal trees and formal forests\n      // Early exit if this is not the case\n      if (!this.hierarchical.isTree) return;\n\n      // if overlap has been detected, we shift the branch\n      if (this.lastNodeOnLevel[level] !== undefined) {\n        var previousPos = this.direction.getPosition(this.body.nodes[this.lastNodeOnLevel[level]]);\n        if (pos - previousPos < this.options.hierarchical.nodeSpacing) {\n          var diff = previousPos + this.options.hierarchical.nodeSpacing - pos;\n          var sharedParent = this._findCommonParent(this.lastNodeOnLevel[level], node.id);\n          this._shiftBlock(sharedParent.withChild, diff);\n        }\n      }\n      this.lastNodeOnLevel[level] = node.id; // store change in position.\n      this.positionedNodes[node.id] = true;\n      this._placeBranchNodes(node.id, level);\n    }\n\n    /**\n     * Receives an array with node indices and returns an array with the actual node references.\n     * Used for sorting based on node properties.\n     *\n     * @param {Array.<Node.id>} idArray\n     * @returns {Array.<Node>}\n     */\n  }, {\n    key: \"_indexArrayToNodes\",\n    value: function _indexArrayToNodes(idArray) {\n      var array = [];\n      for (var i = 0; i < idArray.length; i++) {\n        array.push(this.body.nodes[idArray[i]]);\n      }\n      return array;\n    }\n\n    /**\n     * This function get the distribution of levels based on hubsize\n     *\n     * @returns {object}\n     * @private\n     */\n  }, {\n    key: \"_getDistribution\",\n    value: function _getDistribution() {\n      var distribution = {};\n      var nodeId, node;\n\n      // we fix Y because the hierarchy is vertical,\n      // we fix X so we do not give a node an x position for a second time.\n      // the fix of X is removed after the x value has been set.\n      for (nodeId in this.body.nodes) {\n        if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {\n          node = this.body.nodes[nodeId];\n          var level = this.hierarchical.levels[nodeId] === undefined ? 0 : this.hierarchical.levels[nodeId];\n          this.direction.fix(node, level);\n          if (distribution[level] === undefined) {\n            distribution[level] = {};\n          }\n          distribution[level][nodeId] = node;\n        }\n      }\n      return distribution;\n    }\n\n    /**\n     * Return the active (i.e. visible) edges for this node\n     *\n     * @param {Node} node\n     * @returns {Array.<vis.Edge>} Array of edge instances\n     * @private\n     */\n  }, {\n    key: \"_getActiveEdges\",\n    value: function _getActiveEdges(node) {\n      var _this4 = this;\n      var result = [];\n      forEach$1(node.edges, function (edge) {\n        var _context3;\n        if (_indexOfInstanceProperty(_context3 = _this4.body.edgeIndices).call(_context3, edge.id) !== -1) {\n          result.push(edge);\n        }\n      });\n      return result;\n    }\n\n    /**\n     * Get the hubsizes for all active nodes.\n     *\n     * @returns {number}\n     * @private\n     */\n  }, {\n    key: \"_getHubSizes\",\n    value: function _getHubSizes() {\n      var _this5 = this;\n      var hubSizes = {};\n      var nodeIds = this.body.nodeIndices;\n      forEach$1(nodeIds, function (nodeId) {\n        var node = _this5.body.nodes[nodeId];\n        var hubSize = _this5._getActiveEdges(node).length;\n        hubSizes[hubSize] = true;\n      });\n\n      // Make an array of the size sorted descending\n      var result = [];\n      forEach$1(hubSizes, function (size) {\n        result.push(Number(size));\n      });\n      _sortInstanceProperty(result).call(result, function (a, b) {\n        return b - a;\n      });\n      return result;\n    }\n\n    /**\n     * this function allocates nodes in levels based on the recursive branching from the largest hubs.\n     *\n     * @private\n     */\n  }, {\n    key: \"_determineLevelsByHubsize\",\n    value: function _determineLevelsByHubsize() {\n      var _this6 = this;\n      var levelDownstream = function levelDownstream(nodeA, nodeB) {\n        _this6.hierarchical.levelDownstream(nodeA, nodeB);\n      };\n      var hubSizes = this._getHubSizes();\n      var _loop = function _loop() {\n        var hubSize = hubSizes[i];\n        if (hubSize === 0) return 1; // break\n        forEach$1(_this6.body.nodeIndices, function (nodeId) {\n          var node = _this6.body.nodes[nodeId];\n          if (hubSize === _this6._getActiveEdges(node).length) {\n            _this6._crawlNetwork(levelDownstream, nodeId);\n          }\n        });\n      };\n      for (var i = 0; i < hubSizes.length; ++i) {\n        if (_loop()) break;\n      }\n    }\n\n    /**\n     * TODO: release feature\n     * TODO: Determine if this feature is needed at all\n     *\n     * @private\n     */\n  }, {\n    key: \"_determineLevelsCustomCallback\",\n    value: function _determineLevelsCustomCallback() {\n      var _this7 = this;\n      var minLevel = 100000;\n\n      // TODO: this should come from options.\n      // eslint-disable-next-line no-unused-vars -- This should eventually be implemented with these parameters used.\n      var customCallback = function customCallback(nodeA, nodeB, edge) {};\n\n      // TODO: perhaps move to HierarchicalStatus.\n      //       But I currently don't see the point, this method is not used.\n      var levelByDirection = function levelByDirection(nodeA, nodeB, edge) {\n        var levelA = _this7.hierarchical.levels[nodeA.id];\n        // set initial level\n        if (levelA === undefined) {\n          levelA = _this7.hierarchical.levels[nodeA.id] = minLevel;\n        }\n        var diff = customCallback(NetworkUtil.cloneOptions(nodeA, \"node\"), NetworkUtil.cloneOptions(nodeB, \"node\"), NetworkUtil.cloneOptions(edge, \"edge\"));\n        _this7.hierarchical.levels[nodeB.id] = levelA + diff;\n      };\n      this._crawlNetwork(levelByDirection);\n      this.hierarchical.setMinLevelToZero(this.body.nodes);\n    }\n\n    /**\n     * Allocate nodes in levels based on the direction of the edges.\n     *\n     * @private\n     */\n  }, {\n    key: \"_determineLevelsDirected\",\n    value: function _determineLevelsDirected() {\n      var _context4,\n        _this8 = this;\n      var nodes = _reduceInstanceProperty(_context4 = this.body.nodeIndices).call(_context4, function (acc, id) {\n        acc.set(id, _this8.body.nodes[id]);\n        return acc;\n      }, new _Map());\n      if (this.options.hierarchical.shakeTowards === \"roots\") {\n        this.hierarchical.levels = fillLevelsByDirectionRoots(nodes);\n      } else {\n        this.hierarchical.levels = fillLevelsByDirectionLeaves(nodes);\n      }\n      this.hierarchical.setMinLevelToZero(this.body.nodes);\n    }\n\n    /**\n     * Update the bookkeeping of parent and child.\n     *\n     * @private\n     */\n  }, {\n    key: \"_generateMap\",\n    value: function _generateMap() {\n      var _this9 = this;\n      var fillInRelations = function fillInRelations(parentNode, childNode) {\n        if (_this9.hierarchical.levels[childNode.id] > _this9.hierarchical.levels[parentNode.id]) {\n          _this9.hierarchical.addRelation(parentNode.id, childNode.id);\n        }\n      };\n      this._crawlNetwork(fillInRelations);\n      this.hierarchical.checkIfTree();\n    }\n\n    /**\n     * Crawl over the entire network and use a callback on each node couple that is connected to each other.\n     *\n     * @param {Function} [callback=function(){}]          | will receive nodeA, nodeB and the connecting edge. A and B are distinct.\n     * @param {Node.id} startingNodeId\n     * @private\n     */\n  }, {\n    key: \"_crawlNetwork\",\n    value: function _crawlNetwork() {\n      var _this10 = this;\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n      var startingNodeId = arguments.length > 1 ? arguments[1] : undefined;\n      var progress = {};\n      var crawler = function crawler(node, tree) {\n        if (progress[node.id] === undefined) {\n          _this10.hierarchical.setTreeIndex(node, tree);\n          progress[node.id] = true;\n          var childNode;\n          var edges = _this10._getActiveEdges(node);\n          for (var i = 0; i < edges.length; i++) {\n            var edge = edges[i];\n            if (edge.connected === true) {\n              if (edge.toId == node.id) {\n                // Not '===' because id's can be string and numeric\n                childNode = edge.from;\n              } else {\n                childNode = edge.to;\n              }\n              if (node.id != childNode.id) {\n                // Not '!==' because id's can be string and numeric\n                callback(node, childNode, edge);\n                crawler(childNode, tree);\n              }\n            }\n          }\n        }\n      };\n      if (startingNodeId === undefined) {\n        // Crawl over all nodes\n        var treeIndex = 0; // Serves to pass a unique id for the current distinct tree\n\n        for (var i = 0; i < this.body.nodeIndices.length; i++) {\n          var nodeId = this.body.nodeIndices[i];\n          if (progress[nodeId] === undefined) {\n            var node = this.body.nodes[nodeId];\n            crawler(node, treeIndex);\n            treeIndex += 1;\n          }\n        }\n      } else {\n        // Crawl from the given starting node\n        var _node2 = this.body.nodes[startingNodeId];\n        if (_node2 === undefined) {\n          console.error(\"Node not found:\", startingNodeId);\n          return;\n        }\n        crawler(_node2);\n      }\n    }\n\n    /**\n     * Shift a branch a certain distance\n     *\n     * @param {Node.id} parentId\n     * @param {number} diff\n     * @private\n     */\n  }, {\n    key: \"_shiftBlock\",\n    value: function _shiftBlock(parentId, diff) {\n      var _this11 = this;\n      var progress = {};\n      var shifter = function shifter(parentId) {\n        if (progress[parentId]) {\n          return;\n        }\n        progress[parentId] = true;\n        _this11.direction.shift(parentId, diff);\n        var childRef = _this11.hierarchical.childrenReference[parentId];\n        if (childRef !== undefined) {\n          for (var i = 0; i < childRef.length; i++) {\n            shifter(childRef[i]);\n          }\n        }\n      };\n      shifter(parentId);\n    }\n\n    /**\n     * Find a common parent between branches.\n     *\n     * @param {Node.id} childA\n     * @param {Node.id} childB\n     * @returns {{foundParent, withChild}}\n     * @private\n     */\n  }, {\n    key: \"_findCommonParent\",\n    value: function _findCommonParent(childA, childB) {\n      var _this12 = this;\n      var parents = {};\n      var iterateParents = function iterateParents(parents, child) {\n        var parentRef = _this12.hierarchical.parentReference[child];\n        if (parentRef !== undefined) {\n          for (var i = 0; i < parentRef.length; i++) {\n            var parent = parentRef[i];\n            parents[parent] = true;\n            iterateParents(parents, parent);\n          }\n        }\n      };\n      var findParent = function findParent(parents, child) {\n        var parentRef = _this12.hierarchical.parentReference[child];\n        if (parentRef !== undefined) {\n          for (var i = 0; i < parentRef.length; i++) {\n            var parent = parentRef[i];\n            if (parents[parent] !== undefined) {\n              return {\n                foundParent: parent,\n                withChild: child\n              };\n            }\n            var branch = findParent(parents, parent);\n            if (branch.foundParent !== null) {\n              return branch;\n            }\n          }\n        }\n        return {\n          foundParent: null,\n          withChild: child\n        };\n      };\n      iterateParents(parents, childA);\n      return findParent(parents, childB);\n    }\n\n    /**\n     * Set the strategy pattern for handling the coordinates given the current direction.\n     *\n     * The individual instances contain all the operations and data specific to a layout direction.\n     *\n     * @param {Node} node\n     * @param {{x: number, y: number}} position\n     * @param {number} level\n     * @param {boolean} [doNotUpdate=false]\n     * @private\n     */\n  }, {\n    key: \"setDirectionStrategy\",\n    value: function setDirectionStrategy() {\n      var isVertical = this.options.hierarchical.direction === \"UD\" || this.options.hierarchical.direction === \"DU\";\n      if (isVertical) {\n        this.direction = new VerticalStrategy(this);\n      } else {\n        this.direction = new HorizontalStrategy(this);\n      }\n    }\n\n    /**\n     * Determine the center position of a branch from the passed list of child nodes\n     *\n     * This takes into account the positions of all the child nodes.\n     *\n     * @param {Array.<Node|vis.Node.id>} childNodes  Array of either child nodes or node id's\n     * @returns {number}\n     * @private\n     */\n  }, {\n    key: \"_getCenterPosition\",\n    value: function _getCenterPosition(childNodes) {\n      var minPos = 1e9;\n      var maxPos = -1e9;\n      for (var i = 0; i < childNodes.length; i++) {\n        var childNode = void 0;\n        if (childNodes[i].id !== undefined) {\n          childNode = childNodes[i];\n        } else {\n          var childNodeId = childNodes[i];\n          childNode = this.body.nodes[childNodeId];\n        }\n        var position = this.direction.getPosition(childNode);\n        minPos = Math.min(minPos, position);\n        maxPos = Math.max(maxPos, position);\n      }\n      return 0.5 * (minPos + maxPos);\n    }\n  }]);\n  return LayoutEngine;\n}();\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof _Symbol !== \"undefined\" && _getIteratorMethod(o) || o[\"@@iterator\"]; if (!it) { if (_Array$isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { var _context32; if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = _sliceInstanceProperty(_context32 = Object.prototype.toString.call(o)).call(_context32, 8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return _Array$from$1(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n/**\n * Clears the toolbar div element of children\n *\n * @private\n */\nvar ManipulationSystem = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {Canvas} canvas\n   * @param {SelectionHandler} selectionHandler\n   * @param {InteractionHandler} interactionHandler\n   */\n  function ManipulationSystem(body, canvas, selectionHandler, interactionHandler) {\n    var _this = this,\n      _context,\n      _context2;\n    _classCallCheck(this, ManipulationSystem);\n    this.body = body;\n    this.canvas = canvas;\n    this.selectionHandler = selectionHandler;\n    this.interactionHandler = interactionHandler;\n    this.editMode = false;\n    this.manipulationDiv = undefined;\n    this.editModeDiv = undefined;\n    this.closeDiv = undefined;\n    this._domEventListenerCleanupQueue = [];\n    this.temporaryUIFunctions = {};\n    this.temporaryEventFunctions = [];\n    this.touchTime = 0;\n    this.temporaryIds = {\n      nodes: [],\n      edges: []\n    };\n    this.guiEnabled = false;\n    this.inMode = false;\n    this.selectedControlNode = undefined;\n    this.options = {};\n    this.defaultOptions = {\n      enabled: false,\n      initiallyActive: false,\n      addNode: true,\n      addEdge: true,\n      editNode: undefined,\n      editEdge: true,\n      deleteNode: true,\n      deleteEdge: true,\n      controlNodeStyle: {\n        shape: \"dot\",\n        size: 6,\n        color: {\n          background: \"#ff0000\",\n          border: \"#3c3c3c\",\n          highlight: {\n            background: \"#07f968\",\n            border: \"#3c3c3c\"\n          }\n        },\n        borderWidth: 2,\n        borderWidthSelected: 2\n      }\n    };\n    _Object$assign(this.options, this.defaultOptions);\n    this.body.emitter.on(\"destroy\", function () {\n      _this._clean();\n    });\n    this.body.emitter.on(\"_dataChanged\", _bindInstanceProperty$1(_context = this._restore).call(_context, this));\n    this.body.emitter.on(\"_resetData\", _bindInstanceProperty$1(_context2 = this._restore).call(_context2, this));\n  }\n\n  /**\n   * If something changes in the data during editing, switch back to the initial datamanipulation state and close all edit modes.\n   *\n   * @private\n   */\n  _createClass(ManipulationSystem, [{\n    key: \"_restore\",\n    value: function _restore() {\n      if (this.inMode !== false) {\n        if (this.options.initiallyActive === true) {\n          this.enableEditMode();\n        } else {\n          this.disableEditMode();\n        }\n      }\n    }\n\n    /**\n     * Set the Options\n     *\n     * @param {object} options\n     * @param {object} allOptions\n     * @param {object} globalOptions\n     */\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options, allOptions, globalOptions) {\n      if (allOptions !== undefined) {\n        if (allOptions.locale !== undefined) {\n          this.options.locale = allOptions.locale;\n        } else {\n          this.options.locale = globalOptions.locale;\n        }\n        if (allOptions.locales !== undefined) {\n          this.options.locales = allOptions.locales;\n        } else {\n          this.options.locales = globalOptions.locales;\n        }\n      }\n      if (options !== undefined) {\n        if (typeof options === \"boolean\") {\n          this.options.enabled = options;\n        } else {\n          this.options.enabled = true;\n          deepExtend(this.options, options);\n        }\n        if (this.options.initiallyActive === true) {\n          this.editMode = true;\n        }\n        this._setup();\n      }\n    }\n\n    /**\n     * Enable or disable edit-mode. Draws the DOM required and cleans up after itself.\n     *\n     * @private\n     */\n  }, {\n    key: \"toggleEditMode\",\n    value: function toggleEditMode() {\n      if (this.editMode === true) {\n        this.disableEditMode();\n      } else {\n        this.enableEditMode();\n      }\n    }\n\n    /**\n     * Enables Edit Mode\n     */\n  }, {\n    key: \"enableEditMode\",\n    value: function enableEditMode() {\n      this.editMode = true;\n      this._clean();\n      if (this.guiEnabled === true) {\n        this.manipulationDiv.style.display = \"block\";\n        this.closeDiv.style.display = \"block\";\n        this.editModeDiv.style.display = \"none\";\n        this.showManipulatorToolbar();\n      }\n    }\n\n    /**\n     * Disables Edit Mode\n     */\n  }, {\n    key: \"disableEditMode\",\n    value: function disableEditMode() {\n      this.editMode = false;\n      this._clean();\n      if (this.guiEnabled === true) {\n        this.manipulationDiv.style.display = \"none\";\n        this.closeDiv.style.display = \"none\";\n        this.editModeDiv.style.display = \"block\";\n        this._createEditButton();\n      }\n    }\n\n    /**\n     * Creates the main toolbar. Removes functions bound to the select event. Binds all the buttons of the toolbar.\n     *\n     * @private\n     */\n  }, {\n    key: \"showManipulatorToolbar\",\n    value: function showManipulatorToolbar() {\n      // restore the state of any bound functions or events, remove control nodes, restore physics\n      this._clean();\n\n      // reset global variables\n      this.manipulationDOM = {};\n\n      // if the gui is enabled, draw all elements.\n      if (this.guiEnabled === true) {\n        var _context3, _context4;\n        // a _restore will hide these menus\n        this.editMode = true;\n        this.manipulationDiv.style.display = \"block\";\n        this.closeDiv.style.display = \"block\";\n        var selectedNodeCount = this.selectionHandler.getSelectedNodeCount();\n        var selectedEdgeCount = this.selectionHandler.getSelectedEdgeCount();\n        var selectedTotalCount = selectedNodeCount + selectedEdgeCount;\n        var locale = this.options.locales[this.options.locale];\n        var needSeperator = false;\n        if (this.options.addNode !== false) {\n          this._createAddNodeButton(locale);\n          needSeperator = true;\n        }\n        if (this.options.addEdge !== false) {\n          if (needSeperator === true) {\n            this._createSeperator(1);\n          } else {\n            needSeperator = true;\n          }\n          this._createAddEdgeButton(locale);\n        }\n        if (selectedNodeCount === 1 && typeof this.options.editNode === \"function\") {\n          if (needSeperator === true) {\n            this._createSeperator(2);\n          } else {\n            needSeperator = true;\n          }\n          this._createEditNodeButton(locale);\n        } else if (selectedEdgeCount === 1 && selectedNodeCount === 0 && this.options.editEdge !== false) {\n          if (needSeperator === true) {\n            this._createSeperator(3);\n          } else {\n            needSeperator = true;\n          }\n          this._createEditEdgeButton(locale);\n        }\n\n        // remove buttons\n        if (selectedTotalCount !== 0) {\n          if (selectedNodeCount > 0 && this.options.deleteNode !== false) {\n            if (needSeperator === true) {\n              this._createSeperator(4);\n            }\n            this._createDeleteButton(locale);\n          } else if (selectedNodeCount === 0 && this.options.deleteEdge !== false) {\n            if (needSeperator === true) {\n              this._createSeperator(4);\n            }\n            this._createDeleteButton(locale);\n          }\n        }\n\n        // bind the close button\n        this._bindElementEvents(this.closeDiv, _bindInstanceProperty$1(_context3 = this.toggleEditMode).call(_context3, this));\n\n        // refresh this bar based on what has been selected\n        this._temporaryBindEvent(\"select\", _bindInstanceProperty$1(_context4 = this.showManipulatorToolbar).call(_context4, this));\n      }\n\n      // redraw to show any possible changes\n      this.body.emitter.emit(\"_redraw\");\n    }\n\n    /**\n     * Create the toolbar for adding Nodes\n     */\n  }, {\n    key: \"addNodeMode\",\n    value: function addNodeMode() {\n      var _context6;\n      // when using the gui, enable edit mode if it wasnt already.\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      }\n\n      // restore the state of any bound functions or events, remove control nodes, restore physics\n      this._clean();\n      this.inMode = \"addNode\";\n      if (this.guiEnabled === true) {\n        var _context5;\n        var locale = this.options.locales[this.options.locale];\n        this.manipulationDOM = {};\n        this._createBackButton(locale);\n        this._createSeperator();\n        this._createDescription(locale[\"addDescription\"] || this.options.locales[\"en\"][\"addDescription\"]);\n\n        // bind the close button\n        this._bindElementEvents(this.closeDiv, _bindInstanceProperty$1(_context5 = this.toggleEditMode).call(_context5, this));\n      }\n      this._temporaryBindEvent(\"click\", _bindInstanceProperty$1(_context6 = this._performAddNode).call(_context6, this));\n    }\n\n    /**\n     * call the bound function to handle the editing of the node. The node has to be selected.\n     */\n  }, {\n    key: \"editNode\",\n    value: function editNode() {\n      var _this2 = this;\n      // when using the gui, enable edit mode if it wasnt already.\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      }\n\n      // restore the state of any bound functions or events, remove control nodes, restore physics\n      this._clean();\n      var node = this.selectionHandler.getSelectedNodes()[0];\n      if (node !== undefined) {\n        this.inMode = \"editNode\";\n        if (typeof this.options.editNode === \"function\") {\n          if (node.isCluster !== true) {\n            var data = deepExtend({}, node.options, false);\n            data.x = node.x;\n            data.y = node.y;\n            if (this.options.editNode.length === 2) {\n              this.options.editNode(data, function (finalizedData) {\n                if (finalizedData !== null && finalizedData !== undefined && _this2.inMode === \"editNode\") {\n                  // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {\n                  _this2.body.data.nodes.getDataSet().update(finalizedData);\n                }\n                _this2.showManipulatorToolbar();\n              });\n            } else {\n              throw new Error(\"The function for edit does not support two arguments (data, callback)\");\n            }\n          } else {\n            alert(this.options.locales[this.options.locale][\"editClusterError\"] || this.options.locales[\"en\"][\"editClusterError\"]);\n          }\n        } else {\n          throw new Error(\"No function has been configured to handle the editing of nodes.\");\n        }\n      } else {\n        this.showManipulatorToolbar();\n      }\n    }\n\n    /**\n     * create the toolbar to connect nodes\n     */\n  }, {\n    key: \"addEdgeMode\",\n    value: function addEdgeMode() {\n      var _context8, _context9, _context10, _context11, _context12;\n      // when using the gui, enable edit mode if it wasnt already.\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      }\n\n      // restore the state of any bound functions or events, remove control nodes, restore physics\n      this._clean();\n      this.inMode = \"addEdge\";\n      if (this.guiEnabled === true) {\n        var _context7;\n        var locale = this.options.locales[this.options.locale];\n        this.manipulationDOM = {};\n        this._createBackButton(locale);\n        this._createSeperator();\n        this._createDescription(locale[\"edgeDescription\"] || this.options.locales[\"en\"][\"edgeDescription\"]);\n\n        // bind the close button\n        this._bindElementEvents(this.closeDiv, _bindInstanceProperty$1(_context7 = this.toggleEditMode).call(_context7, this));\n      }\n\n      // temporarily overload functions\n      this._temporaryBindUI(\"onTouch\", _bindInstanceProperty$1(_context8 = this._handleConnect).call(_context8, this));\n      this._temporaryBindUI(\"onDragEnd\", _bindInstanceProperty$1(_context9 = this._finishConnect).call(_context9, this));\n      this._temporaryBindUI(\"onDrag\", _bindInstanceProperty$1(_context10 = this._dragControlNode).call(_context10, this));\n      this._temporaryBindUI(\"onRelease\", _bindInstanceProperty$1(_context11 = this._finishConnect).call(_context11, this));\n      this._temporaryBindUI(\"onDragStart\", _bindInstanceProperty$1(_context12 = this._dragStartEdge).call(_context12, this));\n      this._temporaryBindUI(\"onHold\", function () {});\n    }\n\n    /**\n     * create the toolbar to edit edges\n     */\n  }, {\n    key: \"editEdgeMode\",\n    value: function editEdgeMode() {\n      // when using the gui, enable edit mode if it wasn't already.\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      }\n\n      // restore the state of any bound functions or events, remove control nodes, restore physics\n      this._clean();\n      this.inMode = \"editEdge\";\n      if (_typeof(this.options.editEdge) === \"object\" && typeof this.options.editEdge.editWithoutDrag === \"function\") {\n        this.edgeBeingEditedId = this.selectionHandler.getSelectedEdgeIds()[0];\n        if (this.edgeBeingEditedId !== undefined) {\n          var edge = this.body.edges[this.edgeBeingEditedId];\n          this._performEditEdge(edge.from.id, edge.to.id);\n          return;\n        }\n      }\n      if (this.guiEnabled === true) {\n        var _context13;\n        var locale = this.options.locales[this.options.locale];\n        this.manipulationDOM = {};\n        this._createBackButton(locale);\n        this._createSeperator();\n        this._createDescription(locale[\"editEdgeDescription\"] || this.options.locales[\"en\"][\"editEdgeDescription\"]);\n\n        // bind the close button\n        this._bindElementEvents(this.closeDiv, _bindInstanceProperty$1(_context13 = this.toggleEditMode).call(_context13, this));\n      }\n      this.edgeBeingEditedId = this.selectionHandler.getSelectedEdgeIds()[0];\n      if (this.edgeBeingEditedId !== undefined) {\n        var _context14, _context15, _context16, _context17;\n        var _edge = this.body.edges[this.edgeBeingEditedId];\n\n        // create control nodes\n        var controlNodeFrom = this._getNewTargetNode(_edge.from.x, _edge.from.y);\n        var controlNodeTo = this._getNewTargetNode(_edge.to.x, _edge.to.y);\n        this.temporaryIds.nodes.push(controlNodeFrom.id);\n        this.temporaryIds.nodes.push(controlNodeTo.id);\n        this.body.nodes[controlNodeFrom.id] = controlNodeFrom;\n        this.body.nodeIndices.push(controlNodeFrom.id);\n        this.body.nodes[controlNodeTo.id] = controlNodeTo;\n        this.body.nodeIndices.push(controlNodeTo.id);\n\n        // temporarily overload UI functions, cleaned up automatically because of _temporaryBindUI\n        this._temporaryBindUI(\"onTouch\", _bindInstanceProperty$1(_context14 = this._controlNodeTouch).call(_context14, this)); // used to get the position\n        this._temporaryBindUI(\"onTap\", function () {}); // disabled\n        this._temporaryBindUI(\"onHold\", function () {}); // disabled\n        this._temporaryBindUI(\"onDragStart\", _bindInstanceProperty$1(_context15 = this._controlNodeDragStart).call(_context15, this)); // used to select control node\n        this._temporaryBindUI(\"onDrag\", _bindInstanceProperty$1(_context16 = this._controlNodeDrag).call(_context16, this)); // used to drag control node\n        this._temporaryBindUI(\"onDragEnd\", _bindInstanceProperty$1(_context17 = this._controlNodeDragEnd).call(_context17, this)); // used to connect or revert control nodes\n        this._temporaryBindUI(\"onMouseMove\", function () {}); // disabled\n\n        // create function to position control nodes correctly on movement\n        // automatically cleaned up because we use the temporary bind\n        this._temporaryBindEvent(\"beforeDrawing\", function (ctx) {\n          var positions = _edge.edgeType.findBorderPositions(ctx);\n          if (controlNodeFrom.selected === false) {\n            controlNodeFrom.x = positions.from.x;\n            controlNodeFrom.y = positions.from.y;\n          }\n          if (controlNodeTo.selected === false) {\n            controlNodeTo.x = positions.to.x;\n            controlNodeTo.y = positions.to.y;\n          }\n        });\n        this.body.emitter.emit(\"_redraw\");\n      } else {\n        this.showManipulatorToolbar();\n      }\n    }\n\n    /**\n     * delete everything in the selection\n     */\n  }, {\n    key: \"deleteSelected\",\n    value: function deleteSelected() {\n      var _this3 = this;\n      // when using the gui, enable edit mode if it wasnt already.\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      }\n\n      // restore the state of any bound functions or events, remove control nodes, restore physics\n      this._clean();\n      this.inMode = \"delete\";\n      var selectedNodes = this.selectionHandler.getSelectedNodeIds();\n      var selectedEdges = this.selectionHandler.getSelectedEdgeIds();\n      var deleteFunction = undefined;\n      if (selectedNodes.length > 0) {\n        for (var i = 0; i < selectedNodes.length; i++) {\n          if (this.body.nodes[selectedNodes[i]].isCluster === true) {\n            alert(this.options.locales[this.options.locale][\"deleteClusterError\"] || this.options.locales[\"en\"][\"deleteClusterError\"]);\n            return;\n          }\n        }\n        if (typeof this.options.deleteNode === \"function\") {\n          deleteFunction = this.options.deleteNode;\n        }\n      } else if (selectedEdges.length > 0) {\n        if (typeof this.options.deleteEdge === \"function\") {\n          deleteFunction = this.options.deleteEdge;\n        }\n      }\n      if (typeof deleteFunction === \"function\") {\n        var data = {\n          nodes: selectedNodes,\n          edges: selectedEdges\n        };\n        if (deleteFunction.length === 2) {\n          deleteFunction(data, function (finalizedData) {\n            if (finalizedData !== null && finalizedData !== undefined && _this3.inMode === \"delete\") {\n              // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {\n              _this3.body.data.edges.getDataSet().remove(finalizedData.edges);\n              _this3.body.data.nodes.getDataSet().remove(finalizedData.nodes);\n              _this3.body.emitter.emit(\"startSimulation\");\n              _this3.showManipulatorToolbar();\n            } else {\n              _this3.body.emitter.emit(\"startSimulation\");\n              _this3.showManipulatorToolbar();\n            }\n          });\n        } else {\n          throw new Error(\"The function for delete does not support two arguments (data, callback)\");\n        }\n      } else {\n        this.body.data.edges.getDataSet().remove(selectedEdges);\n        this.body.data.nodes.getDataSet().remove(selectedNodes);\n        this.body.emitter.emit(\"startSimulation\");\n        this.showManipulatorToolbar();\n      }\n    }\n\n    //********************************************** PRIVATE ***************************************//\n\n    /**\n     * draw or remove the DOM\n     *\n     * @private\n     */\n  }, {\n    key: \"_setup\",\n    value: function _setup() {\n      if (this.options.enabled === true) {\n        // Enable the GUI\n        this.guiEnabled = true;\n        this._createWrappers();\n        if (this.editMode === false) {\n          this._createEditButton();\n        } else {\n          this.showManipulatorToolbar();\n        }\n      } else {\n        this._removeManipulationDOM();\n\n        // disable the gui\n        this.guiEnabled = false;\n      }\n    }\n\n    /**\n     * create the div overlays that contain the DOM\n     *\n     * @private\n     */\n  }, {\n    key: \"_createWrappers\",\n    value: function _createWrappers() {\n      // load the manipulator HTML elements. All styling done in css.\n      if (this.manipulationDiv === undefined) {\n        this.manipulationDiv = document.createElement(\"div\");\n        this.manipulationDiv.className = \"vis-manipulation\";\n        if (this.editMode === true) {\n          this.manipulationDiv.style.display = \"block\";\n        } else {\n          this.manipulationDiv.style.display = \"none\";\n        }\n        this.canvas.frame.appendChild(this.manipulationDiv);\n      }\n\n      // container for the edit button.\n      if (this.editModeDiv === undefined) {\n        this.editModeDiv = document.createElement(\"div\");\n        this.editModeDiv.className = \"vis-edit-mode\";\n        if (this.editMode === true) {\n          this.editModeDiv.style.display = \"none\";\n        } else {\n          this.editModeDiv.style.display = \"block\";\n        }\n        this.canvas.frame.appendChild(this.editModeDiv);\n      }\n\n      // container for the close div button\n      if (this.closeDiv === undefined) {\n        var _this$options$locales, _this$options$locales2;\n        this.closeDiv = document.createElement(\"button\");\n        this.closeDiv.className = \"vis-close\";\n        this.closeDiv.setAttribute(\"aria-label\", (_this$options$locales = (_this$options$locales2 = this.options.locales[this.options.locale]) === null || _this$options$locales2 === void 0 ? void 0 : _this$options$locales2[\"close\"]) !== null && _this$options$locales !== void 0 ? _this$options$locales : this.options.locales[\"en\"][\"close\"]);\n        this.closeDiv.style.display = this.manipulationDiv.style.display;\n        this.canvas.frame.appendChild(this.closeDiv);\n      }\n    }\n\n    /**\n     * generate a new target node. Used for creating new edges and editing edges\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {Node}\n     * @private\n     */\n  }, {\n    key: \"_getNewTargetNode\",\n    value: function _getNewTargetNode(x, y) {\n      var controlNodeStyle = deepExtend({}, this.options.controlNodeStyle);\n      controlNodeStyle.id = \"targetNode\" + v4();\n      controlNodeStyle.hidden = false;\n      controlNodeStyle.physics = false;\n      controlNodeStyle.x = x;\n      controlNodeStyle.y = y;\n\n      // we have to define the bounding box in order for the nodes to be drawn immediately\n      var node = this.body.functions.createNode(controlNodeStyle);\n      node.shape.boundingBox = {\n        left: x,\n        right: x,\n        top: y,\n        bottom: y\n      };\n      return node;\n    }\n\n    /**\n     * Create the edit button\n     */\n  }, {\n    key: \"_createEditButton\",\n    value: function _createEditButton() {\n      var _context18;\n      // restore everything to it's original state (if applicable)\n      this._clean();\n\n      // reset the manipulationDOM\n      this.manipulationDOM = {};\n\n      // empty the editModeDiv\n      recursiveDOMDelete(this.editModeDiv);\n\n      // create the contents for the editMode button\n      var locale = this.options.locales[this.options.locale];\n      var button = this._createButton(\"editMode\", \"vis-edit vis-edit-mode\", locale[\"edit\"] || this.options.locales[\"en\"][\"edit\"]);\n      this.editModeDiv.appendChild(button);\n\n      // bind a hammer listener to the button, calling the function toggleEditMode.\n      this._bindElementEvents(button, _bindInstanceProperty$1(_context18 = this.toggleEditMode).call(_context18, this));\n    }\n\n    /**\n     * this function cleans up after everything this module does. Temporary elements, functions and events are removed, physics restored, hammers removed.\n     *\n     * @private\n     */\n  }, {\n    key: \"_clean\",\n    value: function _clean() {\n      // not in mode\n      this.inMode = false;\n\n      // _clean the divs\n      if (this.guiEnabled === true) {\n        recursiveDOMDelete(this.editModeDiv);\n        recursiveDOMDelete(this.manipulationDiv);\n\n        // removes all the bindings and overloads\n        this._cleanupDOMEventListeners();\n      }\n\n      // remove temporary nodes and edges\n      this._cleanupTemporaryNodesAndEdges();\n\n      // restore overloaded UI functions\n      this._unbindTemporaryUIs();\n\n      // remove the temporaryEventFunctions\n      this._unbindTemporaryEvents();\n\n      // restore the physics if required\n      this.body.emitter.emit(\"restorePhysics\");\n    }\n\n    /**\n     * Each dom element has it's own hammer. They are stored in this.manipulationHammers. This cleans them up.\n     *\n     * @private\n     */\n  }, {\n    key: \"_cleanupDOMEventListeners\",\n    value: function _cleanupDOMEventListeners() {\n      var _context19;\n      // _clean DOM event listener bindings\n      var _iterator = _createForOfIteratorHelper(_spliceInstanceProperty(_context19 = this._domEventListenerCleanupQueue).call(_context19, 0)),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var callback = _step.value;\n          callback();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    /**\n     * Remove all DOM elements created by this module.\n     *\n     * @private\n     */\n  }, {\n    key: \"_removeManipulationDOM\",\n    value: function _removeManipulationDOM() {\n      // removes all the bindings and overloads\n      this._clean();\n\n      // empty the manipulation divs\n      recursiveDOMDelete(this.manipulationDiv);\n      recursiveDOMDelete(this.editModeDiv);\n      recursiveDOMDelete(this.closeDiv);\n\n      // remove the manipulation divs\n      if (this.manipulationDiv) {\n        this.canvas.frame.removeChild(this.manipulationDiv);\n      }\n      if (this.editModeDiv) {\n        this.canvas.frame.removeChild(this.editModeDiv);\n      }\n      if (this.closeDiv) {\n        this.canvas.frame.removeChild(this.closeDiv);\n      }\n\n      // set the references to undefined\n      this.manipulationDiv = undefined;\n      this.editModeDiv = undefined;\n      this.closeDiv = undefined;\n    }\n\n    /**\n     * create a seperator line. the index is to differentiate in the manipulation dom\n     *\n     * @param {number} [index=1]\n     * @private\n     */\n  }, {\n    key: \"_createSeperator\",\n    value: function _createSeperator() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      this.manipulationDOM[\"seperatorLineDiv\" + index] = document.createElement(\"div\");\n      this.manipulationDOM[\"seperatorLineDiv\" + index].className = \"vis-separator-line\";\n      this.manipulationDiv.appendChild(this.manipulationDOM[\"seperatorLineDiv\" + index]);\n    }\n\n    // ----------------------    DOM functions for buttons    --------------------------//\n\n    /**\n     *\n     * @param {Locale} locale\n     * @private\n     */\n  }, {\n    key: \"_createAddNodeButton\",\n    value: function _createAddNodeButton(locale) {\n      var _context20;\n      var button = this._createButton(\"addNode\", \"vis-add\", locale[\"addNode\"] || this.options.locales[\"en\"][\"addNode\"]);\n      this.manipulationDiv.appendChild(button);\n      this._bindElementEvents(button, _bindInstanceProperty$1(_context20 = this.addNodeMode).call(_context20, this));\n    }\n\n    /**\n     *\n     * @param {Locale} locale\n     * @private\n     */\n  }, {\n    key: \"_createAddEdgeButton\",\n    value: function _createAddEdgeButton(locale) {\n      var _context21;\n      var button = this._createButton(\"addEdge\", \"vis-connect\", locale[\"addEdge\"] || this.options.locales[\"en\"][\"addEdge\"]);\n      this.manipulationDiv.appendChild(button);\n      this._bindElementEvents(button, _bindInstanceProperty$1(_context21 = this.addEdgeMode).call(_context21, this));\n    }\n\n    /**\n     *\n     * @param {Locale} locale\n     * @private\n     */\n  }, {\n    key: \"_createEditNodeButton\",\n    value: function _createEditNodeButton(locale) {\n      var _context22;\n      var button = this._createButton(\"editNode\", \"vis-edit\", locale[\"editNode\"] || this.options.locales[\"en\"][\"editNode\"]);\n      this.manipulationDiv.appendChild(button);\n      this._bindElementEvents(button, _bindInstanceProperty$1(_context22 = this.editNode).call(_context22, this));\n    }\n\n    /**\n     *\n     * @param {Locale} locale\n     * @private\n     */\n  }, {\n    key: \"_createEditEdgeButton\",\n    value: function _createEditEdgeButton(locale) {\n      var _context23;\n      var button = this._createButton(\"editEdge\", \"vis-edit\", locale[\"editEdge\"] || this.options.locales[\"en\"][\"editEdge\"]);\n      this.manipulationDiv.appendChild(button);\n      this._bindElementEvents(button, _bindInstanceProperty$1(_context23 = this.editEdgeMode).call(_context23, this));\n    }\n\n    /**\n     *\n     * @param {Locale} locale\n     * @private\n     */\n  }, {\n    key: \"_createDeleteButton\",\n    value: function _createDeleteButton(locale) {\n      var _context24;\n      var deleteBtnClass;\n      if (this.options.rtl) {\n        deleteBtnClass = \"vis-delete-rtl\";\n      } else {\n        deleteBtnClass = \"vis-delete\";\n      }\n      var button = this._createButton(\"delete\", deleteBtnClass, locale[\"del\"] || this.options.locales[\"en\"][\"del\"]);\n      this.manipulationDiv.appendChild(button);\n      this._bindElementEvents(button, _bindInstanceProperty$1(_context24 = this.deleteSelected).call(_context24, this));\n    }\n\n    /**\n     *\n     * @param {Locale} locale\n     * @private\n     */\n  }, {\n    key: \"_createBackButton\",\n    value: function _createBackButton(locale) {\n      var _context25;\n      var button = this._createButton(\"back\", \"vis-back\", locale[\"back\"] || this.options.locales[\"en\"][\"back\"]);\n      this.manipulationDiv.appendChild(button);\n      this._bindElementEvents(button, _bindInstanceProperty$1(_context25 = this.showManipulatorToolbar).call(_context25, this));\n    }\n\n    /**\n     *\n     * @param {number|string} id\n     * @param {string} className\n     * @param {label} label\n     * @param {string} labelClassName\n     * @returns {HTMLElement}\n     * @private\n     */\n  }, {\n    key: \"_createButton\",\n    value: function _createButton(id, className, label) {\n      var labelClassName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"vis-label\";\n      this.manipulationDOM[id + \"Div\"] = document.createElement(\"button\");\n      this.manipulationDOM[id + \"Div\"].className = \"vis-button \" + className;\n      this.manipulationDOM[id + \"Label\"] = document.createElement(\"div\");\n      this.manipulationDOM[id + \"Label\"].className = labelClassName;\n      this.manipulationDOM[id + \"Label\"].innerText = label;\n      this.manipulationDOM[id + \"Div\"].appendChild(this.manipulationDOM[id + \"Label\"]);\n      return this.manipulationDOM[id + \"Div\"];\n    }\n\n    /**\n     *\n     * @param {Label} label\n     * @private\n     */\n  }, {\n    key: \"_createDescription\",\n    value: function _createDescription(label) {\n      this.manipulationDOM[\"descriptionLabel\"] = document.createElement(\"div\");\n      this.manipulationDOM[\"descriptionLabel\"].className = \"vis-none\";\n      this.manipulationDOM[\"descriptionLabel\"].innerText = label;\n      this.manipulationDiv.appendChild(this.manipulationDOM[\"descriptionLabel\"]);\n    }\n\n    // -------------------------- End of DOM functions for buttons ------------------------------//\n\n    /**\n     * this binds an event until cleanup by the clean functions.\n     *\n     * @param {Event}  event   The event\n     * @param {Function} newFunction\n     * @private\n     */\n  }, {\n    key: \"_temporaryBindEvent\",\n    value: function _temporaryBindEvent(event, newFunction) {\n      this.temporaryEventFunctions.push({\n        event: event,\n        boundFunction: newFunction\n      });\n      this.body.emitter.on(event, newFunction);\n    }\n\n    /**\n     * this overrides an UI function until cleanup by the clean function\n     *\n     * @param {string} UIfunctionName\n     * @param {Function} newFunction\n     * @private\n     */\n  }, {\n    key: \"_temporaryBindUI\",\n    value: function _temporaryBindUI(UIfunctionName, newFunction) {\n      if (this.body.eventListeners[UIfunctionName] !== undefined) {\n        this.temporaryUIFunctions[UIfunctionName] = this.body.eventListeners[UIfunctionName];\n        this.body.eventListeners[UIfunctionName] = newFunction;\n      } else {\n        throw new Error(\"This UI function does not exist. Typo? You tried: \" + UIfunctionName + \" possible are: \" + _JSON$stringify(_Object$keys(this.body.eventListeners)));\n      }\n    }\n\n    /**\n     * Restore the overridden UI functions to their original state.\n     *\n     * @private\n     */\n  }, {\n    key: \"_unbindTemporaryUIs\",\n    value: function _unbindTemporaryUIs() {\n      for (var functionName in this.temporaryUIFunctions) {\n        if (Object.prototype.hasOwnProperty.call(this.temporaryUIFunctions, functionName)) {\n          this.body.eventListeners[functionName] = this.temporaryUIFunctions[functionName];\n          delete this.temporaryUIFunctions[functionName];\n        }\n      }\n      this.temporaryUIFunctions = {};\n    }\n\n    /**\n     * Unbind the events created by _temporaryBindEvent\n     *\n     * @private\n     */\n  }, {\n    key: \"_unbindTemporaryEvents\",\n    value: function _unbindTemporaryEvents() {\n      for (var i = 0; i < this.temporaryEventFunctions.length; i++) {\n        var eventName = this.temporaryEventFunctions[i].event;\n        var boundFunction = this.temporaryEventFunctions[i].boundFunction;\n        this.body.emitter.off(eventName, boundFunction);\n      }\n      this.temporaryEventFunctions = [];\n    }\n\n    /**\n     * Bind an hammer instance to a DOM element.\n     *\n     * @param {Element} domElement\n     * @param {Function} boundFunction\n     */\n  }, {\n    key: \"_bindElementEvents\",\n    value: function _bindElementEvents(domElement, boundFunction) {\n      // Bind touch events.\n      var hammer = new Hammer(domElement, {});\n      onTouch(hammer, boundFunction);\n      this._domEventListenerCleanupQueue.push(function () {\n        hammer.destroy();\n      });\n\n      // Bind keyboard events.\n      var keyupListener = function keyupListener(_ref) {\n        var keyCode = _ref.keyCode,\n          key = _ref.key;\n        if (key === \"Enter\" || key === \" \" || keyCode === 13 || keyCode === 32) {\n          boundFunction();\n        }\n      };\n      domElement.addEventListener(\"keyup\", keyupListener, false);\n      this._domEventListenerCleanupQueue.push(function () {\n        domElement.removeEventListener(\"keyup\", keyupListener, false);\n      });\n    }\n\n    /**\n     * Neatly clean up temporary edges and nodes\n     *\n     * @private\n     */\n  }, {\n    key: \"_cleanupTemporaryNodesAndEdges\",\n    value: function _cleanupTemporaryNodesAndEdges() {\n      // _clean temporary edges\n      for (var i = 0; i < this.temporaryIds.edges.length; i++) {\n        var _context26;\n        this.body.edges[this.temporaryIds.edges[i]].disconnect();\n        delete this.body.edges[this.temporaryIds.edges[i]];\n        var indexTempEdge = _indexOfInstanceProperty(_context26 = this.body.edgeIndices).call(_context26, this.temporaryIds.edges[i]);\n        if (indexTempEdge !== -1) {\n          var _context27;\n          _spliceInstanceProperty(_context27 = this.body.edgeIndices).call(_context27, indexTempEdge, 1);\n        }\n      }\n\n      // _clean temporary nodes\n      for (var _i = 0; _i < this.temporaryIds.nodes.length; _i++) {\n        var _context28;\n        delete this.body.nodes[this.temporaryIds.nodes[_i]];\n        var indexTempNode = _indexOfInstanceProperty(_context28 = this.body.nodeIndices).call(_context28, this.temporaryIds.nodes[_i]);\n        if (indexTempNode !== -1) {\n          var _context29;\n          _spliceInstanceProperty(_context29 = this.body.nodeIndices).call(_context29, indexTempNode, 1);\n        }\n      }\n      this.temporaryIds = {\n        nodes: [],\n        edges: []\n      };\n    }\n\n    // ------------------------------------------ EDIT EDGE FUNCTIONS -----------------------------------------//\n\n    /**\n     * the touch is used to get the position of the initial click\n     *\n     * @param {Event}  event   The event\n     * @private\n     */\n  }, {\n    key: \"_controlNodeTouch\",\n    value: function _controlNodeTouch(event) {\n      this.selectionHandler.unselectAll();\n      this.lastTouch = this.body.functions.getPointer(event.center);\n      this.lastTouch.translation = _Object$assign({}, this.body.view.translation); // copy the object\n    }\n\n    /**\n     * the drag start is used to mark one of the control nodes as selected.\n     *\n     * @private\n     */\n  }, {\n    key: \"_controlNodeDragStart\",\n    value: function _controlNodeDragStart() {\n      var pointer = this.lastTouch;\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);\n      var from = this.body.nodes[this.temporaryIds.nodes[0]];\n      var to = this.body.nodes[this.temporaryIds.nodes[1]];\n      var edge = this.body.edges[this.edgeBeingEditedId];\n      this.selectedControlNode = undefined;\n      var fromSelect = from.isOverlappingWith(pointerObj);\n      var toSelect = to.isOverlappingWith(pointerObj);\n      if (fromSelect === true) {\n        this.selectedControlNode = from;\n        edge.edgeType.from = from;\n      } else if (toSelect === true) {\n        this.selectedControlNode = to;\n        edge.edgeType.to = to;\n      }\n\n      // we use the selection to find the node that is being dragged. We explicitly select it here.\n      if (this.selectedControlNode !== undefined) {\n        this.selectionHandler.selectObject(this.selectedControlNode);\n      }\n      this.body.emitter.emit(\"_redraw\");\n    }\n\n    /**\n     * dragging the control nodes or the canvas\n     *\n     * @param {Event}  event   The event\n     * @private\n     */\n  }, {\n    key: \"_controlNodeDrag\",\n    value: function _controlNodeDrag(event) {\n      this.body.emitter.emit(\"disablePhysics\");\n      var pointer = this.body.functions.getPointer(event.center);\n      var pos = this.canvas.DOMtoCanvas(pointer);\n      if (this.selectedControlNode !== undefined) {\n        this.selectedControlNode.x = pos.x;\n        this.selectedControlNode.y = pos.y;\n      } else {\n        this.interactionHandler.onDrag(event);\n      }\n      this.body.emitter.emit(\"_redraw\");\n    }\n\n    /**\n     * connecting or restoring the control nodes.\n     *\n     * @param {Event}  event   The event\n     * @private\n     */\n  }, {\n    key: \"_controlNodeDragEnd\",\n    value: function _controlNodeDragEnd(event) {\n      var pointer = this.body.functions.getPointer(event.center);\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);\n      var edge = this.body.edges[this.edgeBeingEditedId];\n      // if the node that was dragged is not a control node, return\n      if (this.selectedControlNode === undefined) {\n        return;\n      }\n\n      // we use the selection to find the node that is being dragged. We explicitly DEselect the control node here.\n      this.selectionHandler.unselectAll();\n      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);\n      var node = undefined;\n      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {\n        if (overlappingNodeIds[i] !== this.selectedControlNode.id) {\n          node = this.body.nodes[overlappingNodeIds[i]];\n          break;\n        }\n      }\n      // perform the connection\n      if (node !== undefined && this.selectedControlNode !== undefined) {\n        if (node.isCluster === true) {\n          alert(this.options.locales[this.options.locale][\"createEdgeError\"] || this.options.locales[\"en\"][\"createEdgeError\"]);\n        } else {\n          var from = this.body.nodes[this.temporaryIds.nodes[0]];\n          if (this.selectedControlNode.id === from.id) {\n            this._performEditEdge(node.id, edge.to.id);\n          } else {\n            this._performEditEdge(edge.from.id, node.id);\n          }\n        }\n      } else {\n        edge.updateEdgeType();\n        this.body.emitter.emit(\"restorePhysics\");\n      }\n      this.body.emitter.emit(\"_redraw\");\n    }\n\n    // ------------------------------------ END OF EDIT EDGE FUNCTIONS -----------------------------------------//\n\n    // ------------------------------------------- ADD EDGE FUNCTIONS -----------------------------------------//\n    /**\n     * the function bound to the selection event. It checks if you want to connect a cluster and changes the description\n     * to walk the user through the process.\n     *\n     * @param {Event} event\n     * @private\n     */\n  }, {\n    key: \"_handleConnect\",\n    value: function _handleConnect(event) {\n      // check to avoid double fireing of this function.\n      if (new Date().valueOf() - this.touchTime > 100) {\n        this.lastTouch = this.body.functions.getPointer(event.center);\n        this.lastTouch.translation = _Object$assign({}, this.body.view.translation); // copy the object\n\n        this.interactionHandler.drag.pointer = this.lastTouch; // Drag pointer is not updated when adding edges\n        this.interactionHandler.drag.translation = this.lastTouch.translation;\n        var pointer = this.lastTouch;\n        var node = this.selectionHandler.getNodeAt(pointer);\n        if (node !== undefined) {\n          if (node.isCluster === true) {\n            alert(this.options.locales[this.options.locale][\"createEdgeError\"] || this.options.locales[\"en\"][\"createEdgeError\"]);\n          } else {\n            // create a node the temporary line can look at\n            var targetNode = this._getNewTargetNode(node.x, node.y);\n            this.body.nodes[targetNode.id] = targetNode;\n            this.body.nodeIndices.push(targetNode.id);\n\n            // create a temporary edge\n            var connectionEdge = this.body.functions.createEdge({\n              id: \"connectionEdge\" + v4(),\n              from: node.id,\n              to: targetNode.id,\n              physics: false,\n              smooth: {\n                enabled: true,\n                type: \"continuous\",\n                roundness: 0.5\n              }\n            });\n            this.body.edges[connectionEdge.id] = connectionEdge;\n            this.body.edgeIndices.push(connectionEdge.id);\n            this.temporaryIds.nodes.push(targetNode.id);\n            this.temporaryIds.edges.push(connectionEdge.id);\n          }\n        }\n        this.touchTime = new Date().valueOf();\n      }\n    }\n\n    /**\n     *\n     * @param {Event} event\n     * @private\n     */\n  }, {\n    key: \"_dragControlNode\",\n    value: function _dragControlNode(event) {\n      var pointer = this.body.functions.getPointer(event.center);\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);\n      // remember the edge id\n      var connectFromId = undefined;\n      if (this.temporaryIds.edges[0] !== undefined) {\n        connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;\n      }\n\n      // get the overlapping node but NOT the temporary node;\n      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);\n      var node = undefined;\n      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {\n        var _context30;\n        // if the node id is NOT a temporary node, accept the node.\n        if (_indexOfInstanceProperty(_context30 = this.temporaryIds.nodes).call(_context30, overlappingNodeIds[i]) === -1) {\n          node = this.body.nodes[overlappingNodeIds[i]];\n          break;\n        }\n      }\n      event.controlEdge = {\n        from: connectFromId,\n        to: node ? node.id : undefined\n      };\n      this.selectionHandler.generateClickEvent(\"controlNodeDragging\", event, pointer);\n      if (this.temporaryIds.nodes[0] !== undefined) {\n        var targetNode = this.body.nodes[this.temporaryIds.nodes[0]]; // there is only one temp node in the add edge mode.\n        targetNode.x = this.canvas._XconvertDOMtoCanvas(pointer.x);\n        targetNode.y = this.canvas._YconvertDOMtoCanvas(pointer.y);\n        this.body.emitter.emit(\"_redraw\");\n      } else {\n        this.interactionHandler.onDrag(event);\n      }\n    }\n\n    /**\n     * Connect the new edge to the target if one exists, otherwise remove temp line\n     *\n     * @param {Event}  event   The event\n     * @private\n     */\n  }, {\n    key: \"_finishConnect\",\n    value: function _finishConnect(event) {\n      var pointer = this.body.functions.getPointer(event.center);\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);\n\n      // remember the edge id\n      var connectFromId = undefined;\n      if (this.temporaryIds.edges[0] !== undefined) {\n        connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;\n      }\n\n      // get the overlapping node but NOT the temporary node;\n      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);\n      var node = undefined;\n      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {\n        var _context31;\n        // if the node id is NOT a temporary node, accept the node.\n        if (_indexOfInstanceProperty(_context31 = this.temporaryIds.nodes).call(_context31, overlappingNodeIds[i]) === -1) {\n          node = this.body.nodes[overlappingNodeIds[i]];\n          break;\n        }\n      }\n\n      // clean temporary nodes and edges.\n      this._cleanupTemporaryNodesAndEdges();\n\n      // perform the connection\n      if (node !== undefined) {\n        if (node.isCluster === true) {\n          alert(this.options.locales[this.options.locale][\"createEdgeError\"] || this.options.locales[\"en\"][\"createEdgeError\"]);\n        } else {\n          if (this.body.nodes[connectFromId] !== undefined && this.body.nodes[node.id] !== undefined) {\n            this._performAddEdge(connectFromId, node.id);\n          }\n        }\n      }\n      event.controlEdge = {\n        from: connectFromId,\n        to: node ? node.id : undefined\n      };\n      this.selectionHandler.generateClickEvent(\"controlNodeDragEnd\", event, pointer);\n\n      // No need to do _generateclickevent('dragEnd') here, the regular dragEnd event fires.\n      this.body.emitter.emit(\"_redraw\");\n    }\n\n    /**\n     *\n     * @param {Event} event\n     * @private\n     */\n  }, {\n    key: \"_dragStartEdge\",\n    value: function _dragStartEdge(event) {\n      var pointer = this.lastTouch;\n      this.selectionHandler.generateClickEvent(\"dragStart\", event, pointer, undefined, true);\n    }\n\n    // --------------------------------------- END OF ADD EDGE FUNCTIONS -------------------------------------//\n\n    // ------------------------------ Performing all the actual data manipulation ------------------------//\n\n    /**\n     * Adds a node on the specified location\n     *\n     * @param {object} clickData\n     * @private\n     */\n  }, {\n    key: \"_performAddNode\",\n    value: function _performAddNode(clickData) {\n      var _this4 = this;\n      var defaultData = {\n        id: v4(),\n        x: clickData.pointer.canvas.x,\n        y: clickData.pointer.canvas.y,\n        label: \"new\"\n      };\n      if (typeof this.options.addNode === \"function\") {\n        if (this.options.addNode.length === 2) {\n          this.options.addNode(defaultData, function (finalizedData) {\n            if (finalizedData !== null && finalizedData !== undefined && _this4.inMode === \"addNode\") {\n              // if for whatever reason the mode has changes (due to dataset change) disregard the callback\n              _this4.body.data.nodes.getDataSet().add(finalizedData);\n            }\n            _this4.showManipulatorToolbar();\n          });\n        } else {\n          this.showManipulatorToolbar();\n          throw new Error(\"The function for add does not support two arguments (data,callback)\");\n        }\n      } else {\n        this.body.data.nodes.getDataSet().add(defaultData);\n        this.showManipulatorToolbar();\n      }\n    }\n\n    /**\n     * connect two nodes with a new edge.\n     *\n     * @param {Node.id} sourceNodeId\n     * @param {Node.id} targetNodeId\n     * @private\n     */\n  }, {\n    key: \"_performAddEdge\",\n    value: function _performAddEdge(sourceNodeId, targetNodeId) {\n      var _this5 = this;\n      var defaultData = {\n        from: sourceNodeId,\n        to: targetNodeId\n      };\n      if (typeof this.options.addEdge === \"function\") {\n        if (this.options.addEdge.length === 2) {\n          this.options.addEdge(defaultData, function (finalizedData) {\n            if (finalizedData !== null && finalizedData !== undefined && _this5.inMode === \"addEdge\") {\n              // if for whatever reason the mode has changes (due to dataset change) disregard the callback\n              _this5.body.data.edges.getDataSet().add(finalizedData);\n              _this5.selectionHandler.unselectAll();\n              _this5.showManipulatorToolbar();\n            }\n          });\n        } else {\n          throw new Error(\"The function for connect does not support two arguments (data,callback)\");\n        }\n      } else {\n        this.body.data.edges.getDataSet().add(defaultData);\n        this.selectionHandler.unselectAll();\n        this.showManipulatorToolbar();\n      }\n    }\n\n    /**\n     * connect two nodes with a new edge.\n     *\n     * @param {Node.id} sourceNodeId\n     * @param {Node.id} targetNodeId\n     * @private\n     */\n  }, {\n    key: \"_performEditEdge\",\n    value: function _performEditEdge(sourceNodeId, targetNodeId) {\n      var _this6 = this;\n      var defaultData = {\n        id: this.edgeBeingEditedId,\n        from: sourceNodeId,\n        to: targetNodeId,\n        label: this.body.data.edges.get(this.edgeBeingEditedId).label\n      };\n      var eeFunct = this.options.editEdge;\n      if (_typeof(eeFunct) === \"object\") {\n        eeFunct = eeFunct.editWithoutDrag;\n      }\n      if (typeof eeFunct === \"function\") {\n        if (eeFunct.length === 2) {\n          eeFunct(defaultData, function (finalizedData) {\n            if (finalizedData === null || finalizedData === undefined || _this6.inMode !== \"editEdge\") {\n              // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {\n              _this6.body.edges[defaultData.id].updateEdgeType();\n              _this6.body.emitter.emit(\"_redraw\");\n              _this6.showManipulatorToolbar();\n            } else {\n              _this6.body.data.edges.getDataSet().update(finalizedData);\n              _this6.selectionHandler.unselectAll();\n              _this6.showManipulatorToolbar();\n            }\n          });\n        } else {\n          throw new Error(\"The function for edit does not support two arguments (data, callback)\");\n        }\n      } else {\n        this.body.data.edges.getDataSet().update(defaultData);\n        this.selectionHandler.unselectAll();\n        this.showManipulatorToolbar();\n      }\n    }\n  }]);\n  return ManipulationSystem;\n}();\n\n/**\r\n * This object contains all possible options. It will check if the types are correct, if required if the option is one\r\n * of the allowed values.\r\n *\r\n * __any__ means that the name of the property does not matter.\r\n * __type__ is a required field for all objects and contains the allowed types of all objects\r\n */\nvar string = \"string\";\nvar bool = \"boolean\";\nvar number = \"number\";\nvar array = \"array\";\nvar object = \"object\"; // should only be in a __type__ property\nvar dom = \"dom\";\nvar any = \"any\";\n// List of endpoints\nvar endPoints = [\"arrow\", \"bar\", \"box\", \"circle\", \"crow\", \"curve\", \"diamond\", \"image\", \"inv_curve\", \"inv_triangle\", \"triangle\", \"vee\"];\n/* eslint-disable @typescript-eslint/naming-convention -- The __*__ format is used to prevent collisions with actual option names. */\nvar nodeOptions = {\n  borderWidth: {\n    number: number\n  },\n  borderWidthSelected: {\n    number: number,\n    undefined: \"undefined\"\n  },\n  brokenImage: {\n    string: string,\n    undefined: \"undefined\"\n  },\n  chosen: {\n    label: {\n      boolean: bool,\n      function: \"function\"\n    },\n    node: {\n      boolean: bool,\n      function: \"function\"\n    },\n    __type__: {\n      object: object,\n      boolean: bool\n    }\n  },\n  color: {\n    border: {\n      string: string\n    },\n    background: {\n      string: string\n    },\n    highlight: {\n      border: {\n        string: string\n      },\n      background: {\n        string: string\n      },\n      __type__: {\n        object: object,\n        string: string\n      }\n    },\n    hover: {\n      border: {\n        string: string\n      },\n      background: {\n        string: string\n      },\n      __type__: {\n        object: object,\n        string: string\n      }\n    },\n    __type__: {\n      object: object,\n      string: string\n    }\n  },\n  opacity: {\n    number: number,\n    undefined: \"undefined\"\n  },\n  fixed: {\n    x: {\n      boolean: bool\n    },\n    y: {\n      boolean: bool\n    },\n    __type__: {\n      object: object,\n      boolean: bool\n    }\n  },\n  font: {\n    align: {\n      string: string\n    },\n    color: {\n      string: string\n    },\n    size: {\n      number: number\n    },\n    face: {\n      string: string\n    },\n    background: {\n      string: string\n    },\n    strokeWidth: {\n      number: number\n    },\n    strokeColor: {\n      string: string\n    },\n    vadjust: {\n      number: number\n    },\n    multi: {\n      boolean: bool,\n      string: string\n    },\n    bold: {\n      color: {\n        string: string\n      },\n      size: {\n        number: number\n      },\n      face: {\n        string: string\n      },\n      mod: {\n        string: string\n      },\n      vadjust: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        string: string\n      }\n    },\n    boldital: {\n      color: {\n        string: string\n      },\n      size: {\n        number: number\n      },\n      face: {\n        string: string\n      },\n      mod: {\n        string: string\n      },\n      vadjust: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        string: string\n      }\n    },\n    ital: {\n      color: {\n        string: string\n      },\n      size: {\n        number: number\n      },\n      face: {\n        string: string\n      },\n      mod: {\n        string: string\n      },\n      vadjust: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        string: string\n      }\n    },\n    mono: {\n      color: {\n        string: string\n      },\n      size: {\n        number: number\n      },\n      face: {\n        string: string\n      },\n      mod: {\n        string: string\n      },\n      vadjust: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        string: string\n      }\n    },\n    __type__: {\n      object: object,\n      string: string\n    }\n  },\n  group: {\n    string: string,\n    number: number,\n    undefined: \"undefined\"\n  },\n  heightConstraint: {\n    minimum: {\n      number: number\n    },\n    valign: {\n      string: string\n    },\n    __type__: {\n      object: object,\n      boolean: bool,\n      number: number\n    }\n  },\n  hidden: {\n    boolean: bool\n  },\n  icon: {\n    face: {\n      string: string\n    },\n    code: {\n      string: string\n    },\n    size: {\n      number: number\n    },\n    color: {\n      string: string\n    },\n    weight: {\n      string: string,\n      number: number\n    },\n    __type__: {\n      object: object\n    }\n  },\n  id: {\n    string: string,\n    number: number\n  },\n  image: {\n    selected: {\n      string: string,\n      undefined: \"undefined\"\n    },\n    unselected: {\n      string: string,\n      undefined: \"undefined\"\n    },\n    __type__: {\n      object: object,\n      string: string\n    }\n  },\n  imagePadding: {\n    top: {\n      number: number\n    },\n    right: {\n      number: number\n    },\n    bottom: {\n      number: number\n    },\n    left: {\n      number: number\n    },\n    __type__: {\n      object: object,\n      number: number\n    }\n  },\n  label: {\n    string: string,\n    undefined: \"undefined\"\n  },\n  labelHighlightBold: {\n    boolean: bool\n  },\n  level: {\n    number: number,\n    undefined: \"undefined\"\n  },\n  margin: {\n    top: {\n      number: number\n    },\n    right: {\n      number: number\n    },\n    bottom: {\n      number: number\n    },\n    left: {\n      number: number\n    },\n    __type__: {\n      object: object,\n      number: number\n    }\n  },\n  mass: {\n    number: number\n  },\n  physics: {\n    boolean: bool\n  },\n  scaling: {\n    min: {\n      number: number\n    },\n    max: {\n      number: number\n    },\n    label: {\n      enabled: {\n        boolean: bool\n      },\n      min: {\n        number: number\n      },\n      max: {\n        number: number\n      },\n      maxVisible: {\n        number: number\n      },\n      drawThreshold: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    customScalingFunction: {\n      function: \"function\"\n    },\n    __type__: {\n      object: object\n    }\n  },\n  shadow: {\n    enabled: {\n      boolean: bool\n    },\n    color: {\n      string: string\n    },\n    size: {\n      number: number\n    },\n    x: {\n      number: number\n    },\n    y: {\n      number: number\n    },\n    __type__: {\n      object: object,\n      boolean: bool\n    }\n  },\n  shape: {\n    string: [\"custom\", \"ellipse\", \"circle\", \"database\", \"box\", \"text\", \"image\", \"circularImage\", \"diamond\", \"dot\", \"star\", \"triangle\", \"triangleDown\", \"square\", \"icon\", \"hexagon\"]\n  },\n  ctxRenderer: {\n    function: \"function\"\n  },\n  shapeProperties: {\n    borderDashes: {\n      boolean: bool,\n      array: array\n    },\n    borderRadius: {\n      number: number\n    },\n    interpolation: {\n      boolean: bool\n    },\n    useImageSize: {\n      boolean: bool\n    },\n    useBorderWithImage: {\n      boolean: bool\n    },\n    coordinateOrigin: {\n      string: [\"center\", \"top-left\"]\n    },\n    __type__: {\n      object: object\n    }\n  },\n  size: {\n    number: number\n  },\n  title: {\n    string: string,\n    dom: dom,\n    undefined: \"undefined\"\n  },\n  value: {\n    number: number,\n    undefined: \"undefined\"\n  },\n  widthConstraint: {\n    minimum: {\n      number: number\n    },\n    maximum: {\n      number: number\n    },\n    __type__: {\n      object: object,\n      boolean: bool,\n      number: number\n    }\n  },\n  x: {\n    number: number\n  },\n  y: {\n    number: number\n  },\n  __type__: {\n    object: object\n  }\n};\nvar allOptions = {\n  configure: {\n    enabled: {\n      boolean: bool\n    },\n    filter: {\n      boolean: bool,\n      string: string,\n      array: array,\n      function: \"function\"\n    },\n    container: {\n      dom: dom\n    },\n    showButton: {\n      boolean: bool\n    },\n    __type__: {\n      object: object,\n      boolean: bool,\n      string: string,\n      array: array,\n      function: \"function\"\n    }\n  },\n  edges: {\n    arrows: {\n      to: {\n        enabled: {\n          boolean: bool\n        },\n        scaleFactor: {\n          number: number\n        },\n        type: {\n          string: endPoints\n        },\n        imageHeight: {\n          number: number\n        },\n        imageWidth: {\n          number: number\n        },\n        src: {\n          string: string\n        },\n        __type__: {\n          object: object,\n          boolean: bool\n        }\n      },\n      middle: {\n        enabled: {\n          boolean: bool\n        },\n        scaleFactor: {\n          number: number\n        },\n        type: {\n          string: endPoints\n        },\n        imageWidth: {\n          number: number\n        },\n        imageHeight: {\n          number: number\n        },\n        src: {\n          string: string\n        },\n        __type__: {\n          object: object,\n          boolean: bool\n        }\n      },\n      from: {\n        enabled: {\n          boolean: bool\n        },\n        scaleFactor: {\n          number: number\n        },\n        type: {\n          string: endPoints\n        },\n        imageWidth: {\n          number: number\n        },\n        imageHeight: {\n          number: number\n        },\n        src: {\n          string: string\n        },\n        __type__: {\n          object: object,\n          boolean: bool\n        }\n      },\n      __type__: {\n        string: [\"from\", \"to\", \"middle\"],\n        object: object\n      }\n    },\n    endPointOffset: {\n      from: {\n        number: number\n      },\n      to: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        number: number\n      }\n    },\n    arrowStrikethrough: {\n      boolean: bool\n    },\n    background: {\n      enabled: {\n        boolean: bool\n      },\n      color: {\n        string: string\n      },\n      size: {\n        number: number\n      },\n      dashes: {\n        boolean: bool,\n        array: array\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    chosen: {\n      label: {\n        boolean: bool,\n        function: \"function\"\n      },\n      edge: {\n        boolean: bool,\n        function: \"function\"\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    color: {\n      color: {\n        string: string\n      },\n      highlight: {\n        string: string\n      },\n      hover: {\n        string: string\n      },\n      inherit: {\n        string: [\"from\", \"to\", \"both\"],\n        boolean: bool\n      },\n      opacity: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        string: string\n      }\n    },\n    dashes: {\n      boolean: bool,\n      array: array\n    },\n    font: {\n      color: {\n        string: string\n      },\n      size: {\n        number: number\n      },\n      face: {\n        string: string\n      },\n      background: {\n        string: string\n      },\n      strokeWidth: {\n        number: number\n      },\n      strokeColor: {\n        string: string\n      },\n      align: {\n        string: [\"horizontal\", \"top\", \"middle\", \"bottom\"]\n      },\n      vadjust: {\n        number: number\n      },\n      multi: {\n        boolean: bool,\n        string: string\n      },\n      bold: {\n        color: {\n          string: string\n        },\n        size: {\n          number: number\n        },\n        face: {\n          string: string\n        },\n        mod: {\n          string: string\n        },\n        vadjust: {\n          number: number\n        },\n        __type__: {\n          object: object,\n          string: string\n        }\n      },\n      boldital: {\n        color: {\n          string: string\n        },\n        size: {\n          number: number\n        },\n        face: {\n          string: string\n        },\n        mod: {\n          string: string\n        },\n        vadjust: {\n          number: number\n        },\n        __type__: {\n          object: object,\n          string: string\n        }\n      },\n      ital: {\n        color: {\n          string: string\n        },\n        size: {\n          number: number\n        },\n        face: {\n          string: string\n        },\n        mod: {\n          string: string\n        },\n        vadjust: {\n          number: number\n        },\n        __type__: {\n          object: object,\n          string: string\n        }\n      },\n      mono: {\n        color: {\n          string: string\n        },\n        size: {\n          number: number\n        },\n        face: {\n          string: string\n        },\n        mod: {\n          string: string\n        },\n        vadjust: {\n          number: number\n        },\n        __type__: {\n          object: object,\n          string: string\n        }\n      },\n      __type__: {\n        object: object,\n        string: string\n      }\n    },\n    hidden: {\n      boolean: bool\n    },\n    hoverWidth: {\n      function: \"function\",\n      number: number\n    },\n    label: {\n      string: string,\n      undefined: \"undefined\"\n    },\n    labelHighlightBold: {\n      boolean: bool\n    },\n    length: {\n      number: number,\n      undefined: \"undefined\"\n    },\n    physics: {\n      boolean: bool\n    },\n    scaling: {\n      min: {\n        number: number\n      },\n      max: {\n        number: number\n      },\n      label: {\n        enabled: {\n          boolean: bool\n        },\n        min: {\n          number: number\n        },\n        max: {\n          number: number\n        },\n        maxVisible: {\n          number: number\n        },\n        drawThreshold: {\n          number: number\n        },\n        __type__: {\n          object: object,\n          boolean: bool\n        }\n      },\n      customScalingFunction: {\n        function: \"function\"\n      },\n      __type__: {\n        object: object\n      }\n    },\n    selectionWidth: {\n      function: \"function\",\n      number: number\n    },\n    selfReferenceSize: {\n      number: number\n    },\n    selfReference: {\n      size: {\n        number: number\n      },\n      angle: {\n        number: number\n      },\n      renderBehindTheNode: {\n        boolean: bool\n      },\n      __type__: {\n        object: object\n      }\n    },\n    shadow: {\n      enabled: {\n        boolean: bool\n      },\n      color: {\n        string: string\n      },\n      size: {\n        number: number\n      },\n      x: {\n        number: number\n      },\n      y: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    smooth: {\n      enabled: {\n        boolean: bool\n      },\n      type: {\n        string: [\"dynamic\", \"continuous\", \"discrete\", \"diagonalCross\", \"straightCross\", \"horizontal\", \"vertical\", \"curvedCW\", \"curvedCCW\", \"cubicBezier\"]\n      },\n      roundness: {\n        number: number\n      },\n      forceDirection: {\n        string: [\"horizontal\", \"vertical\", \"none\"],\n        boolean: bool\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    title: {\n      string: string,\n      undefined: \"undefined\"\n    },\n    width: {\n      number: number\n    },\n    widthConstraint: {\n      maximum: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        boolean: bool,\n        number: number\n      }\n    },\n    value: {\n      number: number,\n      undefined: \"undefined\"\n    },\n    __type__: {\n      object: object\n    }\n  },\n  groups: {\n    useDefaultGroups: {\n      boolean: bool\n    },\n    __any__: nodeOptions,\n    __type__: {\n      object: object\n    }\n  },\n  interaction: {\n    dragNodes: {\n      boolean: bool\n    },\n    dragView: {\n      boolean: bool\n    },\n    hideEdgesOnDrag: {\n      boolean: bool\n    },\n    hideEdgesOnZoom: {\n      boolean: bool\n    },\n    hideNodesOnDrag: {\n      boolean: bool\n    },\n    hover: {\n      boolean: bool\n    },\n    keyboard: {\n      enabled: {\n        boolean: bool\n      },\n      speed: {\n        x: {\n          number: number\n        },\n        y: {\n          number: number\n        },\n        zoom: {\n          number: number\n        },\n        __type__: {\n          object: object\n        }\n      },\n      bindToWindow: {\n        boolean: bool\n      },\n      autoFocus: {\n        boolean: bool\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    multiselect: {\n      boolean: bool\n    },\n    navigationButtons: {\n      boolean: bool\n    },\n    selectable: {\n      boolean: bool\n    },\n    selectConnectedEdges: {\n      boolean: bool\n    },\n    hoverConnectedEdges: {\n      boolean: bool\n    },\n    tooltipDelay: {\n      number: number\n    },\n    zoomView: {\n      boolean: bool\n    },\n    zoomSpeed: {\n      number: number\n    },\n    __type__: {\n      object: object\n    }\n  },\n  layout: {\n    randomSeed: {\n      undefined: \"undefined\",\n      number: number,\n      string: string\n    },\n    improvedLayout: {\n      boolean: bool\n    },\n    clusterThreshold: {\n      number: number\n    },\n    hierarchical: {\n      enabled: {\n        boolean: bool\n      },\n      levelSeparation: {\n        number: number\n      },\n      nodeSpacing: {\n        number: number\n      },\n      treeSpacing: {\n        number: number\n      },\n      blockShifting: {\n        boolean: bool\n      },\n      edgeMinimization: {\n        boolean: bool\n      },\n      parentCentralization: {\n        boolean: bool\n      },\n      direction: {\n        string: [\"UD\", \"DU\", \"LR\", \"RL\"]\n      },\n      sortMethod: {\n        string: [\"hubsize\", \"directed\"]\n      },\n      shakeTowards: {\n        string: [\"leaves\", \"roots\"]\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    __type__: {\n      object: object\n    }\n  },\n  manipulation: {\n    enabled: {\n      boolean: bool\n    },\n    initiallyActive: {\n      boolean: bool\n    },\n    addNode: {\n      boolean: bool,\n      function: \"function\"\n    },\n    addEdge: {\n      boolean: bool,\n      function: \"function\"\n    },\n    editNode: {\n      function: \"function\"\n    },\n    editEdge: {\n      editWithoutDrag: {\n        function: \"function\"\n      },\n      __type__: {\n        object: object,\n        boolean: bool,\n        function: \"function\"\n      }\n    },\n    deleteNode: {\n      boolean: bool,\n      function: \"function\"\n    },\n    deleteEdge: {\n      boolean: bool,\n      function: \"function\"\n    },\n    controlNodeStyle: nodeOptions,\n    __type__: {\n      object: object,\n      boolean: bool\n    }\n  },\n  nodes: nodeOptions,\n  physics: {\n    enabled: {\n      boolean: bool\n    },\n    barnesHut: {\n      theta: {\n        number: number\n      },\n      gravitationalConstant: {\n        number: number\n      },\n      centralGravity: {\n        number: number\n      },\n      springLength: {\n        number: number\n      },\n      springConstant: {\n        number: number\n      },\n      damping: {\n        number: number\n      },\n      avoidOverlap: {\n        number: number\n      },\n      __type__: {\n        object: object\n      }\n    },\n    forceAtlas2Based: {\n      theta: {\n        number: number\n      },\n      gravitationalConstant: {\n        number: number\n      },\n      centralGravity: {\n        number: number\n      },\n      springLength: {\n        number: number\n      },\n      springConstant: {\n        number: number\n      },\n      damping: {\n        number: number\n      },\n      avoidOverlap: {\n        number: number\n      },\n      __type__: {\n        object: object\n      }\n    },\n    repulsion: {\n      centralGravity: {\n        number: number\n      },\n      springLength: {\n        number: number\n      },\n      springConstant: {\n        number: number\n      },\n      nodeDistance: {\n        number: number\n      },\n      damping: {\n        number: number\n      },\n      __type__: {\n        object: object\n      }\n    },\n    hierarchicalRepulsion: {\n      centralGravity: {\n        number: number\n      },\n      springLength: {\n        number: number\n      },\n      springConstant: {\n        number: number\n      },\n      nodeDistance: {\n        number: number\n      },\n      damping: {\n        number: number\n      },\n      avoidOverlap: {\n        number: number\n      },\n      __type__: {\n        object: object\n      }\n    },\n    maxVelocity: {\n      number: number\n    },\n    minVelocity: {\n      number: number\n    },\n    solver: {\n      string: [\"barnesHut\", \"repulsion\", \"hierarchicalRepulsion\", \"forceAtlas2Based\"]\n    },\n    stabilization: {\n      enabled: {\n        boolean: bool\n      },\n      iterations: {\n        number: number\n      },\n      updateInterval: {\n        number: number\n      },\n      onlyDynamicEdges: {\n        boolean: bool\n      },\n      fit: {\n        boolean: bool\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    timestep: {\n      number: number\n    },\n    adaptiveTimestep: {\n      boolean: bool\n    },\n    wind: {\n      x: {\n        number: number\n      },\n      y: {\n        number: number\n      },\n      __type__: {\n        object: object\n      }\n    },\n    __type__: {\n      object: object,\n      boolean: bool\n    }\n  },\n  //globals :\n  autoResize: {\n    boolean: bool\n  },\n  clickToUse: {\n    boolean: bool\n  },\n  locale: {\n    string: string\n  },\n  locales: {\n    __any__: {\n      any: any\n    },\n    __type__: {\n      object: object\n    }\n  },\n  height: {\n    string: string\n  },\n  width: {\n    string: string\n  },\n  __type__: {\n    object: object\n  }\n};\n/* eslint-enable @typescript-eslint/naming-convention */\n/**\r\n * This provides ranges, initial values, steps and dropdown menu choices for the\r\n * configuration.\r\n *\r\n * @remarks\r\n * Checkbox: `boolean`\r\n *   The value supllied will be used as the initial value.\r\n *\r\n * Text field: `string`\r\n *   The passed text will be used as the initial value. Any text will be\r\n *   accepted afterwards.\r\n *\r\n * Number range: `[number, number, number, number]`\r\n *   The meanings are `[initial value, min, max, step]`.\r\n *\r\n * Dropdown: `[Exclude<string, \"color\">, ...(string | number | boolean)[]]`\r\n *   Translations for people with poor understanding of TypeScript: the first\r\n *   value always has to be a string but never `\"color\"`, the rest can be any\r\n *   combination of strings, numbers and booleans.\r\n *\r\n * Color picker: `[\"color\", string]`\r\n *   The first value says this will be a color picker not a dropdown menu. The\r\n *   next value is the initial color.\r\n */\nvar configureOptions = {\n  nodes: {\n    borderWidth: [1, 0, 10, 1],\n    borderWidthSelected: [2, 0, 10, 1],\n    color: {\n      border: [\"color\", \"#2B7CE9\"],\n      background: [\"color\", \"#97C2FC\"],\n      highlight: {\n        border: [\"color\", \"#2B7CE9\"],\n        background: [\"color\", \"#D2E5FF\"]\n      },\n      hover: {\n        border: [\"color\", \"#2B7CE9\"],\n        background: [\"color\", \"#D2E5FF\"]\n      }\n    },\n    opacity: [0, 0, 1, 0.1],\n    fixed: {\n      x: false,\n      y: false\n    },\n    font: {\n      color: [\"color\", \"#343434\"],\n      size: [14, 0, 100, 1],\n      face: [\"arial\", \"verdana\", \"tahoma\"],\n      background: [\"color\", \"none\"],\n      strokeWidth: [0, 0, 50, 1],\n      strokeColor: [\"color\", \"#ffffff\"]\n    },\n    //group: 'string',\n    hidden: false,\n    labelHighlightBold: true,\n    //icon: {\n    //  face: 'string',  //'FontAwesome',\n    //  code: 'string',  //'\\uf007',\n    //  size: [50, 0, 200, 1],  //50,\n    //  color: ['color','#2B7CE9']   //'#aa00ff'\n    //},\n    //image: 'string', // --> URL\n    physics: true,\n    scaling: {\n      min: [10, 0, 200, 1],\n      max: [30, 0, 200, 1],\n      label: {\n        enabled: false,\n        min: [14, 0, 200, 1],\n        max: [30, 0, 200, 1],\n        maxVisible: [30, 0, 200, 1],\n        drawThreshold: [5, 0, 20, 1]\n      }\n    },\n    shadow: {\n      enabled: false,\n      color: \"rgba(0,0,0,0.5)\",\n      size: [10, 0, 20, 1],\n      x: [5, -30, 30, 1],\n      y: [5, -30, 30, 1]\n    },\n    shape: [\"ellipse\", \"box\", \"circle\", \"database\", \"diamond\", \"dot\", \"square\", \"star\", \"text\", \"triangle\", \"triangleDown\", \"hexagon\"],\n    shapeProperties: {\n      borderDashes: false,\n      borderRadius: [6, 0, 20, 1],\n      interpolation: true,\n      useImageSize: false\n    },\n    size: [25, 0, 200, 1]\n  },\n  edges: {\n    arrows: {\n      to: {\n        enabled: false,\n        scaleFactor: [1, 0, 3, 0.05],\n        type: \"arrow\"\n      },\n      middle: {\n        enabled: false,\n        scaleFactor: [1, 0, 3, 0.05],\n        type: \"arrow\"\n      },\n      from: {\n        enabled: false,\n        scaleFactor: [1, 0, 3, 0.05],\n        type: \"arrow\"\n      }\n    },\n    endPointOffset: {\n      from: [0, -10, 10, 1],\n      to: [0, -10, 10, 1]\n    },\n    arrowStrikethrough: true,\n    color: {\n      color: [\"color\", \"#848484\"],\n      highlight: [\"color\", \"#848484\"],\n      hover: [\"color\", \"#848484\"],\n      inherit: [\"from\", \"to\", \"both\", true, false],\n      opacity: [1, 0, 1, 0.05]\n    },\n    dashes: false,\n    font: {\n      color: [\"color\", \"#343434\"],\n      size: [14, 0, 100, 1],\n      face: [\"arial\", \"verdana\", \"tahoma\"],\n      background: [\"color\", \"none\"],\n      strokeWidth: [2, 0, 50, 1],\n      strokeColor: [\"color\", \"#ffffff\"],\n      align: [\"horizontal\", \"top\", \"middle\", \"bottom\"]\n    },\n    hidden: false,\n    hoverWidth: [1.5, 0, 5, 0.1],\n    labelHighlightBold: true,\n    physics: true,\n    scaling: {\n      min: [1, 0, 100, 1],\n      max: [15, 0, 100, 1],\n      label: {\n        enabled: true,\n        min: [14, 0, 200, 1],\n        max: [30, 0, 200, 1],\n        maxVisible: [30, 0, 200, 1],\n        drawThreshold: [5, 0, 20, 1]\n      }\n    },\n    selectionWidth: [1.5, 0, 5, 0.1],\n    selfReferenceSize: [20, 0, 200, 1],\n    selfReference: {\n      size: [20, 0, 200, 1],\n      angle: [Math.PI / 2, -6 * Math.PI, 6 * Math.PI, Math.PI / 8],\n      renderBehindTheNode: true\n    },\n    shadow: {\n      enabled: false,\n      color: \"rgba(0,0,0,0.5)\",\n      size: [10, 0, 20, 1],\n      x: [5, -30, 30, 1],\n      y: [5, -30, 30, 1]\n    },\n    smooth: {\n      enabled: true,\n      type: [\"dynamic\", \"continuous\", \"discrete\", \"diagonalCross\", \"straightCross\", \"horizontal\", \"vertical\", \"curvedCW\", \"curvedCCW\", \"cubicBezier\"],\n      forceDirection: [\"horizontal\", \"vertical\", \"none\"],\n      roundness: [0.5, 0, 1, 0.05]\n    },\n    width: [1, 0, 30, 1]\n  },\n  layout: {\n    //randomSeed: [0, 0, 500, 1],\n    //improvedLayout: true,\n    hierarchical: {\n      enabled: false,\n      levelSeparation: [150, 20, 500, 5],\n      nodeSpacing: [100, 20, 500, 5],\n      treeSpacing: [200, 20, 500, 5],\n      blockShifting: true,\n      edgeMinimization: true,\n      parentCentralization: true,\n      direction: [\"UD\", \"DU\", \"LR\", \"RL\"],\n      sortMethod: [\"hubsize\", \"directed\"],\n      shakeTowards: [\"leaves\", \"roots\"] // leaves, roots\n    }\n  },\n\n  interaction: {\n    dragNodes: true,\n    dragView: true,\n    hideEdgesOnDrag: false,\n    hideEdgesOnZoom: false,\n    hideNodesOnDrag: false,\n    hover: false,\n    keyboard: {\n      enabled: false,\n      speed: {\n        x: [10, 0, 40, 1],\n        y: [10, 0, 40, 1],\n        zoom: [0.02, 0, 0.1, 0.005]\n      },\n      bindToWindow: true,\n      autoFocus: true\n    },\n    multiselect: false,\n    navigationButtons: false,\n    selectable: true,\n    selectConnectedEdges: true,\n    hoverConnectedEdges: true,\n    tooltipDelay: [300, 0, 1000, 25],\n    zoomView: true,\n    zoomSpeed: [1, 0.1, 2, 0.1]\n  },\n  manipulation: {\n    enabled: false,\n    initiallyActive: false\n  },\n  physics: {\n    enabled: true,\n    barnesHut: {\n      theta: [0.5, 0.1, 1, 0.05],\n      gravitationalConstant: [-2000, -30000, 0, 50],\n      centralGravity: [0.3, 0, 10, 0.05],\n      springLength: [95, 0, 500, 5],\n      springConstant: [0.04, 0, 1.2, 0.005],\n      damping: [0.09, 0, 1, 0.01],\n      avoidOverlap: [0, 0, 1, 0.01]\n    },\n    forceAtlas2Based: {\n      theta: [0.5, 0.1, 1, 0.05],\n      gravitationalConstant: [-50, -500, 0, 1],\n      centralGravity: [0.01, 0, 1, 0.005],\n      springLength: [95, 0, 500, 5],\n      springConstant: [0.08, 0, 1.2, 0.005],\n      damping: [0.4, 0, 1, 0.01],\n      avoidOverlap: [0, 0, 1, 0.01]\n    },\n    repulsion: {\n      centralGravity: [0.2, 0, 10, 0.05],\n      springLength: [200, 0, 500, 5],\n      springConstant: [0.05, 0, 1.2, 0.005],\n      nodeDistance: [100, 0, 500, 5],\n      damping: [0.09, 0, 1, 0.01]\n    },\n    hierarchicalRepulsion: {\n      centralGravity: [0.2, 0, 10, 0.05],\n      springLength: [100, 0, 500, 5],\n      springConstant: [0.01, 0, 1.2, 0.005],\n      nodeDistance: [120, 0, 500, 5],\n      damping: [0.09, 0, 1, 0.01],\n      avoidOverlap: [0, 0, 1, 0.01]\n    },\n    maxVelocity: [50, 0, 150, 1],\n    minVelocity: [0.1, 0.01, 0.5, 0.01],\n    solver: [\"barnesHut\", \"forceAtlas2Based\", \"repulsion\", \"hierarchicalRepulsion\"],\n    timestep: [0.5, 0.01, 1, 0.01],\n    wind: {\n      x: [0, -10, 10, 0.1],\n      y: [0, -10, 10, 0.1]\n    }\n    //adaptiveTimestep: true\n  }\n};\n\nvar configuratorHideOption = function configuratorHideOption(parentPath, optionName, options) {\n  var _context;\n  if (_includesInstanceProperty(parentPath).call(parentPath, \"physics\") && _includesInstanceProperty(_context = configureOptions.physics.solver).call(_context, optionName) && options.physics.solver !== optionName && optionName !== \"wind\") {\n    return true;\n  }\n  return false;\n};\n\nvar options = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tallOptions: allOptions,\n\tconfiguratorHideOption: configuratorHideOption,\n\tconfigureOptions: configureOptions\n});\n\n/**\n *  The FloydâWarshall algorithm is an algorithm for finding shortest paths in\n *  a weighted graph with positive or negative edge weights (but with no negative\n *  cycles). - https://en.wikipedia.org/wiki/FloydâWarshall_algorithm\n */\nvar FloydWarshall = /*#__PURE__*/function () {\n  /**\n   * @ignore\n   */\n  function FloydWarshall() {\n    _classCallCheck(this, FloydWarshall);\n  }\n\n  /**\n   *\n   * @param {object} body\n   * @param {Array.<Node>} nodesArray\n   * @param {Array.<Edge>} edgesArray\n   * @returns {{}}\n   */\n  _createClass(FloydWarshall, [{\n    key: \"getDistances\",\n    value: function getDistances(body, nodesArray, edgesArray) {\n      var D_matrix = {};\n      var edges = body.edges;\n\n      // prepare matrix with large numbers\n      for (var i = 0; i < nodesArray.length; i++) {\n        var node = nodesArray[i];\n        var cell = {};\n        D_matrix[node] = cell;\n        for (var j = 0; j < nodesArray.length; j++) {\n          cell[nodesArray[j]] = i == j ? 0 : 1e9;\n        }\n      }\n\n      // put the weights for the edges in. This assumes unidirectionality.\n      for (var _i = 0; _i < edgesArray.length; _i++) {\n        var edge = edges[edgesArray[_i]];\n        // edge has to be connected if it counts to the distances. If it is connected to inner clusters it will crash so we also check if it is in the D_matrix\n        if (edge.connected === true && D_matrix[edge.fromId] !== undefined && D_matrix[edge.toId] !== undefined) {\n          D_matrix[edge.fromId][edge.toId] = 1;\n          D_matrix[edge.toId][edge.fromId] = 1;\n        }\n      }\n      var nodeCount = nodesArray.length;\n\n      // Adapted FloydWarshall based on unidirectionality to greatly reduce complexity.\n      for (var k = 0; k < nodeCount; k++) {\n        var knode = nodesArray[k];\n        var kcolm = D_matrix[knode];\n        for (var _i2 = 0; _i2 < nodeCount - 1; _i2++) {\n          var inode = nodesArray[_i2];\n          var icolm = D_matrix[inode];\n          for (var _j = _i2 + 1; _j < nodeCount; _j++) {\n            var jnode = nodesArray[_j];\n            var jcolm = D_matrix[jnode];\n            var val = Math.min(icolm[jnode], icolm[knode] + kcolm[jnode]);\n            icolm[jnode] = val;\n            jcolm[inode] = val;\n          }\n        }\n      }\n      return D_matrix;\n    }\n  }]);\n  return FloydWarshall;\n}();\n\n/**\n * KamadaKawai positions the nodes initially based on\n *\n * \"AN ALGORITHM FOR DRAWING GENERAL UNDIRECTED GRAPHS\"\n * -- Tomihisa KAMADA and Satoru KAWAI in 1989\n *\n * Possible optimizations in the distance calculation can be implemented.\n */\nvar KamadaKawai = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {number} edgeLength\n   * @param {number} edgeStrength\n   */\n  function KamadaKawai(body, edgeLength, edgeStrength) {\n    _classCallCheck(this, KamadaKawai);\n    this.body = body;\n    this.springLength = edgeLength;\n    this.springConstant = edgeStrength;\n    this.distanceSolver = new FloydWarshall();\n  }\n\n  /**\n   * Not sure if needed but can be used to update the spring length and spring constant\n   *\n   * @param {object} options\n   */\n  _createClass(KamadaKawai, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options) {\n        if (options.springLength) {\n          this.springLength = options.springLength;\n        }\n        if (options.springConstant) {\n          this.springConstant = options.springConstant;\n        }\n      }\n    }\n\n    /**\n     * Position the system\n     *\n     * @param {Array.<Node>} nodesArray\n     * @param {Array.<vis.Edge>} edgesArray\n     * @param {boolean} [ignoreClusters=false]\n     */\n  }, {\n    key: \"solve\",\n    value: function solve(nodesArray, edgesArray) {\n      var ignoreClusters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      // get distance matrix\n      var D_matrix = this.distanceSolver.getDistances(this.body, nodesArray, edgesArray); // distance matrix\n\n      // get the L Matrix\n      this._createL_matrix(D_matrix);\n\n      // get the K Matrix\n      this._createK_matrix(D_matrix);\n\n      // initial E Matrix\n      this._createE_matrix();\n\n      // calculate positions\n      var threshold = 0.01;\n      var innerThreshold = 1;\n      var iterations = 0;\n      var maxIterations = Math.max(1000, Math.min(10 * this.body.nodeIndices.length, 6000));\n      var maxInnerIterations = 5;\n      var maxEnergy = 1e9;\n      var highE_nodeId = 0,\n        dE_dx = 0,\n        dE_dy = 0,\n        delta_m = 0,\n        subIterations = 0;\n      while (maxEnergy > threshold && iterations < maxIterations) {\n        iterations += 1;\n        var _this$_getHighestEner = this._getHighestEnergyNode(ignoreClusters);\n        var _this$_getHighestEner2 = _slicedToArray(_this$_getHighestEner, 4);\n        highE_nodeId = _this$_getHighestEner2[0];\n        maxEnergy = _this$_getHighestEner2[1];\n        dE_dx = _this$_getHighestEner2[2];\n        dE_dy = _this$_getHighestEner2[3];\n        delta_m = maxEnergy;\n        subIterations = 0;\n        while (delta_m > innerThreshold && subIterations < maxInnerIterations) {\n          subIterations += 1;\n          this._moveNode(highE_nodeId, dE_dx, dE_dy);\n          var _this$_getEnergy = this._getEnergy(highE_nodeId);\n          var _this$_getEnergy2 = _slicedToArray(_this$_getEnergy, 3);\n          delta_m = _this$_getEnergy2[0];\n          dE_dx = _this$_getEnergy2[1];\n          dE_dy = _this$_getEnergy2[2];\n        }\n      }\n    }\n\n    /**\n     * get the node with the highest energy\n     *\n     * @param {boolean} ignoreClusters\n     * @returns {number[]}\n     * @private\n     */\n  }, {\n    key: \"_getHighestEnergyNode\",\n    value: function _getHighestEnergyNode(ignoreClusters) {\n      var nodesArray = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n      var maxEnergy = 0;\n      var maxEnergyNodeId = nodesArray[0];\n      var dE_dx_max = 0,\n        dE_dy_max = 0;\n      for (var nodeIdx = 0; nodeIdx < nodesArray.length; nodeIdx++) {\n        var m = nodesArray[nodeIdx];\n        // by not evaluating nodes with predefined positions we should only move nodes that have no positions.\n        if (nodes[m].predefinedPosition !== true || nodes[m].isCluster === true && ignoreClusters === true || nodes[m].options.fixed.x !== true || nodes[m].options.fixed.y !== true) {\n          var _this$_getEnergy3 = this._getEnergy(m),\n            _this$_getEnergy4 = _slicedToArray(_this$_getEnergy3, 3),\n            delta_m = _this$_getEnergy4[0],\n            dE_dx = _this$_getEnergy4[1],\n            dE_dy = _this$_getEnergy4[2];\n          if (maxEnergy < delta_m) {\n            maxEnergy = delta_m;\n            maxEnergyNodeId = m;\n            dE_dx_max = dE_dx;\n            dE_dy_max = dE_dy;\n          }\n        }\n      }\n      return [maxEnergyNodeId, maxEnergy, dE_dx_max, dE_dy_max];\n    }\n\n    /**\n     * calculate the energy of a single node\n     *\n     * @param {Node.id} m\n     * @returns {number[]}\n     * @private\n     */\n  }, {\n    key: \"_getEnergy\",\n    value: function _getEnergy(m) {\n      var _this$E_sums$m = _slicedToArray(this.E_sums[m], 2),\n        dE_dx = _this$E_sums$m[0],\n        dE_dy = _this$E_sums$m[1];\n      var delta_m = Math.sqrt(Math.pow(dE_dx, 2) + Math.pow(dE_dy, 2));\n      return [delta_m, dE_dx, dE_dy];\n    }\n\n    /**\n     * move the node based on it's energy\n     * the dx and dy are calculated from the linear system proposed by Kamada and Kawai\n     *\n     * @param {number} m\n     * @param {number} dE_dx\n     * @param {number} dE_dy\n     * @private\n     */\n  }, {\n    key: \"_moveNode\",\n    value: function _moveNode(m, dE_dx, dE_dy) {\n      var nodesArray = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n      var d2E_dx2 = 0;\n      var d2E_dxdy = 0;\n      var d2E_dy2 = 0;\n      var x_m = nodes[m].x;\n      var y_m = nodes[m].y;\n      var km = this.K_matrix[m];\n      var lm = this.L_matrix[m];\n      for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {\n        var i = nodesArray[iIdx];\n        if (i !== m) {\n          var x_i = nodes[i].x;\n          var y_i = nodes[i].y;\n          var kmat = km[i];\n          var lmat = lm[i];\n          var denominator = 1.0 / Math.pow(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2), 1.5);\n          d2E_dx2 += kmat * (1 - lmat * Math.pow(y_m - y_i, 2) * denominator);\n          d2E_dxdy += kmat * (lmat * (x_m - x_i) * (y_m - y_i) * denominator);\n          d2E_dy2 += kmat * (1 - lmat * Math.pow(x_m - x_i, 2) * denominator);\n        }\n      }\n      // make the variable names easier to make the solving of the linear system easier to read\n      var A = d2E_dx2,\n        B = d2E_dxdy,\n        C = dE_dx,\n        D = d2E_dy2,\n        E = dE_dy;\n\n      // solve the linear system for dx and dy\n      var dy = (C / A + E / B) / (B / A - D / B);\n      var dx = -(B * dy + C) / A;\n\n      // move the node\n      nodes[m].x += dx;\n      nodes[m].y += dy;\n\n      // Recalculate E_matrix (should be incremental)\n      this._updateE_matrix(m);\n    }\n\n    /**\n     * Create the L matrix: edge length times shortest path\n     *\n     * @param {object} D_matrix\n     * @private\n     */\n  }, {\n    key: \"_createL_matrix\",\n    value: function _createL_matrix(D_matrix) {\n      var nodesArray = this.body.nodeIndices;\n      var edgeLength = this.springLength;\n      this.L_matrix = [];\n      for (var i = 0; i < nodesArray.length; i++) {\n        this.L_matrix[nodesArray[i]] = {};\n        for (var j = 0; j < nodesArray.length; j++) {\n          this.L_matrix[nodesArray[i]][nodesArray[j]] = edgeLength * D_matrix[nodesArray[i]][nodesArray[j]];\n        }\n      }\n    }\n\n    /**\n     * Create the K matrix: spring constants times shortest path\n     *\n     * @param {object} D_matrix\n     * @private\n     */\n  }, {\n    key: \"_createK_matrix\",\n    value: function _createK_matrix(D_matrix) {\n      var nodesArray = this.body.nodeIndices;\n      var edgeStrength = this.springConstant;\n      this.K_matrix = [];\n      for (var i = 0; i < nodesArray.length; i++) {\n        this.K_matrix[nodesArray[i]] = {};\n        for (var j = 0; j < nodesArray.length; j++) {\n          this.K_matrix[nodesArray[i]][nodesArray[j]] = edgeStrength * Math.pow(D_matrix[nodesArray[i]][nodesArray[j]], -2);\n        }\n      }\n    }\n\n    /**\n     *  Create matrix with all energies between nodes\n     *\n     *  @private\n     */\n  }, {\n    key: \"_createE_matrix\",\n    value: function _createE_matrix() {\n      var nodesArray = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n      this.E_matrix = {};\n      this.E_sums = {};\n      for (var mIdx = 0; mIdx < nodesArray.length; mIdx++) {\n        this.E_matrix[nodesArray[mIdx]] = [];\n      }\n      for (var _mIdx = 0; _mIdx < nodesArray.length; _mIdx++) {\n        var m = nodesArray[_mIdx];\n        var x_m = nodes[m].x;\n        var y_m = nodes[m].y;\n        var dE_dx = 0;\n        var dE_dy = 0;\n        for (var iIdx = _mIdx; iIdx < nodesArray.length; iIdx++) {\n          var i = nodesArray[iIdx];\n          if (i !== m) {\n            var x_i = nodes[i].x;\n            var y_i = nodes[i].y;\n            var denominator = 1.0 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));\n            this.E_matrix[m][iIdx] = [this.K_matrix[m][i] * (x_m - x_i - this.L_matrix[m][i] * (x_m - x_i) * denominator), this.K_matrix[m][i] * (y_m - y_i - this.L_matrix[m][i] * (y_m - y_i) * denominator)];\n            this.E_matrix[i][_mIdx] = this.E_matrix[m][iIdx];\n            dE_dx += this.E_matrix[m][iIdx][0];\n            dE_dy += this.E_matrix[m][iIdx][1];\n          }\n        }\n        //Store sum\n        this.E_sums[m] = [dE_dx, dE_dy];\n      }\n    }\n\n    /**\n     * Update method, just doing single column (rows are auto-updated) (update all sums)\n     *\n     * @param {number} m\n     * @private\n     */\n  }, {\n    key: \"_updateE_matrix\",\n    value: function _updateE_matrix(m) {\n      var nodesArray = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n      var colm = this.E_matrix[m];\n      var kcolm = this.K_matrix[m];\n      var lcolm = this.L_matrix[m];\n      var x_m = nodes[m].x;\n      var y_m = nodes[m].y;\n      var dE_dx = 0;\n      var dE_dy = 0;\n      for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {\n        var i = nodesArray[iIdx];\n        if (i !== m) {\n          //Keep old energy value for sum modification below\n          var cell = colm[iIdx];\n          var oldDx = cell[0];\n          var oldDy = cell[1];\n\n          //Calc new energy:\n          var x_i = nodes[i].x;\n          var y_i = nodes[i].y;\n          var denominator = 1.0 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));\n          var dx = kcolm[i] * (x_m - x_i - lcolm[i] * (x_m - x_i) * denominator);\n          var dy = kcolm[i] * (y_m - y_i - lcolm[i] * (y_m - y_i) * denominator);\n          colm[iIdx] = [dx, dy];\n          dE_dx += dx;\n          dE_dy += dy;\n\n          //add new energy to sum of each column\n          var sum = this.E_sums[i];\n          sum[0] += dx - oldDx;\n          sum[1] += dy - oldDy;\n        }\n      }\n      //Store sum at -1 index\n      this.E_sums[m] = [dE_dx, dE_dy];\n    }\n  }]);\n  return KamadaKawai;\n}();\n\n/**\n * Create a network visualization, displaying nodes and edges.\n *\n * @param {Element} container   The DOM element in which the Network will\n *                                  be created. Normally a div element.\n * @param {object} data         An object containing parameters\n *                              {Array} nodes\n *                              {Array} edges\n * @param {object} options      Options\n * @class Network\n */\nfunction Network(container, data, options) {\n  var _context,\n    _context2,\n    _context3,\n    _context4,\n    _this = this;\n  if (!(this instanceof Network)) {\n    throw new SyntaxError(\"Constructor must be called with the new operator\");\n  }\n\n  // set constant values\n  this.options = {};\n  this.defaultOptions = {\n    locale: \"en\",\n    locales: locales,\n    clickToUse: false\n  };\n  _Object$assign(this.options, this.defaultOptions);\n\n  /**\n   * Containers for nodes and edges.\n   *\n   * 'edges' and 'nodes' contain the full definitions of all the network elements.\n   * 'nodeIndices' and 'edgeIndices' contain the id's of the active elements.\n   *\n   * The distinction is important, because a defined node need not be active, i.e.\n   * visible on the canvas. This happens in particular when clusters are defined, in\n   * that case there will be nodes and edges not displayed.\n   * The bottom line is that all code with actions related to visibility, *must* use\n   * 'nodeIndices' and 'edgeIndices', not 'nodes' and 'edges' directly.\n   */\n  this.body = {\n    container: container,\n    // See comment above for following fields\n    nodes: {},\n    nodeIndices: [],\n    edges: {},\n    edgeIndices: [],\n    emitter: {\n      on: _bindInstanceProperty$1(_context = this.on).call(_context, this),\n      off: _bindInstanceProperty$1(_context2 = this.off).call(_context2, this),\n      emit: _bindInstanceProperty$1(_context3 = this.emit).call(_context3, this),\n      once: _bindInstanceProperty$1(_context4 = this.once).call(_context4, this)\n    },\n    eventListeners: {\n      onTap: function onTap() {},\n      onTouch: function onTouch() {},\n      onDoubleTap: function onDoubleTap() {},\n      onHold: function onHold() {},\n      onDragStart: function onDragStart() {},\n      onDrag: function onDrag() {},\n      onDragEnd: function onDragEnd() {},\n      onMouseWheel: function onMouseWheel() {},\n      onPinch: function onPinch() {},\n      onMouseMove: function onMouseMove() {},\n      onRelease: function onRelease() {},\n      onContext: function onContext() {}\n    },\n    data: {\n      nodes: null,\n      // A DataSet or DataView\n      edges: null // A DataSet or DataView\n    },\n\n    functions: {\n      createNode: function createNode() {},\n      createEdge: function createEdge() {},\n      getPointer: function getPointer() {}\n    },\n    modules: {},\n    view: {\n      scale: 1,\n      translation: {\n        x: 0,\n        y: 0\n      }\n    },\n    selectionBox: {\n      show: false,\n      position: {\n        start: {\n          x: 0,\n          y: 0\n        },\n        end: {\n          x: 0,\n          y: 0\n        }\n      }\n    }\n  };\n\n  // bind the event listeners\n  this.bindEventListeners();\n\n  // setting up all modules\n  this.images = new Images(function () {\n    return _this.body.emitter.emit(\"_requestRedraw\");\n  }); // object with images\n  this.groups = new Groups(); // object with groups\n  this.canvas = new Canvas(this.body); // DOM handler\n  this.selectionHandler = new SelectionHandler(this.body, this.canvas); // Selection handler\n  this.interactionHandler = new InteractionHandler(this.body, this.canvas, this.selectionHandler); // Interaction handler handles all the hammer bindings (that are bound by canvas), key\n  this.view = new View(this.body, this.canvas); // camera handler, does animations and zooms\n  this.renderer = new CanvasRenderer(this.body, this.canvas); // renderer, starts renderloop, has events that modules can hook into\n  this.physics = new PhysicsEngine(this.body); // physics engine, does all the simulations\n  this.layoutEngine = new LayoutEngine(this.body); // layout engine for inital layout and hierarchical layout\n  this.clustering = new ClusterEngine(this.body); // clustering api\n  this.manipulation = new ManipulationSystem(this.body, this.canvas, this.selectionHandler, this.interactionHandler); // data manipulation system\n\n  this.nodesHandler = new NodesHandler(this.body, this.images, this.groups, this.layoutEngine); // Handle adding, deleting and updating of nodes as well as global options\n  this.edgesHandler = new EdgesHandler(this.body, this.images, this.groups); // Handle adding, deleting and updating of edges as well as global options\n\n  this.body.modules[\"kamadaKawai\"] = new KamadaKawai(this.body, 150, 0.05); // Layouting algorithm.\n  this.body.modules[\"clustering\"] = this.clustering;\n\n  // create the DOM elements\n  this.canvas._create();\n\n  // apply options\n  this.setOptions(options);\n\n  // load data (the disable start variable will be the same as the enabled clustering)\n  this.setData(data);\n}\n\n// Extend Network with an Emitter mixin\nEmitter(Network.prototype);\n\n/**\n * Set options\n *\n * @param {object} options\n */\nNetwork.prototype.setOptions = function (options) {\n  var _this2 = this;\n  if (options === null) {\n    options = undefined; // This ensures that options handling doesn't crash in the handling\n  }\n\n  if (options !== undefined) {\n    var errorFound = Validator.validate(options, allOptions);\n    if (errorFound === true) {\n      console.error(\"%cErrors have been found in the supplied options object.\", VALIDATOR_PRINT_STYLE);\n    }\n\n    // copy the global fields over\n    var fields = [\"locale\", \"locales\", \"clickToUse\"];\n    selectiveDeepExtend(fields, this.options, options);\n\n    // normalize the locale or use English\n    if (options.locale !== undefined) {\n      options.locale = normalizeLanguageCode(options.locales || this.options.locales, options.locale);\n    }\n\n    // the hierarchical system can adapt the edges and the physics to it's own options because not all combinations work with the hierarichical system.\n    options = this.layoutEngine.setOptions(options.layout, options);\n    this.canvas.setOptions(options); // options for canvas are in globals\n\n    // pass the options to the modules\n    this.groups.setOptions(options.groups);\n    this.nodesHandler.setOptions(options.nodes);\n    this.edgesHandler.setOptions(options.edges);\n    this.physics.setOptions(options.physics);\n    this.manipulation.setOptions(options.manipulation, options, this.options); // manipulation uses the locales in the globals\n\n    this.interactionHandler.setOptions(options.interaction);\n    this.renderer.setOptions(options.interaction); // options for rendering are in interaction\n    this.selectionHandler.setOptions(options.interaction); // options for selection are in interaction\n\n    // reload the settings of the nodes to apply changes in groups that are not referenced by pointer.\n    if (options.groups !== undefined) {\n      this.body.emitter.emit(\"refreshNodes\");\n    }\n    // these two do not have options at the moment, here for completeness\n    //this.view.setOptions(options.view);\n    //this.clustering.setOptions(options.clustering);\n\n    if (\"configure\" in options) {\n      if (!this.configurator) {\n        this.configurator = new Configurator(this, this.body.container, configureOptions, this.canvas.pixelRatio, configuratorHideOption);\n      }\n      this.configurator.setOptions(options.configure);\n    }\n\n    // if the configuration system is enabled, copy all options and put them into the config system\n    if (this.configurator && this.configurator.options.enabled === true) {\n      var networkOptions = {\n        nodes: {},\n        edges: {},\n        layout: {},\n        interaction: {},\n        manipulation: {},\n        physics: {},\n        global: {}\n      };\n      deepExtend(networkOptions.nodes, this.nodesHandler.options);\n      deepExtend(networkOptions.edges, this.edgesHandler.options);\n      deepExtend(networkOptions.layout, this.layoutEngine.options);\n      // load the selectionHandler and render default options in to the interaction group\n      deepExtend(networkOptions.interaction, this.selectionHandler.options);\n      deepExtend(networkOptions.interaction, this.renderer.options);\n      deepExtend(networkOptions.interaction, this.interactionHandler.options);\n      deepExtend(networkOptions.manipulation, this.manipulation.options);\n      deepExtend(networkOptions.physics, this.physics.options);\n\n      // load globals into the global object\n      deepExtend(networkOptions.global, this.canvas.options);\n      deepExtend(networkOptions.global, this.options);\n      this.configurator.setModuleOptions(networkOptions);\n    }\n\n    // handle network global options\n    if (options.clickToUse !== undefined) {\n      if (options.clickToUse === true) {\n        if (this.activator === undefined) {\n          this.activator = new Activator(this.canvas.frame);\n          this.activator.on(\"change\", function () {\n            _this2.body.emitter.emit(\"activate\");\n          });\n        }\n      } else {\n        if (this.activator !== undefined) {\n          this.activator.destroy();\n          delete this.activator;\n        }\n        this.body.emitter.emit(\"activate\");\n      }\n    } else {\n      this.body.emitter.emit(\"activate\");\n    }\n    this.canvas.setSize();\n    // start the physics simulation. Can be safely called multiple times.\n    this.body.emitter.emit(\"startSimulation\");\n  }\n};\n\n/**\n * Update the visible nodes and edges list with the most recent node state.\n *\n * Visible nodes are stored in this.body.nodeIndices.\n * Visible edges are stored in this.body.edgeIndices.\n * A node or edges is visible if it is not hidden or clustered.\n *\n * @private\n */\nNetwork.prototype._updateVisibleIndices = function () {\n  var nodes = this.body.nodes;\n  var edges = this.body.edges;\n  this.body.nodeIndices = [];\n  this.body.edgeIndices = [];\n  for (var nodeId in nodes) {\n    if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {\n      if (!this.clustering._isClusteredNode(nodeId) && nodes[nodeId].options.hidden === false) {\n        this.body.nodeIndices.push(nodes[nodeId].id);\n      }\n    }\n  }\n  for (var edgeId in edges) {\n    if (Object.prototype.hasOwnProperty.call(edges, edgeId)) {\n      var edge = edges[edgeId];\n\n      // It can happen that this is executed *after* a node edge has been removed,\n      // but *before* the edge itself has been removed. Taking this into account.\n      var fromNode = nodes[edge.fromId];\n      var toNode = nodes[edge.toId];\n      var edgeNodesPresent = fromNode !== undefined && toNode !== undefined;\n      var isVisible = !this.clustering._isClusteredEdge(edgeId) && edge.options.hidden === false && edgeNodesPresent && fromNode.options.hidden === false &&\n      // Also hidden if any of its connecting nodes are hidden\n      toNode.options.hidden === false; // idem\n\n      if (isVisible) {\n        this.body.edgeIndices.push(edge.id);\n      }\n    }\n  }\n};\n\n/**\n * Bind all events\n */\nNetwork.prototype.bindEventListeners = function () {\n  var _this3 = this;\n  // This event will trigger a rebuilding of the cache everything.\n  // Used when nodes or edges have been added or removed.\n  this.body.emitter.on(\"_dataChanged\", function () {\n    _this3.edgesHandler._updateState();\n    _this3.body.emitter.emit(\"_dataUpdated\");\n  });\n\n  // this is called when options of EXISTING nodes or edges have changed.\n  this.body.emitter.on(\"_dataUpdated\", function () {\n    // Order important in following block\n    _this3.clustering._updateState();\n    _this3._updateVisibleIndices();\n    _this3._updateValueRange(_this3.body.nodes);\n    _this3._updateValueRange(_this3.body.edges);\n    // start simulation (can be called safely, even if already running)\n    _this3.body.emitter.emit(\"startSimulation\");\n    _this3.body.emitter.emit(\"_requestRedraw\");\n  });\n};\n\n/**\n * Set nodes and edges, and optionally options as well.\n *\n * @param {object} data              Object containing parameters:\n *                                   {Array | DataSet | DataView} [nodes] Array with nodes\n *                                   {Array | DataSet | DataView} [edges] Array with edges\n *                                   {String} [dot] String containing data in DOT format\n *                                   {String} [gephi] String containing data in gephi JSON format\n *                                   {Options} [options] Object with options\n */\nNetwork.prototype.setData = function (data) {\n  // reset the physics engine.\n  this.body.emitter.emit(\"resetPhysics\");\n  this.body.emitter.emit(\"_resetData\");\n\n  // unselect all to ensure no selections from old data are carried over.\n  this.selectionHandler.unselectAll();\n  if (data && data.dot && (data.nodes || data.edges)) {\n    throw new SyntaxError('Data must contain either parameter \"dot\" or ' + ' parameter pair \"nodes\" and \"edges\", but not both.');\n  }\n\n  // set options\n  this.setOptions(data && data.options);\n  // set all data\n  if (data && data.dot) {\n    console.warn(\"The dot property has been deprecated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);\");\n    // parse DOT file\n    var dotData = DOTToGraph(data.dot);\n    this.setData(dotData);\n    return;\n  } else if (data && data.gephi) {\n    // parse DOT file\n    console.warn(\"The gephi property has been deprecated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);\");\n    var gephiData = parseGephi(data.gephi);\n    this.setData(gephiData);\n    return;\n  } else {\n    this.nodesHandler.setData(data && data.nodes, true);\n    this.edgesHandler.setData(data && data.edges, true);\n  }\n\n  // emit change in data\n  this.body.emitter.emit(\"_dataChanged\");\n\n  // emit data loaded\n  this.body.emitter.emit(\"_dataLoaded\");\n\n  // find a stable position or start animating to a stable position\n  this.body.emitter.emit(\"initPhysics\");\n};\n\n/**\n * Cleans up all bindings of the network, removing it fully from the memory IF the variable is set to null after calling this function.\n * var network = new vis.Network(..);\n * network.destroy();\n * network = null;\n */\nNetwork.prototype.destroy = function () {\n  this.body.emitter.emit(\"destroy\");\n  // clear events\n  this.body.emitter.off();\n  this.off();\n\n  // delete modules\n  delete this.groups;\n  delete this.canvas;\n  delete this.selectionHandler;\n  delete this.interactionHandler;\n  delete this.view;\n  delete this.renderer;\n  delete this.physics;\n  delete this.layoutEngine;\n  delete this.clustering;\n  delete this.manipulation;\n  delete this.nodesHandler;\n  delete this.edgesHandler;\n  delete this.configurator;\n  delete this.images;\n  for (var nodeId in this.body.nodes) {\n    if (!Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) continue;\n    delete this.body.nodes[nodeId];\n  }\n  for (var edgeId in this.body.edges) {\n    if (!Object.prototype.hasOwnProperty.call(this.body.edges, edgeId)) continue;\n    delete this.body.edges[edgeId];\n  }\n\n  // remove the container and everything inside it recursively\n  recursiveDOMDelete(this.body.container);\n};\n\n/**\n * Update the values of all object in the given array according to the current\n * value range of the objects in the array.\n *\n * @param {object} obj    An object containing a set of Edges or Nodes\n *                        The objects must have a method getValue() and\n *                        setValueRange(min, max).\n * @private\n */\nNetwork.prototype._updateValueRange = function (obj) {\n  var id;\n\n  // determine the range of the objects\n  var valueMin = undefined;\n  var valueMax = undefined;\n  var valueTotal = 0;\n  for (id in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, id)) {\n      var value = obj[id].getValue();\n      if (value !== undefined) {\n        valueMin = valueMin === undefined ? value : Math.min(value, valueMin);\n        valueMax = valueMax === undefined ? value : Math.max(value, valueMax);\n        valueTotal += value;\n      }\n    }\n  }\n\n  // adjust the range of all objects\n  if (valueMin !== undefined && valueMax !== undefined) {\n    for (id in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, id)) {\n        obj[id].setValueRange(valueMin, valueMax, valueTotal);\n      }\n    }\n  }\n};\n\n/**\n * Returns true when the Network is active.\n *\n * @returns {boolean}\n */\nNetwork.prototype.isActive = function () {\n  return !this.activator || this.activator.active;\n};\nNetwork.prototype.setSize = function () {\n  return this.canvas.setSize.apply(this.canvas, arguments);\n};\nNetwork.prototype.canvasToDOM = function () {\n  return this.canvas.canvasToDOM.apply(this.canvas, arguments);\n};\nNetwork.prototype.DOMtoCanvas = function () {\n  return this.canvas.DOMtoCanvas.apply(this.canvas, arguments);\n};\n\n/**\n * Nodes can be in clusters. Clusters can also be in clusters. This function returns and array of\n * nodeIds showing where the node is.\n *\n * If any nodeId in the chain, especially the first passed in as a parameter, is not present in\n * the current nodes list, an empty array is returned.\n *\n * Example:\n * cluster 'A' contains cluster 'B',\n * cluster 'B' contains cluster 'C',\n * cluster 'C' contains node 'fred'.\n * `jsnetwork.clustering.findNode('fred')` will return `['A','B','C','fred']`.\n *\n * @param {string|number} nodeId\n * @returns {Array}\n */\nNetwork.prototype.findNode = function () {\n  return this.clustering.findNode.apply(this.clustering, arguments);\n};\nNetwork.prototype.isCluster = function () {\n  return this.clustering.isCluster.apply(this.clustering, arguments);\n};\nNetwork.prototype.openCluster = function () {\n  return this.clustering.openCluster.apply(this.clustering, arguments);\n};\nNetwork.prototype.cluster = function () {\n  return this.clustering.cluster.apply(this.clustering, arguments);\n};\nNetwork.prototype.getNodesInCluster = function () {\n  return this.clustering.getNodesInCluster.apply(this.clustering, arguments);\n};\nNetwork.prototype.clusterByConnection = function () {\n  return this.clustering.clusterByConnection.apply(this.clustering, arguments);\n};\nNetwork.prototype.clusterByHubsize = function () {\n  return this.clustering.clusterByHubsize.apply(this.clustering, arguments);\n};\nNetwork.prototype.updateClusteredNode = function () {\n  return this.clustering.updateClusteredNode.apply(this.clustering, arguments);\n};\nNetwork.prototype.getClusteredEdges = function () {\n  return this.clustering.getClusteredEdges.apply(this.clustering, arguments);\n};\nNetwork.prototype.getBaseEdge = function () {\n  return this.clustering.getBaseEdge.apply(this.clustering, arguments);\n};\nNetwork.prototype.getBaseEdges = function () {\n  return this.clustering.getBaseEdges.apply(this.clustering, arguments);\n};\nNetwork.prototype.updateEdge = function () {\n  return this.clustering.updateEdge.apply(this.clustering, arguments);\n};\n\n/**\n * This method will cluster all nodes with 1 edge with their respective connected node.\n * The options object is explained in full <a data-scroll=\"\" data-options=\"{ &quot;easing&quot;: &quot;easeInCubic&quot; }\" href=\"#optionsObject\">below</a>.\n *\n * @param {object} [options]\n * @returns {undefined}\n */\nNetwork.prototype.clusterOutliers = function () {\n  return this.clustering.clusterOutliers.apply(this.clustering, arguments);\n};\nNetwork.prototype.getSeed = function () {\n  return this.layoutEngine.getSeed.apply(this.layoutEngine, arguments);\n};\nNetwork.prototype.enableEditMode = function () {\n  return this.manipulation.enableEditMode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.disableEditMode = function () {\n  return this.manipulation.disableEditMode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.addNodeMode = function () {\n  return this.manipulation.addNodeMode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.editNode = function () {\n  return this.manipulation.editNode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.editNodeMode = function () {\n  console.warn(\"Deprecated: Please use editNode instead of editNodeMode.\");\n  return this.manipulation.editNode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.addEdgeMode = function () {\n  return this.manipulation.addEdgeMode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.editEdgeMode = function () {\n  return this.manipulation.editEdgeMode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.deleteSelected = function () {\n  return this.manipulation.deleteSelected.apply(this.manipulation, arguments);\n};\nNetwork.prototype.getPositions = function () {\n  return this.nodesHandler.getPositions.apply(this.nodesHandler, arguments);\n};\nNetwork.prototype.getPosition = function () {\n  return this.nodesHandler.getPosition.apply(this.nodesHandler, arguments);\n};\nNetwork.prototype.storePositions = function () {\n  return this.nodesHandler.storePositions.apply(this.nodesHandler, arguments);\n};\nNetwork.prototype.moveNode = function () {\n  return this.nodesHandler.moveNode.apply(this.nodesHandler, arguments);\n};\nNetwork.prototype.getBoundingBox = function () {\n  return this.nodesHandler.getBoundingBox.apply(this.nodesHandler, arguments);\n};\nNetwork.prototype.getConnectedNodes = function (objectId) {\n  if (this.body.nodes[objectId] !== undefined) {\n    return this.nodesHandler.getConnectedNodes.apply(this.nodesHandler, arguments);\n  } else {\n    return this.edgesHandler.getConnectedNodes.apply(this.edgesHandler, arguments);\n  }\n};\nNetwork.prototype.getConnectedEdges = function () {\n  return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler, arguments);\n};\nNetwork.prototype.startSimulation = function () {\n  return this.physics.startSimulation.apply(this.physics, arguments);\n};\nNetwork.prototype.stopSimulation = function () {\n  return this.physics.stopSimulation.apply(this.physics, arguments);\n};\nNetwork.prototype.stabilize = function () {\n  return this.physics.stabilize.apply(this.physics, arguments);\n};\nNetwork.prototype.getSelection = function () {\n  return this.selectionHandler.getSelection.apply(this.selectionHandler, arguments);\n};\nNetwork.prototype.setSelection = function () {\n  return this.selectionHandler.setSelection.apply(this.selectionHandler, arguments);\n};\nNetwork.prototype.getSelectedNodes = function () {\n  return this.selectionHandler.getSelectedNodeIds.apply(this.selectionHandler, arguments);\n};\nNetwork.prototype.getSelectedEdges = function () {\n  return this.selectionHandler.getSelectedEdgeIds.apply(this.selectionHandler, arguments);\n};\nNetwork.prototype.getNodeAt = function () {\n  var node = this.selectionHandler.getNodeAt.apply(this.selectionHandler, arguments);\n  if (node !== undefined && node.id !== undefined) {\n    return node.id;\n  }\n  return node;\n};\nNetwork.prototype.getEdgeAt = function () {\n  var edge = this.selectionHandler.getEdgeAt.apply(this.selectionHandler, arguments);\n  if (edge !== undefined && edge.id !== undefined) {\n    return edge.id;\n  }\n  return edge;\n};\nNetwork.prototype.selectNodes = function () {\n  return this.selectionHandler.selectNodes.apply(this.selectionHandler, arguments);\n};\nNetwork.prototype.selectEdges = function () {\n  return this.selectionHandler.selectEdges.apply(this.selectionHandler, arguments);\n};\nNetwork.prototype.unselectAll = function () {\n  this.selectionHandler.unselectAll.apply(this.selectionHandler, arguments);\n  this.selectionHandler.commitWithoutEmitting.apply(this.selectionHandler);\n  this.redraw();\n};\nNetwork.prototype.redraw = function () {\n  return this.renderer.redraw.apply(this.renderer, arguments);\n};\nNetwork.prototype.getScale = function () {\n  return this.view.getScale.apply(this.view, arguments);\n};\nNetwork.prototype.getViewPosition = function () {\n  return this.view.getViewPosition.apply(this.view, arguments);\n};\nNetwork.prototype.fit = function () {\n  return this.view.fit.apply(this.view, arguments);\n};\nNetwork.prototype.moveTo = function () {\n  return this.view.moveTo.apply(this.view, arguments);\n};\nNetwork.prototype.focus = function () {\n  return this.view.focus.apply(this.view, arguments);\n};\nNetwork.prototype.releaseNode = function () {\n  return this.view.releaseNode.apply(this.view, arguments);\n};\nNetwork.prototype.getOptionsFromConfigurator = function () {\n  var options = {};\n  if (this.configurator) {\n    options = this.configurator.getOptions.apply(this.configurator);\n  }\n  return options;\n};\n\nvar parseDOTNetwork = DOTToGraph;\n// DataSet, utils etc. can't be reexported here because that would cause stack\n// overflow in UMD builds. They all export vis namespace therefore reexporting\n// leads to loading vis to load vis to load visâ¦\n\n\n//# sourceMappingURL=vis-network.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlzLW5ldHdvcmsvcGVlci9lc20vdmlzLW5ldHdvcmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0U7O0FBRXhFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sbUJBQW1CLGFBQWE7QUFDeEUsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQSxnRkFBZ0YsTUFBTTs7QUFFdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMENBQTBDOztBQUUxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7O0FBRWhCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxrREFBa0Q7QUFDeEYsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUU7O0FBRWpFOztBQUVBOztBQUVBO0FBQ0EseUVBQXlFO0FBQ3pFLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsYUFBYTtBQUMxRDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0RkFBNEY7O0FBRTVGLG1HQUFtRztBQUNuRzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxhQUFhO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0NBQWdDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBLGdFQUFnRSwyREFBMkQ7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7O0FBRS9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDLDhDQUE4QztBQUM5QyxnREFBZ0Q7QUFDaEQ7O0FBRUEseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxXQUFXLG9GQUFvRjtBQUNyRzs7QUFFQTtBQUNBO0FBQ0Esc0VBQXNFLGVBQWU7QUFDckY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxnQkFBZ0I7QUFDMUQ7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdUNBQXVDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVO0FBQ3pELEVBQUUsZ0JBQWdCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsTUFBTSwwREFBMEQ7QUFDaEU7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdHQUF3RztBQUM5RztBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDBEQUEwRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtB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QkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsWUFBWSw0RkFBNEY7QUFDaEgsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sOERBQThEO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7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QUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLDhDQUE4QztBQUNwRDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGdEQUFnRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxvREFBb0Q7QUFDMUQ7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLDBFQUEwRTtBQUNoRjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLHdFQUF3RTtBQUM5RTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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RUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QXFEO0FBQ3JELFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsRUFBRSxlQUFlLEVBQUU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QVE7QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakMsd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDZCQUE2QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxzQkFBc0IsNkJBQTZCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxpQkFBaUI7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyxlQUFlO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtB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QkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FB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QSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVztBQUNwQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVELDJCQUEyQix5QkFBeUIscUNBQXFDLDBDQUEwQyw0REFBNEQsNkRBQTZELDBCQUEwQjtBQUN0Uiw4QkFBOEIsZ0JBQWdCLHNCQUFzQixPQUFPLDBCQUEwQixrREFBa0Qsc0dBQXNHLDhCQUE4QixzTUFBc00seUVBQXlFLEtBQUs7QUFDL2lCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsK0NBQStDLFVBQVU7QUFDekQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRCxtQ0FBbUMsK0RBQStELHlDQUF5Qyw4Q0FB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QUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0QkFBNEI7QUFDM0M7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLE1BQU07QUFDckI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsTUFB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O0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVE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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSx3REFBd0QsdUJBQXVCO0FBQy9FOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0I7QUFDaEU7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZC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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxl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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVEsZ0NBQWdDLHNCQUFzQjtBQUM3RTtBQUNBO0FBQ0EsdURBQXVELHNCQUFzQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVLE1BQU0saUNBQWlDO0FBQ2hFO0FBQ0EsZUFBZSxTQUFTLE1BQU0saUNBQWlDO0FBQy9EO0FBQ0EsZUFBZSxVQUFVLE1BQU0saUJBQWlCO0FBQ2hEO0FBQ0EsZUFBZSxXQUFXLE1BQU0sa0JBQWtCO0FBQ2xEO0FBQ0EsZUFBZSxVQUFVLE1BQU0sb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CO0FBQ0Esb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCO0FBQ0Esb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QjtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG9DQUFvQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1DQUFtQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNY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QTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrSEFBK0g7QUFDL0gscURBQXFELEdBQUc7QUFDeEQsc0RBQXNELEdBQUc7QUFDekQsdUlBQXVJO0FBQ3ZJLDZIQUE2SDtBQUM3SCxtSUFBbUk7QUFDbkksMkRBQTJELEdBQUc7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Es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QWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdB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QSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsc0NBQXNDLDRCQUE0QjtBQUNsRSxzQ0FBc0MsNEJBQTRCO0FBQ2xFLHNDQUFzQyxRQUFRO0FBQzlDLHNDQUFzQyxRQUFRO0FBQzlDLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJRQUEyUTtBQUMzUTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG1SQUFtUjtBQUNuUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkVBQTZFLE1BQU0sWUFBWSxRQUFRLG1CQUFtQjtBQUMxSDtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUUyTDtBQUMzTCIsInNvdXJjZXMiOlsid2VicGFjazovL2dvb3Jvb20tZmUteWFybi8uL25vZGVfbW9kdWxlcy92aXMtbmV0d29yay9wZWVyL2VzbS92aXMtbmV0d29yay5qcz8yNmYwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogdmlzLW5ldHdvcmtcbiAqIGh0dHBzOi8vdmlzanMuZ2l0aHViLmlvL3Zpcy1uZXR3b3JrL1xuICpcbiAqIEEgZHluYW1pYywgYnJvd3Nlci1iYXNlZCB2aXN1YWxpemF0aW9uIGxpYnJhcnkuXG4gKlxuICogQHZlcnNpb24gOS4xLjlcbiAqIEBkYXRlICAgIDIwMjMtMTEtMDNUMDE6NDI6MjcuNDE4WlxuICpcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTEtMjAxNyBBbG1lbmRlIEIuViwgaHR0cDovL2FsbWVuZGUuY29tXG4gKiBAY29weXJpZ2h0IChjKSAyMDE3LTIwMTkgdmlzanMgY29udHJpYnV0b3JzLCBodHRwczovL2dpdGh1Yi5jb20vdmlzanNcbiAqXG4gKiBAbGljZW5zZVxuICogdmlzLmpzIGlzIGR1YWwgbGljZW5zZWQgdW5kZXIgYm90aFxuICpcbiAqICAgMS4gVGhlIEFwYWNoZSAyLjAgTGljZW5zZVxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgIGFuZFxuICpcbiAqICAgMi4gVGhlIE1JVCBMaWNlbnNlXG4gKiAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqXG4gKiB2aXMuanMgbWF5IGJlIGRpc3RyaWJ1dGVkIHVuZGVyIGVpdGhlciBsaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGlzRGF0YVZpZXdMaWtlLCBEYXRhU2V0IH0gZnJvbSAndmlzLWRhdGEvcGVlci9lc20vdmlzLWRhdGEuanMnO1xuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxudmFyIGNoZWNrID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAmJiBpdC5NYXRoID09PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwkbiA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1nbG9iYWwtdGhpcyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8XG4gIGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZikgfHxcbiAgY2hlY2sodHlwZW9mIGNvbW1vbmpzR2xvYmFsID09ICdvYmplY3QnICYmIGNvbW1vbmpzR2xvYmFsKSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmMgLS0gZmFsbGJhY2tcbiAgKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pKCkgfHwgY29tbW9uanNHbG9iYWwgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxudmFyIGZhaWxzJHcgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxudmFyIGZhaWxzJHYgPSBmYWlscyR3O1xuXG52YXIgZnVuY3Rpb25CaW5kTmF0aXZlID0gIWZhaWxzJHYoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tZnVuY3Rpb24tcHJvdG90eXBlLWJpbmQgLS0gc2FmZVxuICB2YXIgdGVzdCA9IChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pLmJpbmQoKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG4gIHJldHVybiB0eXBlb2YgdGVzdCAhPSAnZnVuY3Rpb24nIHx8IHRlc3QuaGFzT3duUHJvcGVydHkoJ3Byb3RvdHlwZScpO1xufSk7XG5cbnZhciBOQVRJVkVfQklORCQ0ID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUkNCA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBhcHBseSQ1ID0gRnVuY3Rpb25Qcm90b3R5cGUkNC5hcHBseTtcbnZhciBjYWxsJGYgPSBGdW5jdGlvblByb3RvdHlwZSQ0LmNhbGw7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1yZWZsZWN0IC0tIHNhZmVcbnZhciBmdW5jdGlvbkFwcGx5ID0gdHlwZW9mIFJlZmxlY3QgPT0gJ29iamVjdCcgJiYgUmVmbGVjdC5hcHBseSB8fCAoTkFUSVZFX0JJTkQkNCA/IGNhbGwkZi5iaW5kKGFwcGx5JDUpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbCRmLmFwcGx5KGFwcGx5JDUsIGFyZ3VtZW50cyk7XG59KTtcblxudmFyIE5BVElWRV9CSU5EJDMgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSQzID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIGNhbGwkZSA9IEZ1bmN0aW9uUHJvdG90eXBlJDMuY2FsbDtcbnZhciB1bmN1cnJ5VGhpc1dpdGhCaW5kID0gTkFUSVZFX0JJTkQkMyAmJiBGdW5jdGlvblByb3RvdHlwZSQzLmJpbmQuYmluZChjYWxsJGUsIGNhbGwkZSk7XG5cbnZhciBmdW5jdGlvblVuY3VycnlUaGlzID0gTkFUSVZFX0JJTkQkMyA/IHVuY3VycnlUaGlzV2l0aEJpbmQgOiBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FsbCRlLmFwcGx5KGZuLCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxudmFyIHVuY3VycnlUaGlzJHggPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuXG52YXIgdG9TdHJpbmckYyA9IHVuY3VycnlUaGlzJHgoe30udG9TdHJpbmcpO1xudmFyIHN0cmluZ1NsaWNlJDEgPSB1bmN1cnJ5VGhpcyR4KCcnLnNsaWNlKTtcblxudmFyIGNsYXNzb2ZSYXckMiA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gc3RyaW5nU2xpY2UkMSh0b1N0cmluZyRjKGl0KSwgOCwgLTEpO1xufTtcblxudmFyIGNsYXNzb2ZSYXckMSA9IGNsYXNzb2ZSYXckMjtcbnZhciB1bmN1cnJ5VGhpcyR3ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIGZ1bmN0aW9uVW5jdXJyeVRoaXNDbGF1c2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgLy8gTmFzaG9ybiBidWc6XG4gIC8vICAgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzExMjhcbiAgLy8gICBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTEzMFxuICBpZiAoY2xhc3NvZlJhdyQxKGZuKSA9PT0gJ0Z1bmN0aW9uJykgcmV0dXJuIHVuY3VycnlUaGlzJHcoZm4pO1xufTtcblxudmFyIGRvY3VtZW50QWxsJDIgPSB0eXBlb2YgZG9jdW1lbnQgPT0gJ29iamVjdCcgJiYgZG9jdW1lbnQuYWxsO1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLUlzSFRNTEREQS1pbnRlcm5hbC1zbG90XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby10eXBlb2YtdW5kZWZpbmVkIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG52YXIgSVNfSFRNTEREQSA9IHR5cGVvZiBkb2N1bWVudEFsbCQyID09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50QWxsJDIgIT09IHVuZGVmaW5lZDtcblxudmFyIGRvY3VtZW50QWxsXzEgPSB7XG4gIGFsbDogZG9jdW1lbnRBbGwkMixcbiAgSVNfSFRNTEREQTogSVNfSFRNTEREQVxufTtcblxudmFyICRkb2N1bWVudEFsbCQxID0gZG9jdW1lbnRBbGxfMTtcblxudmFyIGRvY3VtZW50QWxsJDEgPSAkZG9jdW1lbnRBbGwkMS5hbGw7XG5cbi8vIGBJc0NhbGxhYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjYWxsYWJsZVxudmFyIGlzQ2FsbGFibGUkaSA9ICRkb2N1bWVudEFsbCQxLklTX0hUTUxEREEgPyBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PSAnZnVuY3Rpb24nIHx8IGFyZ3VtZW50ID09PSBkb2N1bWVudEFsbCQxO1xufSA6IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0ge307XG5cbnZhciBmYWlscyR1ID0gZmFpbHMkdztcblxuLy8gRGV0ZWN0IElFOCdzIGluY29tcGxldGUgZGVmaW5lUHJvcGVydHkgaW1wbGVtZW50YXRpb25cbnZhciBkZXNjcmlwdG9ycyA9ICFmYWlscyR1KGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KVsxXSAhPT0gNztcbn0pO1xuXG52YXIgTkFUSVZFX0JJTkQkMiA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcblxudmFyIGNhbGwkZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsO1xuXG52YXIgZnVuY3Rpb25DYWxsID0gTkFUSVZFX0JJTkQkMiA/IGNhbGwkZC5iaW5kKGNhbGwkZCkgOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYWxsJGQuYXBwbHkoY2FsbCRkLCBhcmd1bWVudHMpO1xufTtcblxudmFyIG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlID0ge307XG5cbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUkMSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gTmFzaG9ybiB+IEpESzggYnVnXG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkOSAmJiAhJHByb3BlcnR5SXNFbnVtZXJhYmxlJDEuY2FsbCh7IDE6IDIgfSwgMSk7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eWlzZW51bWVyYWJsZVxub2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUuZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ5KHRoaXMsIFYpO1xuICByZXR1cm4gISFkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZTtcbn0gOiAkcHJvcGVydHlJc0VudW1lcmFibGUkMTtcblxudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1ID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyR2ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmYWlscyR0ID0gZmFpbHMkdztcbnZhciBjbGFzc29mJGUgPSBjbGFzc29mUmF3JDI7XG5cbnZhciAkT2JqZWN0JDUgPSBPYmplY3Q7XG52YXIgc3BsaXQgPSB1bmN1cnJ5VGhpcyR2KCcnLnNwbGl0KTtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBpbmRleGVkT2JqZWN0ID0gZmFpbHMkdChmdW5jdGlvbiAoKSB7XG4gIC8vIHRocm93cyBhbiBlcnJvciBpbiByaGlubywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3JoaW5vL2lzc3Vlcy8zNDZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG4gIHJldHVybiAhJE9iamVjdCQ1KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XG59KSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY2xhc3NvZiRlKGl0KSA9PT0gJ1N0cmluZycgPyBzcGxpdChpdCwgJycpIDogJE9iamVjdCQ1KGl0KTtcbn0gOiAkT2JqZWN0JDU7XG5cbi8vIHdlIGNhbid0IHVzZSBqdXN0IGBpdCA9PSBudWxsYCBzaW5jZSBvZiBgZG9jdW1lbnQuYWxsYCBzcGVjaWFsIGNhc2Vcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtSXNIVE1MRERBLWludGVybmFsLXNsb3QtYWVjXG52YXIgaXNOdWxsT3JVbmRlZmluZWQkNiA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IG51bGwgfHwgaXQgPT09IHVuZGVmaW5lZDtcbn07XG5cbnZhciBpc051bGxPclVuZGVmaW5lZCQ1ID0gaXNOdWxsT3JVbmRlZmluZWQkNjtcblxudmFyICRUeXBlRXJyb3IkZyA9IFR5cGVFcnJvcjtcblxuLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ1ID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpc051bGxPclVuZGVmaW5lZCQ1KGl0KSkgdGhyb3cgbmV3ICRUeXBlRXJyb3IkZyhcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG4vLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QkMyA9IGluZGV4ZWRPYmplY3Q7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ0ID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ1O1xuXG52YXIgdG9JbmRleGVkT2JqZWN0JGEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEluZGV4ZWRPYmplY3QkMyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDQoaXQpKTtcbn07XG5cbnZhciBpc0NhbGxhYmxlJGggPSBpc0NhbGxhYmxlJGk7XG52YXIgJGRvY3VtZW50QWxsID0gZG9jdW1lbnRBbGxfMTtcblxudmFyIGRvY3VtZW50QWxsID0gJGRvY3VtZW50QWxsLmFsbDtcblxudmFyIGlzT2JqZWN0JGogPSAkZG9jdW1lbnRBbGwuSVNfSFRNTEREQSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlJGgoaXQpIHx8IGl0ID09PSBkb2N1bWVudEFsbDtcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogaXNDYWxsYWJsZSRoKGl0KTtcbn07XG5cbnZhciBwYXRoJHcgPSB7fTtcblxudmFyIHBhdGgkdiA9IHBhdGgkdztcbnZhciBnbG9iYWwkbSA9IGdsb2JhbCRuO1xudmFyIGlzQ2FsbGFibGUkZyA9IGlzQ2FsbGFibGUkaTtcblxudmFyIGFGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICByZXR1cm4gaXNDYWxsYWJsZSRnKHZhcmlhYmxlKSA/IHZhcmlhYmxlIDogdW5kZWZpbmVkO1xufTtcblxudmFyIGdldEJ1aWx0SW4kYyA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIG1ldGhvZCkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBhRnVuY3Rpb24ocGF0aCR2W25hbWVzcGFjZV0pIHx8IGFGdW5jdGlvbihnbG9iYWwkbVtuYW1lc3BhY2VdKVxuICAgIDogcGF0aCR2W25hbWVzcGFjZV0gJiYgcGF0aCR2W25hbWVzcGFjZV1bbWV0aG9kXSB8fCBnbG9iYWwkbVtuYW1lc3BhY2VdICYmIGdsb2JhbCRtW25hbWVzcGFjZV1bbWV0aG9kXTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyR1ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIG9iamVjdElzUHJvdG90eXBlT2YgPSB1bmN1cnJ5VGhpcyR1KHt9LmlzUHJvdG90eXBlT2YpO1xuXG52YXIgZW5naW5lVXNlckFnZW50ID0gdHlwZW9mIG5hdmlnYXRvciAhPSAndW5kZWZpbmVkJyAmJiBTdHJpbmcobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgJyc7XG5cbnZhciBnbG9iYWwkbCA9IGdsb2JhbCRuO1xudmFyIHVzZXJBZ2VudCQyID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgcHJvY2VzcyA9IGdsb2JhbCRsLnByb2Nlc3M7XG52YXIgRGVubyA9IGdsb2JhbCRsLkRlbm87XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzICYmIHByb2Nlc3MudmVyc2lvbnMgfHwgRGVubyAmJiBEZW5vLnZlcnNpb247XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52ODtcbnZhciBtYXRjaCwgdmVyc2lvbjtcblxuaWYgKHY4KSB7XG4gIG1hdGNoID0gdjguc3BsaXQoJy4nKTtcbiAgLy8gaW4gb2xkIENocm9tZSwgdmVyc2lvbnMgb2YgVjggaXNuJ3QgVjggPSBDaHJvbWUgLyAxMFxuICAvLyBidXQgdGhlaXIgY29ycmVjdCB2ZXJzaW9ucyBhcmUgbm90IGludGVyZXN0aW5nIGZvciB1c1xuICB2ZXJzaW9uID0gbWF0Y2hbMF0gPiAwICYmIG1hdGNoWzBdIDwgNCA/IDEgOiArKG1hdGNoWzBdICsgbWF0Y2hbMV0pO1xufVxuXG4vLyBCcm93c2VyRlMgTm9kZUpTIGBwcm9jZXNzYCBwb2x5ZmlsbCBpbmNvcnJlY3RseSBzZXQgYC52OGAgdG8gYDAuMGBcbi8vIHNvIGNoZWNrIGB1c2VyQWdlbnRgIGV2ZW4gaWYgYC52OGAgZXhpc3RzLCBidXQgMFxuaWYgKCF2ZXJzaW9uICYmIHVzZXJBZ2VudCQyKSB7XG4gIG1hdGNoID0gdXNlckFnZW50JDIubWF0Y2goL0VkZ2VcXC8oXFxkKykvKTtcbiAgaWYgKCFtYXRjaCB8fCBtYXRjaFsxXSA+PSA3NCkge1xuICAgIG1hdGNoID0gdXNlckFnZW50JDIubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICAgIGlmIChtYXRjaCkgdmVyc2lvbiA9ICttYXRjaFsxXTtcbiAgfVxufVxuXG52YXIgZW5naW5lVjhWZXJzaW9uID0gdmVyc2lvbjtcblxuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG52YXIgVjhfVkVSU0lPTiQyID0gZW5naW5lVjhWZXJzaW9uO1xudmFyIGZhaWxzJHMgPSBmYWlscyR3O1xudmFyIGdsb2JhbCRrID0gZ2xvYmFsJG47XG5cbnZhciAkU3RyaW5nJDUgPSBnbG9iYWwkay5TdHJpbmc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG52YXIgc3ltYm9sQ29uc3RydWN0b3JEZXRlY3Rpb24gPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzJHMoZnVuY3Rpb24gKCkge1xuICB2YXIgc3ltYm9sID0gU3ltYm9sKCdzeW1ib2wgZGV0ZWN0aW9uJyk7XG4gIC8vIENocm9tZSAzOCBTeW1ib2wgaGFzIGluY29ycmVjdCB0b1N0cmluZyBjb252ZXJzaW9uXG4gIC8vIGBnZXQtb3duLXByb3BlcnR5LXN5bWJvbHNgIHBvbHlmaWxsIHN5bWJvbHMgY29udmVydGVkIHRvIG9iamVjdCBhcmUgbm90IFN5bWJvbCBpbnN0YW5jZXNcbiAgLy8gbmI6IERvIG5vdCBjYWxsIGBTdHJpbmdgIGRpcmVjdGx5IHRvIGF2b2lkIHRoaXMgYmVpbmcgb3B0aW1pemVkIG91dCB0byBgc3ltYm9sKycnYCB3aGljaCB3aWxsLFxuICAvLyBvZiBjb3Vyc2UsIGZhaWwuXG4gIHJldHVybiAhJFN0cmluZyQ1KHN5bWJvbCkgfHwgIShPYmplY3Qoc3ltYm9sKSBpbnN0YW5jZW9mIFN5bWJvbCkgfHxcbiAgICAvLyBDaHJvbWUgMzgtNDAgc3ltYm9scyBhcmUgbm90IGluaGVyaXRlZCBmcm9tIERPTSBjb2xsZWN0aW9ucyBwcm90b3R5cGVzIHRvIGluc3RhbmNlc1xuICAgICFTeW1ib2wuc2hhbSAmJiBWOF9WRVJTSU9OJDIgJiYgVjhfVkVSU0lPTiQyIDwgNDE7XG59KTtcblxuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG52YXIgTkFUSVZFX1NZTUJPTCQ1ID0gc3ltYm9sQ29uc3RydWN0b3JEZXRlY3Rpb247XG5cbnZhciB1c2VTeW1ib2xBc1VpZCA9IE5BVElWRV9TWU1CT0wkNVxuICAmJiAhU3ltYm9sLnNoYW1cbiAgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcblxudmFyIGdldEJ1aWx0SW4kYiA9IGdldEJ1aWx0SW4kYztcbnZhciBpc0NhbGxhYmxlJGYgPSBpc0NhbGxhYmxlJGk7XG52YXIgaXNQcm90b3R5cGVPZiRrID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCQxID0gdXNlU3ltYm9sQXNVaWQ7XG5cbnZhciAkT2JqZWN0JDQgPSBPYmplY3Q7XG5cbnZhciBpc1N5bWJvbCQ1ID0gVVNFX1NZTUJPTF9BU19VSUQkMSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgJFN5bWJvbCA9IGdldEJ1aWx0SW4kYignU3ltYm9sJyk7XG4gIHJldHVybiBpc0NhbGxhYmxlJGYoJFN5bWJvbCkgJiYgaXNQcm90b3R5cGVPZiRrKCRTeW1ib2wucHJvdG90eXBlLCAkT2JqZWN0JDQoaXQpKTtcbn07XG5cbnZhciAkU3RyaW5nJDQgPSBTdHJpbmc7XG5cbnZhciB0cnlUb1N0cmluZyQ2ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICRTdHJpbmckNChhcmd1bWVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuICdPYmplY3QnO1xuICB9XG59O1xuXG52YXIgaXNDYWxsYWJsZSRlID0gaXNDYWxsYWJsZSRpO1xudmFyIHRyeVRvU3RyaW5nJDUgPSB0cnlUb1N0cmluZyQ2O1xuXG52YXIgJFR5cGVFcnJvciRmID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBJc0NhbGxhYmxlKGFyZ3VtZW50KSBpcyB0cnVlYFxudmFyIGFDYWxsYWJsZSQ3ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc0NhbGxhYmxlJGUoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93IG5ldyAkVHlwZUVycm9yJGYodHJ5VG9TdHJpbmckNShhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG59O1xuXG52YXIgYUNhbGxhYmxlJDYgPSBhQ2FsbGFibGUkNztcbnZhciBpc051bGxPclVuZGVmaW5lZCQ0ID0gaXNOdWxsT3JVbmRlZmluZWQkNjtcblxuLy8gYEdldE1ldGhvZGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldG1ldGhvZFxudmFyIGdldE1ldGhvZCQzID0gZnVuY3Rpb24gKFYsIFApIHtcbiAgdmFyIGZ1bmMgPSBWW1BdO1xuICByZXR1cm4gaXNOdWxsT3JVbmRlZmluZWQkNChmdW5jKSA/IHVuZGVmaW5lZCA6IGFDYWxsYWJsZSQ2KGZ1bmMpO1xufTtcblxudmFyIGNhbGwkYyA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBpc0NhbGxhYmxlJGQgPSBpc0NhbGxhYmxlJGk7XG52YXIgaXNPYmplY3QkaSA9IGlzT2JqZWN0JGo7XG5cbnZhciAkVHlwZUVycm9yJGUgPSBUeXBlRXJyb3I7XG5cbi8vIGBPcmRpbmFyeVRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUkMSA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKHByZWYgPT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUkZChmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QkaSh2YWwgPSBjYWxsJGMoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChpc0NhbGxhYmxlJGQoZm4gPSBpbnB1dC52YWx1ZU9mKSAmJiAhaXNPYmplY3QkaSh2YWwgPSBjYWxsJGMoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChwcmVmICE9PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlJGQoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0JGkodmFsID0gY2FsbCRjKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBuZXcgJFR5cGVFcnJvciRlKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxudmFyIHNoYXJlZCQ3ID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGdsb2JhbCRqID0gZ2xvYmFsJG47XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5JGYgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBkZWZpbmVQcm9wZXJ0eSRmKGdsb2JhbCRqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGdsb2JhbCRqW2tleV0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgZ2xvYmFsJGkgPSBnbG9iYWwkbjtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSA9IGRlZmluZUdsb2JhbFByb3BlcnR5JDE7XG5cbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSQzID0gZ2xvYmFsJGlbU0hBUkVEXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eShTSEFSRUQsIHt9KTtcblxudmFyIHNoYXJlZFN0b3JlID0gc3RvcmUkMztcblxudmFyIHN0b3JlJDIgPSBzaGFyZWRTdG9yZTtcblxuKHNoYXJlZCQ3LmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmUkMltrZXldIHx8IChzdG9yZSQyW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246ICczLjMzLjAnLFxuICBtb2RlOiAncHVyZScgLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE0LTIwMjMgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknLFxuICBsaWNlbnNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvYmxvYi92My4zMy4wL0xJQ0VOU0UnLFxuICBzb3VyY2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcydcbn0pO1xuXG52YXIgc2hhcmVkRXhwb3J0cyA9IHNoYXJlZCQ3LmV4cG9ydHM7XG5cbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDMgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDU7XG5cbnZhciAkT2JqZWN0JDMgPSBPYmplY3Q7XG5cbi8vIGBUb09iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XG52YXIgdG9PYmplY3QkZSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gJE9iamVjdCQzKHJlcXVpcmVPYmplY3RDb2VyY2libGUkMyhhcmd1bWVudCkpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJHQgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHRvT2JqZWN0JGQgPSB0b09iamVjdCRlO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyR0KHt9Lmhhc093blByb3BlcnR5KTtcblxuLy8gYEhhc093blByb3BlcnR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaGFzb3ducHJvcGVydHlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtaGFzb3duIC0tIHNhZmVcbnZhciBoYXNPd25Qcm9wZXJ0eV8xID0gT2JqZWN0Lmhhc093biB8fCBmdW5jdGlvbiBoYXNPd24oaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkodG9PYmplY3QkZChpdCksIGtleSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkcyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBpZCQyID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcbnZhciB0b1N0cmluZyRiID0gdW5jdXJyeVRoaXMkcygxLjAudG9TdHJpbmcpO1xuXG52YXIgdWlkJDQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcgKyAoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgdG9TdHJpbmckYigrK2lkJDIgKyBwb3N0Zml4LCAzNik7XG59O1xuXG52YXIgZ2xvYmFsJGggPSBnbG9iYWwkbjtcbnZhciBzaGFyZWQkNiA9IHNoYXJlZEV4cG9ydHM7XG52YXIgaGFzT3duJGggPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHVpZCQzID0gdWlkJDQ7XG52YXIgTkFUSVZFX1NZTUJPTCQ0ID0gc3ltYm9sQ29uc3RydWN0b3JEZXRlY3Rpb247XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSB1c2VTeW1ib2xBc1VpZDtcblxudmFyIFN5bWJvbCQ1ID0gZ2xvYmFsJGguU3ltYm9sO1xudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSQyID0gc2hhcmVkJDYoJ3drcycpO1xudmFyIGNyZWF0ZVdlbGxLbm93blN5bWJvbCA9IFVTRV9TWU1CT0xfQVNfVUlEID8gU3ltYm9sJDVbJ2ZvciddIHx8IFN5bWJvbCQ1IDogU3ltYm9sJDUgJiYgU3ltYm9sJDUud2l0aG91dFNldHRlciB8fCB1aWQkMztcblxudmFyIHdlbGxLbm93blN5bWJvbCRtID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCFoYXNPd24kaChXZWxsS25vd25TeW1ib2xzU3RvcmUkMiwgbmFtZSkpIHtcbiAgICBXZWxsS25vd25TeW1ib2xzU3RvcmUkMltuYW1lXSA9IE5BVElWRV9TWU1CT0wkNCAmJiBoYXNPd24kaChTeW1ib2wkNSwgbmFtZSlcbiAgICAgID8gU3ltYm9sJDVbbmFtZV1cbiAgICAgIDogY3JlYXRlV2VsbEtub3duU3ltYm9sKCdTeW1ib2wuJyArIG5hbWUpO1xuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmUkMltuYW1lXTtcbn07XG5cbnZhciBjYWxsJGIgPSBmdW5jdGlvbkNhbGw7XG52YXIgaXNPYmplY3QkaCA9IGlzT2JqZWN0JGo7XG52YXIgaXNTeW1ib2wkNCA9IGlzU3ltYm9sJDU7XG52YXIgZ2V0TWV0aG9kJDIgPSBnZXRNZXRob2QkMztcbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gb3JkaW5hcnlUb1ByaW1pdGl2ZSQxO1xudmFyIHdlbGxLbm93blN5bWJvbCRsID0gd2VsbEtub3duU3ltYm9sJG07XG5cbnZhciAkVHlwZUVycm9yJGQgPSBUeXBlRXJyb3I7XG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sJGwoJ3RvUHJpbWl0aXZlJyk7XG5cbi8vIGBUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG52YXIgdG9QcmltaXRpdmUkNiA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICBpZiAoIWlzT2JqZWN0JGgoaW5wdXQpIHx8IGlzU3ltYm9sJDQoaW5wdXQpKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBleG90aWNUb1ByaW0gPSBnZXRNZXRob2QkMihpbnB1dCwgVE9fUFJJTUlUSVZFKTtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGV4b3RpY1RvUHJpbSkge1xuICAgIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnZGVmYXVsdCc7XG4gICAgcmVzdWx0ID0gY2FsbCRiKGV4b3RpY1RvUHJpbSwgaW5wdXQsIHByZWYpO1xuICAgIGlmICghaXNPYmplY3QkaChyZXN1bHQpIHx8IGlzU3ltYm9sJDQocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICB0aHJvdyBuZXcgJFR5cGVFcnJvciRkKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xuICB9XG4gIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnbnVtYmVyJztcbiAgcmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIHByZWYpO1xufTtcblxudmFyIHRvUHJpbWl0aXZlJDUgPSB0b1ByaW1pdGl2ZSQ2O1xudmFyIGlzU3ltYm9sJDMgPSBpc1N5bWJvbCQ1O1xuXG4vLyBgVG9Qcm9wZXJ0eUtleWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJvcGVydHlrZXlcbnZhciB0b1Byb3BlcnR5S2V5JDQgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIGtleSA9IHRvUHJpbWl0aXZlJDUoYXJndW1lbnQsICdzdHJpbmcnKTtcbiAgcmV0dXJuIGlzU3ltYm9sJDMoa2V5KSA/IGtleSA6IGtleSArICcnO1xufTtcblxudmFyIGdsb2JhbCRnID0gZ2xvYmFsJG47XG52YXIgaXNPYmplY3QkZyA9IGlzT2JqZWN0JGo7XG5cbnZhciBkb2N1bWVudCQxID0gZ2xvYmFsJGcuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBFWElTVFMkMSA9IGlzT2JqZWN0JGcoZG9jdW1lbnQkMSkgJiYgaXNPYmplY3QkZyhkb2N1bWVudCQxLmNyZWF0ZUVsZW1lbnQpO1xuXG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50JDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEVYSVNUUyQxID8gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxudmFyIERFU0NSSVBUT1JTJGggPSBkZXNjcmlwdG9ycztcbnZhciBmYWlscyRyID0gZmFpbHMkdztcbnZhciBjcmVhdGVFbGVtZW50ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDE7XG5cbi8vIFRoYW5rcyB0byBJRTggZm9yIGl0cyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxudmFyIGllOERvbURlZmluZSA9ICFERVNDUklQVE9SUyRoICYmICFmYWlscyRyKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0ZUVsZW1lbnQoJ2RpdicpLCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH1cbiAgfSkuYSAhPT0gNztcbn0pO1xuXG52YXIgREVTQ1JJUFRPUlMkZyA9IGRlc2NyaXB0b3JzO1xudmFyIGNhbGwkYSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQyID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDQgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcbnZhciB0b0luZGV4ZWRPYmplY3QkOSA9IHRvSW5kZXhlZE9iamVjdCRhO1xudmFyIHRvUHJvcGVydHlLZXkkMyA9IHRvUHJvcGVydHlLZXkkNDtcbnZhciBoYXNPd24kZyA9IGhhc093blByb3BlcnR5XzE7XG52YXIgSUU4X0RPTV9ERUZJTkUkMSA9IGllOERvbURlZmluZTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxub2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmYgPSBERVNDUklQVE9SUyRnID8gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSW5kZXhlZE9iamVjdCQ5KE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleSQzKFApO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUkMSkgdHJ5IHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyKE8sIFApO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXNPd24kZyhPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ0KCFjYWxsJGEocHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUkMi5mLCBPLCBQKSwgT1tQXSk7XG59O1xuXG52YXIgZmFpbHMkcSA9IGZhaWxzJHc7XG52YXIgaXNDYWxsYWJsZSRjID0gaXNDYWxsYWJsZSRpO1xuXG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xuXG52YXIgaXNGb3JjZWQkMSA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuICByZXR1cm4gdmFsdWUgPT09IFBPTFlGSUxMID8gdHJ1ZVxuICAgIDogdmFsdWUgPT09IE5BVElWRSA/IGZhbHNlXG4gICAgOiBpc0NhbGxhYmxlJGMoZGV0ZWN0aW9uKSA/IGZhaWxzJHEoZGV0ZWN0aW9uKVxuICAgIDogISFkZXRlY3Rpb247XG59O1xuXG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQkMS5ub3JtYWxpemUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlcGxhY2VtZW50LCAnLicpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG52YXIgZGF0YSA9IGlzRm9yY2VkJDEuZGF0YSA9IHt9O1xudmFyIE5BVElWRSA9IGlzRm9yY2VkJDEuTkFUSVZFID0gJ04nO1xudmFyIFBPTFlGSUxMID0gaXNGb3JjZWQkMS5QT0xZRklMTCA9ICdQJztcblxudmFyIGlzRm9yY2VkXzEgPSBpc0ZvcmNlZCQxO1xuXG52YXIgdW5jdXJyeVRoaXMkciA9IGZ1bmN0aW9uVW5jdXJyeVRoaXNDbGF1c2U7XG52YXIgYUNhbGxhYmxlJDUgPSBhQ2FsbGFibGUkNztcbnZhciBOQVRJVkVfQklORCQxID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgYmluZCRlID0gdW5jdXJyeVRoaXMkcih1bmN1cnJ5VGhpcyRyLmJpbmQpO1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBmdW5jdGlvbkJpbmRDb250ZXh0ID0gZnVuY3Rpb24gKGZuLCB0aGF0KSB7XG4gIGFDYWxsYWJsZSQ1KGZuKTtcbiAgcmV0dXJuIHRoYXQgPT09IHVuZGVmaW5lZCA/IGZuIDogTkFUSVZFX0JJTkQkMSA/IGJpbmQkZShmbiwgdGhhdCkgOiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxudmFyIG9iamVjdERlZmluZVByb3BlcnR5ID0ge307XG5cbnZhciBERVNDUklQVE9SUyRmID0gZGVzY3JpcHRvcnM7XG52YXIgZmFpbHMkcCA9IGZhaWxzJHc7XG5cbi8vIFY4IH4gQ2hyb21lIDM2LVxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzMzNFxudmFyIHY4UHJvdG90eXBlRGVmaW5lQnVnID0gREVTQ1JJUFRPUlMkZiAmJiBmYWlscyRwKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgJ3Byb3RvdHlwZScsIHtcbiAgICB2YWx1ZTogNDIsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pLnByb3RvdHlwZSAhPT0gNDI7XG59KTtcblxudmFyIGlzT2JqZWN0JGYgPSBpc09iamVjdCRqO1xuXG52YXIgJFN0cmluZyQzID0gU3RyaW5nO1xudmFyICRUeXBlRXJyb3IkYyA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogVHlwZShhcmd1bWVudCkgaXMgT2JqZWN0YFxudmFyIGFuT2JqZWN0JGQgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzT2JqZWN0JGYoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93IG5ldyAkVHlwZUVycm9yJGMoJFN0cmluZyQzKGFyZ3VtZW50KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xufTtcblxudmFyIERFU0NSSVBUT1JTJGUgPSBkZXNjcmlwdG9ycztcbnZhciBJRThfRE9NX0RFRklORSA9IGllOERvbURlZmluZTtcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyQxID0gdjhQcm90b3R5cGVEZWZpbmVCdWc7XG52YXIgYW5PYmplY3QkYyA9IGFuT2JqZWN0JGQ7XG52YXIgdG9Qcm9wZXJ0eUtleSQyID0gdG9Qcm9wZXJ0eUtleSQ0O1xuXG52YXIgJFR5cGVFcnJvciRiID0gVHlwZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgJGRlZmluZVByb3BlcnR5JDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBFTlVNRVJBQkxFID0gJ2VudW1lcmFibGUnO1xudmFyIENPTkZJR1VSQUJMRSQxID0gJ2NvbmZpZ3VyYWJsZSc7XG52YXIgV1JJVEFCTEUgPSAnd3JpdGFibGUnO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG5vYmplY3REZWZpbmVQcm9wZXJ0eS5mID0gREVTQ1JJUFRPUlMkZSA/IFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHJDEgPyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0JGMoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5JDIoUCk7XG4gIGFuT2JqZWN0JGMoQXR0cmlidXRlcyk7XG4gIGlmICh0eXBlb2YgTyA9PT0gJ2Z1bmN0aW9uJyAmJiBQID09PSAncHJvdG90eXBlJyAmJiAndmFsdWUnIGluIEF0dHJpYnV0ZXMgJiYgV1JJVEFCTEUgaW4gQXR0cmlidXRlcyAmJiAhQXR0cmlidXRlc1tXUklUQUJMRV0pIHtcbiAgICB2YXIgY3VycmVudCA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMShPLCBQKTtcbiAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50W1dSSVRBQkxFXSkge1xuICAgICAgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gICAgICBBdHRyaWJ1dGVzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IENPTkZJR1VSQUJMRSQxIGluIEF0dHJpYnV0ZXMgPyBBdHRyaWJ1dGVzW0NPTkZJR1VSQUJMRSQxXSA6IGN1cnJlbnRbQ09ORklHVVJBQkxFJDFdLFxuICAgICAgICBlbnVtZXJhYmxlOiBFTlVNRVJBQkxFIGluIEF0dHJpYnV0ZXMgPyBBdHRyaWJ1dGVzW0VOVU1FUkFCTEVdIDogY3VycmVudFtFTlVNRVJBQkxFXSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgfSByZXR1cm4gJGRlZmluZVByb3BlcnR5JDEoTywgUCwgQXR0cmlidXRlcyk7XG59IDogJGRlZmluZVByb3BlcnR5JDEgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0JGMoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5JDIoUCk7XG4gIGFuT2JqZWN0JGMoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gJGRlZmluZVByb3BlcnR5JDEoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgbmV3ICRUeXBlRXJyb3IkYignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxudmFyIERFU0NSSVBUT1JTJGQgPSBkZXNjcmlwdG9ycztcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQzID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDMgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcblxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2ID0gREVTQ1JJUFRPUlMkZCA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlJDMuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDMoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG52YXIgZ2xvYmFsJGYgPSBnbG9iYWwkbjtcbnZhciBhcHBseSQ0ID0gZnVuY3Rpb25BcHBseTtcbnZhciB1bmN1cnJ5VGhpcyRxID0gZnVuY3Rpb25VbmN1cnJ5VGhpc0NsYXVzZTtcbnZhciBpc0NhbGxhYmxlJGIgPSBpc0NhbGxhYmxlJGk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDggPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcbnZhciBpc0ZvcmNlZCA9IGlzRm9yY2VkXzE7XG52YXIgcGF0aCR1ID0gcGF0aCR3O1xudmFyIGJpbmQkZCA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDUgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNjtcbnZhciBoYXNPd24kZiA9IGhhc093blByb3BlcnR5XzE7XG5cbnZhciB3cmFwQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoTmF0aXZlQ29uc3RydWN0b3IpIHtcbiAgdmFyIFdyYXBwZXIgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgV3JhcHBlcikge1xuICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpO1xuICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgTmF0aXZlQ29uc3RydWN0b3IoYSk7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBOYXRpdmVDb25zdHJ1Y3RvcihhLCBiKTtcbiAgICAgIH0gcmV0dXJuIG5ldyBOYXRpdmVDb25zdHJ1Y3RvcihhLCBiLCBjKTtcbiAgICB9IHJldHVybiBhcHBseSQ0KE5hdGl2ZUNvbnN0cnVjdG9yLCB0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICBXcmFwcGVyLnByb3RvdHlwZSA9IE5hdGl2ZUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgcmV0dXJuIFdyYXBwZXI7XG59O1xuXG4vKlxuICBvcHRpb25zLnRhcmdldCAgICAgICAgIC0gbmFtZSBvZiB0aGUgdGFyZ2V0IG9iamVjdFxuICBvcHRpb25zLmdsb2JhbCAgICAgICAgIC0gdGFyZ2V0IGlzIHRoZSBnbG9iYWwgb2JqZWN0XG4gIG9wdGlvbnMuc3RhdCAgICAgICAgICAgLSBleHBvcnQgYXMgc3RhdGljIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucHJvdG8gICAgICAgICAgLSBleHBvcnQgYXMgcHJvdG90eXBlIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucmVhbCAgICAgICAgICAgLSByZWFsIHByb3RvdHlwZSBtZXRob2QgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLmZvcmNlZCAgICAgICAgIC0gZXhwb3J0IGV2ZW4gaWYgdGhlIG5hdGl2ZSBmZWF0dXJlIGlzIGF2YWlsYWJsZVxuICBvcHRpb25zLmJpbmQgICAgICAgICAgIC0gYmluZCBtZXRob2RzIHRvIHRoZSB0YXJnZXQsIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy53cmFwICAgICAgICAgICAtIHdyYXAgY29uc3RydWN0b3JzIHRvIHByZXZlbnRpbmcgZ2xvYmFsIHBvbGx1dGlvbiwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLnVuc2FmZSAgICAgICAgIC0gdXNlIHRoZSBzaW1wbGUgYXNzaWdubWVudCBvZiBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGRlbGV0ZSArIGRlZmluZVByb3BlcnR5XG4gIG9wdGlvbnMuc2hhbSAgICAgICAgICAgLSBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gIG9wdGlvbnMuZW51bWVyYWJsZSAgICAgLSBleHBvcnQgYXMgZW51bWVyYWJsZSBwcm9wZXJ0eVxuICBvcHRpb25zLmRvbnRDYWxsR2V0U2V0IC0gcHJldmVudCBjYWxsaW5nIGEgZ2V0dGVyIG9uIHRhcmdldFxuICBvcHRpb25zLm5hbWUgICAgICAgICAgIC0gdGhlIC5uYW1lIG9mIHRoZSBmdW5jdGlvbiBpZiBpdCBkb2VzIG5vdCBtYXRjaCB0aGUga2V5XG4qL1xudmFyIF9leHBvcnQgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcbiAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xuICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuICB2YXIgUFJPVE8gPSBvcHRpb25zLnByb3RvO1xuXG4gIHZhciBuYXRpdmVTb3VyY2UgPSBHTE9CQUwgPyBnbG9iYWwkZiA6IFNUQVRJQyA/IGdsb2JhbCRmW1RBUkdFVF0gOiAoZ2xvYmFsJGZbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xuXG4gIHZhciB0YXJnZXQgPSBHTE9CQUwgPyBwYXRoJHUgOiBwYXRoJHVbVEFSR0VUXSB8fCBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNShwYXRoJHUsIFRBUkdFVCwge30pW1RBUkdFVF07XG4gIHZhciB0YXJnZXRQcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuXG4gIHZhciBGT1JDRUQsIFVTRV9OQVRJVkUsIFZJUlRVQUxfUFJPVE9UWVBFO1xuICB2YXIga2V5LCBzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHksIG5hdGl2ZVByb3BlcnR5LCByZXN1bHRQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcblxuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZChHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpO1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIFVTRV9OQVRJVkUgPSAhRk9SQ0VEICYmIG5hdGl2ZVNvdXJjZSAmJiBoYXNPd24kZihuYXRpdmVTb3VyY2UsIGtleSk7XG5cbiAgICB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuXG4gICAgaWYgKFVTRV9OQVRJVkUpIGlmIChvcHRpb25zLmRvbnRDYWxsR2V0U2V0KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDgobmF0aXZlU291cmNlLCBrZXkpO1xuICAgICAgbmF0aXZlUHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgfSBlbHNlIG5hdGl2ZVByb3BlcnR5ID0gbmF0aXZlU291cmNlW2tleV07XG5cbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIGltcGxlbWVudGF0aW9uXG4gICAgc291cmNlUHJvcGVydHkgPSAoVVNFX05BVElWRSAmJiBuYXRpdmVQcm9wZXJ0eSkgPyBuYXRpdmVQcm9wZXJ0eSA6IHNvdXJjZVtrZXldO1xuXG4gICAgaWYgKFVTRV9OQVRJVkUgJiYgdHlwZW9mIHRhcmdldFByb3BlcnR5ID09IHR5cGVvZiBzb3VyY2VQcm9wZXJ0eSkgY29udGludWU7XG5cbiAgICAvLyBiaW5kIG1ldGhvZHMgdG8gZ2xvYmFsIGZvciBjYWxsaW5nIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBpZiAob3B0aW9ucy5iaW5kICYmIFVTRV9OQVRJVkUpIHJlc3VsdFByb3BlcnR5ID0gYmluZCRkKHNvdXJjZVByb3BlcnR5LCBnbG9iYWwkZik7XG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZXMgaW4gdGhpcyB2ZXJzaW9uXG4gICAgZWxzZSBpZiAob3B0aW9ucy53cmFwICYmIFVTRV9OQVRJVkUpIHJlc3VsdFByb3BlcnR5ID0gd3JhcENvbnN0cnVjdG9yKHNvdXJjZVByb3BlcnR5KTtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICBlbHNlIGlmIChQUk9UTyAmJiBpc0NhbGxhYmxlJGIoc291cmNlUHJvcGVydHkpKSByZXN1bHRQcm9wZXJ0eSA9IHVuY3VycnlUaGlzJHEoc291cmNlUHJvcGVydHkpO1xuICAgIC8vIGRlZmF1bHQgY2FzZVxuICAgIGVsc2UgcmVzdWx0UHJvcGVydHkgPSBzb3VyY2VQcm9wZXJ0eTtcblxuICAgIC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgICBpZiAob3B0aW9ucy5zaGFtIHx8IChzb3VyY2VQcm9wZXJ0eSAmJiBzb3VyY2VQcm9wZXJ0eS5zaGFtKSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1KHJlc3VsdFByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cblxuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1KHRhcmdldCwga2V5LCByZXN1bHRQcm9wZXJ0eSk7XG5cbiAgICBpZiAoUFJPVE8pIHtcbiAgICAgIFZJUlRVQUxfUFJPVE9UWVBFID0gVEFSR0VUICsgJ1Byb3RvdHlwZSc7XG4gICAgICBpZiAoIWhhc093biRmKHBhdGgkdSwgVklSVFVBTF9QUk9UT1RZUEUpKSB7XG4gICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1KHBhdGgkdSwgVklSVFVBTF9QUk9UT1RZUEUsIHt9KTtcbiAgICAgIH1cbiAgICAgIC8vIGV4cG9ydCB2aXJ0dWFsIHByb3RvdHlwZSBtZXRob2RzXG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNShwYXRoJHVbVklSVFVBTF9QUk9UT1RZUEVdLCBrZXksIHNvdXJjZVByb3BlcnR5KTtcbiAgICAgIC8vIGV4cG9ydCByZWFsIHByb3RvdHlwZSBtZXRob2RzXG4gICAgICBpZiAob3B0aW9ucy5yZWFsICYmIHRhcmdldFByb3RvdHlwZSAmJiAoRk9SQ0VEIHx8ICF0YXJnZXRQcm90b3R5cGVba2V5XSkpIHtcbiAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDUodGFyZ2V0UHJvdG90eXBlLCBrZXksIHNvdXJjZVByb3BlcnR5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yJDEgPSBNYXRoLmZsb29yO1xuXG4vLyBgTWF0aC50cnVuY2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hdGgudHJ1bmNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1tYXRoLXRydW5jIC0tIHNhZmVcbnZhciBtYXRoVHJ1bmMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uIHRydW5jKHgpIHtcbiAgdmFyIG4gPSAreDtcbiAgcmV0dXJuIChuID4gMCA/IGZsb29yJDEgOiBjZWlsKShuKTtcbn07XG5cbnZhciB0cnVuYyA9IG1hdGhUcnVuYztcblxuLy8gYFRvSW50ZWdlck9ySW5maW5pdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJvcmluZmluaXR5XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQ0ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBudW1iZXIgPSArYXJndW1lbnQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gIHJldHVybiBudW1iZXIgIT09IG51bWJlciB8fCBudW1iZXIgPT09IDAgPyAwIDogdHJ1bmMobnVtYmVyKTtcbn07XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5JDMgPSB0b0ludGVnZXJPckluZmluaXR5JDQ7XG5cbnZhciBtYXgkMyA9IE1hdGgubWF4O1xudmFyIG1pbiQyID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cbnZhciB0b0Fic29sdXRlSW5kZXgkNSA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQzKGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4JDMoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4kMihpbnRlZ2VyLCBsZW5ndGgpO1xufTtcblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkMiA9IHRvSW50ZWdlck9ySW5maW5pdHkkNDtcblxudmFyIG1pbiQxID0gTWF0aC5taW47XG5cbi8vIGBUb0xlbmd0aGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG52YXIgdG9MZW5ndGgkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluJDEodG9JbnRlZ2VyT3JJbmZpbml0eSQyKGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG52YXIgdG9MZW5ndGggPSB0b0xlbmd0aCQxO1xuXG4vLyBgTGVuZ3RoT2ZBcnJheUxpa2VgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1sZW5ndGhvZmFycmF5bGlrZVxudmFyIGxlbmd0aE9mQXJyYXlMaWtlJGMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0b0xlbmd0aChvYmoubGVuZ3RoKTtcbn07XG5cbnZhciB0b0luZGV4ZWRPYmplY3QkOCA9IHRvSW5kZXhlZE9iamVjdCRhO1xudmFyIHRvQWJzb2x1dGVJbmRleCQ0ID0gdG9BYnNvbHV0ZUluZGV4JDU7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkYiA9IGxlbmd0aE9mQXJyYXlMaWtlJGM7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBpbmRleE9mLCBpbmNsdWRlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kJDQgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0JDgoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSRiKE8pO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleCQ0KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9PSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgICAgaWYgKHZhbHVlICE9PSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgaWYgKChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSAmJiBPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cbnZhciBhcnJheUluY2x1ZGVzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiAgaW5jbHVkZXM6IGNyZWF0ZU1ldGhvZCQ0KHRydWUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4gIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZCQ0KGZhbHNlKVxufTtcblxudmFyIGhpZGRlbktleXMkNiA9IHt9O1xuXG52YXIgdW5jdXJyeVRoaXMkcCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaGFzT3duJGUgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHRvSW5kZXhlZE9iamVjdCQ3ID0gdG9JbmRleGVkT2JqZWN0JGE7XG52YXIgaW5kZXhPZiQ0ID0gYXJyYXlJbmNsdWRlcy5pbmRleE9mO1xudmFyIGhpZGRlbktleXMkNSA9IGhpZGRlbktleXMkNjtcblxudmFyIHB1c2gkYiA9IHVuY3VycnlUaGlzJHAoW10ucHVzaCk7XG5cbnZhciBvYmplY3RLZXlzSW50ZXJuYWwgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQ3KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSAhaGFzT3duJGUoaGlkZGVuS2V5cyQ1LCBrZXkpICYmIGhhc093biRlKE8sIGtleSkgJiYgcHVzaCRiKHJlc3VsdCwga2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhc093biRlKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YkNChyZXN1bHQsIGtleSkgfHwgcHVzaCRiKHJlc3VsdCwga2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG52YXIgZW51bUJ1Z0tleXMkMyA9IFtcbiAgJ2NvbnN0cnVjdG9yJyxcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9Mb2NhbGVTdHJpbmcnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZidcbl07XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMkMSA9IG9iamVjdEtleXNJbnRlcm5hbDtcbnZhciBlbnVtQnVnS2V5cyQyID0gZW51bUJ1Z0tleXMkMztcblxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3Qta2V5cyAtLSBzYWZlXG52YXIgb2JqZWN0S2V5cyQzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMkMShPLCBlbnVtQnVnS2V5cyQyKTtcbn07XG5cbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSB7fTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gc2FmZVxub2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG52YXIgREVTQ1JJUFRPUlMkYyA9IGRlc2NyaXB0b3JzO1xudmFyIHVuY3VycnlUaGlzJG8gPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGNhbGwkOSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBmYWlscyRvID0gZmFpbHMkdztcbnZhciBvYmplY3RLZXlzJDIgPSBvYmplY3RLZXlzJDM7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDMgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUkMSA9IG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIHRvT2JqZWN0JGMgPSB0b09iamVjdCRlO1xudmFyIEluZGV4ZWRPYmplY3QkMiA9IGluZGV4ZWRPYmplY3Q7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtYXNzaWduIC0tIHNhZmVcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbnZhciBkZWZpbmVQcm9wZXJ0eSRlID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGNvbmNhdCQ2ID0gdW5jdXJyeVRoaXMkbyhbXS5jb25jYXQpO1xuXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cbnZhciBvYmplY3RBc3NpZ24gPSAhJGFzc2lnbiB8fCBmYWlscyRvKGZ1bmN0aW9uICgpIHtcbiAgLy8gc2hvdWxkIGhhdmUgY29ycmVjdCBvcmRlciBvZiBvcGVyYXRpb25zIChFZGdlIGJ1ZylcbiAgaWYgKERFU0NSSVBUT1JTJGMgJiYgJGFzc2lnbih7IGI6IDEgfSwgJGFzc2lnbihkZWZpbmVQcm9wZXJ0eSRlKHt9LCAnYScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgZGVmaW5lUHJvcGVydHkkZSh0aGlzLCAnYicsIHtcbiAgICAgICAgdmFsdWU6IDMsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pLCB7IGI6IDIgfSkpLmIgIT09IDEpIHJldHVybiB0cnVlO1xuICAvLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1ZylcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLXN5bWJvbCAtLSBzYWZlXG4gIHZhciBzeW1ib2wgPSBTeW1ib2woJ2Fzc2lnbiBkZXRlY3Rpb24nKTtcbiAgdmFyIGFscGhhYmV0ID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtzeW1ib2xdID0gNztcbiAgYWxwaGFiZXQuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGNocikgeyBCW2Nocl0gPSBjaHI7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbc3ltYm9sXSAhPT0gNyB8fCBvYmplY3RLZXlzJDIoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9PSBhbHBoYWJldDtcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICB2YXIgVCA9IHRvT2JqZWN0JGModGFyZ2V0KTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUkMy5mO1xuICB2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQxLmY7XG4gIHdoaWxlIChhcmd1bWVudHNMZW5ndGggPiBpbmRleCkge1xuICAgIHZhciBTID0gSW5kZXhlZE9iamVjdCQyKGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQkNihvYmplY3RLZXlzJDIoUyksIGdldE93blByb3BlcnR5U3ltYm9scyhTKSkgOiBvYmplY3RLZXlzJDIoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSB7XG4gICAgICBrZXkgPSBrZXlzW2orK107XG4gICAgICBpZiAoIURFU0NSSVBUT1JTJGMgfHwgY2FsbCQ5KHByb3BlcnR5SXNFbnVtZXJhYmxlLCBTLCBrZXkpKSBUW2tleV0gPSBTW2tleV07XG4gICAgfVxuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG5cbnZhciAkJE8gPSBfZXhwb3J0O1xudmFyIGFzc2lnbiQ1ID0gb2JqZWN0QXNzaWduO1xuXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtYXNzaWduIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4kJE8oeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBhcml0eTogMiwgZm9yY2VkOiBPYmplY3QuYXNzaWduICE9PSBhc3NpZ24kNSB9LCB7XG4gIGFzc2lnbjogYXNzaWduJDVcbn0pO1xuXG52YXIgcGF0aCR0ID0gcGF0aCR3O1xuXG52YXIgYXNzaWduJDQgPSBwYXRoJHQuT2JqZWN0LmFzc2lnbjtcblxudmFyIHBhcmVudCQxYiA9IGFzc2lnbiQ0O1xuXG52YXIgYXNzaWduJDMgPSBwYXJlbnQkMWI7XG5cbnZhciBhc3NpZ24kMiA9IGFzc2lnbiQzO1xuXG52YXIgX09iamVjdCRhc3NpZ24gPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoYXNzaWduJDIpO1xuXG52YXIgdW5jdXJyeVRoaXMkbiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBhcnJheVNsaWNlJDUgPSB1bmN1cnJ5VGhpcyRuKFtdLnNsaWNlKTtcblxudmFyIHVuY3VycnlUaGlzJG0gPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGFDYWxsYWJsZSQ0ID0gYUNhbGxhYmxlJDc7XG52YXIgaXNPYmplY3QkZSA9IGlzT2JqZWN0JGo7XG52YXIgaGFzT3duJGQgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGFycmF5U2xpY2UkNCA9IGFycmF5U2xpY2UkNTtcbnZhciBOQVRJVkVfQklORCA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcblxudmFyICRGdW5jdGlvbiA9IEZ1bmN0aW9uO1xudmFyIGNvbmNhdCQ1ID0gdW5jdXJyeVRoaXMkbShbXS5jb25jYXQpO1xudmFyIGpvaW4gPSB1bmN1cnJ5VGhpcyRtKFtdLmpvaW4pO1xudmFyIGZhY3RvcmllcyA9IHt9O1xuXG52YXIgY29uc3RydWN0JDQgPSBmdW5jdGlvbiAoQywgYXJnc0xlbmd0aCwgYXJncykge1xuICBpZiAoIWhhc093biRkKGZhY3RvcmllcywgYXJnc0xlbmd0aCkpIHtcbiAgICB2YXIgbGlzdCA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGFyZ3NMZW5ndGg7IGkrKykgbGlzdFtpXSA9ICdhWycgKyBpICsgJ10nO1xuICAgIGZhY3Rvcmllc1thcmdzTGVuZ3RoXSA9ICRGdW5jdGlvbignQyxhJywgJ3JldHVybiBuZXcgQygnICsgam9pbihsaXN0LCAnLCcpICsgJyknKTtcbiAgfSByZXR1cm4gZmFjdG9yaWVzW2FyZ3NMZW5ndGhdKEMsIGFyZ3MpO1xufTtcblxuLy8gYEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBkZXRlY3Rpb25cbnZhciBmdW5jdGlvbkJpbmQgPSBOQVRJVkVfQklORCA/ICRGdW5jdGlvbi5iaW5kIDogZnVuY3Rpb24gYmluZCh0aGF0IC8qICwgLi4uYXJncyAqLykge1xuICB2YXIgRiA9IGFDYWxsYWJsZSQ0KHRoaXMpO1xuICB2YXIgUHJvdG90eXBlID0gRi5wcm90b3R5cGU7XG4gIHZhciBwYXJ0QXJncyA9IGFycmF5U2xpY2UkNChhcmd1bWVudHMsIDEpO1xuICB2YXIgYm91bmRGdW5jdGlvbiA9IGZ1bmN0aW9uIGJvdW5kKC8qIGFyZ3MuLi4gKi8pIHtcbiAgICB2YXIgYXJncyA9IGNvbmNhdCQ1KHBhcnRBcmdzLCBhcnJheVNsaWNlJDQoYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBib3VuZEZ1bmN0aW9uID8gY29uc3RydWN0JDQoRiwgYXJncy5sZW5ndGgsIGFyZ3MpIDogRi5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfTtcbiAgaWYgKGlzT2JqZWN0JGUoUHJvdG90eXBlKSkgYm91bmRGdW5jdGlvbi5wcm90b3R5cGUgPSBQcm90b3R5cGU7XG4gIHJldHVybiBib3VuZEZ1bmN0aW9uO1xufTtcblxuLy8gVE9ETzogUmVtb3ZlIGZyb20gYGNvcmUtanNANGBcbnZhciAkJE4gPSBfZXhwb3J0O1xudmFyIGJpbmQkYyA9IGZ1bmN0aW9uQmluZDtcblxuLy8gYEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBkZXRlY3Rpb25cbiQkTih7IHRhcmdldDogJ0Z1bmN0aW9uJywgcHJvdG86IHRydWUsIGZvcmNlZDogRnVuY3Rpb24uYmluZCAhPT0gYmluZCRjIH0sIHtcbiAgYmluZDogYmluZCRjXG59KTtcblxudmFyIHBhdGgkcyA9IHBhdGgkdztcblxudmFyIGVudHJ5VmlydHVhbCRpID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SKSB7XG4gIHJldHVybiBwYXRoJHNbQ09OU1RSVUNUT1IgKyAnUHJvdG90eXBlJ107XG59O1xuXG52YXIgZW50cnlWaXJ0dWFsJGggPSBlbnRyeVZpcnR1YWwkaTtcblxudmFyIGJpbmQkYiA9IGVudHJ5VmlydHVhbCRoKCdGdW5jdGlvbicpLmJpbmQ7XG5cbnZhciBpc1Byb3RvdHlwZU9mJGogPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCRmID0gYmluZCRiO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUkMiA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxudmFyIGJpbmQkYSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuYmluZDtcbiAgcmV0dXJuIGl0ID09PSBGdW5jdGlvblByb3RvdHlwZSQyIHx8IChpc1Byb3RvdHlwZU9mJGooRnVuY3Rpb25Qcm90b3R5cGUkMiwgaXQpICYmIG93biA9PT0gRnVuY3Rpb25Qcm90b3R5cGUkMi5iaW5kKSA/IG1ldGhvZCRmIDogb3duO1xufTtcblxudmFyIHBhcmVudCQxYSA9IGJpbmQkYTtcblxudmFyIGJpbmQkOSA9IHBhcmVudCQxYTtcblxudmFyIGJpbmQkOCA9IGJpbmQkOTtcblxudmFyIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGJpbmQkOCk7XG5cbi8qKlxyXG4gKiBEcmF3IGEgY2lyY2xlLlxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhpcyBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIHRvLlxyXG4gKiBAcGFyYW0geCAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHkgYXhpcy5cclxuICogQHBhcmFtIHIgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGUuXHJcbiAqL1xuZnVuY3Rpb24gZHJhd0NpcmNsZShjdHgsIHgsIHksIHIpIHtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIHIsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cbi8qKlxyXG4gKiBEcmF3IGEgc3F1YXJlLlxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhpcyBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIHRvLlxyXG4gKiBAcGFyYW0geCAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHkgYXhpcy5cclxuICogQHBhcmFtIHIgLSBIYWxmIG9mIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBzcXVhcmUuXHJcbiAqL1xuZnVuY3Rpb24gZHJhd1NxdWFyZShjdHgsIHgsIHksIHIpIHtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgucmVjdCh4IC0gciwgeSAtIHIsIHIgKiAyLCByICogMik7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cbi8qKlxyXG4gKiBEcmF3IGFuIGVxdWlsYXRlcmFsIHRyaWFuZ2xlIHN0YW5kaW5nIG9uIGEgc2lkZS5cclxuICpcclxuICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoaXMgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCB0by5cclxuICogQHBhcmFtIHggLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeCBheGlzLlxyXG4gKiBAcGFyYW0geSAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB5IGF4aXMuXHJcbiAqIEBwYXJhbSByIC0gSGFsZiBvZiB0aGUgbGVuZ3RoIG9mIHRoZSBzaWRlcy5cclxuICogQHJlbWFya3NcclxuICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FcXVpbGF0ZXJhbF90cmlhbmdsZVxyXG4gKi9cbmZ1bmN0aW9uIGRyYXdUcmlhbmdsZShjdHgsIHgsIHksIHIpIHtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICAvLyB0aGUgY2hhbmdlIGluIHJhZGl1cyBhbmQgdGhlIG9mZnNldCBpcyBoZXJlIHRvIGNlbnRlciB0aGUgc2hhcGVcbiAgciAqPSAxLjE1O1xuICB5ICs9IDAuMjc1ICogcjtcbiAgdmFyIHMgPSByICogMjtcbiAgdmFyIHMyID0gcyAvIDI7XG4gIHZhciBpciA9IE1hdGguc3FydCgzKSAvIDYgKiBzOyAvLyByYWRpdXMgb2YgaW5uZXIgY2lyY2xlXG4gIHZhciBoID0gTWF0aC5zcXJ0KHMgKiBzIC0gczIgKiBzMik7IC8vIGhlaWdodFxuICBjdHgubW92ZVRvKHgsIHkgLSAoaCAtIGlyKSk7XG4gIGN0eC5saW5lVG8oeCArIHMyLCB5ICsgaXIpO1xuICBjdHgubGluZVRvKHggLSBzMiwgeSArIGlyKTtcbiAgY3R4LmxpbmVUbyh4LCB5IC0gKGggLSBpcikpO1xuICBjdHguY2xvc2VQYXRoKCk7XG59XG4vKipcclxuICogRHJhdyBhbiBlcXVpbGF0ZXJhbCB0cmlhbmdsZSBzdGFuZGluZyBvbiBhIHZlcnRleC5cclxuICpcclxuICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoaXMgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCB0by5cclxuICogQHBhcmFtIHggLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeCBheGlzLlxyXG4gKiBAcGFyYW0geSAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB5IGF4aXMuXHJcbiAqIEBwYXJhbSByIC0gSGFsZiBvZiB0aGUgbGVuZ3RoIG9mIHRoZSBzaWRlcy5cclxuICogQHJlbWFya3NcclxuICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FcXVpbGF0ZXJhbF90cmlhbmdsZVxyXG4gKi9cbmZ1bmN0aW9uIGRyYXdUcmlhbmdsZURvd24oY3R4LCB4LCB5LCByKSB7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgLy8gdGhlIGNoYW5nZSBpbiByYWRpdXMgYW5kIHRoZSBvZmZzZXQgaXMgaGVyZSB0byBjZW50ZXIgdGhlIHNoYXBlXG4gIHIgKj0gMS4xNTtcbiAgeSAtPSAwLjI3NSAqIHI7XG4gIHZhciBzID0gciAqIDI7XG4gIHZhciBzMiA9IHMgLyAyO1xuICB2YXIgaXIgPSBNYXRoLnNxcnQoMykgLyA2ICogczsgLy8gcmFkaXVzIG9mIGlubmVyIGNpcmNsZVxuICB2YXIgaCA9IE1hdGguc3FydChzICogcyAtIHMyICogczIpOyAvLyBoZWlnaHRcbiAgY3R4Lm1vdmVUbyh4LCB5ICsgKGggLSBpcikpO1xuICBjdHgubGluZVRvKHggKyBzMiwgeSAtIGlyKTtcbiAgY3R4LmxpbmVUbyh4IC0gczIsIHkgLSBpcik7XG4gIGN0eC5saW5lVG8oeCwgeSArIChoIC0gaXIpKTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuLyoqXHJcbiAqIERyYXcgYSBzdGFyLlxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhpcyBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIHRvLlxyXG4gKiBAcGFyYW0geCAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHkgYXhpcy5cclxuICogQHBhcmFtIHIgLSBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBzdGFyLlxyXG4gKi9cbmZ1bmN0aW9uIGRyYXdTdGFyKGN0eCwgeCwgeSwgcikge1xuICAvLyBodHRwOi8vd3d3Lmh0bWw1Y2FudmFzdHV0b3JpYWxzLmNvbS9sYWJzL2h0bWw1LWNhbnZhcy1zdGFyLXNwaW5uZXIvXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgLy8gdGhlIGNoYW5nZSBpbiByYWRpdXMgYW5kIHRoZSBvZmZzZXQgaXMgaGVyZSB0byBjZW50ZXIgdGhlIHNoYXBlXG4gIHIgKj0gMC44MjtcbiAgeSArPSAwLjEgKiByO1xuICBmb3IgKHZhciBuID0gMDsgbiA8IDEwOyBuKyspIHtcbiAgICB2YXIgcmFkaXVzID0gbiAlIDIgPT09IDAgPyByICogMS4zIDogciAqIDAuNTtcbiAgICBjdHgubGluZVRvKHggKyByYWRpdXMgKiBNYXRoLnNpbihuICogMiAqIE1hdGguUEkgLyAxMCksIHkgLSByYWRpdXMgKiBNYXRoLmNvcyhuICogMiAqIE1hdGguUEkgLyAxMCkpO1xuICB9XG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cbi8qKlxyXG4gKiBEcmF3IGEgZGlhbW9uZC5cclxuICpcclxuICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoaXMgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCB0by5cclxuICogQHBhcmFtIHggLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeCBheGlzLlxyXG4gKiBAcGFyYW0geSAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB5IGF4aXMuXHJcbiAqIEBwYXJhbSByIC0gSGFsZiBvZiB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgZGlhbW9uZC5cclxuICogQHJlbWFya3NcclxuICogaHR0cDovL3d3dy5odG1sNWNhbnZhc3R1dG9yaWFscy5jb20vbGFicy9odG1sNS1jYW52YXMtc3Rhci1zcGlubmVyL1xyXG4gKi9cbmZ1bmN0aW9uIGRyYXdEaWFtb25kKGN0eCwgeCwgeSwgcikge1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5saW5lVG8oeCwgeSArIHIpO1xuICBjdHgubGluZVRvKHggKyByLCB5KTtcbiAgY3R4LmxpbmVUbyh4LCB5IC0gcik7XG4gIGN0eC5saW5lVG8oeCAtIHIsIHkpO1xuICBjdHguY2xvc2VQYXRoKCk7XG59XG4vKipcclxuICogRHJhdyBhIHJlY3RhbmdsZSB3aXRoIHJvdW5kZWQgY29ybmVycy5cclxuICpcclxuICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoaXMgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCB0by5cclxuICogQHBhcmFtIHggLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeCBheGlzLlxyXG4gKiBAcGFyYW0geSAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB5IGF4aXMuXHJcbiAqIEBwYXJhbSB3IC0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUuXHJcbiAqIEBwYXJhbSBoIC0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlLlxyXG4gKiBAcGFyYW0gciAtIFRoZSByYWRpdXMgb2YgdGhlIGNvcm5lcnMuXHJcbiAqIEByZW1hcmtzXHJcbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTI1NTUxMi9ob3ctdG8tZHJhdy1hLXJvdW5kZWQtcmVjdGFuZ2xlLW9uLWh0bWwtY2FudmFzXHJcbiAqL1xuZnVuY3Rpb24gZHJhd1JvdW5kUmVjdChjdHgsIHgsIHksIHcsIGgsIHIpIHtcbiAgdmFyIHIyZCA9IE1hdGguUEkgLyAxODA7XG4gIGlmICh3IC0gMiAqIHIgPCAwKSB7XG4gICAgciA9IHcgLyAyO1xuICB9IC8vZW5zdXJlIHRoYXQgdGhlIHJhZGl1cyBpc24ndCB0b28gbGFyZ2UgZm9yIHhcbiAgaWYgKGggLSAyICogciA8IDApIHtcbiAgICByID0gaCAvIDI7XG4gIH0gLy9lbnN1cmUgdGhhdCB0aGUgcmFkaXVzIGlzbid0IHRvbyBsYXJnZSBmb3IgeVxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5tb3ZlVG8oeCArIHIsIHkpO1xuICBjdHgubGluZVRvKHggKyB3IC0gciwgeSk7XG4gIGN0eC5hcmMoeCArIHcgLSByLCB5ICsgciwgciwgcjJkICogMjcwLCByMmQgKiAzNjAsIGZhbHNlKTtcbiAgY3R4LmxpbmVUbyh4ICsgdywgeSArIGggLSByKTtcbiAgY3R4LmFyYyh4ICsgdyAtIHIsIHkgKyBoIC0gciwgciwgMCwgcjJkICogOTAsIGZhbHNlKTtcbiAgY3R4LmxpbmVUbyh4ICsgciwgeSArIGgpO1xuICBjdHguYXJjKHggKyByLCB5ICsgaCAtIHIsIHIsIHIyZCAqIDkwLCByMmQgKiAxODAsIGZhbHNlKTtcbiAgY3R4LmxpbmVUbyh4LCB5ICsgcik7XG4gIGN0eC5hcmMoeCArIHIsIHkgKyByLCByLCByMmQgKiAxODAsIHIyZCAqIDI3MCwgZmFsc2UpO1xuICBjdHguY2xvc2VQYXRoKCk7XG59XG4vKipcclxuICogRHJhdyBhbiBlbGxpcHNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhpcyBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIHRvLlxyXG4gKiBAcGFyYW0geCAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHkgYXhpcy5cclxuICogQHBhcmFtIHcgLSBUaGUgd2lkdGggb2YgdGhlIGVsbGlwc2UuXHJcbiAqIEBwYXJhbSBoIC0gVGhlIGhlaWdodCBvZiB0aGUgZWxsaXBzZS5cclxuICogQHJlbWFya3NcclxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMTcyNzk4L2hvdy10by1kcmF3LWFuLW92YWwtaW4taHRtbDUtY2FudmFzXHJcbiAqXHJcbiAqIFBvc3RmaXggJ192aXMnIGFkZGVkIHRvIGRpc2Nlcm4gaXQgZnJvbSBzdGFuZGFyZCBtZXRob2QgZWxsaXBzZSgpLlxyXG4gKi9cbmZ1bmN0aW9uIGRyYXdFbGxpcHNlKGN0eCwgeCwgeSwgdywgaCkge1xuICB2YXIga2FwcGEgPSAwLjU1MjI4NDgsXG4gICAgb3ggPSB3IC8gMiAqIGthcHBhLFxuICAgIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IGhvcml6b250YWxcbiAgICBveSA9IGggLyAyICoga2FwcGEsXG4gICAgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgdmVydGljYWxcbiAgICB4ZSA9IHggKyB3LFxuICAgIC8vIHgtZW5kXG4gICAgeWUgPSB5ICsgaCxcbiAgICAvLyB5LWVuZFxuICAgIHhtID0geCArIHcgLyAyLFxuICAgIC8vIHgtbWlkZGxlXG4gICAgeW0gPSB5ICsgaCAvIDI7IC8vIHktbWlkZGxlXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4Lm1vdmVUbyh4LCB5bSk7XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKHgsIHltIC0gb3ksIHhtIC0gb3gsIHksIHhtLCB5KTtcbiAgY3R4LmJlemllckN1cnZlVG8oeG0gKyBveCwgeSwgeGUsIHltIC0gb3ksIHhlLCB5bSk7XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKHhlLCB5bSArIG95LCB4bSArIG94LCB5ZSwgeG0sIHllKTtcbiAgY3R4LmJlemllckN1cnZlVG8oeG0gLSBveCwgeWUsIHgsIHltICsgb3ksIHgsIHltKTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuLyoqXHJcbiAqIERyYXcgYW4gaXNvbWV0cmljIGN5bGluZGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhpcyBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIHRvLlxyXG4gKiBAcGFyYW0geCAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHkgYXhpcy5cclxuICogQHBhcmFtIHcgLSBUaGUgd2lkdGggb2YgdGhlIGRhdGFiYXNlLlxyXG4gKiBAcGFyYW0gaCAtIFRoZSBoZWlnaHQgb2YgdGhlIGRhdGFiYXNlLlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIxNzI3OTgvaG93LXRvLWRyYXctYW4tb3ZhbC1pbi1odG1sNS1jYW52YXNcclxuICovXG5mdW5jdGlvbiBkcmF3RGF0YWJhc2UoY3R4LCB4LCB5LCB3LCBoKSB7XG4gIHZhciBmID0gMSAvIDM7XG4gIHZhciB3RWxsaXBzZSA9IHc7XG4gIHZhciBoRWxsaXBzZSA9IGggKiBmO1xuICB2YXIga2FwcGEgPSAwLjU1MjI4NDgsXG4gICAgb3ggPSB3RWxsaXBzZSAvIDIgKiBrYXBwYSxcbiAgICAvLyBjb250cm9sIHBvaW50IG9mZnNldCBob3Jpem9udGFsXG4gICAgb3kgPSBoRWxsaXBzZSAvIDIgKiBrYXBwYSxcbiAgICAvLyBjb250cm9sIHBvaW50IG9mZnNldCB2ZXJ0aWNhbFxuICAgIHhlID0geCArIHdFbGxpcHNlLFxuICAgIC8vIHgtZW5kXG4gICAgeWUgPSB5ICsgaEVsbGlwc2UsXG4gICAgLy8geS1lbmRcbiAgICB4bSA9IHggKyB3RWxsaXBzZSAvIDIsXG4gICAgLy8geC1taWRkbGVcbiAgICB5bSA9IHkgKyBoRWxsaXBzZSAvIDIsXG4gICAgLy8geS1taWRkbGVcbiAgICB5bWIgPSB5ICsgKGggLSBoRWxsaXBzZSAvIDIpLFxuICAgIC8vIHktbWlkbGxlLCBib3R0b20gZWxsaXBzZVxuICAgIHllYiA9IHkgKyBoOyAvLyB5LWVuZCwgYm90dG9tIGVsbGlwc2VcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgubW92ZVRvKHhlLCB5bSk7XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKHhlLCB5bSArIG95LCB4bSArIG94LCB5ZSwgeG0sIHllKTtcbiAgY3R4LmJlemllckN1cnZlVG8oeG0gLSBveCwgeWUsIHgsIHltICsgb3ksIHgsIHltKTtcbiAgY3R4LmJlemllckN1cnZlVG8oeCwgeW0gLSBveSwgeG0gLSBveCwgeSwgeG0sIHkpO1xuICBjdHguYmV6aWVyQ3VydmVUbyh4bSArIG94LCB5LCB4ZSwgeW0gLSBveSwgeGUsIHltKTtcbiAgY3R4LmxpbmVUbyh4ZSwgeW1iKTtcbiAgY3R4LmJlemllckN1cnZlVG8oeGUsIHltYiArIG95LCB4bSArIG94LCB5ZWIsIHhtLCB5ZWIpO1xuICBjdHguYmV6aWVyQ3VydmVUbyh4bSAtIG94LCB5ZWIsIHgsIHltYiArIG95LCB4LCB5bWIpO1xuICBjdHgubGluZVRvKHgsIHltKTtcbn1cbi8qKlxyXG4gKiBEcmF3IGEgZGFzaGVkIGxpbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5IC0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9uIHRoZSB5IGF4aXMuXHJcbiAqIEBwYXJhbSB4MiAtIFRoZSBlbmQgcG9zaXRpb24gb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkyIC0gVGhlIGVuZCBwb3NpdGlvbiBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gcGF0dGVybiAtIExpc3Qgb2YgbGVuZ3RocyBzdGFydGluZyB3aXRoIGxpbmUgYW5kIHRoZW4gYWx0ZXJuYXRpbmcgYmV0d2VlbiBzcGFjZSBhbmQgbGluZS5cclxuICogQGF1dGhvciBEYXZpZCBKb3JkYW5cclxuICogQHJlbWFya3NcclxuICogZGF0ZSAyMDEyLTA4LTA4XHJcbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDU3NjcyNC9kb3R0ZWQtc3Ryb2tlLWluLWNhbnZhc1xyXG4gKi9cbmZ1bmN0aW9uIGRyYXdEYXNoZWRMaW5lKGN0eCwgeCwgeSwgeDIsIHkyLCBwYXR0ZXJuKSB7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgdmFyIHBhdHRlcm5MZW5ndGggPSBwYXR0ZXJuLmxlbmd0aDtcbiAgdmFyIGR4ID0geDIgLSB4O1xuICB2YXIgZHkgPSB5MiAtIHk7XG4gIHZhciBzbG9wZSA9IGR5IC8gZHg7XG4gIHZhciBkaXN0UmVtYWluaW5nID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgdmFyIHBhdHRlcm5JbmRleCA9IDA7XG4gIHZhciBkcmF3ID0gdHJ1ZTtcbiAgdmFyIHhTdGVwID0gMDtcbiAgdmFyIGRhc2hMZW5ndGggPSArcGF0dGVyblswXTtcbiAgd2hpbGUgKGRpc3RSZW1haW5pbmcgPj0gMC4xKSB7XG4gICAgZGFzaExlbmd0aCA9ICtwYXR0ZXJuW3BhdHRlcm5JbmRleCsrICUgcGF0dGVybkxlbmd0aF07XG4gICAgaWYgKGRhc2hMZW5ndGggPiBkaXN0UmVtYWluaW5nKSB7XG4gICAgICBkYXNoTGVuZ3RoID0gZGlzdFJlbWFpbmluZztcbiAgICB9XG4gICAgeFN0ZXAgPSBNYXRoLnNxcnQoZGFzaExlbmd0aCAqIGRhc2hMZW5ndGggLyAoMSArIHNsb3BlICogc2xvcGUpKTtcbiAgICB4U3RlcCA9IGR4IDwgMCA/IC14U3RlcCA6IHhTdGVwO1xuICAgIHggKz0geFN0ZXA7XG4gICAgeSArPSBzbG9wZSAqIHhTdGVwO1xuICAgIGlmIChkcmF3ID09PSB0cnVlKSB7XG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgIH1cbiAgICBkaXN0UmVtYWluaW5nIC09IGRhc2hMZW5ndGg7XG4gICAgZHJhdyA9ICFkcmF3O1xuICB9XG59XG4vKipcclxuICogRHJhdyBhIGhleGFnb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gciAtIFRoZSByYWRpdXMgb2YgdGhlIGhleGFnb24uXHJcbiAqL1xuZnVuY3Rpb24gZHJhd0hleGFnb24oY3R4LCB4LCB5LCByKSB7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgdmFyIHNpZGVzID0gNjtcbiAgdmFyIGEgPSBNYXRoLlBJICogMiAvIHNpZGVzO1xuICBjdHgubW92ZVRvKHggKyByLCB5KTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBzaWRlczsgaSsrKSB7XG4gICAgY3R4LmxpbmVUbyh4ICsgciAqIE1hdGguY29zKGEgKiBpKSwgeSArIHIgKiBNYXRoLnNpbihhICogaSkpO1xuICB9XG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cbnZhciBzaGFwZU1hcCA9IHtcbiAgY2lyY2xlOiBkcmF3Q2lyY2xlLFxuICBkYXNoZWRMaW5lOiBkcmF3RGFzaGVkTGluZSxcbiAgZGF0YWJhc2U6IGRyYXdEYXRhYmFzZSxcbiAgZGlhbW9uZDogZHJhd0RpYW1vbmQsXG4gIGVsbGlwc2U6IGRyYXdFbGxpcHNlLFxuICBlbGxpcHNlX3ZpczogZHJhd0VsbGlwc2UsXG4gIGhleGFnb246IGRyYXdIZXhhZ29uLFxuICByb3VuZFJlY3Q6IGRyYXdSb3VuZFJlY3QsXG4gIHNxdWFyZTogZHJhd1NxdWFyZSxcbiAgc3RhcjogZHJhd1N0YXIsXG4gIHRyaWFuZ2xlOiBkcmF3VHJpYW5nbGUsXG4gIHRyaWFuZ2xlRG93bjogZHJhd1RyaWFuZ2xlRG93blxufTtcbi8qKlxyXG4gKiBSZXR1cm5zIGVpdGhlciBjdXN0b20gb3IgbmF0aXZlIGRyYXdpbmcgZnVuY3Rpb24gYmFzZSBvbiBzdXBwbGllZCBuYW1lLlxyXG4gKlxyXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbi4gRWl0aGVyIHRoZSBuYW1lIG9mIGFcclxuICogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHByb3BlcnR5IG9yIGFuIGV4cG9ydCBmcm9tIHNoYXBlcy50cyB3aXRob3V0IHRoZVxyXG4gKiBkcmF3IHByZWZpeC5cclxuICogQHJldHVybnMgVGhlIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgZm9yIHJlbmRlcmluZy4gSW4gY2FzZSBvZiBuYXRpdmVcclxuICogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIGZ1bmN0aW9uIHRoZSBBUEkgaXMgbm9ybWFsaXplZCB0b1xyXG4gKiBgKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCAuLi5vcmlnaW5hbEFyZ3MpID0+IHZvaWRgLlxyXG4gKi9cbmZ1bmN0aW9uIGdldFNoYXBlKG5hbWUpIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzaGFwZU1hcCwgbmFtZSkpIHtcbiAgICByZXR1cm4gc2hhcGVNYXBbbmFtZV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlW25hbWVdLmNhbGwoY3R4LCBhcmdzKTtcbiAgICB9O1xuICB9XG59XG5cbnZhciBjb21wb25lbnRFbWl0dGVyID0ge2V4cG9ydHM6IHt9fTtcblxuKGZ1bmN0aW9uIChtb2R1bGUpIHtcblx0LyoqXHJcblx0ICogRXhwb3NlIGBFbWl0dGVyYC5cclxuXHQgKi9cclxuXHJcblx0e1xyXG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXHJcblx0ICpcclxuXHQgKiBAYXBpIHB1YmxpY1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBFbWl0dGVyKG9iaikge1xyXG5cdCAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XHJcblx0fVxyXG5cdC8qKlxyXG5cdCAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcblx0ICogQHJldHVybiB7T2JqZWN0fVxyXG5cdCAqIEBhcGkgcHJpdmF0ZVxyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBtaXhpbihvYmopIHtcclxuXHQgIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xyXG5cdCAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XHJcblx0ICB9XHJcblx0ICByZXR1cm4gb2JqO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcblx0ICogQHJldHVybiB7RW1pdHRlcn1cclxuXHQgKiBAYXBpIHB1YmxpY1xyXG5cdCAqL1xyXG5cclxuXHRFbWl0dGVyLnByb3RvdHlwZS5vbiA9XHJcblx0RW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcblx0ICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblx0ICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXHJcblx0ICAgIC5wdXNoKGZuKTtcclxuXHQgIHJldHVybiB0aGlzO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG5cdCAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG5cdCAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcblx0ICogQGFwaSBwdWJsaWNcclxuXHQgKi9cclxuXHJcblx0RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcblx0ICBmdW5jdGlvbiBvbigpIHtcclxuXHQgICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcclxuXHQgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHQgIH1cclxuXHJcblx0ICBvbi5mbiA9IGZuO1xyXG5cdCAgdGhpcy5vbihldmVudCwgb24pO1xyXG5cdCAgcmV0dXJuIHRoaXM7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuXHQgKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcblx0ICogQHJldHVybiB7RW1pdHRlcn1cclxuXHQgKiBAYXBpIHB1YmxpY1xyXG5cdCAqL1xyXG5cclxuXHRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxyXG5cdEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cclxuXHRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxyXG5cdEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG5cdCAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuXHQgIC8vIGFsbFxyXG5cdCAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdCAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuXHQgICAgcmV0dXJuIHRoaXM7XHJcblx0ICB9XHJcblxyXG5cdCAgLy8gc3BlY2lmaWMgZXZlbnRcclxuXHQgIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG5cdCAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xyXG5cclxuXHQgIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuXHQgIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHQgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblx0ICAgIHJldHVybiB0aGlzO1xyXG5cdCAgfVxyXG5cclxuXHQgIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcblx0ICB2YXIgY2I7XHJcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuXHQgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuXHQgICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xyXG5cdCAgICAgIGJyZWFrO1xyXG5cdCAgICB9XHJcblx0ICB9XHJcblxyXG5cdCAgLy8gUmVtb3ZlIGV2ZW50IHNwZWNpZmljIGFycmF5cyBmb3IgZXZlbnQgdHlwZXMgdGhhdCBub1xyXG5cdCAgLy8gb25lIGlzIHN1YnNjcmliZWQgZm9yIHRvIGF2b2lkIG1lbW9yeSBsZWFrLlxyXG5cdCAgaWYgKGNhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcclxuXHQgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblx0ICB9XHJcblxyXG5cdCAgcmV0dXJuIHRoaXM7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuXHQgKiBAcGFyYW0ge01peGVkfSAuLi5cclxuXHQgKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG5cdCAqL1xyXG5cclxuXHRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xyXG5cdCAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuXHQgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKVxyXG5cdCAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblxyXG5cdCAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XHJcblx0ICB9XHJcblxyXG5cdCAgaWYgKGNhbGxiYWNrcykge1xyXG5cdCAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XHJcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuXHQgICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHJcblx0ICByZXR1cm4gdGhpcztcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcblx0ICogQHJldHVybiB7QXJyYXl9XHJcblx0ICogQGFwaSBwdWJsaWNcclxuXHQgKi9cclxuXHJcblx0RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG5cdCAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cdCAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cclxuXHQgKiBAYXBpIHB1YmxpY1xyXG5cdCAqL1xyXG5cclxuXHRFbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcblx0ICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcclxuXHR9OyBcbn0gKGNvbXBvbmVudEVtaXR0ZXIpKTtcblxudmFyIGNvbXBvbmVudEVtaXR0ZXJFeHBvcnRzID0gY29tcG9uZW50RW1pdHRlci5leHBvcnRzO1xudmFyIEVtaXR0ZXIgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoY29tcG9uZW50RW1pdHRlckV4cG9ydHMpO1xuXG52YXIgd2VsbEtub3duU3ltYm9sJGsgPSB3ZWxsS25vd25TeW1ib2wkbTtcblxudmFyIFRPX1NUUklOR19UQUckMyA9IHdlbGxLbm93blN5bWJvbCRrKCd0b1N0cmluZ1RhZycpO1xudmFyIHRlc3QkMiA9IHt9O1xuXG50ZXN0JDJbVE9fU1RSSU5HX1RBRyQzXSA9ICd6JztcblxudmFyIHRvU3RyaW5nVGFnU3VwcG9ydCA9IFN0cmluZyh0ZXN0JDIpID09PSAnW29iamVjdCB6XSc7XG5cbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQkMiA9IHRvU3RyaW5nVGFnU3VwcG9ydDtcbnZhciBpc0NhbGxhYmxlJGEgPSBpc0NhbGxhYmxlJGk7XG52YXIgY2xhc3NvZlJhdyA9IGNsYXNzb2ZSYXckMjtcbnZhciB3ZWxsS25vd25TeW1ib2wkaiA9IHdlbGxLbm93blN5bWJvbCRtO1xuXG52YXIgVE9fU1RSSU5HX1RBRyQyID0gd2VsbEtub3duU3ltYm9sJGooJ3RvU3RyaW5nVGFnJyk7XG52YXIgJE9iamVjdCQyID0gT2JqZWN0O1xuXG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIENPUlJFQ1RfQVJHVU1FTlRTID0gY2xhc3NvZlJhdyhmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbi8vIGdldHRpbmcgdGFnIGZyb20gRVM2KyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2BcbnZhciBjbGFzc29mJGQgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQkMiA/IGNsYXNzb2ZSYXcgOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIHRhZywgcmVzdWx0O1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSAkT2JqZWN0JDIoaXQpLCBUT19TVFJJTkdfVEFHJDIpKSA9PSAnc3RyaW5nJyA/IHRhZ1xuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQ09SUkVDVF9BUkdVTUVOVFMgPyBjbGFzc29mUmF3KE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKHJlc3VsdCA9IGNsYXNzb2ZSYXcoTykpID09PSAnT2JqZWN0JyAmJiBpc0NhbGxhYmxlJGEoTy5jYWxsZWUpID8gJ0FyZ3VtZW50cycgOiByZXN1bHQ7XG59O1xuXG52YXIgY2xhc3NvZiRjID0gY2xhc3NvZiRkO1xuXG52YXIgJFN0cmluZyQyID0gU3RyaW5nO1xuXG52YXIgdG9TdHJpbmckYSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoY2xhc3NvZiRjKGFyZ3VtZW50KSA9PT0gJ1N5bWJvbCcpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nJyk7XG4gIHJldHVybiAkU3RyaW5nJDIoYXJndW1lbnQpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJGwgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkMSA9IHRvSW50ZWdlck9ySW5maW5pdHkkNDtcbnZhciB0b1N0cmluZyQ5ID0gdG9TdHJpbmckYTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDIgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDU7XG5cbnZhciBjaGFyQXQkMyA9IHVuY3VycnlUaGlzJGwoJycuY2hhckF0KTtcbnZhciBjaGFyQ29kZUF0JDEgPSB1bmN1cnJ5VGhpcyRsKCcnLmNoYXJDb2RlQXQpO1xudmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMkbCgnJy5zbGljZSk7XG5cbnZhciBjcmVhdGVNZXRob2QkMyA9IGZ1bmN0aW9uIChDT05WRVJUX1RPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBwb3MpIHtcbiAgICB2YXIgUyA9IHRvU3RyaW5nJDkocmVxdWlyZU9iamVjdENvZXJjaWJsZSQyKCR0aGlzKSk7XG4gICAgdmFyIHBvc2l0aW9uID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQxKHBvcyk7XG4gICAgdmFyIHNpemUgPSBTLmxlbmd0aDtcbiAgICB2YXIgZmlyc3QsIHNlY29uZDtcbiAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IHNpemUpIHJldHVybiBDT05WRVJUX1RPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGZpcnN0ID0gY2hhckNvZGVBdCQxKFMsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYgfHwgcG9zaXRpb24gKyAxID09PSBzaXplXG4gICAgICB8fCAoc2Vjb25kID0gY2hhckNvZGVBdCQxKFMsIHBvc2l0aW9uICsgMSkpIDwgMHhEQzAwIHx8IHNlY29uZCA+IDB4REZGRlxuICAgICAgICA/IENPTlZFUlRfVE9fU1RSSU5HXG4gICAgICAgICAgPyBjaGFyQXQkMyhTLCBwb3NpdGlvbilcbiAgICAgICAgICA6IGZpcnN0XG4gICAgICAgIDogQ09OVkVSVF9UT19TVFJJTkdcbiAgICAgICAgICA/IHN0cmluZ1NsaWNlKFMsIHBvc2l0aW9uLCBwb3NpdGlvbiArIDIpXG4gICAgICAgICAgOiAoZmlyc3QgLSAweEQ4MDAgPDwgMTApICsgKHNlY29uZCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxudmFyIHN0cmluZ011bHRpYnl0ZSA9IHtcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuY29kZXBvaW50YXRcbiAgY29kZUF0OiBjcmVhdGVNZXRob2QkMyhmYWxzZSksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxuICBjaGFyQXQ6IGNyZWF0ZU1ldGhvZCQzKHRydWUpXG59O1xuXG52YXIgZ2xvYmFsJGUgPSBnbG9iYWwkbjtcbnZhciBpc0NhbGxhYmxlJDkgPSBpc0NhbGxhYmxlJGk7XG5cbnZhciBXZWFrTWFwJDEgPSBnbG9iYWwkZS5XZWFrTWFwO1xuXG52YXIgd2Vha01hcEJhc2ljRGV0ZWN0aW9uID0gaXNDYWxsYWJsZSQ5KFdlYWtNYXAkMSkgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KFN0cmluZyhXZWFrTWFwJDEpKTtcblxudmFyIHNoYXJlZCQ1ID0gc2hhcmVkRXhwb3J0cztcbnZhciB1aWQkMiA9IHVpZCQ0O1xuXG52YXIga2V5cyQzID0gc2hhcmVkJDUoJ2tleXMnKTtcblxudmFyIHNoYXJlZEtleSQ0ID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4ga2V5cyQzW2tleV0gfHwgKGtleXMkM1trZXldID0gdWlkJDIoa2V5KSk7XG59O1xuXG52YXIgTkFUSVZFX1dFQUtfTUFQJDEgPSB3ZWFrTWFwQmFzaWNEZXRlY3Rpb247XG52YXIgZ2xvYmFsJGQgPSBnbG9iYWwkbjtcbnZhciBpc09iamVjdCRkID0gaXNPYmplY3QkajtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNCA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2O1xudmFyIGhhc093biRjID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBzaGFyZWQkNCA9IHNoYXJlZFN0b3JlO1xudmFyIHNoYXJlZEtleSQzID0gc2hhcmVkS2V5JDQ7XG52YXIgaGlkZGVuS2V5cyQ0ID0gaGlkZGVuS2V5cyQ2O1xuXG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xudmFyIFR5cGVFcnJvciQyID0gZ2xvYmFsJGQuVHlwZUVycm9yO1xudmFyIFdlYWtNYXAgPSBnbG9iYWwkZC5XZWFrTWFwO1xudmFyIHNldCQzLCBnZXQkNiwgaGFzO1xuXG52YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaGFzKGl0KSA/IGdldCQ2KGl0KSA6IHNldCQzKGl0LCB7fSk7XG59O1xuXG52YXIgZ2V0dGVyRm9yID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBzdGF0ZTtcbiAgICBpZiAoIWlzT2JqZWN0JGQoaXQpIHx8IChzdGF0ZSA9IGdldCQ2KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciQyKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCcpO1xuICAgIH0gcmV0dXJuIHN0YXRlO1xuICB9O1xufTtcblxuaWYgKE5BVElWRV9XRUFLX01BUCQxIHx8IHNoYXJlZCQ0LnN0YXRlKSB7XG4gIHZhciBzdG9yZSQxID0gc2hhcmVkJDQuc3RhdGUgfHwgKHNoYXJlZCQ0LnN0YXRlID0gbmV3IFdlYWtNYXAoKSk7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtYXNzaWduIC0tIHByb3RvdHlwZSBtZXRob2RzIHByb3RlY3Rpb24gKi9cbiAgc3RvcmUkMS5nZXQgPSBzdG9yZSQxLmdldDtcbiAgc3RvcmUkMS5oYXMgPSBzdG9yZSQxLmhhcztcbiAgc3RvcmUkMS5zZXQgPSBzdG9yZSQxLnNldDtcbiAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWFzc2lnbiAtLSBwcm90b3R5cGUgbWV0aG9kcyBwcm90ZWN0aW9uICovXG4gIHNldCQzID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmIChzdG9yZSQxLmhhcyhpdCkpIHRocm93IG5ldyBUeXBlRXJyb3IkMihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgc3RvcmUkMS5zZXQoaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCQ2ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHN0b3JlJDEuZ2V0KGl0KSB8fCB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHN0b3JlJDEuaGFzKGl0KTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBTVEFURSA9IHNoYXJlZEtleSQzKCdzdGF0ZScpO1xuICBoaWRkZW5LZXlzJDRbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0JDMgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKGhhc093biRjKGl0LCBTVEFURSkpIHRocm93IG5ldyBUeXBlRXJyb3IkMihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDQoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQkNiA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXNPd24kYyhpdCwgU1RBVEUpID8gaXRbU1RBVEVdIDoge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXNPd24kYyhpdCwgU1RBVEUpO1xuICB9O1xufVxuXG52YXIgaW50ZXJuYWxTdGF0ZSA9IHtcbiAgc2V0OiBzZXQkMyxcbiAgZ2V0OiBnZXQkNixcbiAgaGFzOiBoYXMsXG4gIGVuZm9yY2U6IGVuZm9yY2UsXG4gIGdldHRlckZvcjogZ2V0dGVyRm9yXG59O1xuXG52YXIgREVTQ1JJUFRPUlMkYiA9IGRlc2NyaXB0b3JzO1xudmFyIGhhc093biRiID0gaGFzT3duUHJvcGVydHlfMTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlJDEgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0RGVzY3JpcHRvciA9IERFU0NSSVBUT1JTJGIgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxudmFyIEVYSVNUUyA9IGhhc093biRiKEZ1bmN0aW9uUHJvdG90eXBlJDEsICduYW1lJyk7XG4vLyBhZGRpdGlvbmFsIHByb3RlY3Rpb24gZnJvbSBtaW5pZmllZCAvIG1hbmdsZWQgLyBkcm9wcGVkIGZ1bmN0aW9uIG5hbWVzXG52YXIgUFJPUEVSID0gRVhJU1RTICYmIChmdW5jdGlvbiBzb21ldGhpbmcoKSB7IC8qIGVtcHR5ICovIH0pLm5hbWUgPT09ICdzb21ldGhpbmcnO1xudmFyIENPTkZJR1VSQUJMRSA9IEVYSVNUUyAmJiAoIURFU0NSSVBUT1JTJGIgfHwgKERFU0NSSVBUT1JTJGIgJiYgZ2V0RGVzY3JpcHRvcihGdW5jdGlvblByb3RvdHlwZSQxLCAnbmFtZScpLmNvbmZpZ3VyYWJsZSkpO1xuXG52YXIgZnVuY3Rpb25OYW1lID0ge1xuICBFWElTVFM6IEVYSVNUUyxcbiAgUFJPUEVSOiBQUk9QRVIsXG4gIENPTkZJR1VSQUJMRTogQ09ORklHVVJBQkxFXG59O1xuXG52YXIgb2JqZWN0RGVmaW5lUHJvcGVydGllcyA9IHt9O1xuXG52YXIgREVTQ1JJUFRPUlMkYSA9IGRlc2NyaXB0b3JzO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID0gdjhQcm90b3R5cGVEZWZpbmVCdWc7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMiA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIGFuT2JqZWN0JGIgPSBhbk9iamVjdCRkO1xudmFyIHRvSW5kZXhlZE9iamVjdCQ2ID0gdG9JbmRleGVkT2JqZWN0JGE7XG52YXIgb2JqZWN0S2V5cyQxID0gb2JqZWN0S2V5cyQzO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0aWVzIC0tIHNhZmVcbm9iamVjdERlZmluZVByb3BlcnRpZXMuZiA9IERFU0NSSVBUT1JTJGEgJiYgIVY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QkYihPKTtcbiAgdmFyIHByb3BzID0gdG9JbmRleGVkT2JqZWN0JDYoUHJvcGVydGllcyk7XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyQxKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgZGVmaW5lUHJvcGVydHlNb2R1bGUkMi5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIHByb3BzW2tleV0pO1xuICByZXR1cm4gTztcbn07XG5cbnZhciBnZXRCdWlsdEluJGEgPSBnZXRCdWlsdEluJGM7XG5cbnZhciBodG1sJDEgPSBnZXRCdWlsdEluJGEoJ2RvY3VtZW50JywgJ2RvY3VtZW50RWxlbWVudCcpO1xuXG4vKiBnbG9iYWwgQWN0aXZlWE9iamVjdCAtLSBvbGQgSUUsIFdTSCAqL1xudmFyIGFuT2JqZWN0JGEgPSBhbk9iamVjdCRkO1xudmFyIGRlZmluZVByb3BlcnRpZXNNb2R1bGUkMSA9IG9iamVjdERlZmluZVByb3BlcnRpZXM7XG52YXIgZW51bUJ1Z0tleXMkMSA9IGVudW1CdWdLZXlzJDM7XG52YXIgaGlkZGVuS2V5cyQzID0gaGlkZGVuS2V5cyQ2O1xudmFyIGh0bWwgPSBodG1sJDE7XG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDE7XG52YXIgc2hhcmVkS2V5JDIgPSBzaGFyZWRLZXkkNDtcblxudmFyIEdUID0gJz4nO1xudmFyIExUID0gJzwnO1xudmFyIFBST1RPVFlQRSQxID0gJ3Byb3RvdHlwZSc7XG52YXIgU0NSSVBUID0gJ3NjcmlwdCc7XG52YXIgSUVfUFJPVE8kMSA9IHNoYXJlZEtleSQyKCdJRV9QUk9UTycpO1xuXG52YXIgRW1wdHlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcblxudmFyIHNjcmlwdFRhZyA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gIHJldHVybiBMVCArIFNDUklQVCArIEdUICsgY29udGVudCArIExUICsgJy8nICsgU0NSSVBUICsgR1Q7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgQWN0aXZlWCBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVggPSBmdW5jdGlvbiAoYWN0aXZlWERvY3VtZW50KSB7XG4gIGFjdGl2ZVhEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJycpKTtcbiAgYWN0aXZlWERvY3VtZW50LmNsb3NlKCk7XG4gIHZhciB0ZW1wID0gYWN0aXZlWERvY3VtZW50LnBhcmVudFdpbmRvdy5PYmplY3Q7XG4gIGFjdGl2ZVhEb2N1bWVudCA9IG51bGw7IC8vIGF2b2lkIG1lbW9yeSBsZWFrXG4gIHJldHVybiB0ZW1wO1xufTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIE51bGxQcm90b09iamVjdFZpYUlGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gIHZhciBKUyA9ICdqYXZhJyArIFNDUklQVCArICc6JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgaHRtbC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNDc1XG4gIGlmcmFtZS5zcmMgPSBTdHJpbmcoSlMpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnZG9jdW1lbnQuRj1PYmplY3QnKSk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIHJldHVybiBpZnJhbWVEb2N1bWVudC5GO1xufTtcblxuLy8gQ2hlY2sgZm9yIGRvY3VtZW50LmRvbWFpbiBhbmQgYWN0aXZlIHggc3VwcG9ydFxuLy8gTm8gbmVlZCB0byB1c2UgYWN0aXZlIHggYXBwcm9hY2ggd2hlbiBkb2N1bWVudC5kb21haW4gaXMgbm90IHNldFxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMTUwXG4vLyB2YXJpYXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2tpdGNhbWJyaWRnZS9lczUtc2hpbS9jb21taXQvNGY3MzhhYzA2NjM0NlxuLy8gYXZvaWQgSUUgR0MgYnVnXG52YXIgYWN0aXZlWERvY3VtZW50O1xudmFyIE51bGxQcm90b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBhY3RpdmVYRG9jdW1lbnQgPSBuZXcgQWN0aXZlWE9iamVjdCgnaHRtbGZpbGUnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogaWdub3JlICovIH1cbiAgTnVsbFByb3RvT2JqZWN0ID0gdHlwZW9mIGRvY3VtZW50ICE9ICd1bmRlZmluZWQnXG4gICAgPyBkb2N1bWVudC5kb21haW4gJiYgYWN0aXZlWERvY3VtZW50XG4gICAgICA/IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KSAvLyBvbGQgSUVcbiAgICAgIDogTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lKClcbiAgICA6IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KTsgLy8gV1NIXG4gIHZhciBsZW5ndGggPSBlbnVtQnVnS2V5cyQxLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSBkZWxldGUgTnVsbFByb3RvT2JqZWN0W1BST1RPVFlQRSQxXVtlbnVtQnVnS2V5cyQxW2xlbmd0aF1dO1xuICByZXR1cm4gTnVsbFByb3RvT2JqZWN0KCk7XG59O1xuXG5oaWRkZW5LZXlzJDNbSUVfUFJPVE8kMV0gPSB0cnVlO1xuXG4vLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtY3JlYXRlIC0tIHNhZmVcbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEUkMV0gPSBhbk9iamVjdCRhKE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eUNvbnN0cnVjdG9yKCk7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEUkMV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE8kMV0gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gTnVsbFByb3RvT2JqZWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlJDEuZihyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcblxudmFyIGZhaWxzJG4gPSBmYWlscyR3O1xuXG52YXIgY29ycmVjdFByb3RvdHlwZUdldHRlciA9ICFmYWlscyRuKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICBGLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG51bGw7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0cHJvdG90eXBlb2YgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgRigpKSAhPT0gRi5wcm90b3R5cGU7XG59KTtcblxudmFyIGhhc093biRhID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc0NhbGxhYmxlJDggPSBpc0NhbGxhYmxlJGk7XG52YXIgdG9PYmplY3QkYiA9IHRvT2JqZWN0JGU7XG52YXIgc2hhcmVkS2V5JDEgPSBzaGFyZWRLZXkkNDtcbnZhciBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIkMSA9IGNvcnJlY3RQcm90b3R5cGVHZXR0ZXI7XG5cbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSQxKCdJRV9QUk9UTycpO1xudmFyICRPYmplY3QkMSA9IE9iamVjdDtcbnZhciBPYmplY3RQcm90b3R5cGUkMiA9ICRPYmplY3QkMS5wcm90b3R5cGU7XG5cbi8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2Zcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0cHJvdG90eXBlb2YgLS0gc2FmZVxudmFyIG9iamVjdEdldFByb3RvdHlwZU9mID0gQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSJDEgPyAkT2JqZWN0JDEuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xuICB2YXIgb2JqZWN0ID0gdG9PYmplY3QkYihPKTtcbiAgaWYgKGhhc093biRhKG9iamVjdCwgSUVfUFJPVE8pKSByZXR1cm4gb2JqZWN0W0lFX1BST1RPXTtcbiAgdmFyIGNvbnN0cnVjdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBpZiAoaXNDYWxsYWJsZSQ4KGNvbnN0cnVjdG9yKSAmJiBvYmplY3QgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mICRPYmplY3QkMSA/IE9iamVjdFByb3RvdHlwZSQyIDogbnVsbDtcbn07XG5cbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMyA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2O1xuXG52YXIgZGVmaW5lQnVpbHRJbiQ1ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmVudW1lcmFibGUpIHRhcmdldFtrZXldID0gdmFsdWU7XG4gIGVsc2UgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDModGFyZ2V0LCBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBmYWlscyRtID0gZmFpbHMkdztcbnZhciBpc0NhbGxhYmxlJDcgPSBpc0NhbGxhYmxlJGk7XG52YXIgaXNPYmplY3QkYyA9IGlzT2JqZWN0JGo7XG52YXIgY3JlYXRlJGEgPSBvYmplY3RDcmVhdGU7XG52YXIgZ2V0UHJvdG90eXBlT2YkOCA9IG9iamVjdEdldFByb3RvdHlwZU9mO1xudmFyIGRlZmluZUJ1aWx0SW4kNCA9IGRlZmluZUJ1aWx0SW4kNTtcbnZhciB3ZWxsS25vd25TeW1ib2wkaSA9IHdlbGxLbm93blN5bWJvbCRtO1xuXG52YXIgSVRFUkFUT1IkNiA9IHdlbGxLbm93blN5bWJvbCRpKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMkMSA9IGZhbHNlO1xuXG4vLyBgJUl0ZXJhdG9yUHJvdG90eXBlJWAgb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtb2JqZWN0XG52YXIgSXRlcmF0b3JQcm90b3R5cGUkMSwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1hcnJheS1wcm90b3R5cGUta2V5cyAtLSBzYWZlICovXG5pZiAoW10ua2V5cykge1xuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xuICAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDEgPSB0cnVlO1xuICBlbHNlIHtcbiAgICBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZiQ4KGdldFByb3RvdHlwZU9mJDgoYXJyYXlJdGVyYXRvcikpO1xuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlJDEgPSBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cbn1cblxudmFyIE5FV19JVEVSQVRPUl9QUk9UT1RZUEUgPSAhaXNPYmplY3QkYyhJdGVyYXRvclByb3RvdHlwZSQxKSB8fCBmYWlscyRtKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgLy8gRkY0NC0gbGVnYWN5IGl0ZXJhdG9ycyBjYXNlXG4gIHJldHVybiBJdGVyYXRvclByb3RvdHlwZSQxW0lURVJBVE9SJDZdLmNhbGwodGVzdCkgIT09IHRlc3Q7XG59KTtcblxuaWYgKE5FV19JVEVSQVRPUl9QUk9UT1RZUEUpIEl0ZXJhdG9yUHJvdG90eXBlJDEgPSB7fTtcbmVsc2UgSXRlcmF0b3JQcm90b3R5cGUkMSA9IGNyZWF0ZSRhKEl0ZXJhdG9yUHJvdG90eXBlJDEpO1xuXG4vLyBgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1AQGl0ZXJhdG9yXG5pZiAoIWlzQ2FsbGFibGUkNyhJdGVyYXRvclByb3RvdHlwZSQxW0lURVJBVE9SJDZdKSkge1xuICBkZWZpbmVCdWlsdEluJDQoSXRlcmF0b3JQcm90b3R5cGUkMSwgSVRFUkFUT1IkNiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcbn1cblxudmFyIGl0ZXJhdG9yc0NvcmUgPSB7XG4gIEl0ZXJhdG9yUHJvdG90eXBlOiBJdGVyYXRvclByb3RvdHlwZSQxLFxuICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDFcbn07XG5cbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQkMSA9IHRvU3RyaW5nVGFnU3VwcG9ydDtcbnZhciBjbGFzc29mJGIgPSBjbGFzc29mJGQ7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xudmFyIG9iamVjdFRvU3RyaW5nID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUJDEgPyB7fS50b1N0cmluZyA6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YkYih0aGlzKSArICddJztcbn07XG5cbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSB0b1N0cmluZ1RhZ1N1cHBvcnQ7XG52YXIgZGVmaW5lUHJvcGVydHkkZCA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDIgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNjtcbnZhciBoYXNPd24kOSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgdG9TdHJpbmckOCA9IG9iamVjdFRvU3RyaW5nO1xudmFyIHdlbGxLbm93blN5bWJvbCRoID0gd2VsbEtub3duU3ltYm9sJG07XG5cbnZhciBUT19TVFJJTkdfVEFHJDEgPSB3ZWxsS25vd25TeW1ib2wkaCgndG9TdHJpbmdUYWcnKTtcblxudmFyIHNldFRvU3RyaW5nVGFnJDYgPSBmdW5jdGlvbiAoaXQsIFRBRywgU1RBVElDLCBTRVRfTUVUSE9EKSB7XG4gIGlmIChpdCkge1xuICAgIHZhciB0YXJnZXQgPSBTVEFUSUMgPyBpdCA6IGl0LnByb3RvdHlwZTtcbiAgICBpZiAoIWhhc093biQ5KHRhcmdldCwgVE9fU1RSSU5HX1RBRyQxKSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkkZCh0YXJnZXQsIFRPX1NUUklOR19UQUckMSwgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBUQUcgfSk7XG4gICAgfVxuICAgIGlmIChTRVRfTUVUSE9EICYmICFUT19TVFJJTkdfVEFHX1NVUFBPUlQpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyKHRhcmdldCwgJ3RvU3RyaW5nJywgdG9TdHJpbmckOCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgaXRlcmF0b3JzID0ge307XG5cbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IGl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgY3JlYXRlJDkgPSBvYmplY3RDcmVhdGU7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDIgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcbnZhciBzZXRUb1N0cmluZ1RhZyQ1ID0gc2V0VG9TdHJpbmdUYWckNjtcbnZhciBJdGVyYXRvcnMkNSA9IGl0ZXJhdG9ycztcblxudmFyIHJldHVyblRoaXMkMSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbnZhciBpdGVyYXRvckNyZWF0ZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQsIEVOVU1FUkFCTEVfTkVYVCkge1xuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgSXRlcmF0b3JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUkOShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMigrIUVOVU1FUkFCTEVfTkVYVCwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnJDUoSXRlcmF0b3JDb25zdHJ1Y3RvciwgVE9fU1RSSU5HX1RBRywgZmFsc2UsIHRydWUpO1xuICBJdGVyYXRvcnMkNVtUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXMkMTtcbiAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkayA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgYUNhbGxhYmxlJDMgPSBhQ2FsbGFibGUkNztcblxudmFyIGZ1bmN0aW9uVW5jdXJyeVRoaXNBY2Nlc3NvciA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgbWV0aG9kKSB7XG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxuICAgIHJldHVybiB1bmN1cnJ5VGhpcyRrKGFDYWxsYWJsZSQzKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBrZXkpW21ldGhvZF0pKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxufTtcblxudmFyIGlzQ2FsbGFibGUkNiA9IGlzQ2FsbGFibGUkaTtcblxudmFyICRTdHJpbmckMSA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yJGEgPSBUeXBlRXJyb3I7XG5cbnZhciBhUG9zc2libGVQcm90b3R5cGUkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50ID09ICdvYmplY3QnIHx8IGlzQ2FsbGFibGUkNihhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IkYShcIkNhbid0IHNldCBcIiArICRTdHJpbmckMShhcmd1bWVudCkgKyAnIGFzIGEgcHJvdG90eXBlJyk7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAtLSBzYWZlICovXG52YXIgdW5jdXJyeVRoaXNBY2Nlc3NvciA9IGZ1bmN0aW9uVW5jdXJyeVRoaXNBY2Nlc3NvcjtcbnZhciBhbk9iamVjdCQ5ID0gYW5PYmplY3QkZDtcbnZhciBhUG9zc2libGVQcm90b3R5cGUgPSBhUG9zc2libGVQcm90b3R5cGUkMTtcblxuLy8gYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5zZXRwcm90b3R5cGVvZlxuLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LXNldHByb3RvdHlwZW9mIC0tIHNhZmVcbnZhciBvYmplY3RTZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyBmdW5jdGlvbiAoKSB7XG4gIHZhciBDT1JSRUNUX1NFVFRFUiA9IGZhbHNlO1xuICB2YXIgdGVzdCA9IHt9O1xuICB2YXIgc2V0dGVyO1xuICB0cnkge1xuICAgIHNldHRlciA9IHVuY3VycnlUaGlzQWNjZXNzb3IoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycsICdzZXQnKTtcbiAgICBzZXR0ZXIodGVzdCwgW10pO1xuICAgIENPUlJFQ1RfU0VUVEVSID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5O1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgIGFuT2JqZWN0JDkoTyk7XG4gICAgYVBvc3NpYmxlUHJvdG90eXBlKHByb3RvKTtcbiAgICBpZiAoQ09SUkVDVF9TRVRURVIpIHNldHRlcihPLCBwcm90byk7XG4gICAgZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgIHJldHVybiBPO1xuICB9O1xufSgpIDogdW5kZWZpbmVkKTtcblxudmFyICQkTSA9IF9leHBvcnQ7XG52YXIgY2FsbCQ4ID0gZnVuY3Rpb25DYWxsO1xudmFyIEZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uTmFtZTtcbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gaXRlcmF0b3JDcmVhdGVDb25zdHJ1Y3RvcjtcbnZhciBnZXRQcm90b3R5cGVPZiQ3ID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0VG9TdHJpbmdUYWckNCA9IHNldFRvU3RyaW5nVGFnJDY7XG52YXIgZGVmaW5lQnVpbHRJbiQzID0gZGVmaW5lQnVpbHRJbiQ1O1xudmFyIHdlbGxLbm93blN5bWJvbCRnID0gd2VsbEtub3duU3ltYm9sJG07XG52YXIgSXRlcmF0b3JzJDQgPSBpdGVyYXRvcnM7XG52YXIgSXRlcmF0b3JzQ29yZSA9IGl0ZXJhdG9yc0NvcmU7XG5cbnZhciBQUk9QRVJfRlVOQ1RJT05fTkFNRSA9IEZ1bmN0aW9uTmFtZS5QUk9QRVI7XG5GdW5jdGlvbk5hbWUuQ09ORklHVVJBQkxFO1xuSXRlcmF0b3JzQ29yZS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gSXRlcmF0b3JzQ29yZS5CVUdHWV9TQUZBUklfSVRFUkFUT1JTO1xudmFyIElURVJBVE9SJDUgPSB3ZWxsS25vd25TeW1ib2wkZygnaXRlcmF0b3InKTtcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xudmFyIEVOVFJJRVMgPSAnZW50cmllcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxudmFyIGl0ZXJhdG9yRGVmaW5lID0gZnVuY3Rpb24gKEl0ZXJhYmxlLCBOQU1FLCBJdGVyYXRvckNvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuXG4gIHZhciBnZXRJdGVyYXRpb25NZXRob2QgPSBmdW5jdGlvbiAoS0lORCkge1xuICAgIGlmIChLSU5EID09PSBERUZBVUxUICYmIGRlZmF1bHRJdGVyYXRvcikgcmV0dXJuIGRlZmF1bHRJdGVyYXRvcjtcbiAgICBpZiAoIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgS0lORCAmJiBLSU5EIGluIEl0ZXJhYmxlUHJvdG90eXBlKSByZXR1cm4gSXRlcmFibGVQcm90b3R5cGVbS0lORF07XG5cbiAgICBzd2l0Y2ggKEtJTkQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIEVOVFJJRVM6IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMpOyB9O1xuICB9O1xuXG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gZmFsc2U7XG4gIHZhciBJdGVyYWJsZVByb3RvdHlwZSA9IEl0ZXJhYmxlLnByb3RvdHlwZTtcbiAgdmFyIG5hdGl2ZUl0ZXJhdG9yID0gSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1IkNV1cbiAgICB8fCBJdGVyYWJsZVByb3RvdHlwZVsnQEBpdGVyYXRvciddXG4gICAgfHwgREVGQVVMVCAmJiBJdGVyYWJsZVByb3RvdHlwZVtERUZBVUxUXTtcbiAgdmFyIGRlZmF1bHRJdGVyYXRvciA9ICFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIG5hdGl2ZUl0ZXJhdG9yIHx8IGdldEl0ZXJhdGlvbk1ldGhvZChERUZBVUxUKTtcbiAgdmFyIGFueU5hdGl2ZUl0ZXJhdG9yID0gTkFNRSA9PT0gJ0FycmF5JyA/IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXMgfHwgbmF0aXZlSXRlcmF0b3IgOiBuYXRpdmVJdGVyYXRvcjtcbiAgdmFyIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgbWV0aG9kcywgS0VZO1xuXG4gIC8vIGZpeCBuYXRpdmVcbiAgaWYgKGFueU5hdGl2ZUl0ZXJhdG9yKSB7XG4gICAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YkNyhhbnlOYXRpdmVJdGVyYXRvci5jYWxsKG5ldyBJdGVyYWJsZSgpKSk7XG4gICAgaWYgKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWckNChDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHRydWUsIHRydWUpO1xuICAgICAgSXRlcmF0b3JzJDRbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpeCBBcnJheS5wcm90b3R5cGUueyB2YWx1ZXMsIEBAaXRlcmF0b3IgfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKFBST1BFUl9GVU5DVElPTl9OQU1FICYmIERFRkFVTFQgPT09IFZBTFVFUyAmJiBuYXRpdmVJdGVyYXRvciAmJiBuYXRpdmVJdGVyYXRvci5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICB7XG4gICAgICBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSB0cnVlO1xuICAgICAgZGVmYXVsdEl0ZXJhdG9yID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gY2FsbCQ4KG5hdGl2ZUl0ZXJhdG9yLCB0aGlzKTsgfTtcbiAgICB9XG4gIH1cblxuICAvLyBleHBvcnQgYWRkaXRpb25hbCBtZXRob2RzXG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogZ2V0SXRlcmF0aW9uTWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyBkZWZhdWx0SXRlcmF0b3IgOiBnZXRJdGVyYXRpb25NZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiBnZXRJdGVyYXRpb25NZXRob2QoRU5UUklFUylcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoS0VZIGluIG1ldGhvZHMpIHtcbiAgICAgIGlmIChCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB8fCAhKEtFWSBpbiBJdGVyYWJsZVByb3RvdHlwZSkpIHtcbiAgICAgICAgZGVmaW5lQnVpbHRJbiQzKEl0ZXJhYmxlUHJvdG90eXBlLCBLRVksIG1ldGhvZHNbS0VZXSk7XG4gICAgICB9XG4gICAgfSBlbHNlICQkTSh7IHRhcmdldDogTkFNRSwgcHJvdG86IHRydWUsIGZvcmNlZDogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfSwgbWV0aG9kcyk7XG4gIH1cblxuICAvLyBkZWZpbmUgaXRlcmF0b3JcbiAgaWYgKChGT1JDRUQpICYmIEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SJDVdICE9PSBkZWZhdWx0SXRlcmF0b3IpIHtcbiAgICBkZWZpbmVCdWlsdEluJDMoSXRlcmFibGVQcm90b3R5cGUsIElURVJBVE9SJDUsIGRlZmF1bHRJdGVyYXRvciwgeyBuYW1lOiBERUZBVUxUIH0pO1xuICB9XG4gIEl0ZXJhdG9ycyQ0W05BTUVdID0gZGVmYXVsdEl0ZXJhdG9yO1xuXG4gIHJldHVybiBtZXRob2RzO1xufTtcblxuLy8gYENyZWF0ZUl0ZXJSZXN1bHRPYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGVpdGVycmVzdWx0b2JqZWN0XG52YXIgY3JlYXRlSXRlclJlc3VsdE9iamVjdCQzID0gZnVuY3Rpb24gKHZhbHVlLCBkb25lKSB7XG4gIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogZG9uZSB9O1xufTtcblxudmFyIGNoYXJBdCQyID0gc3RyaW5nTXVsdGlieXRlLmNoYXJBdDtcbnZhciB0b1N0cmluZyQ3ID0gdG9TdHJpbmckYTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDUgPSBpbnRlcm5hbFN0YXRlO1xudmFyIGRlZmluZUl0ZXJhdG9yJDIgPSBpdGVyYXRvckRlZmluZTtcbnZhciBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0JDIgPSBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0JDM7XG5cbnZhciBTVFJJTkdfSVRFUkFUT1IgPSAnU3RyaW5nIEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlJDUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDUuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUkMiA9IEludGVybmFsU3RhdGVNb2R1bGUkNS5nZXR0ZXJGb3IoU1RSSU5HX0lURVJBVE9SKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLUBAaXRlcmF0b3JcbmRlZmluZUl0ZXJhdG9yJDIoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHNldEludGVybmFsU3RhdGUkNSh0aGlzLCB7XG4gICAgdHlwZTogU1RSSU5HX0lURVJBVE9SLFxuICAgIHN0cmluZzogdG9TdHJpbmckNyhpdGVyYXRlZCksXG4gICAgaW5kZXg6IDBcbiAgfSk7XG4vLyBgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXN0cmluZ2l0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG59LCBmdW5jdGlvbiBuZXh0KCkge1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlJDIodGhpcyk7XG4gIHZhciBzdHJpbmcgPSBzdGF0ZS5zdHJpbmc7XG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4O1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBzdHJpbmcubGVuZ3RoKSByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdCQyKHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIHBvaW50ID0gY2hhckF0JDIoc3RyaW5nLCBpbmRleCk7XG4gIHN0YXRlLmluZGV4ICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QkMihwb2ludCwgZmFsc2UpO1xufSk7XG5cbnZhciBjYWxsJDcgPSBmdW5jdGlvbkNhbGw7XG52YXIgYW5PYmplY3QkOCA9IGFuT2JqZWN0JGQ7XG52YXIgZ2V0TWV0aG9kJDEgPSBnZXRNZXRob2QkMztcblxudmFyIGl0ZXJhdG9yQ2xvc2UkMiA9IGZ1bmN0aW9uIChpdGVyYXRvciwga2luZCwgdmFsdWUpIHtcbiAgdmFyIGlubmVyUmVzdWx0LCBpbm5lckVycm9yO1xuICBhbk9iamVjdCQ4KGl0ZXJhdG9yKTtcbiAgdHJ5IHtcbiAgICBpbm5lclJlc3VsdCA9IGdldE1ldGhvZCQxKGl0ZXJhdG9yLCAncmV0dXJuJyk7XG4gICAgaWYgKCFpbm5lclJlc3VsdCkge1xuICAgICAgaWYgKGtpbmQgPT09ICd0aHJvdycpIHRocm93IHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpbm5lclJlc3VsdCA9IGNhbGwkNyhpbm5lclJlc3VsdCwgaXRlcmF0b3IpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlubmVyRXJyb3IgPSB0cnVlO1xuICAgIGlubmVyUmVzdWx0ID0gZXJyb3I7XG4gIH1cbiAgaWYgKGtpbmQgPT09ICd0aHJvdycpIHRocm93IHZhbHVlO1xuICBpZiAoaW5uZXJFcnJvcikgdGhyb3cgaW5uZXJSZXN1bHQ7XG4gIGFuT2JqZWN0JDgoaW5uZXJSZXN1bHQpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgYW5PYmplY3QkNyA9IGFuT2JqZWN0JGQ7XG52YXIgaXRlcmF0b3JDbG9zZSQxID0gaXRlcmF0b3JDbG9zZSQyO1xuXG4vLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyQxID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIEVOVFJJRVMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gRU5UUklFUyA/IGZuKGFuT2JqZWN0JDcodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaXRlcmF0b3JDbG9zZSQxKGl0ZXJhdG9yLCAndGhyb3cnLCBlcnJvcik7XG4gIH1cbn07XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkZiA9IHdlbGxLbm93blN5bWJvbCRtO1xudmFyIEl0ZXJhdG9ycyQzID0gaXRlcmF0b3JzO1xuXG52YXIgSVRFUkFUT1IkNCA9IHdlbGxLbm93blN5bWJvbCRmKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG90eXBlJGcgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QkMiA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzJDMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG90eXBlJGdbSVRFUkFUT1IkNF0gPT09IGl0KTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRqID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBpc0NhbGxhYmxlJDUgPSBpc0NhbGxhYmxlJGk7XG52YXIgc3RvcmUgPSBzaGFyZWRTdG9yZTtcblxudmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyRqKEZ1bmN0aW9uLnRvU3RyaW5nKTtcblxuLy8gdGhpcyBoZWxwZXIgYnJva2VuIGluIGBjb3JlLWpzQDMuNC4xLTMuNC40YCwgc28gd2UgY2FuJ3QgdXNlIGBzaGFyZWRgIGhlbHBlclxuaWYgKCFpc0NhbGxhYmxlJDUoc3RvcmUuaW5zcGVjdFNvdXJjZSkpIHtcbiAgc3RvcmUuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nKGl0KTtcbiAgfTtcbn1cblxudmFyIGluc3BlY3RTb3VyY2UkMSA9IHN0b3JlLmluc3BlY3RTb3VyY2U7XG5cbnZhciB1bmN1cnJ5VGhpcyRpID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmYWlscyRsID0gZmFpbHMkdztcbnZhciBpc0NhbGxhYmxlJDQgPSBpc0NhbGxhYmxlJGk7XG52YXIgY2xhc3NvZiRhID0gY2xhc3NvZiRkO1xudmFyIGdldEJ1aWx0SW4kOSA9IGdldEJ1aWx0SW4kYztcbnZhciBpbnNwZWN0U291cmNlID0gaW5zcGVjdFNvdXJjZSQxO1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBlbXB0eSA9IFtdO1xudmFyIGNvbnN0cnVjdCQzID0gZ2V0QnVpbHRJbiQ5KCdSZWZsZWN0JywgJ2NvbnN0cnVjdCcpO1xudmFyIGNvbnN0cnVjdG9yUmVnRXhwID0gL15cXHMqKD86Y2xhc3N8ZnVuY3Rpb24pXFxiLztcbnZhciBleGVjJDIgPSB1bmN1cnJ5VGhpcyRpKGNvbnN0cnVjdG9yUmVnRXhwLmV4ZWMpO1xudmFyIElOQ09SUkVDVF9UT19TVFJJTkcgPSAhY29uc3RydWN0b3JSZWdFeHAudGVzdChub29wKTtcblxudmFyIGlzQ29uc3RydWN0b3JNb2Rlcm4gPSBmdW5jdGlvbiBpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG4gIGlmICghaXNDYWxsYWJsZSQ0KGFyZ3VtZW50KSkgcmV0dXJuIGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0cnVjdCQzKG5vb3AsIGVtcHR5LCBhcmd1bWVudCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgaXNDb25zdHJ1Y3RvckxlZ2FjeSA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlJDQoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAoY2xhc3NvZiRhKGFyZ3VtZW50KSkge1xuICAgIGNhc2UgJ0FzeW5jRnVuY3Rpb24nOlxuICAgIGNhc2UgJ0dlbmVyYXRvckZ1bmN0aW9uJzpcbiAgICBjYXNlICdBc3luY0dlbmVyYXRvckZ1bmN0aW9uJzogcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gd2UgY2FuJ3QgY2hlY2sgLnByb3RvdHlwZSBzaW5jZSBjb25zdHJ1Y3RvcnMgcHJvZHVjZWQgYnkgLmJpbmQgaGF2ZW4ndCBpdFxuICAgIC8vIGBGdW5jdGlvbiN0b1N0cmluZ2AgdGhyb3dzIG9uIHNvbWUgYnVpbHQtaXQgZnVuY3Rpb24gaW4gc29tZSBsZWdhY3kgZW5naW5lc1xuICAgIC8vIChmb3IgZXhhbXBsZSwgYERPTVF1YWRgIGFuZCBzaW1pbGFyIGluIEZGNDEtKVxuICAgIHJldHVybiBJTkNPUlJFQ1RfVE9fU1RSSU5HIHx8ICEhZXhlYyQyKGNvbnN0cnVjdG9yUmVnRXhwLCBpbnNwZWN0U291cmNlKGFyZ3VtZW50KSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbmlzQ29uc3RydWN0b3JMZWdhY3kuc2hhbSA9IHRydWU7XG5cbi8vIGBJc0NvbnN0cnVjdG9yYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjb25zdHJ1Y3RvclxudmFyIGlzQ29uc3RydWN0b3IkNCA9ICFjb25zdHJ1Y3QkMyB8fCBmYWlscyRsKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxlZDtcbiAgcmV0dXJuIGlzQ29uc3RydWN0b3JNb2Rlcm4oaXNDb25zdHJ1Y3Rvck1vZGVybi5jYWxsKVxuICAgIHx8ICFpc0NvbnN0cnVjdG9yTW9kZXJuKE9iamVjdClcbiAgICB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihmdW5jdGlvbiAoKSB7IGNhbGxlZCA9IHRydWU7IH0pXG4gICAgfHwgY2FsbGVkO1xufSkgPyBpc0NvbnN0cnVjdG9yTGVnYWN5IDogaXNDb25zdHJ1Y3Rvck1vZGVybjtcblxudmFyIHRvUHJvcGVydHlLZXkkMSA9IHRvUHJvcGVydHlLZXkkNDtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcblxudmFyIGNyZWF0ZVByb3BlcnR5JDYgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBwcm9wZXJ0eUtleSA9IHRvUHJvcGVydHlLZXkkMShrZXkpO1xuICBpZiAocHJvcGVydHlLZXkgaW4gb2JqZWN0KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxLmYob2JqZWN0LCBwcm9wZXJ0eUtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDEoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbcHJvcGVydHlLZXldID0gdmFsdWU7XG59O1xuXG52YXIgY2xhc3NvZiQ5ID0gY2xhc3NvZiRkO1xudmFyIGdldE1ldGhvZCA9IGdldE1ldGhvZCQzO1xudmFyIGlzTnVsbE9yVW5kZWZpbmVkJDMgPSBpc051bGxPclVuZGVmaW5lZCQ2O1xudmFyIEl0ZXJhdG9ycyQyID0gaXRlcmF0b3JzO1xudmFyIHdlbGxLbm93blN5bWJvbCRlID0gd2VsbEtub3duU3ltYm9sJG07XG5cbnZhciBJVEVSQVRPUiQzID0gd2VsbEtub3duU3ltYm9sJGUoJ2l0ZXJhdG9yJyk7XG5cbnZhciBnZXRJdGVyYXRvck1ldGhvZCQ5ID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNOdWxsT3JVbmRlZmluZWQkMyhpdCkpIHJldHVybiBnZXRNZXRob2QoaXQsIElURVJBVE9SJDMpXG4gICAgfHwgZ2V0TWV0aG9kKGl0LCAnQEBpdGVyYXRvcicpXG4gICAgfHwgSXRlcmF0b3JzJDJbY2xhc3NvZiQ5KGl0KV07XG59O1xuXG52YXIgY2FsbCQ2ID0gZnVuY3Rpb25DYWxsO1xudmFyIGFDYWxsYWJsZSQyID0gYUNhbGxhYmxlJDc7XG52YXIgYW5PYmplY3QkNiA9IGFuT2JqZWN0JGQ7XG52YXIgdHJ5VG9TdHJpbmckNCA9IHRyeVRvU3RyaW5nJDY7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkOCA9IGdldEl0ZXJhdG9yTWV0aG9kJDk7XG5cbnZhciAkVHlwZUVycm9yJDkgPSBUeXBlRXJyb3I7XG5cbnZhciBnZXRJdGVyYXRvciQyID0gZnVuY3Rpb24gKGFyZ3VtZW50LCB1c2luZ0l0ZXJhdG9yKSB7XG4gIHZhciBpdGVyYXRvck1ldGhvZCA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZ2V0SXRlcmF0b3JNZXRob2QkOChhcmd1bWVudCkgOiB1c2luZ0l0ZXJhdG9yO1xuICBpZiAoYUNhbGxhYmxlJDIoaXRlcmF0b3JNZXRob2QpKSByZXR1cm4gYW5PYmplY3QkNihjYWxsJDYoaXRlcmF0b3JNZXRob2QsIGFyZ3VtZW50KSk7XG4gIHRocm93IG5ldyAkVHlwZUVycm9yJDkodHJ5VG9TdHJpbmckNChhcmd1bWVudCkgKyAnIGlzIG5vdCBpdGVyYWJsZScpO1xufTtcblxudmFyIGJpbmQkNyA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgY2FsbCQ1ID0gZnVuY3Rpb25DYWxsO1xudmFyIHRvT2JqZWN0JGEgPSB0b09iamVjdCRlO1xudmFyIGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcgPSBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nJDE7XG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDEgPSBpc0FycmF5SXRlcmF0b3JNZXRob2QkMjtcbnZhciBpc0NvbnN0cnVjdG9yJDMgPSBpc0NvbnN0cnVjdG9yJDQ7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkYSA9IGxlbmd0aE9mQXJyYXlMaWtlJGM7XG52YXIgY3JlYXRlUHJvcGVydHkkNSA9IGNyZWF0ZVByb3BlcnR5JDY7XG52YXIgZ2V0SXRlcmF0b3IkMSA9IGdldEl0ZXJhdG9yJDI7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkNyA9IGdldEl0ZXJhdG9yTWV0aG9kJDk7XG5cbnZhciAkQXJyYXkkMyA9IEFycmF5O1xuXG4vLyBgQXJyYXkuZnJvbWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LmZyb21cbnZhciBhcnJheUZyb20gPSBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZSAvKiAsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkICovKSB7XG4gIHZhciBPID0gdG9PYmplY3QkYShhcnJheUxpa2UpO1xuICB2YXIgSVNfQ09OU1RSVUNUT1IgPSBpc0NvbnN0cnVjdG9yJDModGhpcyk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgbWFwZm4gPSBhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gIGlmIChtYXBwaW5nKSBtYXBmbiA9IGJpbmQkNyhtYXBmbiwgYXJndW1lbnRzTGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gIHZhciBpdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kJDcoTyk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3IsIG5leHQsIHZhbHVlO1xuICAvLyBpZiB0aGUgdGFyZ2V0IGlzIG5vdCBpdGVyYWJsZSBvciBpdCdzIGFuIGFycmF5IHdpdGggdGhlIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2UgYSBzaW1wbGUgY2FzZVxuICBpZiAoaXRlcmF0b3JNZXRob2QgJiYgISh0aGlzID09PSAkQXJyYXkkMyAmJiBpc0FycmF5SXRlcmF0b3JNZXRob2QkMShpdGVyYXRvck1ldGhvZCkpKSB7XG4gICAgaXRlcmF0b3IgPSBnZXRJdGVyYXRvciQxKE8sIGl0ZXJhdG9yTWV0aG9kKTtcbiAgICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcbiAgICByZXN1bHQgPSBJU19DT05TVFJVQ1RPUiA/IG5ldyB0aGlzKCkgOiBbXTtcbiAgICBmb3IgKDshKHN0ZXAgPSBjYWxsJDUobmV4dCwgaXRlcmF0b3IpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICB2YWx1ZSA9IG1hcHBpbmcgPyBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlO1xuICAgICAgY3JlYXRlUHJvcGVydHkkNShyZXN1bHQsIGluZGV4LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJGEoTyk7XG4gICAgcmVzdWx0ID0gSVNfQ09OU1RSVUNUT1IgPyBuZXcgdGhpcyhsZW5ndGgpIDogJEFycmF5JDMobGVuZ3RoKTtcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgdmFsdWUgPSBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdO1xuICAgICAgY3JlYXRlUHJvcGVydHkkNShyZXN1bHQsIGluZGV4LCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkZCA9IHdlbGxLbm93blN5bWJvbCRtO1xuXG52YXIgSVRFUkFUT1IkMiA9IHdlbGxLbm93blN5bWJvbCRkKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgY2FsbGVkID0gMDtcbiAgdmFyIGl0ZXJhdG9yV2l0aFJldHVybiA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4geyBkb25lOiAhIWNhbGxlZCsrIH07XG4gICAgfSxcbiAgICAncmV0dXJuJzogZnVuY3Rpb24gKCkge1xuICAgICAgU0FGRV9DTE9TSU5HID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIGl0ZXJhdG9yV2l0aFJldHVybltJVEVSQVRPUiQyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWFycmF5LWZyb20sIG5vLXRocm93LWxpdGVyYWwgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgQXJyYXkuZnJvbShpdGVyYXRvcldpdGhSZXR1cm4sIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbnZhciBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24kMSA9IGZ1bmN0aW9uIChleGVjLCBTS0lQX0NMT1NJTkcpIHtcbiAgdHJ5IHtcbiAgICBpZiAoIVNLSVBfQ0xPU0lORyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IHJldHVybiBmYWxzZTsgfSAvLyB3b3JrYXJvdW5kIG9mIG9sZCBXZWJLaXQgKyBgZXZhbGAgYnVnXG4gIHZhciBJVEVSQVRJT05fU1VQUE9SVCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICBvYmplY3RbSVRFUkFUT1IkMl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogSVRFUkFUSU9OX1NVUFBPUlQgPSB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBleGVjKG9iamVjdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIElURVJBVElPTl9TVVBQT1JUO1xufTtcblxudmFyICQkTCA9IF9leHBvcnQ7XG52YXIgZnJvbSQ2ID0gYXJyYXlGcm9tO1xudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiQxO1xuXG52YXIgSU5DT1JSRUNUX0lURVJBVElPTiA9ICFjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1mcm9tIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIEFycmF5LmZyb20oaXRlcmFibGUpO1xufSk7XG5cbi8vIGBBcnJheS5mcm9tYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkuZnJvbVxuJCRMKHsgdGFyZ2V0OiAnQXJyYXknLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IElOQ09SUkVDVF9JVEVSQVRJT04gfSwge1xuICBmcm9tOiBmcm9tJDZcbn0pO1xuXG52YXIgcGF0aCRyID0gcGF0aCR3O1xuXG52YXIgZnJvbSQ1ID0gcGF0aCRyLkFycmF5LmZyb207XG5cbnZhciBwYXJlbnQkMTkgPSBmcm9tJDU7XG5cbnZhciBmcm9tJDQgPSBwYXJlbnQkMTk7XG5cbnZhciBmcm9tJDMgPSBmcm9tJDQ7XG5cbnZhciBfQXJyYXkkZnJvbSQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGZyb20kMyk7XG5cbnZhciB0b0luZGV4ZWRPYmplY3QkNSA9IHRvSW5kZXhlZE9iamVjdCRhO1xudmFyIEl0ZXJhdG9ycyQxID0gaXRlcmF0b3JzO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkNCA9IGludGVybmFsU3RhdGU7XG5vYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIGRlZmluZUl0ZXJhdG9yJDEgPSBpdGVyYXRvckRlZmluZTtcbnZhciBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0JDEgPSBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0JDM7XG5cbnZhciBBUlJBWV9JVEVSQVRPUiA9ICdBcnJheSBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQ0ID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQ0LnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlJDEgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDQuZ2V0dGVyRm9yKEFSUkFZX0lURVJBVE9SKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5lbnRyaWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmVudHJpZXNcbi8vIGBBcnJheS5wcm90b3R5cGUua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5rZXlzXG4vLyBgQXJyYXkucHJvdG90eXBlLnZhbHVlc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS52YWx1ZXNcbi8vIGBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEBpdGVyYXRvclxuLy8gYENyZWF0ZUFycmF5SXRlcmF0b3JgIGludGVybmFsIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGVhcnJheWl0ZXJhdG9yXG5kZWZpbmVJdGVyYXRvciQxKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSQ0KHRoaXMsIHtcbiAgICB0eXBlOiBBUlJBWV9JVEVSQVRPUixcbiAgICB0YXJnZXQ6IHRvSW5kZXhlZE9iamVjdCQ1KGl0ZXJhdGVkKSwgLy8gdGFyZ2V0XG4gICAgaW5kZXg6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gICAga2luZDoga2luZCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gIH0pO1xuLy8gYCVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWFycmF5aXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMpO1xuICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0O1xuICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4Kys7XG4gIGlmICghdGFyZ2V0IHx8IGluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICBzdGF0ZS50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QkMSh1bmRlZmluZWQsIHRydWUpO1xuICB9XG4gIHN3aXRjaCAoa2luZCkge1xuICAgIGNhc2UgJ2tleXMnOiByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdCQxKGluZGV4LCBmYWxzZSk7XG4gICAgY2FzZSAndmFsdWVzJzogcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QkMSh0YXJnZXRbaW5kZXhdLCBmYWxzZSk7XG4gIH0gcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QkMShbaW5kZXgsIHRhcmdldFtpbmRleF1dLCBmYWxzZSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGV1bm1hcHBlZGFyZ3VtZW50c29iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGVtYXBwZWRhcmd1bWVudHNvYmplY3Rcbkl0ZXJhdG9ycyQxLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycyQxLkFycmF5O1xuXG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkNiA9IGdldEl0ZXJhdG9yTWV0aG9kJDk7XG5cbnZhciBnZXRJdGVyYXRvck1ldGhvZF8xID0gZ2V0SXRlcmF0b3JNZXRob2QkNjtcblxuLy8gaXRlcmFibGUgRE9NIGNvbGxlY3Rpb25zXG4vLyBmbGFnIC0gYGl0ZXJhYmxlYCBpbnRlcmZhY2UgLSAnZW50cmllcycsICdrZXlzJywgJ3ZhbHVlcycsICdmb3JFYWNoJyBtZXRob2RzXG52YXIgZG9tSXRlcmFibGVzID0ge1xuICBDU1NSdWxlTGlzdDogMCxcbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogMCxcbiAgQ1NTVmFsdWVMaXN0OiAwLFxuICBDbGllbnRSZWN0TGlzdDogMCxcbiAgRE9NUmVjdExpc3Q6IDAsXG4gIERPTVN0cmluZ0xpc3Q6IDAsXG4gIERPTVRva2VuTGlzdDogMSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IDAsXG4gIEZpbGVMaXN0OiAwLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogMCxcbiAgSFRNTENvbGxlY3Rpb246IDAsXG4gIEhUTUxGb3JtRWxlbWVudDogMCxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IDAsXG4gIE1lZGlhTGlzdDogMCxcbiAgTWltZVR5cGVBcnJheTogMCxcbiAgTmFtZWROb2RlTWFwOiAwLFxuICBOb2RlTGlzdDogMSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogMCxcbiAgUGx1Z2luOiAwLFxuICBQbHVnaW5BcnJheTogMCxcbiAgU1ZHTGVuZ3RoTGlzdDogMCxcbiAgU1ZHTnVtYmVyTGlzdDogMCxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IDAsXG4gIFNWR1BvaW50TGlzdDogMCxcbiAgU1ZHU3RyaW5nTGlzdDogMCxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogMCxcbiAgU291cmNlQnVmZmVyTGlzdDogMCxcbiAgU3R5bGVTaGVldExpc3Q6IDAsXG4gIFRleHRUcmFja0N1ZUxpc3Q6IDAsXG4gIFRleHRUcmFja0xpc3Q6IDAsXG4gIFRvdWNoTGlzdDogMFxufTtcblxudmFyIERPTUl0ZXJhYmxlcyQyID0gZG9tSXRlcmFibGVzO1xudmFyIGdsb2JhbCRjID0gZ2xvYmFsJG47XG52YXIgY2xhc3NvZiQ4ID0gY2xhc3NvZiRkO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQxID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDY7XG52YXIgSXRlcmF0b3JzID0gaXRlcmF0b3JzO1xudmFyIHdlbGxLbm93blN5bWJvbCRjID0gd2VsbEtub3duU3ltYm9sJG07XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sJGMoJ3RvU3RyaW5nVGFnJyk7XG5cbmZvciAodmFyIENPTExFQ1RJT05fTkFNRSBpbiBET01JdGVyYWJsZXMkMikge1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbCRjW0NPTExFQ1RJT05fTkFNRV07XG4gIHZhciBDb2xsZWN0aW9uUHJvdG90eXBlID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGUgJiYgY2xhc3NvZiQ4KENvbGxlY3Rpb25Qcm90b3R5cGUpICE9PSBUT19TVFJJTkdfVEFHKSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEoQ29sbGVjdGlvblByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgQ09MTEVDVElPTl9OQU1FKTtcbiAgfVxuICBJdGVyYXRvcnNbQ09MTEVDVElPTl9OQU1FXSA9IEl0ZXJhdG9ycy5BcnJheTtcbn1cblxudmFyIHBhcmVudCQxOCA9IGdldEl0ZXJhdG9yTWV0aG9kXzE7XG5cblxudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDUgPSBwYXJlbnQkMTg7XG5cbnZhciBwYXJlbnQkMTcgPSBnZXRJdGVyYXRvck1ldGhvZCQ1O1xuXG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkNCA9IHBhcmVudCQxNztcblxudmFyIHBhcmVudCQxNiA9IGdldEl0ZXJhdG9yTWV0aG9kJDQ7XG5cbnZhciBnZXRJdGVyYXRvck1ldGhvZCQzID0gcGFyZW50JDE2O1xuXG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkMiA9IGdldEl0ZXJhdG9yTWV0aG9kJDM7XG5cbnZhciBfZ2V0SXRlcmF0b3JNZXRob2QkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhnZXRJdGVyYXRvck1ldGhvZCQyKTtcblxudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDEgPSBnZXRJdGVyYXRvck1ldGhvZCQyO1xuXG52YXIgX2dldEl0ZXJhdG9yTWV0aG9kID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGdldEl0ZXJhdG9yTWV0aG9kJDEpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG52YXIgZGVmaW5lUHJvcGVydHkkYyA9IHtleHBvcnRzOiB7fX07XG5cbnZhciAkJEsgPSBfZXhwb3J0O1xudmFyIERFU0NSSVBUT1JTJDkgPSBkZXNjcmlwdG9ycztcbnZhciBkZWZpbmVQcm9wZXJ0eSRiID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG4kJEsoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAhPT0gZGVmaW5lUHJvcGVydHkkYiwgc2hhbTogIURFU0NSSVBUT1JTJDkgfSwge1xuICBkZWZpbmVQcm9wZXJ0eTogZGVmaW5lUHJvcGVydHkkYlxufSk7XG5cbnZhciBwYXRoJHEgPSBwYXRoJHc7XG5cbnZhciBPYmplY3QkNSA9IHBhdGgkcS5PYmplY3Q7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSRhID0gZGVmaW5lUHJvcGVydHkkYy5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYykge1xuICByZXR1cm4gT2JqZWN0JDUuZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyk7XG59O1xuXG5pZiAoT2JqZWN0JDUuZGVmaW5lUHJvcGVydHkuc2hhbSkgZGVmaW5lUHJvcGVydHkkYS5zaGFtID0gdHJ1ZTtcblxudmFyIGRlZmluZVByb3BlcnR5RXhwb3J0cyA9IGRlZmluZVByb3BlcnR5JGMuZXhwb3J0cztcblxudmFyIHBhcmVudCQxNSA9IGRlZmluZVByb3BlcnR5RXhwb3J0cztcblxudmFyIGRlZmluZVByb3BlcnR5JDkgPSBwYXJlbnQkMTU7XG5cbnZhciBwYXJlbnQkMTQgPSBkZWZpbmVQcm9wZXJ0eSQ5O1xuXG52YXIgZGVmaW5lUHJvcGVydHkkOCA9IHBhcmVudCQxNDtcblxudmFyIHBhcmVudCQxMyA9IGRlZmluZVByb3BlcnR5JDg7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSQ3ID0gcGFyZW50JDEzO1xuXG52YXIgZGVmaW5lUHJvcGVydHkkNiA9IGRlZmluZVByb3BlcnR5JDc7XG5cbnZhciBfT2JqZWN0JGRlZmluZVByb3BlcnR5JDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZGVmaW5lUHJvcGVydHkkNik7XG5cbnZhciBjbGFzc29mJDcgPSBjbGFzc29mUmF3JDI7XG5cbi8vIGBJc0FycmF5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNhcnJheVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWFycmF5LWlzYXJyYXkgLS0gc2FmZVxudmFyIGlzQXJyYXkkZSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmd1bWVudCkge1xuICByZXR1cm4gY2xhc3NvZiQ3KGFyZ3VtZW50KSA9PT0gJ0FycmF5Jztcbn07XG5cbnZhciAkVHlwZUVycm9yJDggPSBUeXBlRXJyb3I7XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDB4MUZGRkZGRkZGRkZGRkY7IC8vIDIgKiogNTMgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcblxudmFyIGRvZXNOb3RFeGNlZWRTYWZlSW50ZWdlciQzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA+IE1BWF9TQUZFX0lOVEVHRVIpIHRocm93ICRUeXBlRXJyb3IkOCgnTWF4aW11bSBhbGxvd2VkIGluZGV4IGV4Y2VlZGVkJyk7XG4gIHJldHVybiBpdDtcbn07XG5cbnZhciBpc0FycmF5JGQgPSBpc0FycmF5JGU7XG52YXIgaXNDb25zdHJ1Y3RvciQyID0gaXNDb25zdHJ1Y3RvciQ0O1xudmFyIGlzT2JqZWN0JGIgPSBpc09iamVjdCRqO1xudmFyIHdlbGxLbm93blN5bWJvbCRiID0gd2VsbEtub3duU3ltYm9sJG07XG5cbnZhciBTUEVDSUVTJDMgPSB3ZWxsS25vd25TeW1ib2wkYignc3BlY2llcycpO1xudmFyICRBcnJheSQyID0gQXJyYXk7XG5cbi8vIGEgcGFydCBvZiBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG52YXIgYXJyYXlTcGVjaWVzQ29uc3RydWN0b3IkMSA9IGZ1bmN0aW9uIChvcmlnaW5hbEFycmF5KSB7XG4gIHZhciBDO1xuICBpZiAoaXNBcnJheSRkKG9yaWdpbmFsQXJyYXkpKSB7XG4gICAgQyA9IG9yaWdpbmFsQXJyYXkuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZiAoaXNDb25zdHJ1Y3RvciQyKEMpICYmIChDID09PSAkQXJyYXkkMiB8fCBpc0FycmF5JGQoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcbiAgICBlbHNlIGlmIChpc09iamVjdCRiKEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTJDNdO1xuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBDID09PSB1bmRlZmluZWQgPyAkQXJyYXkkMiA6IEM7XG59O1xuXG52YXIgYXJyYXlTcGVjaWVzQ29uc3RydWN0b3IgPSBhcnJheVNwZWNpZXNDb25zdHJ1Y3RvciQxO1xuXG4vLyBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlJDMgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgKGFycmF5U3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsQXJyYXkpKShsZW5ndGggPT09IDAgPyAwIDogbGVuZ3RoKTtcbn07XG5cbnZhciBmYWlscyRrID0gZmFpbHMkdztcbnZhciB3ZWxsS25vd25TeW1ib2wkYSA9IHdlbGxLbm93blN5bWJvbCRtO1xudmFyIFY4X1ZFUlNJT04kMSA9IGVuZ2luZVY4VmVyc2lvbjtcblxudmFyIFNQRUNJRVMkMiA9IHdlbGxLbm93blN5bWJvbCRhKCdzcGVjaWVzJyk7XG5cbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDUgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHRoaXMgZmVhdHVyZSBkZXRlY3Rpb24gaW4gVjggc2luY2UgaXQgY2F1c2VzXG4gIC8vIGRlb3B0aW1pemF0aW9uIGFuZCBzZXJpb3VzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzdcbiAgcmV0dXJuIFY4X1ZFUlNJT04kMSA+PSA1MSB8fCAhZmFpbHMkayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gYXJyYXkuY29uc3RydWN0b3IgPSB7fTtcbiAgICBjb25zdHJ1Y3RvcltTUEVDSUVTJDJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHsgZm9vOiAxIH07XG4gICAgfTtcbiAgICByZXR1cm4gYXJyYXlbTUVUSE9EX05BTUVdKEJvb2xlYW4pLmZvbyAhPT0gMTtcbiAgfSk7XG59O1xuXG52YXIgJCRKID0gX2V4cG9ydDtcbnZhciBmYWlscyRqID0gZmFpbHMkdztcbnZhciBpc0FycmF5JGMgPSBpc0FycmF5JGU7XG52YXIgaXNPYmplY3QkYSA9IGlzT2JqZWN0JGo7XG52YXIgdG9PYmplY3QkOSA9IHRvT2JqZWN0JGU7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkOSA9IGxlbmd0aE9mQXJyYXlMaWtlJGM7XG52YXIgZG9lc05vdEV4Y2VlZFNhZmVJbnRlZ2VyJDIgPSBkb2VzTm90RXhjZWVkU2FmZUludGVnZXIkMztcbnZhciBjcmVhdGVQcm9wZXJ0eSQ0ID0gY3JlYXRlUHJvcGVydHkkNjtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUkMiA9IGFycmF5U3BlY2llc0NyZWF0ZSQzO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkNCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkNTtcbnZhciB3ZWxsS25vd25TeW1ib2wkOSA9IHdlbGxLbm93blN5bWJvbCRtO1xudmFyIFY4X1ZFUlNJT04gPSBlbmdpbmVWOFZlcnNpb247XG5cbnZhciBJU19DT05DQVRfU1BSRUFEQUJMRSA9IHdlbGxLbm93blN5bWJvbCQ5KCdpc0NvbmNhdFNwcmVhZGFibGUnKTtcblxuLy8gV2UgY2FuJ3QgdXNlIHRoaXMgZmVhdHVyZSBkZXRlY3Rpb24gaW4gVjggc2luY2UgaXQgY2F1c2VzXG4vLyBkZW9wdGltaXphdGlvbiBhbmQgc2VyaW91cyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY3OVxudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFX1NVUFBPUlQgPSBWOF9WRVJTSU9OID49IDUxIHx8ICFmYWlscyRqKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFycmF5ID0gW107XG4gIGFycmF5W0lTX0NPTkNBVF9TUFJFQURBQkxFXSA9IGZhbHNlO1xuICByZXR1cm4gYXJyYXkuY29uY2F0KClbMF0gIT09IGFycmF5O1xufSk7XG5cbnZhciBpc0NvbmNhdFNwcmVhZGFibGUgPSBmdW5jdGlvbiAoTykge1xuICBpZiAoIWlzT2JqZWN0JGEoTykpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNwcmVhZGFibGUgPSBPW0lTX0NPTkNBVF9TUFJFQURBQkxFXTtcbiAgcmV0dXJuIHNwcmVhZGFibGUgIT09IHVuZGVmaW5lZCA/ICEhc3ByZWFkYWJsZSA6IGlzQXJyYXkkYyhPKTtcbn07XG5cbnZhciBGT1JDRUQkYSA9ICFJU19DT05DQVRfU1BSRUFEQUJMRV9TVVBQT1JUIHx8ICFhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDQoJ2NvbmNhdCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmNvbmNhdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5jb25jYXRcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBpc0NvbmNhdFNwcmVhZGFibGUgYW5kIEBAc3BlY2llc1xuJCRKKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgYXJpdHk6IDEsIGZvcmNlZDogRk9SQ0VEJGEgfSwge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICBjb25jYXQ6IGZ1bmN0aW9uIGNvbmNhdChhcmcpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0JDkodGhpcyk7XG4gICAgdmFyIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUkMihPLCAwKTtcbiAgICB2YXIgbiA9IDA7XG4gICAgdmFyIGksIGssIGxlbmd0aCwgbGVuLCBFO1xuICAgIGZvciAoaSA9IC0xLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIEUgPSBpID09PSAtMSA/IE8gOiBhcmd1bWVudHNbaV07XG4gICAgICBpZiAoaXNDb25jYXRTcHJlYWRhYmxlKEUpKSB7XG4gICAgICAgIGxlbiA9IGxlbmd0aE9mQXJyYXlMaWtlJDkoRSk7XG4gICAgICAgIGRvZXNOb3RFeGNlZWRTYWZlSW50ZWdlciQyKG4gKyBsZW4pO1xuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbGVuOyBrKyssIG4rKykgaWYgKGsgaW4gRSkgY3JlYXRlUHJvcGVydHkkNChBLCBuLCBFW2tdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvZXNOb3RFeGNlZWRTYWZlSW50ZWdlciQyKG4gKyAxKTtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkkNChBLCBuKyssIEUpO1xuICAgICAgfVxuICAgIH1cbiAgICBBLmxlbmd0aCA9IG47XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcyA9IHt9O1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gb2JqZWN0S2V5c0ludGVybmFsO1xudmFyIGVudW1CdWdLZXlzID0gZW51bUJ1Z0tleXMkMztcblxudmFyIGhpZGRlbktleXMkMiA9IGVudW1CdWdLZXlzLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eW5hbWVzIC0tIHNhZmVcbm9iamVjdEdldE93blByb3BlcnR5TmFtZXMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGhpZGRlbktleXMkMik7XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsID0ge307XG5cbnZhciB0b0Fic29sdXRlSW5kZXgkMyA9IHRvQWJzb2x1dGVJbmRleCQ1O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDggPSBsZW5ndGhPZkFycmF5TGlrZSRjO1xudmFyIGNyZWF0ZVByb3BlcnR5JDMgPSBjcmVhdGVQcm9wZXJ0eSQ2O1xuXG52YXIgJEFycmF5JDEgPSBBcnJheTtcbnZhciBtYXgkMiA9IE1hdGgubWF4O1xuXG52YXIgYXJyYXlTbGljZVNpbXBsZSA9IGZ1bmN0aW9uIChPLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQ4KE8pO1xuICB2YXIgayA9IHRvQWJzb2x1dGVJbmRleCQzKHN0YXJ0LCBsZW5ndGgpO1xuICB2YXIgZmluID0gdG9BYnNvbHV0ZUluZGV4JDMoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQsIGxlbmd0aCk7XG4gIHZhciByZXN1bHQgPSAkQXJyYXkkMShtYXgkMihmaW4gLSBrLCAwKSk7XG4gIHZhciBuID0gMDtcbiAgZm9yICg7IGsgPCBmaW47IGsrKywgbisrKSBjcmVhdGVQcm9wZXJ0eSQzKHJlc3VsdCwgbiwgT1trXSk7XG4gIHJlc3VsdC5sZW5ndGggPSBuO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZSAqL1xudmFyIGNsYXNzb2YkNiA9IGNsYXNzb2ZSYXckMjtcbnZhciB0b0luZGV4ZWRPYmplY3QkNCA9IHRvSW5kZXhlZE9iamVjdCRhO1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzJDEgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzLmY7XG52YXIgYXJyYXlTbGljZSQzID0gYXJyYXlTbGljZVNpbXBsZTtcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uIChpdCkge1xuICB0cnkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlOYW1lcyQxKGl0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gYXJyYXlTbGljZSQzKHdpbmRvd05hbWVzKTtcbiAgfVxufTtcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xub2JqZWN0R2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiBjbGFzc29mJDYoaXQpID09PSAnV2luZG93J1xuICAgID8gZ2V0V2luZG93TmFtZXMoaXQpXG4gICAgOiAkZ2V0T3duUHJvcGVydHlOYW1lcyQxKHRvSW5kZXhlZE9iamVjdCQ0KGl0KSk7XG59O1xuXG52YXIgZGVmaW5lUHJvcGVydHkkNSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xuXG52YXIgZGVmaW5lQnVpbHRJbkFjY2Vzc29yJDMgPSBmdW5jdGlvbiAodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eSQ1LmYodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKTtcbn07XG5cbnZhciB3ZWxsS25vd25TeW1ib2xXcmFwcGVkID0ge307XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkOCA9IHdlbGxLbm93blN5bWJvbCRtO1xuXG53ZWxsS25vd25TeW1ib2xXcmFwcGVkLmYgPSB3ZWxsS25vd25TeW1ib2wkODtcblxudmFyIHBhdGgkcCA9IHBhdGgkdztcbnZhciBoYXNPd24kOCA9IGhhc093blByb3BlcnR5XzE7XG52YXIgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSQxID0gd2VsbEtub3duU3ltYm9sV3JhcHBlZDtcbnZhciBkZWZpbmVQcm9wZXJ0eSQ0ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcblxudmFyIHdlbGxLbm93blN5bWJvbERlZmluZSA9IGZ1bmN0aW9uIChOQU1FKSB7XG4gIHZhciBTeW1ib2wgPSBwYXRoJHAuU3ltYm9sIHx8IChwYXRoJHAuU3ltYm9sID0ge30pO1xuICBpZiAoIWhhc093biQ4KFN5bWJvbCwgTkFNRSkpIGRlZmluZVByb3BlcnR5JDQoU3ltYm9sLCBOQU1FLCB7XG4gICAgdmFsdWU6IHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUkMS5mKE5BTUUpXG4gIH0pO1xufTtcblxudmFyIGNhbGwkNCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBnZXRCdWlsdEluJDggPSBnZXRCdWlsdEluJGM7XG52YXIgd2VsbEtub3duU3ltYm9sJDcgPSB3ZWxsS25vd25TeW1ib2wkbTtcbnZhciBkZWZpbmVCdWlsdEluJDIgPSBkZWZpbmVCdWlsdEluJDU7XG5cbnZhciBzeW1ib2xEZWZpbmVUb1ByaW1pdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIFN5bWJvbCA9IGdldEJ1aWx0SW4kOCgnU3ltYm9sJyk7XG4gIHZhciBTeW1ib2xQcm90b3R5cGUgPSBTeW1ib2wgJiYgU3ltYm9sLnByb3RvdHlwZTtcbiAgdmFyIHZhbHVlT2YgPSBTeW1ib2xQcm90b3R5cGUgJiYgU3ltYm9sUHJvdG90eXBlLnZhbHVlT2Y7XG4gIHZhciBUT19QUklNSVRJVkUgPSB3ZWxsS25vd25TeW1ib2wkNygndG9QcmltaXRpdmUnKTtcblxuICBpZiAoU3ltYm9sUHJvdG90eXBlICYmICFTeW1ib2xQcm90b3R5cGVbVE9fUFJJTUlUSVZFXSkge1xuICAgIC8vIGBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUtQEB0b3ByaW1pdGl2ZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgLmxlbmd0aFxuICAgIGRlZmluZUJ1aWx0SW4kMihTeW1ib2xQcm90b3R5cGUsIFRPX1BSSU1JVElWRSwgZnVuY3Rpb24gKGhpbnQpIHtcbiAgICAgIHJldHVybiBjYWxsJDQodmFsdWVPZiwgdGhpcyk7XG4gICAgfSwgeyBhcml0eTogMSB9KTtcbiAgfVxufTtcblxudmFyIGJpbmQkNiA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgdW5jdXJyeVRoaXMkaCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgSW5kZXhlZE9iamVjdCQxID0gaW5kZXhlZE9iamVjdDtcbnZhciB0b09iamVjdCQ4ID0gdG9PYmplY3QkZTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQ3ID0gbGVuZ3RoT2ZBcnJheUxpa2UkYztcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUkMSA9IGFycmF5U3BlY2llc0NyZWF0ZSQzO1xuXG52YXIgcHVzaCRhID0gdW5jdXJyeVRoaXMkaChbXS5wdXNoKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGZvckVhY2gsIG1hcCwgZmlsdGVyLCBzb21lLCBldmVyeSwgZmluZCwgZmluZEluZGV4LCBmaWx0ZXJSZWplY3QgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCQyID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgdmFyIElTX01BUCA9IFRZUEUgPT09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09PSAyO1xuICB2YXIgSVNfU09NRSA9IFRZUEUgPT09IDM7XG4gIHZhciBJU19FVkVSWSA9IFRZUEUgPT09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PT0gNjtcbiAgdmFyIElTX0ZJTFRFUl9SRUpFQ1QgPSBUWVBFID09PSA3O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09PSA1IHx8IElTX0ZJTkRfSU5ERVg7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQsIHNwZWNpZmljQ3JlYXRlKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCQ4KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IEluZGV4ZWRPYmplY3QkMShPKTtcbiAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQkNihjYWxsYmFja2ZuLCB0aGF0KTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkNyhzZWxmKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjcmVhdGUgPSBzcGVjaWZpY0NyZWF0ZSB8fCBhcnJheVNwZWNpZXNDcmVhdGUkMTtcbiAgICB2YXIgdGFyZ2V0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSIHx8IElTX0ZJTFRFUl9SRUpFQ1QgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWx1ZSwgcmVzdWx0O1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgdmFsdWUgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlc3VsdCA9IGJvdW5kRnVuY3Rpb24odmFsdWUsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHRhcmdldFtpbmRleF0gPSByZXN1bHQ7IC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXN1bHQpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsdWU7ICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiBwdXNoJGEodGFyZ2V0LCB2YWx1ZSk7ICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICBjYXNlIDQ6IHJldHVybiBmYWxzZTsgICAgICAgICAgICAgLy8gZXZlcnlcbiAgICAgICAgICBjYXNlIDc6IHB1c2gkYSh0YXJnZXQsIHZhbHVlKTsgICAgICAvLyBmaWx0ZXJSZWplY3RcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogdGFyZ2V0O1xuICB9O1xufTtcblxudmFyIGFycmF5SXRlcmF0aW9uID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG4gIGZvckVhY2g6IGNyZWF0ZU1ldGhvZCQyKDApLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuICBtYXA6IGNyZWF0ZU1ldGhvZCQyKDEpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbHRlclxuICBmaWx0ZXI6IGNyZWF0ZU1ldGhvZCQyKDIpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLnNvbWVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb21lXG4gIHNvbWU6IGNyZWF0ZU1ldGhvZCQyKDMpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmV2ZXJ5YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZXZlcnlcbiAgZXZlcnk6IGNyZWF0ZU1ldGhvZCQyKDQpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kXG4gIGZpbmQ6IGNyZWF0ZU1ldGhvZCQyKDUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRJbmRleFxuICBmaW5kSW5kZXg6IGNyZWF0ZU1ldGhvZCQyKDYpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlclJlamVjdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFycmF5LWZpbHRlcmluZ1xuICBmaWx0ZXJSZWplY3Q6IGNyZWF0ZU1ldGhvZCQyKDcpXG59O1xuXG52YXIgJCRJID0gX2V4cG9ydDtcbnZhciBnbG9iYWwkYiA9IGdsb2JhbCRuO1xudmFyIGNhbGwkMyA9IGZ1bmN0aW9uQ2FsbDtcbnZhciB1bmN1cnJ5VGhpcyRnID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBERVNDUklQVE9SUyQ4ID0gZGVzY3JpcHRvcnM7XG52YXIgTkFUSVZFX1NZTUJPTCQzID0gc3ltYm9sQ29uc3RydWN0b3JEZXRlY3Rpb247XG52YXIgZmFpbHMkaSA9IGZhaWxzJHc7XG52YXIgaGFzT3duJDcgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGlzUHJvdG90eXBlT2YkaSA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgYW5PYmplY3QkNSA9IGFuT2JqZWN0JGQ7XG52YXIgdG9JbmRleGVkT2JqZWN0JDMgPSB0b0luZGV4ZWRPYmplY3QkYTtcbnZhciB0b1Byb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleSQ0O1xudmFyICR0b1N0cmluZyA9IHRvU3RyaW5nJGE7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG52YXIgbmF0aXZlT2JqZWN0Q3JlYXRlID0gb2JqZWN0Q3JlYXRlO1xudmFyIG9iamVjdEtleXMgPSBvYmplY3RLZXlzJDM7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSQyID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWw7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDIgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlJDIgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlID0gb2JqZWN0RGVmaW5lUHJvcGVydGllcztcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIGRlZmluZUJ1aWx0SW4kMSA9IGRlZmluZUJ1aWx0SW4kNTtcbnZhciBkZWZpbmVCdWlsdEluQWNjZXNzb3IkMiA9IGRlZmluZUJ1aWx0SW5BY2Nlc3NvciQzO1xudmFyIHNoYXJlZCQzID0gc2hhcmVkRXhwb3J0cztcbnZhciBzaGFyZWRLZXkgPSBzaGFyZWRLZXkkNDtcbnZhciBoaWRkZW5LZXlzJDEgPSBoaWRkZW5LZXlzJDY7XG52YXIgdWlkJDEgPSB1aWQkNDtcbnZhciB3ZWxsS25vd25TeW1ib2wkNiA9IHdlbGxLbm93blN5bWJvbCRtO1xudmFyIHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUgPSB3ZWxsS25vd25TeW1ib2xXcmFwcGVkO1xudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRsID0gd2VsbEtub3duU3ltYm9sRGVmaW5lO1xudmFyIGRlZmluZVN5bWJvbFRvUHJpbWl0aXZlJDEgPSBzeW1ib2xEZWZpbmVUb1ByaW1pdGl2ZTtcbnZhciBzZXRUb1N0cmluZ1RhZyQzID0gc2V0VG9TdHJpbmdUYWckNjtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDMgPSBpbnRlcm5hbFN0YXRlO1xudmFyICRmb3JFYWNoJDEgPSBhcnJheUl0ZXJhdGlvbi5mb3JFYWNoO1xuXG52YXIgSElEREVOID0gc2hhcmVkS2V5KCdoaWRkZW4nKTtcbnZhciBTWU1CT0wgPSAnU3ltYm9sJztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyIHNldEludGVybmFsU3RhdGUkMyA9IEludGVybmFsU3RhdGVNb2R1bGUkMy5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUkMy5nZXR0ZXJGb3IoU1lNQk9MKTtcblxudmFyIE9iamVjdFByb3RvdHlwZSQxID0gT2JqZWN0W1BST1RPVFlQRV07XG52YXIgJFN5bWJvbCA9IGdsb2JhbCRiLlN5bWJvbDtcbnZhciBTeW1ib2xQcm90b3R5cGUgPSAkU3ltYm9sICYmICRTeW1ib2xbUFJPVE9UWVBFXTtcbnZhciBSYW5nZUVycm9yJDEgPSBnbG9iYWwkYi5SYW5nZUVycm9yO1xudmFyIFR5cGVFcnJvciQxID0gZ2xvYmFsJGIuVHlwZUVycm9yO1xudmFyIFFPYmplY3QgPSBnbG9iYWwkYi5RT2JqZWN0O1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlJDIuZjtcbnZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyA9IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mO1xudmFyIG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlID0gcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZjtcbnZhciBwdXNoJDkgPSB1bmN1cnJ5VGhpcyRnKFtdLnB1c2gpO1xuXG52YXIgQWxsU3ltYm9scyA9IHNoYXJlZCQzKCdzeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG90eXBlU3ltYm9scyA9IHNoYXJlZCQzKCdvcC1zeW1ib2xzJyk7XG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlJDEgPSBzaGFyZWQkMygnd2tzJyk7XG5cbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIFVTRV9TRVRURVIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBmYWxsYmFja0RlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgdmFyIE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMShPYmplY3RQcm90b3R5cGUkMSwgUCk7XG4gIGlmIChPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yKSBkZWxldGUgT2JqZWN0UHJvdG90eXBlJDFbUF07XG4gIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICBpZiAoT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvciAmJiBPICE9PSBPYmplY3RQcm90b3R5cGUkMSkge1xuICAgIG5hdGl2ZURlZmluZVByb3BlcnR5KE9iamVjdFByb3RvdHlwZSQxLCBQLCBPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yKTtcbiAgfVxufTtcblxudmFyIHNldFN5bWJvbERlc2NyaXB0b3IgPSBERVNDUklQVE9SUyQ4ICYmIGZhaWxzJGkoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0Q3JlYXRlKG5hdGl2ZURlZmluZVByb3BlcnR5KHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KHRoaXMsICdhJywgeyB2YWx1ZTogNyB9KS5hOyB9XG4gIH0pKS5hICE9PSA3O1xufSkgPyBmYWxsYmFja0RlZmluZVByb3BlcnR5IDogbmF0aXZlRGVmaW5lUHJvcGVydHk7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZywgZGVzY3JpcHRpb24pIHtcbiAgdmFyIHN5bWJvbCA9IEFsbFN5bWJvbHNbdGFnXSA9IG5hdGl2ZU9iamVjdENyZWF0ZShTeW1ib2xQcm90b3R5cGUpO1xuICBzZXRJbnRlcm5hbFN0YXRlJDMoc3ltYm9sLCB7XG4gICAgdHlwZTogU1lNQk9MLFxuICAgIHRhZzogdGFnLFxuICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvblxuICB9KTtcbiAgaWYgKCFERVNDUklQVE9SUyQ4KSBzeW1ib2wuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgcmV0dXJuIHN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGlmIChPID09PSBPYmplY3RQcm90b3R5cGUkMSkgJGRlZmluZVByb3BlcnR5KE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIFAsIEF0dHJpYnV0ZXMpO1xuICBhbk9iamVjdCQ1KE8pO1xuICB2YXIga2V5ID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgYW5PYmplY3QkNShBdHRyaWJ1dGVzKTtcbiAgaWYgKGhhc093biQ3KEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUF0dHJpYnV0ZXMuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXNPd24kNyhPLCBISURERU4pKSBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBISURERU4sIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB7fSkpO1xuICAgICAgT1tISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzT3duJDcoTywgSElEREVOKSAmJiBPW0hJRERFTl1ba2V5XSkgT1tISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEF0dHJpYnV0ZXMgPSBuYXRpdmVPYmplY3RDcmVhdGUoQXR0cmlidXRlcywgeyBlbnVtZXJhYmxlOiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgZmFsc2UpIH0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2NyaXB0b3IoTywga2V5LCBBdHRyaWJ1dGVzKTtcbiAgfSByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkoTywga2V5LCBBdHRyaWJ1dGVzKTtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdCQ1KE8pO1xuICB2YXIgcHJvcGVydGllcyA9IHRvSW5kZXhlZE9iamVjdCQzKFByb3BlcnRpZXMpO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMocHJvcGVydGllcykuY29uY2F0KCRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMocHJvcGVydGllcykpO1xuICAkZm9yRWFjaCQxKGtleXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIURFU0NSSVBUT1JTJDggfHwgY2FsbCQzKCRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgcHJvcGVydGllcywga2V5KSkgJGRlZmluZVByb3BlcnR5KE8sIGtleSwgcHJvcGVydGllc1trZXldKTtcbiAgfSk7XG4gIHJldHVybiBPO1xufTtcblxudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gbmF0aXZlT2JqZWN0Q3JlYXRlKE8pIDogJGRlZmluZVByb3BlcnRpZXMobmF0aXZlT2JqZWN0Q3JlYXRlKE8pLCBQcm9wZXJ0aWVzKTtcbn07XG5cbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBQID0gdG9Qcm9wZXJ0eUtleShWKTtcbiAgdmFyIGVudW1lcmFibGUgPSBjYWxsJDMobmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUsIHRoaXMsIFApO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG90eXBlJDEgJiYgaGFzT3duJDcoQWxsU3ltYm9scywgUCkgJiYgIWhhc093biQ3KE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIFApKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBlbnVtZXJhYmxlIHx8ICFoYXNPd24kNyh0aGlzLCBQKSB8fCAhaGFzT3duJDcoQWxsU3ltYm9scywgUCkgfHwgaGFzT3duJDcodGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1bUF1cbiAgICA/IGVudW1lcmFibGUgOiB0cnVlO1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICB2YXIgaXQgPSB0b0luZGV4ZWRPYmplY3QkMyhPKTtcbiAgdmFyIGtleSA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG90eXBlJDEgJiYgaGFzT3duJDcoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzT3duJDcoT2JqZWN0UHJvdG90eXBlU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgZGVzY3JpcHRvciA9IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKGl0LCBrZXkpO1xuICBpZiAoZGVzY3JpcHRvciAmJiBoYXNPd24kNyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzT3duJDcoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkge1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGRlc2NyaXB0b3I7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgdmFyIG5hbWVzID0gbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyh0b0luZGV4ZWRPYmplY3QkMyhPKSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgJGZvckVhY2gkMShuYW1lcywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghaGFzT3duJDcoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzT3duJDcoaGlkZGVuS2V5cyQxLCBrZXkpKSBwdXNoJDkocmVzdWx0LCBrZXkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gKE8pIHtcbiAgdmFyIElTX09CSkVDVF9QUk9UT1RZUEUgPSBPID09PSBPYmplY3RQcm90b3R5cGUkMTtcbiAgdmFyIG5hbWVzID0gbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyhJU19PQkpFQ1RfUFJPVE9UWVBFID8gT2JqZWN0UHJvdG90eXBlU3ltYm9scyA6IHRvSW5kZXhlZE9iamVjdCQzKE8pKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICAkZm9yRWFjaCQxKG5hbWVzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGhhc093biQ3KEFsbFN5bWJvbHMsIGtleSkgJiYgKCFJU19PQkpFQ1RfUFJPVE9UWVBFIHx8IGhhc093biQ3KE9iamVjdFByb3RvdHlwZSQxLCBrZXkpKSkge1xuICAgICAgcHVzaCQ5KHJlc3VsdCwgQWxsU3ltYm9sc1trZXldKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gYFN5bWJvbGAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLWNvbnN0cnVjdG9yXG5pZiAoIU5BVElWRV9TWU1CT0wkMykge1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIGlmIChpc1Byb3RvdHlwZU9mJGkoU3ltYm9sUHJvdG90eXBlLCB0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvciQxKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSAhYXJndW1lbnRzLmxlbmd0aCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6ICR0b1N0cmluZyhhcmd1bWVudHNbMF0pO1xuICAgIHZhciB0YWcgPSB1aWQkMShkZXNjcmlwdGlvbik7XG4gICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvdHlwZSQxKSBjYWxsJDMoc2V0dGVyLCBPYmplY3RQcm90b3R5cGVTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzT3duJDcodGhpcywgSElEREVOKSAmJiBoYXNPd24kNyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSk7XG4gICAgICB0cnkge1xuICAgICAgICBzZXRTeW1ib2xEZXNjcmlwdG9yKHRoaXMsIHRhZywgZGVzY3JpcHRvcik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoIShlcnJvciBpbnN0YW5jZW9mIFJhbmdlRXJyb3IkMSkpIHRocm93IGVycm9yO1xuICAgICAgICBmYWxsYmFja0RlZmluZVByb3BlcnR5KHRoaXMsIHRhZywgZGVzY3JpcHRvcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMkOCAmJiBVU0VfU0VUVEVSKSBzZXRTeW1ib2xEZXNjcmlwdG9yKE9iamVjdFByb3RvdHlwZSQxLCB0YWcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IHNldHRlciB9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcsIGRlc2NyaXB0aW9uKTtcbiAgfTtcblxuICBTeW1ib2xQcm90b3R5cGUgPSAkU3ltYm9sW1BST1RPVFlQRV07XG5cbiAgZGVmaW5lQnVpbHRJbiQxKFN5bWJvbFByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykudGFnO1xuICB9KTtcblxuICBkZWZpbmVCdWlsdEluJDEoJFN5bWJvbCwgJ3dpdGhvdXRTZXR0ZXInLCBmdW5jdGlvbiAoZGVzY3JpcHRpb24pIHtcbiAgICByZXR1cm4gd3JhcCh1aWQkMShkZXNjcmlwdGlvbiksIGRlc2NyaXB0aW9uKTtcbiAgfSk7XG5cbiAgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgZGVmaW5lUHJvcGVydHlNb2R1bGUuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgZGVmaW5lUHJvcGVydGllc01vZHVsZS5mID0gJGRlZmluZVByb3BlcnRpZXM7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSQyLmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlJDIuZiA9IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQyLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2VsbEtub3duU3ltYm9sJDYobmFtZSksIG5hbWUpO1xuICB9O1xuXG4gIGlmIChERVNDUklQVE9SUyQ4KSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtU3ltYm9sLWRlc2NyaXB0aW9uXG4gICAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yJDIoU3ltYm9sUHJvdG90eXBlLCAnZGVzY3JpcHRpb24nLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5kZXNjcmlwdGlvbjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4kJEkoeyBnbG9iYWw6IHRydWUsIGNvbnN0cnVjdG9yOiB0cnVlLCB3cmFwOiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MJDMsIHNoYW06ICFOQVRJVkVfU1lNQk9MJDMgfSwge1xuICBTeW1ib2w6ICRTeW1ib2xcbn0pO1xuXG4kZm9yRWFjaCQxKG9iamVjdEtleXMoV2VsbEtub3duU3ltYm9sc1N0b3JlJDEpLCBmdW5jdGlvbiAobmFtZSkge1xuICBkZWZpbmVXZWxsS25vd25TeW1ib2wkbChuYW1lKTtcbn0pO1xuXG4kJEkoeyB0YXJnZXQ6IFNZTUJPTCwgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCQzIH0sIHtcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7IFVTRV9TRVRURVIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uICgpIHsgVVNFX1NFVFRFUiA9IGZhbHNlOyB9XG59KTtcblxuJCRJKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCQzLCBzaGFtOiAhREVTQ1JJUFRPUlMkOCB9LCB7XG4gIC8vIGBPYmplY3QuY3JlYXRlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydGllc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Jcbn0pO1xuXG4kJEkoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MJDMgfSwge1xuICAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzXG59KTtcblxuLy8gYFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9wcmltaXRpdmVcbmRlZmluZVN5bWJvbFRvUHJpbWl0aXZlJDEoKTtcblxuLy8gYFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11gIHByb3BlcnR5XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUtQEB0b3N0cmluZ3RhZ1xuc2V0VG9TdHJpbmdUYWckMygkU3ltYm9sLCBTWU1CT0wpO1xuXG5oaWRkZW5LZXlzJDFbSElEREVOXSA9IHRydWU7XG5cbnZhciBOQVRJVkVfU1lNQk9MJDIgPSBzeW1ib2xDb25zdHJ1Y3RvckRldGVjdGlvbjtcblxuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3ltYm9sIC0tIHNhZmUgKi9cbnZhciBzeW1ib2xSZWdpc3RyeURldGVjdGlvbiA9IE5BVElWRV9TWU1CT0wkMiAmJiAhIVN5bWJvbFsnZm9yJ10gJiYgISFTeW1ib2wua2V5Rm9yO1xuXG52YXIgJCRIID0gX2V4cG9ydDtcbnZhciBnZXRCdWlsdEluJDcgPSBnZXRCdWlsdEluJGM7XG52YXIgaGFzT3duJDYgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHRvU3RyaW5nJDYgPSB0b1N0cmluZyRhO1xudmFyIHNoYXJlZCQyID0gc2hhcmVkRXhwb3J0cztcbnZhciBOQVRJVkVfU1lNQk9MX1JFR0lTVFJZJDEgPSBzeW1ib2xSZWdpc3RyeURldGVjdGlvbjtcblxudmFyIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQkMignc3RyaW5nLXRvLXN5bWJvbC1yZWdpc3RyeScpO1xudmFyIFN5bWJvbFRvU3RyaW5nUmVnaXN0cnkkMSA9IHNoYXJlZCQyKCdzeW1ib2wtdG8tc3RyaW5nLXJlZ2lzdHJ5Jyk7XG5cbi8vIGBTeW1ib2wuZm9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLmZvclxuJCRIKHsgdGFyZ2V0OiAnU3ltYm9sJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTF9SRUdJU1RSWSQxIH0sIHtcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgc3RyaW5nID0gdG9TdHJpbmckNihrZXkpO1xuICAgIGlmIChoYXNPd24kNihTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5LCBzdHJpbmcpKSByZXR1cm4gU3RyaW5nVG9TeW1ib2xSZWdpc3RyeVtzdHJpbmddO1xuICAgIHZhciBzeW1ib2wgPSBnZXRCdWlsdEluJDcoJ1N5bWJvbCcpKHN0cmluZyk7XG4gICAgU3RyaW5nVG9TeW1ib2xSZWdpc3RyeVtzdHJpbmddID0gc3ltYm9sO1xuICAgIFN5bWJvbFRvU3RyaW5nUmVnaXN0cnkkMVtzeW1ib2xdID0gc3RyaW5nO1xuICAgIHJldHVybiBzeW1ib2w7XG4gIH1cbn0pO1xuXG52YXIgJCRHID0gX2V4cG9ydDtcbnZhciBoYXNPd24kNSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgaXNTeW1ib2wkMiA9IGlzU3ltYm9sJDU7XG52YXIgdHJ5VG9TdHJpbmckMyA9IHRyeVRvU3RyaW5nJDY7XG52YXIgc2hhcmVkJDEgPSBzaGFyZWRFeHBvcnRzO1xudmFyIE5BVElWRV9TWU1CT0xfUkVHSVNUUlkgPSBzeW1ib2xSZWdpc3RyeURldGVjdGlvbjtcblxudmFyIFN5bWJvbFRvU3RyaW5nUmVnaXN0cnkgPSBzaGFyZWQkMSgnc3ltYm9sLXRvLXN0cmluZy1yZWdpc3RyeScpO1xuXG4vLyBgU3ltYm9sLmtleUZvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5rZXlmb3JcbiQkRyh7IHRhcmdldDogJ1N5bWJvbCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0xfUkVHSVNUUlkgfSwge1xuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihzeW0pIHtcbiAgICBpZiAoIWlzU3ltYm9sJDIoc3ltKSkgdGhyb3cgbmV3IFR5cGVFcnJvcih0cnlUb1N0cmluZyQzKHN5bSkgKyAnIGlzIG5vdCBhIHN5bWJvbCcpO1xuICAgIGlmIChoYXNPd24kNShTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5LCBzeW0pKSByZXR1cm4gU3ltYm9sVG9TdHJpbmdSZWdpc3RyeVtzeW1dO1xuICB9XG59KTtcblxudmFyIHVuY3VycnlUaGlzJGYgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlzQXJyYXkkYiA9IGlzQXJyYXkkZTtcbnZhciBpc0NhbGxhYmxlJDMgPSBpc0NhbGxhYmxlJGk7XG52YXIgY2xhc3NvZiQ1ID0gY2xhc3NvZlJhdyQyO1xudmFyIHRvU3RyaW5nJDUgPSB0b1N0cmluZyRhO1xuXG52YXIgcHVzaCQ4ID0gdW5jdXJyeVRoaXMkZihbXS5wdXNoKTtcblxudmFyIGdldEpzb25SZXBsYWNlckZ1bmN0aW9uID0gZnVuY3Rpb24gKHJlcGxhY2VyKSB7XG4gIGlmIChpc0NhbGxhYmxlJDMocmVwbGFjZXIpKSByZXR1cm4gcmVwbGFjZXI7XG4gIGlmICghaXNBcnJheSRiKHJlcGxhY2VyKSkgcmV0dXJuO1xuICB2YXIgcmF3TGVuZ3RoID0gcmVwbGFjZXIubGVuZ3RoO1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0xlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZW1lbnQgPSByZXBsYWNlcltpXTtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT0gJ3N0cmluZycpIHB1c2gkOChrZXlzLCBlbGVtZW50KTtcbiAgICBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PSAnbnVtYmVyJyB8fCBjbGFzc29mJDUoZWxlbWVudCkgPT09ICdOdW1iZXInIHx8IGNsYXNzb2YkNShlbGVtZW50KSA9PT0gJ1N0cmluZycpIHB1c2gkOChrZXlzLCB0b1N0cmluZyQ1KGVsZW1lbnQpKTtcbiAgfVxuICB2YXIga2V5c0xlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgcm9vdCA9IHRydWU7XG4gIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChyb290KSB7XG4gICAgICByb290ID0gZmFsc2U7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChpc0FycmF5JGIodGhpcykpIHJldHVybiB2YWx1ZTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXNMZW5ndGg7IGorKykgaWYgKGtleXNbal0gPT09IGtleSkgcmV0dXJuIHZhbHVlO1xuICB9O1xufTtcblxudmFyICQkRiA9IF9leHBvcnQ7XG52YXIgZ2V0QnVpbHRJbiQ2ID0gZ2V0QnVpbHRJbiRjO1xudmFyIGFwcGx5JDMgPSBmdW5jdGlvbkFwcGx5O1xudmFyIGNhbGwkMiA9IGZ1bmN0aW9uQ2FsbDtcbnZhciB1bmN1cnJ5VGhpcyRlID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmYWlscyRoID0gZmFpbHMkdztcbnZhciBpc0NhbGxhYmxlJDIgPSBpc0NhbGxhYmxlJGk7XG52YXIgaXNTeW1ib2wkMSA9IGlzU3ltYm9sJDU7XG52YXIgYXJyYXlTbGljZSQyID0gYXJyYXlTbGljZSQ1O1xudmFyIGdldFJlcGxhY2VyRnVuY3Rpb24gPSBnZXRKc29uUmVwbGFjZXJGdW5jdGlvbjtcbnZhciBOQVRJVkVfU1lNQk9MJDEgPSBzeW1ib2xDb25zdHJ1Y3RvckRldGVjdGlvbjtcblxudmFyICRTdHJpbmcgPSBTdHJpbmc7XG52YXIgJHN0cmluZ2lmeSA9IGdldEJ1aWx0SW4kNignSlNPTicsICdzdHJpbmdpZnknKTtcbnZhciBleGVjJDEgPSB1bmN1cnJ5VGhpcyRlKC8uLy5leGVjKTtcbnZhciBjaGFyQXQkMSA9IHVuY3VycnlUaGlzJGUoJycuY2hhckF0KTtcbnZhciBjaGFyQ29kZUF0ID0gdW5jdXJyeVRoaXMkZSgnJy5jaGFyQ29kZUF0KTtcbnZhciByZXBsYWNlJDEgPSB1bmN1cnJ5VGhpcyRlKCcnLnJlcGxhY2UpO1xudmFyIG51bWJlclRvU3RyaW5nID0gdW5jdXJyeVRoaXMkZSgxLjAudG9TdHJpbmcpO1xuXG52YXIgdGVzdGVyID0gL1tcXHVEODAwLVxcdURGRkZdL2c7XG52YXIgbG93ID0gL15bXFx1RDgwMC1cXHVEQkZGXSQvO1xudmFyIGhpID0gL15bXFx1REMwMC1cXHVERkZGXSQvO1xuXG52YXIgV1JPTkdfU1lNQk9MU19DT05WRVJTSU9OID0gIU5BVElWRV9TWU1CT0wkMSB8fCBmYWlscyRoKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN5bWJvbCA9IGdldEJ1aWx0SW4kNignU3ltYm9sJykoJ3N0cmluZ2lmeSBkZXRlY3Rpb24nKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgcmV0dXJuICRzdHJpbmdpZnkoW3N5bWJvbF0pICE9PSAnW251bGxdJ1xuICAgIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAgIHx8ICRzdHJpbmdpZnkoeyBhOiBzeW1ib2wgfSkgIT09ICd7fSdcbiAgICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICAgIHx8ICRzdHJpbmdpZnkoT2JqZWN0KHN5bWJvbCkpICE9PSAne30nO1xufSk7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXdlbGwtZm9ybWVkLXN0cmluZ2lmeVxudmFyIElMTF9GT1JNRURfVU5JQ09ERSA9IGZhaWxzJGgoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJHN0cmluZ2lmeSgnXFx1REYwNlxcdUQ4MzQnKSAhPT0gJ1wiXFxcXHVkZjA2XFxcXHVkODM0XCInXG4gICAgfHwgJHN0cmluZ2lmeSgnXFx1REVBRCcpICE9PSAnXCJcXFxcdWRlYWRcIic7XG59KTtcblxudmFyIHN0cmluZ2lmeVdpdGhTeW1ib2xzRml4ID0gZnVuY3Rpb24gKGl0LCByZXBsYWNlcikge1xuICB2YXIgYXJncyA9IGFycmF5U2xpY2UkMihhcmd1bWVudHMpO1xuICB2YXIgJHJlcGxhY2VyID0gZ2V0UmVwbGFjZXJGdW5jdGlvbihyZXBsYWNlcik7XG4gIGlmICghaXNDYWxsYWJsZSQyKCRyZXBsYWNlcikgJiYgKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2wkMShpdCkpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgYXJnc1sxXSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgLy8gc29tZSBvbGQgaW1wbGVtZW50YXRpb25zIChsaWtlIFdlYktpdCkgY291bGQgcGFzcyBudW1iZXJzIGFzIGtleXNcbiAgICBpZiAoaXNDYWxsYWJsZSQyKCRyZXBsYWNlcikpIHZhbHVlID0gY2FsbCQyKCRyZXBsYWNlciwgdGhpcywgJFN0cmluZyhrZXkpLCB2YWx1ZSk7XG4gICAgaWYgKCFpc1N5bWJvbCQxKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICB9O1xuICByZXR1cm4gYXBwbHkkMygkc3RyaW5naWZ5LCBudWxsLCBhcmdzKTtcbn07XG5cbnZhciBmaXhJbGxGb3JtZWQgPSBmdW5jdGlvbiAobWF0Y2gsIG9mZnNldCwgc3RyaW5nKSB7XG4gIHZhciBwcmV2ID0gY2hhckF0JDEoc3RyaW5nLCBvZmZzZXQgLSAxKTtcbiAgdmFyIG5leHQgPSBjaGFyQXQkMShzdHJpbmcsIG9mZnNldCArIDEpO1xuICBpZiAoKGV4ZWMkMShsb3csIG1hdGNoKSAmJiAhZXhlYyQxKGhpLCBuZXh0KSkgfHwgKGV4ZWMkMShoaSwgbWF0Y2gpICYmICFleGVjJDEobG93LCBwcmV2KSkpIHtcbiAgICByZXR1cm4gJ1xcXFx1JyArIG51bWJlclRvU3RyaW5nKGNoYXJDb2RlQXQobWF0Y2gsIDApLCAxNik7XG4gIH0gcmV0dXJuIG1hdGNoO1xufTtcblxuaWYgKCRzdHJpbmdpZnkpIHtcbiAgLy8gYEpTT04uc3RyaW5naWZ5YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1qc29uLnN0cmluZ2lmeVxuICAkJEYoeyB0YXJnZXQ6ICdKU09OJywgc3RhdDogdHJ1ZSwgYXJpdHk6IDMsIGZvcmNlZDogV1JPTkdfU1lNQk9MU19DT05WRVJTSU9OIHx8IElMTF9GT1JNRURfVU5JQ09ERSB9LCB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgICB2YXIgYXJncyA9IGFycmF5U2xpY2UkMihhcmd1bWVudHMpO1xuICAgICAgdmFyIHJlc3VsdCA9IGFwcGx5JDMoV1JPTkdfU1lNQk9MU19DT05WRVJTSU9OID8gc3RyaW5naWZ5V2l0aFN5bWJvbHNGaXggOiAkc3RyaW5naWZ5LCBudWxsLCBhcmdzKTtcbiAgICAgIHJldHVybiBJTExfRk9STUVEX1VOSUNPREUgJiYgdHlwZW9mIHJlc3VsdCA9PSAnc3RyaW5nJyA/IHJlcGxhY2UkMShyZXN1bHQsIHRlc3RlciwgZml4SWxsRm9ybWVkKSA6IHJlc3VsdDtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgJCRFID0gX2V4cG9ydDtcbnZhciBOQVRJVkVfU1lNQk9MID0gc3ltYm9sQ29uc3RydWN0b3JEZXRlY3Rpb247XG52YXIgZmFpbHMkZyA9IGZhaWxzJHc7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDEgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgdG9PYmplY3QkNyA9IHRvT2JqZWN0JGU7XG5cbi8vIFY4IH4gQ2hyb21lIDM4IGFuZCAzOSBgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc2AgZmFpbHMgb24gcHJpbWl0aXZlc1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzQ0M1xudmFyIEZPUkNFRCQ5ID0gIU5BVElWRV9TWU1CT0wgfHwgZmFpbHMkZyhmdW5jdGlvbiAoKSB7IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQxLmYoMSk7IH0pO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eXN5bWJvbHNcbiQkRSh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRk9SQ0VEJDkgfSwge1xuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICAgIHZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDEuZjtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5U3ltYm9scyA/ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHModG9PYmplY3QkNyhpdCkpIDogW107XG4gIH1cbn0pO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGsgPSB3ZWxsS25vd25TeW1ib2xEZWZpbmU7XG5cbi8vIGBTeW1ib2wuYXN5bmNJdGVyYXRvcmAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLmFzeW5jaXRlcmF0b3JcbmRlZmluZVdlbGxLbm93blN5bWJvbCRrKCdhc3luY0l0ZXJhdG9yJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkaiA9IHdlbGxLbm93blN5bWJvbERlZmluZTtcblxuLy8gYFN5bWJvbC5oYXNJbnN0YW5jZWAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLmhhc2luc3RhbmNlXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkaignaGFzSW5zdGFuY2UnKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRpID0gd2VsbEtub3duU3ltYm9sRGVmaW5lO1xuXG4vLyBgU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZWAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLmlzY29uY2F0c3ByZWFkYWJsZVxuZGVmaW5lV2VsbEtub3duU3ltYm9sJGkoJ2lzQ29uY2F0U3ByZWFkYWJsZScpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGggPSB3ZWxsS25vd25TeW1ib2xEZWZpbmU7XG5cbi8vIGBTeW1ib2wuaXRlcmF0b3JgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5pdGVyYXRvclxuZGVmaW5lV2VsbEtub3duU3ltYm9sJGgoJ2l0ZXJhdG9yJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkZyA9IHdlbGxLbm93blN5bWJvbERlZmluZTtcblxuLy8gYFN5bWJvbC5tYXRjaGAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLm1hdGNoXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkZygnbWF0Y2gnKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRmID0gd2VsbEtub3duU3ltYm9sRGVmaW5lO1xuXG4vLyBgU3ltYm9sLm1hdGNoQWxsYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wubWF0Y2hhbGxcbmRlZmluZVdlbGxLbm93blN5bWJvbCRmKCdtYXRjaEFsbCcpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGUgPSB3ZWxsS25vd25TeW1ib2xEZWZpbmU7XG5cbi8vIGBTeW1ib2wucmVwbGFjZWAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnJlcGxhY2VcbmRlZmluZVdlbGxLbm93blN5bWJvbCRlKCdyZXBsYWNlJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkZCA9IHdlbGxLbm93blN5bWJvbERlZmluZTtcblxuLy8gYFN5bWJvbC5zZWFyY2hgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5zZWFyY2hcbmRlZmluZVdlbGxLbm93blN5bWJvbCRkKCdzZWFyY2gnKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRjID0gd2VsbEtub3duU3ltYm9sRGVmaW5lO1xuXG4vLyBgU3ltYm9sLnNwZWNpZXNgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5zcGVjaWVzXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkYygnc3BlY2llcycpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGIgPSB3ZWxsS25vd25TeW1ib2xEZWZpbmU7XG5cbi8vIGBTeW1ib2wuc3BsaXRgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5zcGxpdFxuZGVmaW5lV2VsbEtub3duU3ltYm9sJGIoJ3NwbGl0Jyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkYSA9IHdlbGxLbm93blN5bWJvbERlZmluZTtcbnZhciBkZWZpbmVTeW1ib2xUb1ByaW1pdGl2ZSA9IHN5bWJvbERlZmluZVRvUHJpbWl0aXZlO1xuXG4vLyBgU3ltYm9sLnRvUHJpbWl0aXZlYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wudG9wcmltaXRpdmVcbmRlZmluZVdlbGxLbm93blN5bWJvbCRhKCd0b1ByaW1pdGl2ZScpO1xuXG4vLyBgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUtQEB0b3ByaW1pdGl2ZVxuZGVmaW5lU3ltYm9sVG9QcmltaXRpdmUoKTtcblxudmFyIGdldEJ1aWx0SW4kNSA9IGdldEJ1aWx0SW4kYztcbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkOSA9IHdlbGxLbm93blN5bWJvbERlZmluZTtcbnZhciBzZXRUb1N0cmluZ1RhZyQyID0gc2V0VG9TdHJpbmdUYWckNjtcblxuLy8gYFN5bWJvbC50b1N0cmluZ1RhZ2Agd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnRvc3RyaW5ndGFnXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkOSgndG9TdHJpbmdUYWcnKTtcblxuLy8gYFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11gIHByb3BlcnR5XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUtQEB0b3N0cmluZ3RhZ1xuc2V0VG9TdHJpbmdUYWckMihnZXRCdWlsdEluJDUoJ1N5bWJvbCcpLCAnU3ltYm9sJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkOCA9IHdlbGxLbm93blN5bWJvbERlZmluZTtcblxuLy8gYFN5bWJvbC51bnNjb3BhYmxlc2Agd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnVuc2NvcGFibGVzXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkOCgndW5zY29wYWJsZXMnKTtcblxudmFyIGdsb2JhbCRhID0gZ2xvYmFsJG47XG52YXIgc2V0VG9TdHJpbmdUYWckMSA9IHNldFRvU3RyaW5nVGFnJDY7XG5cbi8vIEpTT05bQEB0b1N0cmluZ1RhZ10gcHJvcGVydHlcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtanNvbi1AQHRvc3RyaW5ndGFnXG5zZXRUb1N0cmluZ1RhZyQxKGdsb2JhbCRhLkpTT04sICdKU09OJywgdHJ1ZSk7XG5cbnZhciBwYXRoJG8gPSBwYXRoJHc7XG5cbnZhciBzeW1ib2wkNSA9IHBhdGgkby5TeW1ib2w7XG5cbnZhciBwYXJlbnQkMTIgPSBzeW1ib2wkNTtcblxuXG52YXIgc3ltYm9sJDQgPSBwYXJlbnQkMTI7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkNSA9IHdlbGxLbm93blN5bWJvbCRtO1xudmFyIGRlZmluZVByb3BlcnR5JDMgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xuXG52YXIgTUVUQURBVEEkMSA9IHdlbGxLbm93blN5bWJvbCQ1KCdtZXRhZGF0YScpO1xudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vLyBGdW5jdGlvbi5wcm90b3R5cGVbQEBtZXRhZGF0YV1cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWRlY29yYXRvci1tZXRhZGF0YVxuaWYgKEZ1bmN0aW9uUHJvdG90eXBlW01FVEFEQVRBJDFdID09PSB1bmRlZmluZWQpIHtcbiAgZGVmaW5lUHJvcGVydHkkMyhGdW5jdGlvblByb3RvdHlwZSwgTUVUQURBVEEkMSwge1xuICAgIHZhbHVlOiBudWxsXG4gIH0pO1xufVxuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJDcgPSB3ZWxsS25vd25TeW1ib2xEZWZpbmU7XG5cbi8vIGBTeW1ib2wuYXN5bmNEaXNwb3NlYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXN5bmMtZXhwbGljaXQtcmVzb3VyY2UtbWFuYWdlbWVudFxuZGVmaW5lV2VsbEtub3duU3ltYm9sJDcoJ2FzeW5jRGlzcG9zZScpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJDYgPSB3ZWxsS25vd25TeW1ib2xEZWZpbmU7XG5cbi8vIGBTeW1ib2wuZGlzcG9zZWAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWV4cGxpY2l0LXJlc291cmNlLW1hbmFnZW1lbnRcbmRlZmluZVdlbGxLbm93blN5bWJvbCQ2KCdkaXNwb3NlJyk7XG5cbi8vIFRPRE86IFJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJDUgPSB3ZWxsS25vd25TeW1ib2xEZWZpbmU7XG5cbi8vIGBTeW1ib2wubWV0YWRhdGFgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1kZWNvcmF0b3JzXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkNSgnbWV0YWRhdGEnKTtcblxudmFyIHBhcmVudCQxMSA9IHN5bWJvbCQ0O1xuXG5cblxuXG5cblxudmFyIHN5bWJvbCQzID0gcGFyZW50JDExO1xuXG52YXIgZ2V0QnVpbHRJbiQ0ID0gZ2V0QnVpbHRJbiRjO1xudmFyIHVuY3VycnlUaGlzJGQgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuXG52YXIgU3ltYm9sJDQgPSBnZXRCdWlsdEluJDQoJ1N5bWJvbCcpO1xudmFyIGtleUZvciA9IFN5bWJvbCQ0LmtleUZvcjtcbnZhciB0aGlzU3ltYm9sVmFsdWUkMSA9IHVuY3VycnlUaGlzJGQoU3ltYm9sJDQucHJvdG90eXBlLnZhbHVlT2YpO1xuXG4vLyBgU3ltYm9sLmlzUmVnaXN0ZXJlZFN5bWJvbGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvcHJvcG9zYWwtc3ltYm9sLXByZWRpY2F0ZXMvI3NlYy1zeW1ib2wtaXNyZWdpc3RlcmVkc3ltYm9sXG52YXIgc3ltYm9sSXNSZWdpc3RlcmVkID0gU3ltYm9sJDQuaXNSZWdpc3RlcmVkU3ltYm9sIHx8IGZ1bmN0aW9uIGlzUmVnaXN0ZXJlZFN5bWJvbCh2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiBrZXlGb3IodGhpc1N5bWJvbFZhbHVlJDEodmFsdWUpKSAhPT0gdW5kZWZpbmVkO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyICQkRCA9IF9leHBvcnQ7XG52YXIgaXNSZWdpc3RlcmVkU3ltYm9sJDEgPSBzeW1ib2xJc1JlZ2lzdGVyZWQ7XG5cbi8vIGBTeW1ib2wuaXNSZWdpc3RlcmVkU3ltYm9sYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9wcm9wb3NhbC1zeW1ib2wtcHJlZGljYXRlcy8jc2VjLXN5bWJvbC1pc3JlZ2lzdGVyZWRzeW1ib2xcbiQkRCh7IHRhcmdldDogJ1N5bWJvbCcsIHN0YXQ6IHRydWUgfSwge1xuICBpc1JlZ2lzdGVyZWRTeW1ib2w6IGlzUmVnaXN0ZXJlZFN5bWJvbCQxXG59KTtcblxudmFyIHNoYXJlZCA9IHNoYXJlZEV4cG9ydHM7XG52YXIgZ2V0QnVpbHRJbiQzID0gZ2V0QnVpbHRJbiRjO1xudmFyIHVuY3VycnlUaGlzJGMgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlzU3ltYm9sID0gaXNTeW1ib2wkNTtcbnZhciB3ZWxsS25vd25TeW1ib2wkNCA9IHdlbGxLbm93blN5bWJvbCRtO1xuXG52YXIgU3ltYm9sJDMgPSBnZXRCdWlsdEluJDMoJ1N5bWJvbCcpO1xudmFyICRpc1dlbGxLbm93blN5bWJvbCA9IFN5bWJvbCQzLmlzV2VsbEtub3duU3ltYm9sO1xudmFyIGdldE93blByb3BlcnR5TmFtZXMkNCA9IGdldEJ1aWx0SW4kMygnT2JqZWN0JywgJ2dldE93blByb3BlcnR5TmFtZXMnKTtcbnZhciB0aGlzU3ltYm9sVmFsdWUgPSB1bmN1cnJ5VGhpcyRjKFN5bWJvbCQzLnByb3RvdHlwZS52YWx1ZU9mKTtcbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQoJ3drcycpO1xuXG5mb3IgKHZhciBpID0gMCwgc3ltYm9sS2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMkNChTeW1ib2wkMyksIHN5bWJvbEtleXNMZW5ndGggPSBzeW1ib2xLZXlzLmxlbmd0aDsgaSA8IHN5bWJvbEtleXNMZW5ndGg7IGkrKykge1xuICAvLyBzb21lIG9sZCBlbmdpbmVzIHRocm93cyBvbiBhY2Nlc3MgdG8gc29tZSBrZXlzIGxpa2UgYGFyZ3VtZW50c2Agb3IgYGNhbGxlcmBcbiAgdHJ5IHtcbiAgICB2YXIgc3ltYm9sS2V5ID0gc3ltYm9sS2V5c1tpXTtcbiAgICBpZiAoaXNTeW1ib2woU3ltYm9sJDNbc3ltYm9sS2V5XSkpIHdlbGxLbm93blN5bWJvbCQ0KHN5bWJvbEtleSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbn1cblxuLy8gYFN5bWJvbC5pc1dlbGxLbm93blN5bWJvbGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvcHJvcG9zYWwtc3ltYm9sLXByZWRpY2F0ZXMvI3NlYy1zeW1ib2wtaXN3ZWxsa25vd25zeW1ib2xcbi8vIFdlIHNob3VsZCBwYXRjaCBpdCBmb3IgbmV3bHkgYWRkZWQgd2VsbC1rbm93biBzeW1ib2xzLiBJZiBpdCdzIG5vdCByZXF1aXJlZCwgdGhpcyBtb2R1bGUganVzdCB3aWxsIG5vdCBiZSBpbmplY3RlZFxudmFyIHN5bWJvbElzV2VsbEtub3duID0gZnVuY3Rpb24gaXNXZWxsS25vd25TeW1ib2wodmFsdWUpIHtcbiAgaWYgKCRpc1dlbGxLbm93blN5bWJvbCAmJiAkaXNXZWxsS25vd25TeW1ib2wodmFsdWUpKSByZXR1cm4gdHJ1ZTtcbiAgdHJ5IHtcbiAgICB2YXIgc3ltYm9sID0gdGhpc1N5bWJvbFZhbHVlKHZhbHVlKTtcbiAgICBmb3IgKHZhciBqID0gMCwga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMkNChXZWxsS25vd25TeW1ib2xzU3RvcmUpLCBrZXlzTGVuZ3RoID0ga2V5cy5sZW5ndGg7IGogPCBrZXlzTGVuZ3RoOyBqKyspIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXEgLS0gcG9seWZpbGxlZCBzeW1ib2xzIGNhc2VcbiAgICAgIGlmIChXZWxsS25vd25TeW1ib2xzU3RvcmVba2V5c1tqXV0gPT0gc3ltYm9sKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyICQkQyA9IF9leHBvcnQ7XG52YXIgaXNXZWxsS25vd25TeW1ib2wkMSA9IHN5bWJvbElzV2VsbEtub3duO1xuXG4vLyBgU3ltYm9sLmlzV2VsbEtub3duU3ltYm9sYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9wcm9wb3NhbC1zeW1ib2wtcHJlZGljYXRlcy8jc2VjLXN5bWJvbC1pc3dlbGxrbm93bnN5bWJvbFxuLy8gV2Ugc2hvdWxkIHBhdGNoIGl0IGZvciBuZXdseSBhZGRlZCB3ZWxsLWtub3duIHN5bWJvbHMuIElmIGl0J3Mgbm90IHJlcXVpcmVkLCB0aGlzIG1vZHVsZSBqdXN0IHdpbGwgbm90IGJlIGluamVjdGVkXG4kJEMoeyB0YXJnZXQ6ICdTeW1ib2wnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IHRydWUgfSwge1xuICBpc1dlbGxLbm93blN5bWJvbDogaXNXZWxsS25vd25TeW1ib2wkMVxufSk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkNCA9IHdlbGxLbm93blN5bWJvbERlZmluZTtcblxuLy8gYFN5bWJvbC5tYXRjaGVyYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcGF0dGVybi1tYXRjaGluZ1xuZGVmaW5lV2VsbEtub3duU3ltYm9sJDQoJ21hdGNoZXInKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCQzID0gd2VsbEtub3duU3ltYm9sRGVmaW5lO1xuXG4vLyBgU3ltYm9sLm9ic2VydmFibGVgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYnNlcnZhYmxlXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkMygnb2JzZXJ2YWJsZScpO1xuXG52YXIgJCRCID0gX2V4cG9ydDtcbnZhciBpc1JlZ2lzdGVyZWRTeW1ib2wgPSBzeW1ib2xJc1JlZ2lzdGVyZWQ7XG5cbi8vIGBTeW1ib2wuaXNSZWdpc3RlcmVkYCBtZXRob2Rcbi8vIG9ic29sZXRlIHZlcnNpb24gb2YgaHR0cHM6Ly90YzM5LmVzL3Byb3Bvc2FsLXN5bWJvbC1wcmVkaWNhdGVzLyNzZWMtc3ltYm9sLWlzcmVnaXN0ZXJlZHN5bWJvbFxuJCRCKHsgdGFyZ2V0OiAnU3ltYm9sJywgc3RhdDogdHJ1ZSwgbmFtZTogJ2lzUmVnaXN0ZXJlZFN5bWJvbCcgfSwge1xuICBpc1JlZ2lzdGVyZWQ6IGlzUmVnaXN0ZXJlZFN5bWJvbFxufSk7XG5cbnZhciAkJEEgPSBfZXhwb3J0O1xudmFyIGlzV2VsbEtub3duU3ltYm9sID0gc3ltYm9sSXNXZWxsS25vd247XG5cbi8vIGBTeW1ib2wuaXNXZWxsS25vd25gIG1ldGhvZFxuLy8gb2Jzb2xldGUgdmVyc2lvbiBvZiBodHRwczovL3RjMzkuZXMvcHJvcG9zYWwtc3ltYm9sLXByZWRpY2F0ZXMvI3NlYy1zeW1ib2wtaXN3ZWxsa25vd25zeW1ib2xcbi8vIFdlIHNob3VsZCBwYXRjaCBpdCBmb3IgbmV3bHkgYWRkZWQgd2VsbC1rbm93biBzeW1ib2xzLiBJZiBpdCdzIG5vdCByZXF1aXJlZCwgdGhpcyBtb2R1bGUganVzdCB3aWxsIG5vdCBiZSBpbmplY3RlZFxuJCRBKHsgdGFyZ2V0OiAnU3ltYm9sJywgc3RhdDogdHJ1ZSwgbmFtZTogJ2lzV2VsbEtub3duU3ltYm9sJywgZm9yY2VkOiB0cnVlIH0sIHtcbiAgaXNXZWxsS25vd246IGlzV2VsbEtub3duU3ltYm9sXG59KTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCQyID0gd2VsbEtub3duU3ltYm9sRGVmaW5lO1xuXG4vLyBgU3ltYm9sLm1ldGFkYXRhS2V5YCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZGVjb3JhdG9yLW1ldGFkYXRhXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkMignbWV0YWRhdGFLZXknKTtcblxuLy8gVE9ETzogcmVtb3ZlIGZyb20gYGNvcmUtanNANGBcbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkMSA9IHdlbGxLbm93blN5bWJvbERlZmluZTtcblxuLy8gYFN5bWJvbC5wYXR0ZXJuTWF0Y2hgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wYXR0ZXJuLW1hdGNoaW5nXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkMSgncGF0dGVybk1hdGNoJyk7XG5cbi8vIFRPRE86IHJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gd2VsbEtub3duU3ltYm9sRGVmaW5lO1xuXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ3JlcGxhY2VBbGwnKTtcblxudmFyIHBhcmVudCQxMCA9IHN5bWJvbCQzO1xuXG5cblxuXG4vLyBUT0RPOiBSZW1vdmUgZnJvbSBgY29yZS1qc0A0YFxuXG5cblxuXG5cblxudmFyIHN5bWJvbCQyID0gcGFyZW50JDEwO1xuXG52YXIgc3ltYm9sJDEgPSBzeW1ib2wkMjtcblxudmFyIF9TeW1ib2wkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhzeW1ib2wkMSk7XG5cbnZhciBXcmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlJDEgPSB3ZWxsS25vd25TeW1ib2xXcmFwcGVkO1xuXG52YXIgaXRlcmF0b3IkNCA9IFdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUkMS5mKCdpdGVyYXRvcicpO1xuXG52YXIgcGFyZW50JCQgPSBpdGVyYXRvciQ0O1xuXG5cbnZhciBpdGVyYXRvciQzID0gcGFyZW50JCQ7XG5cbnZhciBwYXJlbnQkXyA9IGl0ZXJhdG9yJDM7XG5cbnZhciBpdGVyYXRvciQyID0gcGFyZW50JF87XG5cbnZhciBwYXJlbnQkWiA9IGl0ZXJhdG9yJDI7XG5cbnZhciBpdGVyYXRvciQxID0gcGFyZW50JFo7XG5cbnZhciBpdGVyYXRvciA9IGl0ZXJhdG9yJDE7XG5cbnZhciBfU3ltYm9sJGl0ZXJhdG9yID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGl0ZXJhdG9yKTtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgX1N5bWJvbCQxICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIF9TeW1ib2wkaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBfU3ltYm9sJDEgJiYgby5jb25zdHJ1Y3RvciA9PT0gX1N5bWJvbCQxICYmIG8gIT09IF9TeW1ib2wkMS5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIF90eXBlb2Yobyk7XG59XG5cbnZhciBXcmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlID0gd2VsbEtub3duU3ltYm9sV3JhcHBlZDtcblxudmFyIHRvUHJpbWl0aXZlJDQgPSBXcmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlLmYoJ3RvUHJpbWl0aXZlJyk7XG5cbnZhciBwYXJlbnQkWSA9IHRvUHJpbWl0aXZlJDQ7XG5cbnZhciB0b1ByaW1pdGl2ZSQzID0gcGFyZW50JFk7XG5cbnZhciBwYXJlbnQkWCA9IHRvUHJpbWl0aXZlJDM7XG5cbnZhciB0b1ByaW1pdGl2ZSQyID0gcGFyZW50JFg7XG5cbnZhciBwYXJlbnQkVyA9IHRvUHJpbWl0aXZlJDI7XG5cbnZhciB0b1ByaW1pdGl2ZSQxID0gcGFyZW50JFc7XG5cbnZhciB0b1ByaW1pdGl2ZSA9IHRvUHJpbWl0aXZlJDE7XG5cbnZhciBfU3ltYm9sJHRvUHJpbWl0aXZlID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHRvUHJpbWl0aXZlKTtcblxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7XG4gIGlmIChfdHlwZW9mKGlucHV0KSAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICB2YXIgcHJpbSA9IGlucHV0W19TeW1ib2wkdG9QcmltaXRpdmVdO1xuICBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKF90eXBlb2YocmVzKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG59XG5cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiBfdHlwZW9mKGtleSkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgX09iamVjdCRkZWZpbmVQcm9wZXJ0eSQxKHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBfT2JqZWN0JGRlZmluZVByb3BlcnR5JDEoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxudmFyICQkeiA9IF9leHBvcnQ7XG52YXIgaXNBcnJheSRhID0gaXNBcnJheSRlO1xuXG4vLyBgQXJyYXkuaXNBcnJheWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LmlzYXJyYXlcbiQkeih7IHRhcmdldDogJ0FycmF5Jywgc3RhdDogdHJ1ZSB9LCB7XG4gIGlzQXJyYXk6IGlzQXJyYXkkYVxufSk7XG5cbnZhciBwYXRoJG4gPSBwYXRoJHc7XG5cbnZhciBpc0FycmF5JDkgPSBwYXRoJG4uQXJyYXkuaXNBcnJheTtcblxudmFyIHBhcmVudCRWID0gaXNBcnJheSQ5O1xuXG52YXIgaXNBcnJheSQ4ID0gcGFyZW50JFY7XG5cbnZhciBwYXJlbnQkVSA9IGlzQXJyYXkkODtcblxudmFyIGlzQXJyYXkkNyA9IHBhcmVudCRVO1xuXG52YXIgcGFyZW50JFQgPSBpc0FycmF5JDc7XG5cbnZhciBpc0FycmF5JDYgPSBwYXJlbnQkVDtcblxudmFyIGlzQXJyYXkkNSA9IGlzQXJyYXkkNjtcblxudmFyIF9BcnJheSRpc0FycmF5JDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoaXNBcnJheSQ1KTtcblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoX0FycmF5JGlzQXJyYXkkMShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG52YXIgREVTQ1JJUFRPUlMkNyA9IGRlc2NyaXB0b3JzO1xudmFyIGlzQXJyYXkkNCA9IGlzQXJyYXkkZTtcblxudmFyICRUeXBlRXJyb3IkNyA9IFR5cGVFcnJvcjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkNyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIFNhZmFyaSA8IDEzIGRvZXMgbm90IHRocm93IGFuIGVycm9yIGluIHRoaXMgY2FzZVxudmFyIFNJTEVOVF9PTl9OT05fV1JJVEFCTEVfTEVOR1RIX1NFVCA9IERFU0NSSVBUT1JTJDcgJiYgIWZ1bmN0aW9uICgpIHtcbiAgLy8gbWFrZXMgbm8gc2Vuc2Ugd2l0aG91dCBwcm9wZXIgc3RyaWN0IG1vZGUgc3VwcG9ydFxuICBpZiAodGhpcyAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdHJ1ZTtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoW10sICdsZW5ndGgnLCB7IHdyaXRhYmxlOiBmYWxzZSB9KS5sZW5ndGggPSAxO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvcjtcbiAgfVxufSgpO1xuXG52YXIgYXJyYXlTZXRMZW5ndGggPSBTSUxFTlRfT05fTk9OX1dSSVRBQkxFX0xFTkdUSF9TRVQgPyBmdW5jdGlvbiAoTywgbGVuZ3RoKSB7XG4gIGlmIChpc0FycmF5JDQoTykgJiYgIWdldE93blByb3BlcnR5RGVzY3JpcHRvciQ3KE8sICdsZW5ndGgnKS53cml0YWJsZSkge1xuICAgIHRocm93IG5ldyAkVHlwZUVycm9yJDcoJ0Nhbm5vdCBzZXQgcmVhZCBvbmx5IC5sZW5ndGgnKTtcbiAgfSByZXR1cm4gTy5sZW5ndGggPSBsZW5ndGg7XG59IDogZnVuY3Rpb24gKE8sIGxlbmd0aCkge1xuICByZXR1cm4gTy5sZW5ndGggPSBsZW5ndGg7XG59O1xuXG52YXIgJCR5ID0gX2V4cG9ydDtcbnZhciB0b09iamVjdCQ2ID0gdG9PYmplY3QkZTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQ2ID0gbGVuZ3RoT2ZBcnJheUxpa2UkYztcbnZhciBzZXRBcnJheUxlbmd0aCQxID0gYXJyYXlTZXRMZW5ndGg7XG52YXIgZG9lc05vdEV4Y2VlZFNhZmVJbnRlZ2VyJDEgPSBkb2VzTm90RXhjZWVkU2FmZUludGVnZXIkMztcbnZhciBmYWlscyRmID0gZmFpbHMkdztcblxudmFyIElOQ09SUkVDVF9UT19MRU5HVEggPSBmYWlscyRmKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFtdLnB1c2guY2FsbCh7IGxlbmd0aDogMHgxMDAwMDAwMDAgfSwgMSkgIT09IDQyOTQ5NjcyOTc7XG59KTtcblxuLy8gVjggYW5kIFNhZmFyaSA8PSAxNS40LCBGRiA8IDIzIHRocm93cyBJbnRlcm5hbEVycm9yXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0xMjY4MVxudmFyIHByb3BlckVycm9yT25Ob25Xcml0YWJsZUxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoW10sICdsZW5ndGgnLCB7IHdyaXRhYmxlOiBmYWxzZSB9KS5wdXNoKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yO1xuICB9XG59O1xuXG52YXIgRk9SQ0VEJDggPSBJTkNPUlJFQ1RfVE9fTEVOR1RIIHx8ICFwcm9wZXJFcnJvck9uTm9uV3JpdGFibGVMZW5ndGgoKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5wdXNoYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnB1c2hcbiQkeSh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGFyaXR5OiAxLCBmb3JjZWQ6IEZPUkNFRCQ4IH0sIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgcHVzaDogZnVuY3Rpb24gcHVzaChpdGVtKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCQ2KHRoaXMpO1xuICAgIHZhciBsZW4gPSBsZW5ndGhPZkFycmF5TGlrZSQ2KE8pO1xuICAgIHZhciBhcmdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZG9lc05vdEV4Y2VlZFNhZmVJbnRlZ2VyJDEobGVuICsgYXJnQ291bnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnQ291bnQ7IGkrKykge1xuICAgICAgT1tsZW5dID0gYXJndW1lbnRzW2ldO1xuICAgICAgbGVuKys7XG4gICAgfVxuICAgIHNldEFycmF5TGVuZ3RoJDEoTywgbGVuKTtcbiAgICByZXR1cm4gbGVuO1xuICB9XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCRnID0gZW50cnlWaXJ0dWFsJGk7XG5cbnZhciBwdXNoJDcgPSBlbnRyeVZpcnR1YWwkZygnQXJyYXknKS5wdXNoO1xuXG52YXIgaXNQcm90b3R5cGVPZiRoID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkZSA9IHB1c2gkNztcblxudmFyIEFycmF5UHJvdG90eXBlJGYgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBwdXNoJDYgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LnB1c2g7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkZiB8fCAoaXNQcm90b3R5cGVPZiRoKEFycmF5UHJvdG90eXBlJGYsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJGYucHVzaCkgPyBtZXRob2QkZSA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQkUyA9IHB1c2gkNjtcblxudmFyIHB1c2gkNSA9IHBhcmVudCRTO1xuXG52YXIgcGFyZW50JFIgPSBwdXNoJDU7XG5cbnZhciBwdXNoJDQgPSBwYXJlbnQkUjtcblxudmFyIHBhcmVudCRRID0gcHVzaCQ0O1xuXG52YXIgcHVzaCQzID0gcGFyZW50JFE7XG5cbnZhciBwdXNoJDIgPSBwdXNoJDM7XG5cbnZhciBfcHVzaEluc3RhbmNlUHJvcGVydHkgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMocHVzaCQyKTtcblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHtcbiAgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgX1N5bWJvbCQxICYmIF9nZXRJdGVyYXRvck1ldGhvZCQxKHIpIHx8IHJbXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAobnVsbCAhPSB0KSB7XG4gICAgdmFyIGUsXG4gICAgICBuLFxuICAgICAgaSxcbiAgICAgIHUsXG4gICAgICBhID0gW10sXG4gICAgICBmID0gITAsXG4gICAgICBvID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHtcbiAgICAgICAgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuO1xuICAgICAgICBmID0gITE7XG4gICAgICB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoX3B1c2hJbnN0YW5jZVByb3BlcnR5KGEpLmNhbGwoYSwgZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTtcbiAgICB9IGNhdGNoIChyKSB7XG4gICAgICBvID0gITAsIG4gPSByO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAobykgdGhyb3cgbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cbn1cblxudmFyICQkeCA9IF9leHBvcnQ7XG52YXIgaXNBcnJheSQzID0gaXNBcnJheSRlO1xudmFyIGlzQ29uc3RydWN0b3IkMSA9IGlzQ29uc3RydWN0b3IkNDtcbnZhciBpc09iamVjdCQ5ID0gaXNPYmplY3QkajtcbnZhciB0b0Fic29sdXRlSW5kZXgkMiA9IHRvQWJzb2x1dGVJbmRleCQ1O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDUgPSBsZW5ndGhPZkFycmF5TGlrZSRjO1xudmFyIHRvSW5kZXhlZE9iamVjdCQyID0gdG9JbmRleGVkT2JqZWN0JGE7XG52YXIgY3JlYXRlUHJvcGVydHkkMiA9IGNyZWF0ZVByb3BlcnR5JDY7XG52YXIgd2VsbEtub3duU3ltYm9sJDMgPSB3ZWxsS25vd25TeW1ib2wkbTtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDMgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDU7XG52YXIgbmF0aXZlU2xpY2UgPSBhcnJheVNsaWNlJDU7XG5cbnZhciBIQVNfU1BFQ0lFU19TVVBQT1JUJDMgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDMoJ3NsaWNlJyk7XG5cbnZhciBTUEVDSUVTJDEgPSB3ZWxsS25vd25TeW1ib2wkMygnc3BlY2llcycpO1xudmFyICRBcnJheSA9IEFycmF5O1xudmFyIG1heCQxID0gTWF0aC5tYXg7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuc2xpY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc2xpY2Vcbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5ncyBhbmQgRE9NIG9iamVjdHNcbiQkeCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIUhBU19TUEVDSUVTX1NVUFBPUlQkMyB9LCB7XG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QkMih0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkNShPKTtcbiAgICB2YXIgayA9IHRvQWJzb2x1dGVJbmRleCQyKHN0YXJ0LCBsZW5ndGgpO1xuICAgIHZhciBmaW4gPSB0b0Fic29sdXRlSW5kZXgkMihlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZCwgbGVuZ3RoKTtcbiAgICAvLyBpbmxpbmUgYEFycmF5U3BlY2llc0NyZWF0ZWAgZm9yIHVzYWdlIG5hdGl2ZSBgQXJyYXkjc2xpY2VgIHdoZXJlIGl0J3MgcG9zc2libGVcbiAgICB2YXIgQ29uc3RydWN0b3IsIHJlc3VsdCwgbjtcbiAgICBpZiAoaXNBcnJheSQzKE8pKSB7XG4gICAgICBDb25zdHJ1Y3RvciA9IE8uY29uc3RydWN0b3I7XG4gICAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgICAgaWYgKGlzQ29uc3RydWN0b3IkMShDb25zdHJ1Y3RvcikgJiYgKENvbnN0cnVjdG9yID09PSAkQXJyYXkgfHwgaXNBcnJheSQzKENvbnN0cnVjdG9yLnByb3RvdHlwZSkpKSB7XG4gICAgICAgIENvbnN0cnVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdCQ5KENvbnN0cnVjdG9yKSkge1xuICAgICAgICBDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yW1NQRUNJRVMkMV07XG4gICAgICAgIGlmIChDb25zdHJ1Y3RvciA9PT0gbnVsbCkgQ29uc3RydWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoQ29uc3RydWN0b3IgPT09ICRBcnJheSB8fCBDb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVTbGljZShPLCBrLCBmaW4pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQgPSBuZXcgKENvbnN0cnVjdG9yID09PSB1bmRlZmluZWQgPyAkQXJyYXkgOiBDb25zdHJ1Y3RvcikobWF4JDEoZmluIC0gaywgMCkpO1xuICAgIGZvciAobiA9IDA7IGsgPCBmaW47IGsrKywgbisrKSBpZiAoayBpbiBPKSBjcmVhdGVQcm9wZXJ0eSQyKHJlc3VsdCwgbiwgT1trXSk7XG4gICAgcmVzdWx0Lmxlbmd0aCA9IG47XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cbnZhciBlbnRyeVZpcnR1YWwkZiA9IGVudHJ5VmlydHVhbCRpO1xuXG52YXIgc2xpY2UkNiA9IGVudHJ5VmlydHVhbCRmKCdBcnJheScpLnNsaWNlO1xuXG52YXIgaXNQcm90b3R5cGVPZiRnID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkZCA9IHNsaWNlJDY7XG5cbnZhciBBcnJheVByb3RvdHlwZSRlID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgc2xpY2UkNSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuc2xpY2U7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkZSB8fCAoaXNQcm90b3R5cGVPZiRnKEFycmF5UHJvdG90eXBlJGUsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJGUuc2xpY2UpID8gbWV0aG9kJGQgOiBvd247XG59O1xuXG52YXIgcGFyZW50JFAgPSBzbGljZSQ1O1xuXG52YXIgc2xpY2UkNCA9IHBhcmVudCRQO1xuXG52YXIgcGFyZW50JE8gPSBzbGljZSQ0O1xuXG52YXIgc2xpY2UkMyA9IHBhcmVudCRPO1xuXG52YXIgcGFyZW50JE4gPSBzbGljZSQzO1xuXG52YXIgc2xpY2UkMiA9IHBhcmVudCROO1xuXG52YXIgc2xpY2UkMSA9IHNsaWNlJDI7XG5cbnZhciBfc2xpY2VJbnN0YW5jZVByb3BlcnR5JDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoc2xpY2UkMSk7XG5cbnZhciBwYXJlbnQkTSA9IGZyb20kNDtcblxudmFyIGZyb20kMiA9IHBhcmVudCRNO1xuXG52YXIgcGFyZW50JEwgPSBmcm9tJDI7XG5cbnZhciBmcm9tJDEgPSBwYXJlbnQkTDtcblxudmFyIGZyb20gPSBmcm9tJDE7XG5cbnZhciBfQXJyYXkkZnJvbSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhmcm9tKTtcblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkNyhhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDcobywgbWluTGVuKSB7XG4gIHZhciBfY29udGV4dDtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDcobywgbWluTGVuKTtcbiAgdmFyIG4gPSBfc2xpY2VJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpLmNhbGwoX2NvbnRleHQsIDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIF9BcnJheSRmcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDcobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNyhhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoX0FycmF5JGlzQXJyYXkkMShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNyhhcnIpO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBfU3ltYm9sJDEgIT09IFwidW5kZWZpbmVkXCIgJiYgX2dldEl0ZXJhdG9yTWV0aG9kJDEoaXRlcikgIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gX0FycmF5JGZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNyhhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG52YXIgc3ltYm9sID0gc3ltYm9sJDQ7XG5cbnZhciBfU3ltYm9sID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHN5bWJvbCk7XG5cbnZhciBlbnRyeVZpcnR1YWwkZSA9IGVudHJ5VmlydHVhbCRpO1xuXG52YXIgY29uY2F0JDQgPSBlbnRyeVZpcnR1YWwkZSgnQXJyYXknKS5jb25jYXQ7XG5cbnZhciBpc1Byb3RvdHlwZU9mJGYgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCRjID0gY29uY2F0JDQ7XG5cbnZhciBBcnJheVByb3RvdHlwZSRkID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgY29uY2F0JDMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LmNvbmNhdDtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSRkIHx8IChpc1Byb3RvdHlwZU9mJGYoQXJyYXlQcm90b3R5cGUkZCwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkZC5jb25jYXQpID8gbWV0aG9kJGMgOiBvd247XG59O1xuXG52YXIgcGFyZW50JEsgPSBjb25jYXQkMztcblxudmFyIGNvbmNhdCQyID0gcGFyZW50JEs7XG5cbnZhciBjb25jYXQkMSA9IGNvbmNhdCQyO1xuXG52YXIgX2NvbmNhdEluc3RhbmNlUHJvcGVydHkgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoY29uY2F0JDEpO1xuXG52YXIgc2xpY2UgPSBzbGljZSQ0O1xuXG52YXIgX3NsaWNlSW5zdGFuY2VQcm9wZXJ0eSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhzbGljZSk7XG5cbnZhciBnZXRCdWlsdEluJDIgPSBnZXRCdWlsdEluJGM7XG52YXIgdW5jdXJyeVRoaXMkYiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgYW5PYmplY3QkNCA9IGFuT2JqZWN0JGQ7XG5cbnZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyRiKFtdLmNvbmNhdCk7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBvd25LZXlzJDUgPSBnZXRCdWlsdEluJDIoJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlJDEuZihhbk9iamVjdCQ0KGl0KSk7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdChrZXlzLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuXG52YXIgaXNBcnJheSQyID0gaXNBcnJheSQ4O1xuXG52YXIgX0FycmF5JGlzQXJyYXkgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoaXNBcnJheSQyKTtcblxudmFyICQkdyA9IF9leHBvcnQ7XG52YXIgJG1hcCA9IGFycmF5SXRlcmF0aW9uLm1hcDtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDIgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDU7XG5cbnZhciBIQVNfU1BFQ0lFU19TVVBQT1JUJDIgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDIoJ21hcCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5tYXBcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBzcGVjaWVzXG4kJHcoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUJDIgfSwge1xuICBtYXA6IGZ1bmN0aW9uIG1hcChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkbWFwKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnZhciBlbnRyeVZpcnR1YWwkZCA9IGVudHJ5VmlydHVhbCRpO1xuXG52YXIgbWFwJDYgPSBlbnRyeVZpcnR1YWwkZCgnQXJyYXknKS5tYXA7XG5cbnZhciBpc1Byb3RvdHlwZU9mJGUgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCRiID0gbWFwJDY7XG5cbnZhciBBcnJheVByb3RvdHlwZSRjID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgbWFwJDUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0Lm1hcDtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSRjIHx8IChpc1Byb3RvdHlwZU9mJGUoQXJyYXlQcm90b3R5cGUkYywgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkYy5tYXApID8gbWV0aG9kJGIgOiBvd247XG59O1xuXG52YXIgcGFyZW50JEogPSBtYXAkNTtcblxudmFyIG1hcCQ0ID0gcGFyZW50JEo7XG5cbnZhciBtYXAkMyA9IG1hcCQ0O1xuXG52YXIgX21hcEluc3RhbmNlUHJvcGVydHkgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMobWFwJDMpO1xuXG52YXIgJCR2ID0gX2V4cG9ydDtcbnZhciB0b09iamVjdCQ1ID0gdG9PYmplY3QkZTtcbnZhciBuYXRpdmVLZXlzID0gb2JqZWN0S2V5cyQzO1xudmFyIGZhaWxzJGUgPSBmYWlscyR3O1xuXG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyQzID0gZmFpbHMkZShmdW5jdGlvbiAoKSB7IG5hdGl2ZUtleXMoMSk7IH0pO1xuXG4vLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuJCR2KHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGQUlMU19PTl9QUklNSVRJVkVTJDMgfSwge1xuICBrZXlzOiBmdW5jdGlvbiBrZXlzKGl0KSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXModG9PYmplY3QkNShpdCkpO1xuICB9XG59KTtcblxudmFyIHBhdGgkbSA9IHBhdGgkdztcblxudmFyIGtleXMkMiA9IHBhdGgkbS5PYmplY3Qua2V5cztcblxudmFyIHBhcmVudCRJID0ga2V5cyQyO1xuXG52YXIga2V5cyQxID0gcGFyZW50JEk7XG5cbnZhciBrZXlzID0ga2V5cyQxO1xuXG52YXIgX09iamVjdCRrZXlzID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGtleXMpO1xuXG4vLyBUT0RPOiBSZW1vdmUgZnJvbSBgY29yZS1qc0A0YFxudmFyICQkdSA9IF9leHBvcnQ7XG52YXIgdW5jdXJyeVRoaXMkYSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciAkRGF0ZSA9IERhdGU7XG52YXIgdGhpc1RpbWVWYWx1ZSA9IHVuY3VycnlUaGlzJGEoJERhdGUucHJvdG90eXBlLmdldFRpbWUpO1xuXG4vLyBgRGF0ZS5ub3dgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1kYXRlLm5vd1xuJCR1KHsgdGFyZ2V0OiAnRGF0ZScsIHN0YXQ6IHRydWUgfSwge1xuICBub3c6IGZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4gdGhpc1RpbWVWYWx1ZShuZXcgJERhdGUoKSk7XG4gIH1cbn0pO1xuXG52YXIgcGF0aCRsID0gcGF0aCR3O1xuXG52YXIgbm93JDMgPSBwYXRoJGwuRGF0ZS5ub3c7XG5cbnZhciBwYXJlbnQkSCA9IG5vdyQzO1xuXG52YXIgbm93JDIgPSBwYXJlbnQkSDtcblxudmFyIG5vdyQxID0gbm93JDI7XG5cbnZhciBfRGF0ZSRub3cgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMobm93JDEpO1xuXG52YXIgZmFpbHMkZCA9IGZhaWxzJHc7XG5cbnZhciBhcnJheU1ldGhvZElzU3RyaWN0JDYgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUsIGFyZ3VtZW50KSB7XG4gIHZhciBtZXRob2QgPSBbXVtNRVRIT0RfTkFNRV07XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyRkKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgbWV0aG9kLmNhbGwobnVsbCwgYXJndW1lbnQgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gMTsgfSwgMSk7XG4gIH0pO1xufTtcblxudmFyICRmb3JFYWNoID0gYXJyYXlJdGVyYXRpb24uZm9yRWFjaDtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0JDUgPSBhcnJheU1ldGhvZElzU3RyaWN0JDY7XG5cbnZhciBTVFJJQ1RfTUVUSE9EJDMgPSBhcnJheU1ldGhvZElzU3RyaWN0JDUoJ2ZvckVhY2gnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbnZhciBhcnJheUZvckVhY2ggPSAhU1RSSUNUX01FVEhPRCQzID8gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICByZXR1cm4gJGZvckVhY2godGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWFycmF5LXByb3RvdHlwZS1mb3JlYWNoIC0tIHNhZmVcbn0gOiBbXS5mb3JFYWNoO1xuXG52YXIgJCR0ID0gX2V4cG9ydDtcbnZhciBmb3JFYWNoJDYgPSBhcnJheUZvckVhY2g7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktcHJvdG90eXBlLWZvcmVhY2ggLS0gc2FmZVxuJCR0KHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBbXS5mb3JFYWNoICE9PSBmb3JFYWNoJDYgfSwge1xuICBmb3JFYWNoOiBmb3JFYWNoJDZcbn0pO1xuXG52YXIgZW50cnlWaXJ0dWFsJGMgPSBlbnRyeVZpcnR1YWwkaTtcblxudmFyIGZvckVhY2gkNSA9IGVudHJ5VmlydHVhbCRjKCdBcnJheScpLmZvckVhY2g7XG5cbnZhciBwYXJlbnQkRyA9IGZvckVhY2gkNTtcblxudmFyIGZvckVhY2gkNCA9IHBhcmVudCRHO1xuXG52YXIgY2xhc3NvZiQ0ID0gY2xhc3NvZiRkO1xudmFyIGhhc093biQ0ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc1Byb3RvdHlwZU9mJGQgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCRhID0gZm9yRWFjaCQ0O1xuXG52YXIgQXJyYXlQcm90b3R5cGUkYiA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIERPTUl0ZXJhYmxlcyQxID0ge1xuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIE5vZGVMaXN0OiB0cnVlXG59O1xuXG52YXIgZm9yRWFjaCQzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5mb3JFYWNoO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJGIgfHwgKGlzUHJvdG90eXBlT2YkZChBcnJheVByb3RvdHlwZSRiLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSRiLmZvckVhY2gpXG4gICAgfHwgaGFzT3duJDQoRE9NSXRlcmFibGVzJDEsIGNsYXNzb2YkNChpdCkpID8gbWV0aG9kJGEgOiBvd247XG59O1xuXG52YXIgZm9yRWFjaCQyID0gZm9yRWFjaCQzO1xuXG52YXIgX2ZvckVhY2hJbnN0YW5jZVByb3BlcnR5ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGZvckVhY2gkMik7XG5cbnZhciAkJHMgPSBfZXhwb3J0O1xudmFyIHVuY3VycnlUaGlzJDkgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlzQXJyYXkkMSA9IGlzQXJyYXkkZTtcblxudmFyIG5hdGl2ZVJldmVyc2UgPSB1bmN1cnJ5VGhpcyQ5KFtdLnJldmVyc2UpO1xudmFyIHRlc3QkMSA9IFsxLCAyXTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5yZXZlcnNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJldmVyc2Vcbi8vIGZpeCBmb3IgU2FmYXJpIDEyLjAgYnVnXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTg4Nzk0XG4kJHMoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IFN0cmluZyh0ZXN0JDEpID09PSBTdHJpbmcodGVzdCQxLnJldmVyc2UoKSkgfSwge1xuICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnbiAtLSBkaXJ0eSBoYWNrXG4gICAgaWYgKGlzQXJyYXkkMSh0aGlzKSkgdGhpcy5sZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gbmF0aXZlUmV2ZXJzZSh0aGlzKTtcbiAgfVxufSk7XG5cbnZhciBlbnRyeVZpcnR1YWwkYiA9IGVudHJ5VmlydHVhbCRpO1xuXG52YXIgcmV2ZXJzZSQzID0gZW50cnlWaXJ0dWFsJGIoJ0FycmF5JykucmV2ZXJzZTtcblxudmFyIGlzUHJvdG90eXBlT2YkYyA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJDkgPSByZXZlcnNlJDM7XG5cbnZhciBBcnJheVByb3RvdHlwZSRhID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgcmV2ZXJzZSQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5yZXZlcnNlO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJGEgfHwgKGlzUHJvdG90eXBlT2YkYyhBcnJheVByb3RvdHlwZSRhLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSRhLnJldmVyc2UpID8gbWV0aG9kJDkgOiBvd247XG59O1xuXG52YXIgcGFyZW50JEYgPSByZXZlcnNlJDI7XG5cbnZhciByZXZlcnNlJDEgPSBwYXJlbnQkRjtcblxudmFyIHJldmVyc2UgPSByZXZlcnNlJDE7XG5cbnZhciBfcmV2ZXJzZUluc3RhbmNlUHJvcGVydHkgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMocmV2ZXJzZSk7XG5cbnZhciB0cnlUb1N0cmluZyQyID0gdHJ5VG9TdHJpbmckNjtcblxudmFyICRUeXBlRXJyb3IkNiA9IFR5cGVFcnJvcjtcblxudmFyIGRlbGV0ZVByb3BlcnR5T3JUaHJvdyQyID0gZnVuY3Rpb24gKE8sIFApIHtcbiAgaWYgKCFkZWxldGUgT1tQXSkgdGhyb3cgbmV3ICRUeXBlRXJyb3IkNignQ2Fubm90IGRlbGV0ZSBwcm9wZXJ0eSAnICsgdHJ5VG9TdHJpbmckMihQKSArICcgb2YgJyArIHRyeVRvU3RyaW5nJDIoTykpO1xufTtcblxudmFyICQkciA9IF9leHBvcnQ7XG52YXIgdG9PYmplY3QkNCA9IHRvT2JqZWN0JGU7XG52YXIgdG9BYnNvbHV0ZUluZGV4JDEgPSB0b0Fic29sdXRlSW5kZXgkNTtcbnZhciB0b0ludGVnZXJPckluZmluaXR5ID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ0O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDQgPSBsZW5ndGhPZkFycmF5TGlrZSRjO1xudmFyIHNldEFycmF5TGVuZ3RoID0gYXJyYXlTZXRMZW5ndGg7XG52YXIgZG9lc05vdEV4Y2VlZFNhZmVJbnRlZ2VyID0gZG9lc05vdEV4Y2VlZFNhZmVJbnRlZ2VyJDM7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gYXJyYXlTcGVjaWVzQ3JlYXRlJDM7XG52YXIgY3JlYXRlUHJvcGVydHkkMSA9IGNyZWF0ZVByb3BlcnR5JDY7XG52YXIgZGVsZXRlUHJvcGVydHlPclRocm93JDEgPSBkZWxldGVQcm9wZXJ0eU9yVGhyb3ckMjtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDEgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDU7XG5cbnZhciBIQVNfU1BFQ0lFU19TVVBQT1JUJDEgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDEoJ3NwbGljZScpO1xuXG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuc3BsaWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNwbGljZVxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcbiQkcih7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIUhBU19TUEVDSUVTX1NVUFBPUlQkMSB9LCB7XG4gIHNwbGljZTogZnVuY3Rpb24gc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCAvKiAsIC4uLml0ZW1zICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCQ0KHRoaXMpO1xuICAgIHZhciBsZW4gPSBsZW5ndGhPZkFycmF5TGlrZSQ0KE8pO1xuICAgIHZhciBhY3R1YWxTdGFydCA9IHRvQWJzb2x1dGVJbmRleCQxKHN0YXJ0LCBsZW4pO1xuICAgIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBpbnNlcnRDb3VudCwgYWN0dWFsRGVsZXRlQ291bnQsIEEsIGssIGZyb20sIHRvO1xuICAgIGlmIChhcmd1bWVudHNMZW5ndGggPT09IDApIHtcbiAgICAgIGluc2VydENvdW50ID0gYWN0dWFsRGVsZXRlQ291bnQgPSAwO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzTGVuZ3RoID09PSAxKSB7XG4gICAgICBpbnNlcnRDb3VudCA9IDA7XG4gICAgICBhY3R1YWxEZWxldGVDb3VudCA9IGxlbiAtIGFjdHVhbFN0YXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnNlcnRDb3VudCA9IGFyZ3VtZW50c0xlbmd0aCAtIDI7XG4gICAgICBhY3R1YWxEZWxldGVDb3VudCA9IG1pbihtYXgodG9JbnRlZ2VyT3JJbmZpbml0eShkZWxldGVDb3VudCksIDApLCBsZW4gLSBhY3R1YWxTdGFydCk7XG4gICAgfVxuICAgIGRvZXNOb3RFeGNlZWRTYWZlSW50ZWdlcihsZW4gKyBpbnNlcnRDb3VudCAtIGFjdHVhbERlbGV0ZUNvdW50KTtcbiAgICBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlKE8sIGFjdHVhbERlbGV0ZUNvdW50KTtcbiAgICBmb3IgKGsgPSAwOyBrIDwgYWN0dWFsRGVsZXRlQ291bnQ7IGsrKykge1xuICAgICAgZnJvbSA9IGFjdHVhbFN0YXJ0ICsgaztcbiAgICAgIGlmIChmcm9tIGluIE8pIGNyZWF0ZVByb3BlcnR5JDEoQSwgaywgT1tmcm9tXSk7XG4gICAgfVxuICAgIEEubGVuZ3RoID0gYWN0dWFsRGVsZXRlQ291bnQ7XG4gICAgaWYgKGluc2VydENvdW50IDwgYWN0dWFsRGVsZXRlQ291bnQpIHtcbiAgICAgIGZvciAoayA9IGFjdHVhbFN0YXJ0OyBrIDwgbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQ7IGsrKykge1xuICAgICAgICBmcm9tID0gayArIGFjdHVhbERlbGV0ZUNvdW50O1xuICAgICAgICB0byA9IGsgKyBpbnNlcnRDb3VudDtcbiAgICAgICAgaWYgKGZyb20gaW4gTykgT1t0b10gPSBPW2Zyb21dO1xuICAgICAgICBlbHNlIGRlbGV0ZVByb3BlcnR5T3JUaHJvdyQxKE8sIHRvKTtcbiAgICAgIH1cbiAgICAgIGZvciAoayA9IGxlbjsgayA+IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50ICsgaW5zZXJ0Q291bnQ7IGstLSkgZGVsZXRlUHJvcGVydHlPclRocm93JDEoTywgayAtIDEpO1xuICAgIH0gZWxzZSBpZiAoaW5zZXJ0Q291bnQgPiBhY3R1YWxEZWxldGVDb3VudCkge1xuICAgICAgZm9yIChrID0gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQ7IGsgPiBhY3R1YWxTdGFydDsgay0tKSB7XG4gICAgICAgIGZyb20gPSBrICsgYWN0dWFsRGVsZXRlQ291bnQgLSAxO1xuICAgICAgICB0byA9IGsgKyBpbnNlcnRDb3VudCAtIDE7XG4gICAgICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtcbiAgICAgICAgZWxzZSBkZWxldGVQcm9wZXJ0eU9yVGhyb3ckMShPLCB0byk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoayA9IDA7IGsgPCBpbnNlcnRDb3VudDsgaysrKSB7XG4gICAgICBPW2sgKyBhY3R1YWxTdGFydF0gPSBhcmd1bWVudHNbayArIDJdO1xuICAgIH1cbiAgICBzZXRBcnJheUxlbmd0aChPLCBsZW4gLSBhY3R1YWxEZWxldGVDb3VudCArIGluc2VydENvdW50KTtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG5cbnZhciBlbnRyeVZpcnR1YWwkYSA9IGVudHJ5VmlydHVhbCRpO1xuXG52YXIgc3BsaWNlJDQgPSBlbnRyeVZpcnR1YWwkYSgnQXJyYXknKS5zcGxpY2U7XG5cbnZhciBpc1Byb3RvdHlwZU9mJGIgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCQ4ID0gc3BsaWNlJDQ7XG5cbnZhciBBcnJheVByb3RvdHlwZSQ5ID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgc3BsaWNlJDMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LnNwbGljZTtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSQ5IHx8IChpc1Byb3RvdHlwZU9mJGIoQXJyYXlQcm90b3R5cGUkOSwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkOS5zcGxpY2UpID8gbWV0aG9kJDggOiBvd247XG59O1xuXG52YXIgcGFyZW50JEUgPSBzcGxpY2UkMztcblxudmFyIHNwbGljZSQyID0gcGFyZW50JEU7XG5cbnZhciBzcGxpY2UkMSA9IHNwbGljZSQyO1xuXG52YXIgX3NwbGljZUluc3RhbmNlUHJvcGVydHkgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoc3BsaWNlJDEpO1xuXG52YXIgJCRxID0gX2V4cG9ydDtcbnZhciAkaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLmluY2x1ZGVzO1xudmFyIGZhaWxzJGMgPSBmYWlscyR3O1xuXG4vLyBGRjk5KyBidWdcbnZhciBCUk9LRU5fT05fU1BBUlNFID0gZmFpbHMkYyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1wcm90b3R5cGUtaW5jbHVkZXMgLS0gZGV0ZWN0aW9uXG4gIHJldHVybiAhQXJyYXkoMSkuaW5jbHVkZXMoKTtcbn0pO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4kJHEoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEJST0tFTl9PTl9TUEFSU0UgfSwge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWwgLyogLCBmcm9tSW5kZXggPSAwICovKSB7XG4gICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCQ5ID0gZW50cnlWaXJ0dWFsJGk7XG5cbnZhciBpbmNsdWRlcyQ0ID0gZW50cnlWaXJ0dWFsJDkoJ0FycmF5JykuaW5jbHVkZXM7XG5cbnZhciBpc09iamVjdCQ4ID0gaXNPYmplY3QkajtcbnZhciBjbGFzc29mJDMgPSBjbGFzc29mUmF3JDI7XG52YXIgd2VsbEtub3duU3ltYm9sJDIgPSB3ZWxsS25vd25TeW1ib2wkbTtcblxudmFyIE1BVENIJDEgPSB3ZWxsS25vd25TeW1ib2wkMignbWF0Y2gnKTtcblxuLy8gYElzUmVnRXhwYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNyZWdleHBcbnZhciBpc1JlZ2V4cCA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXNSZWdFeHA7XG4gIHJldHVybiBpc09iamVjdCQ4KGl0KSAmJiAoKGlzUmVnRXhwID0gaXRbTUFUQ0gkMV0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY2xhc3NvZiQzKGl0KSA9PT0gJ1JlZ0V4cCcpO1xufTtcblxudmFyIGlzUmVnRXhwID0gaXNSZWdleHA7XG5cbnZhciAkVHlwZUVycm9yJDUgPSBUeXBlRXJyb3I7XG5cbnZhciBub3RBUmVnZXhwID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpc1JlZ0V4cChpdCkpIHtcbiAgICB0aHJvdyBuZXcgJFR5cGVFcnJvciQ1KFwiVGhlIG1ldGhvZCBkb2Vzbid0IGFjY2VwdCByZWd1bGFyIGV4cHJlc3Npb25zXCIpO1xuICB9IHJldHVybiBpdDtcbn07XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkMSA9IHdlbGxLbm93blN5bWJvbCRtO1xuXG52YXIgTUFUQ0ggPSB3ZWxsS25vd25TeW1ib2wkMSgnbWF0Y2gnKTtcblxudmFyIGNvcnJlY3RJc1JlZ2V4cExvZ2ljID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gIHZhciByZWdleHAgPSAvLi87XG4gIHRyeSB7XG4gICAgJy8uLydbTUVUSE9EX05BTUVdKHJlZ2V4cCk7XG4gIH0gY2F0Y2ggKGVycm9yMSkge1xuICAgIHRyeSB7XG4gICAgICByZWdleHBbTUFUQ0hdID0gZmFsc2U7XG4gICAgICByZXR1cm4gJy8uLydbTUVUSE9EX05BTUVdKHJlZ2V4cCk7XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7IC8qIGVtcHR5ICovIH1cbiAgfSByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgJCRwID0gX2V4cG9ydDtcbnZhciB1bmN1cnJ5VGhpcyQ4ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBub3RBUmVnRXhwID0gbm90QVJlZ2V4cDtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDEgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDU7XG52YXIgdG9TdHJpbmckNCA9IHRvU3RyaW5nJGE7XG52YXIgY29ycmVjdElzUmVnRXhwTG9naWMgPSBjb3JyZWN0SXNSZWdleHBMb2dpYztcblxudmFyIHN0cmluZ0luZGV4T2YgPSB1bmN1cnJ5VGhpcyQ4KCcnLmluZGV4T2YpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXNcbiQkcCh7IHRhcmdldDogJ1N0cmluZycsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFjb3JyZWN0SXNSZWdFeHBMb2dpYygnaW5jbHVkZXMnKSB9LCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcbiAgICByZXR1cm4gISF+c3RyaW5nSW5kZXhPZihcbiAgICAgIHRvU3RyaW5nJDQocmVxdWlyZU9iamVjdENvZXJjaWJsZSQxKHRoaXMpKSxcbiAgICAgIHRvU3RyaW5nJDQobm90QVJlZ0V4cChzZWFyY2hTdHJpbmcpKSxcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkXG4gICAgKTtcbiAgfVxufSk7XG5cbnZhciBlbnRyeVZpcnR1YWwkOCA9IGVudHJ5VmlydHVhbCRpO1xuXG52YXIgaW5jbHVkZXMkMyA9IGVudHJ5VmlydHVhbCQ4KCdTdHJpbmcnKS5pbmNsdWRlcztcblxudmFyIGlzUHJvdG90eXBlT2YkYSA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgYXJyYXlNZXRob2QgPSBpbmNsdWRlcyQ0O1xudmFyIHN0cmluZ01ldGhvZCA9IGluY2x1ZGVzJDM7XG5cbnZhciBBcnJheVByb3RvdHlwZSQ4ID0gQXJyYXkucHJvdG90eXBlO1xudmFyIFN0cmluZ1Byb3RvdHlwZSA9IFN0cmluZy5wcm90b3R5cGU7XG5cbnZhciBpbmNsdWRlcyQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5pbmNsdWRlcztcbiAgaWYgKGl0ID09PSBBcnJheVByb3RvdHlwZSQ4IHx8IChpc1Byb3RvdHlwZU9mJGEoQXJyYXlQcm90b3R5cGUkOCwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkOC5pbmNsdWRlcykpIHJldHVybiBhcnJheU1ldGhvZDtcbiAgaWYgKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyB8fCBpdCA9PT0gU3RyaW5nUHJvdG90eXBlIHx8IChpc1Byb3RvdHlwZU9mJGEoU3RyaW5nUHJvdG90eXBlLCBpdCkgJiYgb3duID09PSBTdHJpbmdQcm90b3R5cGUuaW5jbHVkZXMpKSB7XG4gICAgcmV0dXJuIHN0cmluZ01ldGhvZDtcbiAgfSByZXR1cm4gb3duO1xufTtcblxudmFyIHBhcmVudCREID0gaW5jbHVkZXMkMjtcblxudmFyIGluY2x1ZGVzJDEgPSBwYXJlbnQkRDtcblxudmFyIGluY2x1ZGVzID0gaW5jbHVkZXMkMTtcblxudmFyIF9pbmNsdWRlc0luc3RhbmNlUHJvcGVydHkgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoaW5jbHVkZXMpO1xuXG52YXIgJCRvID0gX2V4cG9ydDtcbnZhciBmYWlscyRiID0gZmFpbHMkdztcbnZhciB0b09iamVjdCQzID0gdG9PYmplY3QkZTtcbnZhciBuYXRpdmVHZXRQcm90b3R5cGVPZiA9IG9iamVjdEdldFByb3RvdHlwZU9mO1xudmFyIENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA9IGNvcnJlY3RQcm90b3R5cGVHZXR0ZXI7XG5cbnZhciBGQUlMU19PTl9QUklNSVRJVkVTJDIgPSBmYWlscyRiKGZ1bmN0aW9uICgpIHsgbmF0aXZlR2V0UHJvdG90eXBlT2YoMSk7IH0pO1xuXG4vLyBgT2JqZWN0LmdldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldHByb3RvdHlwZW9mXG4kJG8oeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZBSUxTX09OX1BSSU1JVElWRVMkMiwgc2hhbTogIUNPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiB9LCB7XG4gIGdldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCkge1xuICAgIHJldHVybiBuYXRpdmVHZXRQcm90b3R5cGVPZih0b09iamVjdCQzKGl0KSk7XG4gIH1cbn0pO1xuXG52YXIgcGF0aCRrID0gcGF0aCR3O1xuXG52YXIgZ2V0UHJvdG90eXBlT2YkNiA9IHBhdGgkay5PYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbnZhciBwYXJlbnQkQyA9IGdldFByb3RvdHlwZU9mJDY7XG5cbnZhciBnZXRQcm90b3R5cGVPZiQ1ID0gcGFyZW50JEM7XG5cbnZhciBnZXRQcm90b3R5cGVPZiQ0ID0gZ2V0UHJvdG90eXBlT2YkNTtcblxudmFyIF9PYmplY3QkZ2V0UHJvdG90eXBlT2YkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhnZXRQcm90b3R5cGVPZiQ0KTtcblxudmFyICQkbiA9IF9leHBvcnQ7XG52YXIgJGZpbHRlciA9IGFycmF5SXRlcmF0aW9uLmZpbHRlcjtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCQ1O1xuXG52YXIgSEFTX1NQRUNJRVNfU1VQUE9SVCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoJ2ZpbHRlcicpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBzcGVjaWVzXG4kJG4oeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUIH0sIHtcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJGZpbHRlcih0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG52YXIgZW50cnlWaXJ0dWFsJDcgPSBlbnRyeVZpcnR1YWwkaTtcblxudmFyIGZpbHRlciQzID0gZW50cnlWaXJ0dWFsJDcoJ0FycmF5JykuZmlsdGVyO1xuXG52YXIgaXNQcm90b3R5cGVPZiQ5ID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkNyA9IGZpbHRlciQzO1xuXG52YXIgQXJyYXlQcm90b3R5cGUkNyA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIGZpbHRlciQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5maWx0ZXI7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkNyB8fCAoaXNQcm90b3R5cGVPZiQ5KEFycmF5UHJvdG90eXBlJDcsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJDcuZmlsdGVyKSA/IG1ldGhvZCQ3IDogb3duO1xufTtcblxudmFyIHBhcmVudCRCID0gZmlsdGVyJDI7XG5cbnZhciBmaWx0ZXIkMSA9IHBhcmVudCRCO1xuXG52YXIgZmlsdGVyID0gZmlsdGVyJDE7XG5cbnZhciBfZmlsdGVySW5zdGFuY2VQcm9wZXJ0eSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhmaWx0ZXIpO1xuXG4vLyBhIHN0cmluZyBvZiBhbGwgdmFsaWQgdW5pY29kZSB3aGl0ZXNwYWNlc1xudmFyIHdoaXRlc3BhY2VzJDMgPSAnXFx1MDAwOVxcdTAwMEFcXHUwMDBCXFx1MDAwQ1xcdTAwMERcXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUyMDAwXFx1MjAwMVxcdTIwMDInICtcbiAgJ1xcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJztcblxudmFyIHVuY3VycnlUaGlzJDcgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDU7XG52YXIgdG9TdHJpbmckMyA9IHRvU3RyaW5nJGE7XG52YXIgd2hpdGVzcGFjZXMkMiA9IHdoaXRlc3BhY2VzJDM7XG5cbnZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMkNygnJy5yZXBsYWNlKTtcbnZhciBsdHJpbSA9IFJlZ0V4cCgnXlsnICsgd2hpdGVzcGFjZXMkMiArICddKycpO1xudmFyIHJ0cmltID0gUmVnRXhwKCcoXnxbXicgKyB3aGl0ZXNwYWNlcyQyICsgJ10pWycgKyB3aGl0ZXNwYWNlcyQyICsgJ10rJCcpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW0sIHRyaW1TdGFydCwgdHJpbUVuZCwgdHJpbUxlZnQsIHRyaW1SaWdodCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kJDEgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzKSB7XG4gICAgdmFyIHN0cmluZyA9IHRvU3RyaW5nJDMocmVxdWlyZU9iamVjdENvZXJjaWJsZSgkdGhpcykpO1xuICAgIGlmIChUWVBFICYgMSkgc3RyaW5nID0gcmVwbGFjZShzdHJpbmcsIGx0cmltLCAnJyk7XG4gICAgaWYgKFRZUEUgJiAyKSBzdHJpbmcgPSByZXBsYWNlKHN0cmluZywgcnRyaW0sICckMScpO1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH07XG59O1xuXG52YXIgc3RyaW5nVHJpbSA9IHtcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltTGVmdCwgdHJpbVN0YXJ0IH1gIG1ldGhvZHNcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1zdGFydFxuICBzdGFydDogY3JlYXRlTWV0aG9kJDEoMSksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbVJpZ2h0LCB0cmltRW5kIH1gIG1ldGhvZHNcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1lbmRcbiAgZW5kOiBjcmVhdGVNZXRob2QkMSgyKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUudHJpbWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltXG4gIHRyaW06IGNyZWF0ZU1ldGhvZCQxKDMpXG59O1xuXG52YXIgZ2xvYmFsJDkgPSBnbG9iYWwkbjtcbnZhciBmYWlscyRhID0gZmFpbHMkdztcbnZhciB1bmN1cnJ5VGhpcyQ2ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciB0b1N0cmluZyQyID0gdG9TdHJpbmckYTtcbnZhciB0cmltJDEgPSBzdHJpbmdUcmltLnRyaW07XG52YXIgd2hpdGVzcGFjZXMkMSA9IHdoaXRlc3BhY2VzJDM7XG5cbnZhciAkcGFyc2VJbnQkMSA9IGdsb2JhbCQ5LnBhcnNlSW50O1xudmFyIFN5bWJvbCQyID0gZ2xvYmFsJDkuU3ltYm9sO1xudmFyIElURVJBVE9SJDEgPSBTeW1ib2wkMiAmJiBTeW1ib2wkMi5pdGVyYXRvcjtcbnZhciBoZXggPSAvXlsrLV0/MHgvaTtcbnZhciBleGVjID0gdW5jdXJyeVRoaXMkNihoZXguZXhlYyk7XG52YXIgRk9SQ0VEJDcgPSAkcGFyc2VJbnQkMSh3aGl0ZXNwYWNlcyQxICsgJzA4JykgIT09IDggfHwgJHBhcnNlSW50JDEod2hpdGVzcGFjZXMkMSArICcweDE2JykgIT09IDIyXG4gIC8vIE1TIEVkZ2UgMTgtIGJyb2tlbiB3aXRoIGJveGVkIHN5bWJvbHNcbiAgfHwgKElURVJBVE9SJDEgJiYgIWZhaWxzJGEoZnVuY3Rpb24gKCkgeyAkcGFyc2VJbnQkMShPYmplY3QoSVRFUkFUT1IkMSkpOyB9KSk7XG5cbi8vIGBwYXJzZUludGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXBhcnNlaW50LXN0cmluZy1yYWRpeFxudmFyIG51bWJlclBhcnNlSW50ID0gRk9SQ0VEJDcgPyBmdW5jdGlvbiBwYXJzZUludChzdHJpbmcsIHJhZGl4KSB7XG4gIHZhciBTID0gdHJpbSQxKHRvU3RyaW5nJDIoc3RyaW5nKSk7XG4gIHJldHVybiAkcGFyc2VJbnQkMShTLCAocmFkaXggPj4+IDApIHx8IChleGVjKGhleCwgUykgPyAxNiA6IDEwKSk7XG59IDogJHBhcnNlSW50JDE7XG5cbnZhciAkJG0gPSBfZXhwb3J0O1xudmFyICRwYXJzZUludCA9IG51bWJlclBhcnNlSW50O1xuXG4vLyBgcGFyc2VJbnRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wYXJzZWludC1zdHJpbmctcmFkaXhcbiQkbSh7IGdsb2JhbDogdHJ1ZSwgZm9yY2VkOiBwYXJzZUludCAhPT0gJHBhcnNlSW50IH0sIHtcbiAgcGFyc2VJbnQ6ICRwYXJzZUludFxufSk7XG5cbnZhciBwYXRoJGogPSBwYXRoJHc7XG5cbnZhciBfcGFyc2VJbnQkMyA9IHBhdGgkai5wYXJzZUludDtcblxudmFyIHBhcmVudCRBID0gX3BhcnNlSW50JDM7XG5cbnZhciBfcGFyc2VJbnQkMiA9IHBhcmVudCRBO1xuXG52YXIgX3BhcnNlSW50ID0gX3BhcnNlSW50JDI7XG5cbnZhciBfcGFyc2VJbnQkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhfcGFyc2VJbnQpO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1hcnJheS1wcm90b3R5cGUtaW5kZXhvZiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xudmFyICQkbCA9IF9leHBvcnQ7XG52YXIgdW5jdXJyeVRoaXMkNSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXNDbGF1c2U7XG52YXIgJGluZGV4T2YgPSBhcnJheUluY2x1ZGVzLmluZGV4T2Y7XG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCQ0ID0gYXJyYXlNZXRob2RJc1N0cmljdCQ2O1xuXG52YXIgbmF0aXZlSW5kZXhPZiA9IHVuY3VycnlUaGlzJDUoW10uaW5kZXhPZik7XG5cbnZhciBORUdBVElWRV9aRVJPID0gISFuYXRpdmVJbmRleE9mICYmIDEgLyBuYXRpdmVJbmRleE9mKFsxXSwgMSwgLTApIDwgMDtcbnZhciBGT1JDRUQkNiA9IE5FR0FUSVZFX1pFUk8gfHwgIWFycmF5TWV0aG9kSXNTdHJpY3QkNCgnaW5kZXhPZicpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxuJCRsKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQkNiB9LCB7XG4gIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICB2YXIgZnJvbUluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIE5FR0FUSVZFX1pFUk9cbiAgICAgIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICAgID8gbmF0aXZlSW5kZXhPZih0aGlzLCBzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHx8IDBcbiAgICAgIDogJGluZGV4T2YodGhpcywgc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KTtcbiAgfVxufSk7XG5cbnZhciBlbnRyeVZpcnR1YWwkNiA9IGVudHJ5VmlydHVhbCRpO1xuXG52YXIgaW5kZXhPZiQzID0gZW50cnlWaXJ0dWFsJDYoJ0FycmF5JykuaW5kZXhPZjtcblxudmFyIGlzUHJvdG90eXBlT2YkOCA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJDYgPSBpbmRleE9mJDM7XG5cbnZhciBBcnJheVByb3RvdHlwZSQ2ID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgaW5kZXhPZiQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5pbmRleE9mO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJDYgfHwgKGlzUHJvdG90eXBlT2YkOChBcnJheVByb3RvdHlwZSQ2LCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSQ2LmluZGV4T2YpID8gbWV0aG9kJDYgOiBvd247XG59O1xuXG52YXIgcGFyZW50JHogPSBpbmRleE9mJDI7XG5cbnZhciBpbmRleE9mJDEgPSBwYXJlbnQkejtcblxudmFyIGluZGV4T2YgPSBpbmRleE9mJDE7XG5cbnZhciBfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoaW5kZXhPZik7XG5cbi8vIFRPRE86IFJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgXG52YXIgJCRrID0gX2V4cG9ydDtcbnZhciBERVNDUklQVE9SUyQ2ID0gZGVzY3JpcHRvcnM7XG52YXIgY3JlYXRlJDggPSBvYmplY3RDcmVhdGU7XG5cbi8vIGBPYmplY3QuY3JlYXRlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuJCRrKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgc2hhbTogIURFU0NSSVBUT1JTJDYgfSwge1xuICBjcmVhdGU6IGNyZWF0ZSQ4XG59KTtcblxudmFyIHBhdGgkaSA9IHBhdGgkdztcblxudmFyIE9iamVjdCQ0ID0gcGF0aCRpLk9iamVjdDtcblxudmFyIGNyZWF0ZSQ3ID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpIHtcbiAgcmV0dXJuIE9iamVjdCQ0LmNyZWF0ZShQLCBEKTtcbn07XG5cbnZhciBwYXJlbnQkeSA9IGNyZWF0ZSQ3O1xuXG52YXIgY3JlYXRlJDYgPSBwYXJlbnQkeTtcblxudmFyIGNyZWF0ZSQ1ID0gY3JlYXRlJDY7XG5cbnZhciBfT2JqZWN0JGNyZWF0ZSQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGNyZWF0ZSQ1KTtcblxudmFyIHBhdGgkaCA9IHBhdGgkdztcbnZhciBhcHBseSQyID0gZnVuY3Rpb25BcHBseTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWpzb24gLS0gc2FmZVxuaWYgKCFwYXRoJGguSlNPTikgcGF0aCRoLkpTT04gPSB7IHN0cmluZ2lmeTogSlNPTi5zdHJpbmdpZnkgfTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbnZhciBzdHJpbmdpZnkkMiA9IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gIHJldHVybiBhcHBseSQyKHBhdGgkaC5KU09OLnN0cmluZ2lmeSwgbnVsbCwgYXJndW1lbnRzKTtcbn07XG5cbnZhciBwYXJlbnQkeCA9IHN0cmluZ2lmeSQyO1xuXG52YXIgc3RyaW5naWZ5JDEgPSBwYXJlbnQkeDtcblxudmFyIHN0cmluZ2lmeSA9IHN0cmluZ2lmeSQxO1xuXG52YXIgX0pTT04kc3RyaW5naWZ5ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHN0cmluZ2lmeSk7XG5cbi8qIGdsb2JhbCBCdW4gLS0gRGVubyBjYXNlICovXG52YXIgZW5naW5lSXNCdW4gPSB0eXBlb2YgQnVuID09ICdmdW5jdGlvbicgJiYgQnVuICYmIHR5cGVvZiBCdW4udmVyc2lvbiA9PSAnc3RyaW5nJztcblxudmFyICRUeXBlRXJyb3IkNCA9IFR5cGVFcnJvcjtcblxudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDEgPSBmdW5jdGlvbiAocGFzc2VkLCByZXF1aXJlZCkge1xuICBpZiAocGFzc2VkIDwgcmVxdWlyZWQpIHRocm93IG5ldyAkVHlwZUVycm9yJDQoJ05vdCBlbm91Z2ggYXJndW1lbnRzJyk7XG4gIHJldHVybiBwYXNzZWQ7XG59O1xuXG52YXIgZ2xvYmFsJDggPSBnbG9iYWwkbjtcbnZhciBhcHBseSQxID0gZnVuY3Rpb25BcHBseTtcbnZhciBpc0NhbGxhYmxlJDEgPSBpc0NhbGxhYmxlJGk7XG52YXIgRU5HSU5FX0lTX0JVTiA9IGVuZ2luZUlzQnVuO1xudmFyIFVTRVJfQUdFTlQgPSBlbmdpbmVVc2VyQWdlbnQ7XG52YXIgYXJyYXlTbGljZSQxID0gYXJyYXlTbGljZSQ1O1xudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoID0gdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMTtcblxudmFyIEZ1bmN0aW9uJDEgPSBnbG9iYWwkOC5GdW5jdGlvbjtcbi8vIGRpcnR5IElFOS0gYW5kIEJ1biAwLjMuMC0gY2hlY2tzXG52YXIgV1JBUCA9IC9NU0lFIC5cXC4vLnRlc3QoVVNFUl9BR0VOVCkgfHwgRU5HSU5FX0lTX0JVTiAmJiAoZnVuY3Rpb24gKCkge1xuICB2YXIgdmVyc2lvbiA9IGdsb2JhbCQ4LkJ1bi52ZXJzaW9uLnNwbGl0KCcuJyk7XG4gIHJldHVybiB2ZXJzaW9uLmxlbmd0aCA8IDMgfHwgdmVyc2lvblswXSA9PT0gJzAnICYmICh2ZXJzaW9uWzFdIDwgMyB8fCB2ZXJzaW9uWzFdID09PSAnMycgJiYgdmVyc2lvblsyXSA9PT0gJzAnKTtcbn0pKCk7XG5cbi8vIElFOS0gLyBCdW4gMC4zLjAtIHNldFRpbWVvdXQgLyBzZXRJbnRlcnZhbCAvIHNldEltbWVkaWF0ZSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZml4XG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS90aW1lcnMtYW5kLXVzZXItcHJvbXB0cy5odG1sI3RpbWVyc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL292ZW4tc2gvYnVuL2lzc3Vlcy8xNjMzXG52YXIgc2NoZWR1bGVyc0ZpeCQyID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgaGFzVGltZUFyZykge1xuICB2YXIgZmlyc3RQYXJhbUluZGV4ID0gaGFzVGltZUFyZyA/IDIgOiAxO1xuICByZXR1cm4gV1JBUCA/IGZ1bmN0aW9uIChoYW5kbGVyLCB0aW1lb3V0IC8qICwgLi4uYXJndW1lbnRzICovKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDEpID4gZmlyc3RQYXJhbUluZGV4O1xuICAgIHZhciBmbiA9IGlzQ2FsbGFibGUkMShoYW5kbGVyKSA/IGhhbmRsZXIgOiBGdW5jdGlvbiQxKGhhbmRsZXIpO1xuICAgIHZhciBwYXJhbXMgPSBib3VuZEFyZ3MgPyBhcnJheVNsaWNlJDEoYXJndW1lbnRzLCBmaXJzdFBhcmFtSW5kZXgpIDogW107XG4gICAgdmFyIGNhbGxiYWNrID0gYm91bmRBcmdzID8gZnVuY3Rpb24gKCkge1xuICAgICAgYXBwbHkkMShmbiwgdGhpcywgcGFyYW1zKTtcbiAgICB9IDogZm47XG4gICAgcmV0dXJuIGhhc1RpbWVBcmcgPyBzY2hlZHVsZXIoY2FsbGJhY2ssIHRpbWVvdXQpIDogc2NoZWR1bGVyKGNhbGxiYWNrKTtcbiAgfSA6IHNjaGVkdWxlcjtcbn07XG5cbnZhciAkJGogPSBfZXhwb3J0O1xudmFyIGdsb2JhbCQ3ID0gZ2xvYmFsJG47XG52YXIgc2NoZWR1bGVyc0ZpeCQxID0gc2NoZWR1bGVyc0ZpeCQyO1xuXG52YXIgc2V0SW50ZXJ2YWwkMiA9IHNjaGVkdWxlcnNGaXgkMShnbG9iYWwkNy5zZXRJbnRlcnZhbCwgdHJ1ZSk7XG5cbi8vIEJ1biAvIElFOS0gc2V0SW50ZXJ2YWwgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZpeFxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvdGltZXJzLWFuZC11c2VyLXByb21wdHMuaHRtbCNkb20tc2V0aW50ZXJ2YWxcbiQkaih7IGdsb2JhbDogdHJ1ZSwgYmluZDogdHJ1ZSwgZm9yY2VkOiBnbG9iYWwkNy5zZXRJbnRlcnZhbCAhPT0gc2V0SW50ZXJ2YWwkMiB9LCB7XG4gIHNldEludGVydmFsOiBzZXRJbnRlcnZhbCQyXG59KTtcblxudmFyICQkaSA9IF9leHBvcnQ7XG52YXIgZ2xvYmFsJDYgPSBnbG9iYWwkbjtcbnZhciBzY2hlZHVsZXJzRml4ID0gc2NoZWR1bGVyc0ZpeCQyO1xuXG52YXIgc2V0VGltZW91dCQzID0gc2NoZWR1bGVyc0ZpeChnbG9iYWwkNi5zZXRUaW1lb3V0LCB0cnVlKTtcblxuLy8gQnVuIC8gSUU5LSBzZXRUaW1lb3V0IGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmaXhcbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3RpbWVycy1hbmQtdXNlci1wcm9tcHRzLmh0bWwjZG9tLXNldHRpbWVvdXRcbiQkaSh7IGdsb2JhbDogdHJ1ZSwgYmluZDogdHJ1ZSwgZm9yY2VkOiBnbG9iYWwkNi5zZXRUaW1lb3V0ICE9PSBzZXRUaW1lb3V0JDMgfSwge1xuICBzZXRUaW1lb3V0OiBzZXRUaW1lb3V0JDNcbn0pO1xuXG52YXIgcGF0aCRnID0gcGF0aCR3O1xuXG52YXIgc2V0VGltZW91dCQyID0gcGF0aCRnLnNldFRpbWVvdXQ7XG5cbnZhciBzZXRUaW1lb3V0JDEgPSBzZXRUaW1lb3V0JDI7XG5cbnZhciBfc2V0VGltZW91dCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhzZXRUaW1lb3V0JDEpO1xuXG52YXIgdG9PYmplY3QkMiA9IHRvT2JqZWN0JGU7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gdG9BYnNvbHV0ZUluZGV4JDU7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMyA9IGxlbmd0aE9mQXJyYXlMaWtlJGM7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZmlsbGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWxsXG52YXIgYXJyYXlGaWxsID0gZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiAsIHN0YXJ0ID0gMCwgZW5kID0gQGxlbmd0aCAqLykge1xuICB2YXIgTyA9IHRvT2JqZWN0JDIodGhpcyk7XG4gIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQzKE8pO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGFyZ3VtZW50c0xlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBhcmd1bWVudHNMZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICB2YXIgZW5kUG9zID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW5ndGgpO1xuICB3aGlsZSAoZW5kUG9zID4gaW5kZXgpIE9baW5kZXgrK10gPSB2YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgJCRoID0gX2V4cG9ydDtcbnZhciBmaWxsJDQgPSBhcnJheUZpbGw7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZmlsbGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWxsXG4kJGgoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlIH0sIHtcbiAgZmlsbDogZmlsbCQ0XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCQ1ID0gZW50cnlWaXJ0dWFsJGk7XG5cbnZhciBmaWxsJDMgPSBlbnRyeVZpcnR1YWwkNSgnQXJyYXknKS5maWxsO1xuXG52YXIgaXNQcm90b3R5cGVPZiQ3ID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkNSA9IGZpbGwkMztcblxudmFyIEFycmF5UHJvdG90eXBlJDUgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBmaWxsJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LmZpbGw7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkNSB8fCAoaXNQcm90b3R5cGVPZiQ3KEFycmF5UHJvdG90eXBlJDUsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJDUuZmlsbCkgPyBtZXRob2QkNSA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQkdyA9IGZpbGwkMjtcblxudmFyIGZpbGwkMSA9IHBhcmVudCR3O1xuXG52YXIgZmlsbCA9IGZpbGwkMTtcblxudmFyIF9maWxsSW5zdGFuY2VQcm9wZXJ0eSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhmaWxsKTtcblxuLyohIEhhbW1lci5KUyAtIHYyLjAuMTctcmMgLSAyMDE5LTEyLTE2XG4gKiBodHRwOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanNcbiAqXG4gKiBGb3JrZWQgQnkgTmF2ZXIgZWdqc1xuICogQ29weXJpZ2h0IChjKSBoYW1tZXJqc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlICovXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQkMShzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZXh0ZW5kIG9iamVjdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyBpbiBkZXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIG9uZXMgaW4gc3JjLlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHsuLi5PYmplY3R9IG9iamVjdHNfdG9fYXNzaWduXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0YXJnZXRcbiAqL1xudmFyIGFzc2lnbjtcblxuaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSAnZnVuY3Rpb24nKSB7XG4gIGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcbiAgICB9XG5cbiAgICB2YXIgb3V0cHV0ID0gT2JqZWN0KHRhcmdldCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG5cbiAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KG5leHRLZXkpKSB7XG4gICAgICAgICAgICBvdXRwdXRbbmV4dEtleV0gPSBzb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcbn0gZWxzZSB7XG4gIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG59XG5cbnZhciBhc3NpZ24kMSA9IGFzc2lnbjtcblxudmFyIFZFTkRPUl9QUkVGSVhFUyA9IFsnJywgJ3dlYmtpdCcsICdNb3onLCAnTVMnLCAnbXMnLCAnbyddO1xudmFyIFRFU1RfRUxFTUVOVCA9IHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IHtcbiAgc3R5bGU6IHt9XG59IDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG52YXIgVFlQRV9GVU5DVElPTiA9ICdmdW5jdGlvbic7XG52YXIgcm91bmQgPSBNYXRoLnJvdW5kLFxuICAgIGFicyQxID0gTWF0aC5hYnM7XG52YXIgbm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGdldCB0aGUgcHJlZml4ZWQgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICogQHJldHVybnMge1N0cmluZ3xVbmRlZmluZWR9IHByZWZpeGVkXG4gKi9cblxuZnVuY3Rpb24gcHJlZml4ZWQob2JqLCBwcm9wZXJ0eSkge1xuICB2YXIgcHJlZml4O1xuICB2YXIgcHJvcDtcbiAgdmFyIGNhbWVsUHJvcCA9IHByb3BlcnR5WzBdLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgVkVORE9SX1BSRUZJWEVTLmxlbmd0aCkge1xuICAgIHByZWZpeCA9IFZFTkRPUl9QUkVGSVhFU1tpXTtcbiAgICBwcm9wID0gcHJlZml4ID8gcHJlZml4ICsgY2FtZWxQcm9wIDogcHJvcGVydHk7XG5cbiAgICBpZiAocHJvcCBpbiBvYmopIHtcbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH1cblxuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLW5ldy1mdW5jLCBuby1uZXN0ZWQtdGVybmFyeSAqL1xudmFyIHdpbjtcblxuaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgLy8gd2luZG93IGlzIHVuZGVmaW5lZCBpbiBub2RlLmpzXG4gIHdpbiA9IHt9O1xufSBlbHNlIHtcbiAgd2luID0gd2luZG93O1xufVxuXG52YXIgUFJFRklYRURfVE9VQ0hfQUNUSU9OID0gcHJlZml4ZWQoVEVTVF9FTEVNRU5ULnN0eWxlLCAndG91Y2hBY3Rpb24nKTtcbnZhciBOQVRJVkVfVE9VQ0hfQUNUSU9OID0gUFJFRklYRURfVE9VQ0hfQUNUSU9OICE9PSB1bmRlZmluZWQ7XG5mdW5jdGlvbiBnZXRUb3VjaEFjdGlvblByb3BzKCkge1xuICBpZiAoIU5BVElWRV9UT1VDSF9BQ1RJT04pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdG91Y2hNYXAgPSB7fTtcbiAgdmFyIGNzc1N1cHBvcnRzID0gd2luLkNTUyAmJiB3aW4uQ1NTLnN1cHBvcnRzO1xuICBbJ2F1dG8nLCAnbWFuaXB1bGF0aW9uJywgJ3Bhbi15JywgJ3Bhbi14JywgJ3Bhbi14IHBhbi15JywgJ25vbmUnXS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAvLyBJZiBjc3Muc3VwcG9ydHMgaXMgbm90IHN1cHBvcnRlZCBidXQgdGhlcmUgaXMgbmF0aXZlIHRvdWNoLWFjdGlvbiBhc3N1bWUgaXQgc3VwcG9ydHNcbiAgICAvLyBhbGwgdmFsdWVzLiBUaGlzIGlzIHRoZSBjYXNlIGZvciBJRSAxMCBhbmQgMTEuXG4gICAgcmV0dXJuIHRvdWNoTWFwW3ZhbF0gPSBjc3NTdXBwb3J0cyA/IHdpbi5DU1Muc3VwcG9ydHMoJ3RvdWNoLWFjdGlvbicsIHZhbCkgOiB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHRvdWNoTWFwO1xufVxuXG52YXIgVE9VQ0hfQUNUSU9OX0NPTVBVVEUgPSAnY29tcHV0ZSc7XG52YXIgVE9VQ0hfQUNUSU9OX0FVVE8gPSAnYXV0byc7XG52YXIgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTiA9ICdtYW5pcHVsYXRpb24nOyAvLyBub3QgaW1wbGVtZW50ZWRcblxudmFyIFRPVUNIX0FDVElPTl9OT05FID0gJ25vbmUnO1xudmFyIFRPVUNIX0FDVElPTl9QQU5fWCA9ICdwYW4teCc7XG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9ZID0gJ3Bhbi15JztcbnZhciBUT1VDSF9BQ1RJT05fTUFQID0gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpO1xuXG52YXIgTU9CSUxFX1JFR0VYID0gL21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZC9pO1xudmFyIFNVUFBPUlRfVE9VQ0ggPSAnb250b3VjaHN0YXJ0JyBpbiB3aW47XG52YXIgU1VQUE9SVF9QT0lOVEVSX0VWRU5UUyA9IHByZWZpeGVkKHdpbiwgJ1BvaW50ZXJFdmVudCcpICE9PSB1bmRlZmluZWQ7XG52YXIgU1VQUE9SVF9PTkxZX1RPVUNIID0gU1VQUE9SVF9UT1VDSCAmJiBNT0JJTEVfUkVHRVgudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJTlBVVF9UWVBFX1RPVUNIID0gJ3RvdWNoJztcbnZhciBJTlBVVF9UWVBFX1BFTiA9ICdwZW4nO1xudmFyIElOUFVUX1RZUEVfTU9VU0UgPSAnbW91c2UnO1xudmFyIElOUFVUX1RZUEVfS0lORUNUID0gJ2tpbmVjdCc7XG52YXIgQ09NUFVURV9JTlRFUlZBTCA9IDI1O1xudmFyIElOUFVUX1NUQVJUID0gMTtcbnZhciBJTlBVVF9NT1ZFID0gMjtcbnZhciBJTlBVVF9FTkQgPSA0O1xudmFyIElOUFVUX0NBTkNFTCA9IDg7XG52YXIgRElSRUNUSU9OX05PTkUgPSAxO1xudmFyIERJUkVDVElPTl9MRUZUID0gMjtcbnZhciBESVJFQ1RJT05fUklHSFQgPSA0O1xudmFyIERJUkVDVElPTl9VUCA9IDg7XG52YXIgRElSRUNUSU9OX0RPV04gPSAxNjtcbnZhciBESVJFQ1RJT05fSE9SSVpPTlRBTCA9IERJUkVDVElPTl9MRUZUIHwgRElSRUNUSU9OX1JJR0hUO1xudmFyIERJUkVDVElPTl9WRVJUSUNBTCA9IERJUkVDVElPTl9VUCB8IERJUkVDVElPTl9ET1dOO1xudmFyIERJUkVDVElPTl9BTEwgPSBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTDtcbnZhciBQUk9QU19YWSA9IFsneCcsICd5J107XG52YXIgUFJPUFNfQ0xJRU5UX1hZID0gWydjbGllbnRYJywgJ2NsaWVudFknXTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogd2FsayBvYmplY3RzIGFuZCBhcnJheXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICovXG5mdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgdmFyIGk7XG5cbiAgaWYgKCFvYmopIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAob2JqLmZvckVhY2gpIHtcbiAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IG9iai5sZW5ndGgpIHtcbiAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICBvYmouaGFzT3duUHJvcGVydHkoaSkgJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGxldCBhIGJvb2xlYW4gdmFsdWUgYWxzbyBiZSBhIGZ1bmN0aW9uIHRoYXQgbXVzdCByZXR1cm4gYSBib29sZWFuXG4gKiB0aGlzIGZpcnN0IGl0ZW0gaW4gYXJncyB3aWxsIGJlIHVzZWQgYXMgdGhlIGNvbnRleHRcbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gdmFsXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJnc11cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGJvb2xPckZuKHZhbCwgYXJncykge1xuICBpZiAodHlwZW9mIHZhbCA9PT0gVFlQRV9GVU5DVElPTikge1xuICAgIHJldHVybiB2YWwuYXBwbHkoYXJncyA/IGFyZ3NbMF0gfHwgdW5kZWZpbmVkIDogdW5kZWZpbmVkLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIHNtYWxsIGluZGV4T2Ygd3JhcHBlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBmb3VuZFxuICovXG5mdW5jdGlvbiBpblN0cihzdHIsIGZpbmQpIHtcbiAgcmV0dXJuIHN0ci5pbmRleE9mKGZpbmQpID4gLTE7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIHdoZW4gdGhlIHRvdWNoQWN0aW9ucyBhcmUgY29sbGVjdGVkIHRoZXkgYXJlIG5vdCBhIHZhbGlkIHZhbHVlLCBzbyB3ZSBuZWVkIHRvIGNsZWFuIHRoaW5ncyB1cC4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbnNcbiAqIEByZXR1cm5zIHsqfVxuICovXG5cbmZ1bmN0aW9uIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMpIHtcbiAgLy8gbm9uZVxuICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpKSB7XG4gICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICB9XG5cbiAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpO1xuICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7IC8vIGlmIGJvdGggcGFuLXggYW5kIHBhbi15IGFyZSBzZXQgKGRpZmZlcmVudCByZWNvZ25pemVyc1xuICAvLyBmb3IgZGlmZmVyZW50IGRpcmVjdGlvbnMsIGUuZy4gaG9yaXpvbnRhbCBwYW4gYnV0IHZlcnRpY2FsIHN3aXBlPylcbiAgLy8gd2UgbmVlZCBub25lIChhcyBvdGhlcndpc2Ugd2l0aCBwYW4teCBwYW4teSBjb21iaW5lZCBub25lIG9mIHRoZXNlXG4gIC8vIHJlY29nbml6ZXJzIHdpbGwgd29yaywgc2luY2UgdGhlIGJyb3dzZXIgd291bGQgaGFuZGxlIGFsbCBwYW5uaW5nXG5cbiAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcbiAgfSAvLyBwYW4teCBPUiBwYW4teVxuXG5cbiAgaWYgKGhhc1BhblggfHwgaGFzUGFuWSkge1xuICAgIHJldHVybiBoYXNQYW5YID8gVE9VQ0hfQUNUSU9OX1BBTl9YIDogVE9VQ0hfQUNUSU9OX1BBTl9ZO1xuICB9IC8vIG1hbmlwdWxhdGlvblxuXG5cbiAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04pKSB7XG4gICAgcmV0dXJuIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT047XG4gIH1cblxuICByZXR1cm4gVE9VQ0hfQUNUSU9OX0FVVE87XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFRvdWNoIEFjdGlvblxuICogc2V0cyB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgb3IgdXNlcyB0aGUganMgYWx0ZXJuYXRpdmVcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG52YXIgVG91Y2hBY3Rpb24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUb3VjaEFjdGlvbihtYW5hZ2VyLCB2YWx1ZSkge1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5zZXQodmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlIG9uIHRoZSBlbGVtZW50IG9yIGVuYWJsZSB0aGUgcG9seWZpbGxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFRvdWNoQWN0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gZmluZCBvdXQgdGhlIHRvdWNoLWFjdGlvbiBieSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICBpZiAodmFsdWUgPT09IFRPVUNIX0FDVElPTl9DT01QVVRFKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuY29tcHV0ZSgpO1xuICAgIH1cblxuICAgIGlmIChOQVRJVkVfVE9VQ0hfQUNUSU9OICYmIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlICYmIFRPVUNIX0FDVElPTl9NQVBbdmFsdWVdKSB7XG4gICAgICB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZVtQUkVGSVhFRF9UT1VDSF9BQ1RJT05dID0gdmFsdWU7XG4gICAgfVxuXG4gICAgdGhpcy5hY3Rpb25zID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBqdXN0IHJlLXNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWVcbiAgICovXG5cblxuICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHRoaXMuc2V0KHRoaXMubWFuYWdlci5vcHRpb25zLnRvdWNoQWN0aW9uKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGNvbXB1dGUgdGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgYmFzZWQgb24gdGhlIHJlY29nbml6ZXIncyBzZXR0aW5nc1xuICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxuICAgKi9cblxuXG4gIF9wcm90by5jb21wdXRlID0gZnVuY3Rpb24gY29tcHV0ZSgpIHtcbiAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgIGVhY2godGhpcy5tYW5hZ2VyLnJlY29nbml6ZXJzLCBmdW5jdGlvbiAocmVjb2duaXplcikge1xuICAgICAgaWYgKGJvb2xPckZuKHJlY29nbml6ZXIub3B0aW9ucy5lbmFibGUsIFtyZWNvZ25pemVyXSkpIHtcbiAgICAgICAgYWN0aW9ucyA9IGFjdGlvbnMuY29uY2F0KHJlY29nbml6ZXIuZ2V0VG91Y2hBY3Rpb24oKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMuam9pbignICcpKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICovXG5cblxuICBfcHJvdG8ucHJldmVudERlZmF1bHRzID0gZnVuY3Rpb24gcHJldmVudERlZmF1bHRzKGlucHV0KSB7XG4gICAgdmFyIHNyY0V2ZW50ID0gaW5wdXQuc3JjRXZlbnQ7XG4gICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0Lm9mZnNldERpcmVjdGlvbjsgLy8gaWYgdGhlIHRvdWNoIGFjdGlvbiBkaWQgcHJldmVudGVkIG9uY2UgdGhpcyBzZXNzaW9uXG5cbiAgICBpZiAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkKSB7XG4gICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuICAgIHZhciBoYXNOb25lID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9ZXTtcbiAgICB2YXIgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9YXTtcblxuICAgIGlmIChoYXNOb25lKSB7XG4gICAgICAvLyBkbyBub3QgcHJldmVudCBkZWZhdWx0cyBpZiB0aGlzIGlzIGEgdGFwIGdlc3R1cmVcbiAgICAgIHZhciBpc1RhcFBvaW50ZXIgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IDE7XG4gICAgICB2YXIgaXNUYXBNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgMjtcbiAgICAgIHZhciBpc1RhcFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IDI1MDtcblxuICAgICAgaWYgKGlzVGFwUG9pbnRlciAmJiBpc1RhcE1vdmVtZW50ICYmIGlzVGFwVG91Y2hUaW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICAvLyBgcGFuLXggcGFuLXlgIG1lYW5zIGJyb3dzZXIgaGFuZGxlcyBhbGwgc2Nyb2xsaW5nL3Bhbm5pbmcsIGRvIG5vdCBwcmV2ZW50XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGhhc05vbmUgfHwgaGFzUGFuWSAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCB8fCBoYXNQYW5YICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJldmVudFNyYyhzcmNFdmVudCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogY2FsbCBwcmV2ZW50RGVmYXVsdCB0byBwcmV2ZW50IHRoZSBicm93c2VyJ3MgZGVmYXVsdCBiZWhhdmlvciAoc2Nyb2xsaW5nIGluIG1vc3QgY2FzZXMpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNFdmVudFxuICAgKi9cblxuXG4gIF9wcm90by5wcmV2ZW50U3JjID0gZnVuY3Rpb24gcHJldmVudFNyYyhzcmNFdmVudCkge1xuICAgIHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCA9IHRydWU7XG4gICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICByZXR1cm4gVG91Y2hBY3Rpb247XG59KCk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcbiAqIEBtZXRob2QgaGFzUGFyZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gKi9cbmZ1bmN0aW9uIGhhc1BhcmVudChub2RlLCBwYXJlbnQpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludGVyc1xuICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgY29udGFpbnMgYHhgIGFuZCBgeWAgcHJvcGVydGllc1xuICovXG5cbmZ1bmN0aW9uIGdldENlbnRlcihwb2ludGVycykge1xuICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7IC8vIG5vIG5lZWQgdG8gbG9vcCB3aGVuIG9ubHkgb25lIHRvdWNoXG5cbiAgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFgpLFxuICAgICAgeTogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WSlcbiAgICB9O1xuICB9XG5cbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IHBvaW50ZXJzTGVuZ3RoKSB7XG4gICAgeCArPSBwb2ludGVyc1tpXS5jbGllbnRYO1xuICAgIHkgKz0gcG9pbnRlcnNbaV0uY2xpZW50WTtcbiAgICBpKys7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHJvdW5kKHggLyBwb2ludGVyc0xlbmd0aCksXG4gICAgeTogcm91bmQoeSAvIHBvaW50ZXJzTGVuZ3RoKVxuICB9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBjcmVhdGUgYSBzaW1wbGUgY2xvbmUgZnJvbSB0aGUgaW5wdXQgdXNlZCBmb3Igc3RvcmFnZSBvZiBmaXJzdElucHV0IGFuZCBmaXJzdE11bHRpcGxlXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqIEByZXR1cm5zIHtPYmplY3R9IGNsb25lZElucHV0RGF0YVxuICovXG5cbmZ1bmN0aW9uIHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KSB7XG4gIC8vIG1ha2UgYSBzaW1wbGUgY29weSBvZiB0aGUgcG9pbnRlcnMgYmVjYXVzZSB3ZSB3aWxsIGdldCBhIHJlZmVyZW5jZSBpZiB3ZSBkb24ndFxuICAvLyB3ZSBvbmx5IG5lZWQgY2xpZW50WFkgZm9yIHRoZSBjYWxjdWxhdGlvbnNcbiAgdmFyIHBvaW50ZXJzID0gW107XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCkge1xuICAgIHBvaW50ZXJzW2ldID0ge1xuICAgICAgY2xpZW50WDogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WCksXG4gICAgICBjbGllbnRZOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRZKVxuICAgIH07XG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0aW1lU3RhbXA6IG5vdygpLFxuICAgIHBvaW50ZXJzOiBwb2ludGVycyxcbiAgICBjZW50ZXI6IGdldENlbnRlcihwb2ludGVycyksXG4gICAgZGVsdGFYOiBpbnB1dC5kZWx0YVgsXG4gICAgZGVsdGFZOiBpbnB1dC5kZWx0YVlcbiAgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY2FsY3VsYXRlIHRoZSBhYnNvbHV0ZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMSB7eCwgeX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiB7eCwgeX1cbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2VcbiAqL1xuXG5mdW5jdGlvbiBnZXREaXN0YW5jZShwMSwgcDIsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICBwcm9wcyA9IFBST1BTX1hZO1xuICB9XG5cbiAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV07XG4gIHZhciB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge09iamVjdH0gcDFcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMlxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICovXG5cbmZ1bmN0aW9uIGdldEFuZ2xlKHAxLCBwMiwgcHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHByb3BzID0gUFJPUFNfWFk7XG4gIH1cblxuICB2YXIgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXTtcbiAgdmFyIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG4gIHJldHVybiBNYXRoLmF0YW4yKHksIHgpICogMTgwIC8gTWF0aC5QSTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IHRoZSBkaXJlY3Rpb24gYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge051bWJlcn0gZGlyZWN0aW9uXG4gKi9cblxuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4gRElSRUNUSU9OX05PTkU7XG4gIH1cblxuICBpZiAoYWJzJDEoeCkgPj0gYWJzJDEoeSkpIHtcbiAgICByZXR1cm4geCA8IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgfVxuXG4gIHJldHVybiB5IDwgMCA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCkge1xuICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyOyAvLyBsZXQgeyBvZmZzZXREZWx0YTpvZmZzZXQgPSB7fSwgcHJldkRlbHRhID0ge30sIHByZXZJbnB1dCA9IHt9IH0gPSBzZXNzaW9uO1xuICAvLyBqc2NzIHRocm93aW5nIGVycm9yIG9uIGRlZmFsdXQgZGVzdHJ1Y3R1cmVkIHZhbHVlcyBhbmQgd2l0aG91dCBkZWZhdWx0cyB0ZXN0cyBmYWlsXG5cbiAgdmFyIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgfHwge307XG4gIHZhciBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSB8fCB7fTtcbiAgdmFyIHByZXZJbnB1dCA9IHNlc3Npb24ucHJldklucHV0IHx8IHt9O1xuXG4gIGlmIChpbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX1NUQVJUIHx8IHByZXZJbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX0VORCkge1xuICAgIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhID0ge1xuICAgICAgeDogcHJldklucHV0LmRlbHRhWCB8fCAwLFxuICAgICAgeTogcHJldklucHV0LmRlbHRhWSB8fCAwXG4gICAgfTtcbiAgICBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhID0ge1xuICAgICAgeDogY2VudGVyLngsXG4gICAgICB5OiBjZW50ZXIueVxuICAgIH07XG4gIH1cblxuICBpbnB1dC5kZWx0YVggPSBwcmV2RGVsdGEueCArIChjZW50ZXIueCAtIG9mZnNldC54KTtcbiAgaW5wdXQuZGVsdGFZID0gcHJldkRlbHRhLnkgKyAoY2VudGVyLnkgLSBvZmZzZXQueSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGNhbGN1bGF0ZSB0aGUgdmVsb2NpdHkgYmV0d2VlbiB0d28gcG9pbnRzLiB1bml0IGlzIGluIHB4IHBlciBtcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVRpbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybiB7T2JqZWN0fSB2ZWxvY2l0eSBgeGAgYW5kIGB5YFxuICovXG5mdW5jdGlvbiBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIHgsIHkpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiB4IC8gZGVsdGFUaW1lIHx8IDAsXG4gICAgeTogeSAvIGRlbHRhVGltZSB8fCAwXG4gIH07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBubyBzY2FsZSBpcyAxLCBhbmQgZ29lcyBkb3duIHRvIDAgd2hlbiBwaW5jaGVkIHRvZ2V0aGVyLCBhbmQgYmlnZ2VyIHdoZW4gcGluY2hlZCBvdXRcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gc2NhbGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRTY2FsZShzdGFydCwgZW5kKSB7XG4gIHJldHVybiBnZXREaXN0YW5jZShlbmRbMF0sIGVuZFsxXSwgUFJPUFNfQ0xJRU5UX1hZKSAvIGdldERpc3RhbmNlKHN0YXJ0WzBdLCBzdGFydFsxXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHJvdGF0aW9uXG4gKi9cblxuZnVuY3Rpb24gZ2V0Um90YXRpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZ2V0QW5nbGUoZW5kWzFdLCBlbmRbMF0sIFBST1BTX0NMSUVOVF9YWSkgKyBnZXRBbmdsZShzdGFydFsxXSwgc3RhcnRbMF0sIFBST1BTX0NMSUVOVF9YWSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIHZlbG9jaXR5IGlzIGNhbGN1bGF0ZWQgZXZlcnkgeCBtc1xuICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5cbmZ1bmN0aW9uIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCkge1xuICB2YXIgbGFzdCA9IHNlc3Npb24ubGFzdEludGVydmFsIHx8IGlucHV0O1xuICB2YXIgZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gbGFzdC50aW1lU3RhbXA7XG4gIHZhciB2ZWxvY2l0eTtcbiAgdmFyIHZlbG9jaXR5WDtcbiAgdmFyIHZlbG9jaXR5WTtcbiAgdmFyIGRpcmVjdGlvbjtcblxuICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9PSBJTlBVVF9DQU5DRUwgJiYgKGRlbHRhVGltZSA+IENPTVBVVEVfSU5URVJWQUwgfHwgbGFzdC52ZWxvY2l0eSA9PT0gdW5kZWZpbmVkKSkge1xuICAgIHZhciBkZWx0YVggPSBpbnB1dC5kZWx0YVggLSBsYXN0LmRlbHRhWDtcbiAgICB2YXIgZGVsdGFZID0gaW5wdXQuZGVsdGFZIC0gbGFzdC5kZWx0YVk7XG4gICAgdmFyIHYgPSBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICB2ZWxvY2l0eVggPSB2Lng7XG4gICAgdmVsb2NpdHlZID0gdi55O1xuICAgIHZlbG9jaXR5ID0gYWJzJDEodi54KSA+IGFicyQxKHYueSkgPyB2LnggOiB2Lnk7XG4gICAgZGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGRlbHRhWCwgZGVsdGFZKTtcbiAgICBzZXNzaW9uLmxhc3RJbnRlcnZhbCA9IGlucHV0O1xuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBsYXRlc3QgdmVsb2NpdHkgaW5mbyBpZiBpdCBkb2Vzbid0IG92ZXJ0YWtlIGEgbWluaW11bSBwZXJpb2RcbiAgICB2ZWxvY2l0eSA9IGxhc3QudmVsb2NpdHk7XG4gICAgdmVsb2NpdHlYID0gbGFzdC52ZWxvY2l0eVg7XG4gICAgdmVsb2NpdHlZID0gbGFzdC52ZWxvY2l0eVk7XG4gICAgZGlyZWN0aW9uID0gbGFzdC5kaXJlY3Rpb247XG4gIH1cblxuICBpbnB1dC52ZWxvY2l0eSA9IHZlbG9jaXR5O1xuICBpbnB1dC52ZWxvY2l0eVggPSB2ZWxvY2l0eVg7XG4gIGlucHV0LnZlbG9jaXR5WSA9IHZlbG9jaXR5WTtcbiAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xufVxuXG4vKipcbiogQHByaXZhdGVcbiAqIGV4dGVuZCB0aGUgZGF0YSB3aXRoIHNvbWUgdXNhYmxlIHByb3BlcnRpZXMgbGlrZSBzY2FsZSwgcm90YXRlLCB2ZWxvY2l0eSBldGNcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYW5hZ2VyXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuXG5mdW5jdGlvbiBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KSB7XG4gIHZhciBzZXNzaW9uID0gbWFuYWdlci5zZXNzaW9uO1xuICB2YXIgcG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycztcbiAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoOyAvLyBzdG9yZSB0aGUgZmlyc3QgaW5wdXQgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBhbmQgZGlyZWN0aW9uXG5cbiAgaWYgKCFzZXNzaW9uLmZpcnN0SW5wdXQpIHtcbiAgICBzZXNzaW9uLmZpcnN0SW5wdXQgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XG4gIH0gLy8gdG8gY29tcHV0ZSBzY2FsZSBhbmQgcm90YXRpb24gd2UgbmVlZCB0byBzdG9yZSB0aGUgbXVsdGlwbGUgdG91Y2hlc1xuXG5cbiAgaWYgKHBvaW50ZXJzTGVuZ3RoID4gMSAmJiAhc2Vzc2lvbi5maXJzdE11bHRpcGxlKSB7XG4gICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICB9IGVsc2UgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gZmFsc2U7XG4gIH1cblxuICB2YXIgZmlyc3RJbnB1dCA9IHNlc3Npb24uZmlyc3RJbnB1dCxcbiAgICAgIGZpcnN0TXVsdGlwbGUgPSBzZXNzaW9uLmZpcnN0TXVsdGlwbGU7XG4gIHZhciBvZmZzZXRDZW50ZXIgPSBmaXJzdE11bHRpcGxlID8gZmlyc3RNdWx0aXBsZS5jZW50ZXIgOiBmaXJzdElucHV0LmNlbnRlcjtcbiAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlciA9IGdldENlbnRlcihwb2ludGVycyk7XG4gIGlucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICBpbnB1dC5kZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBmaXJzdElucHV0LnRpbWVTdGFtcDtcbiAgaW5wdXQuYW5nbGUgPSBnZXRBbmdsZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG4gIGlucHV0LmRpc3RhbmNlID0gZ2V0RGlzdGFuY2Uob2Zmc2V0Q2VudGVyLCBjZW50ZXIpO1xuICBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCk7XG4gIGlucHV0Lm9mZnNldERpcmVjdGlvbiA9IGdldERpcmVjdGlvbihpbnB1dC5kZWx0YVgsIGlucHV0LmRlbHRhWSk7XG4gIHZhciBvdmVyYWxsVmVsb2NpdHkgPSBnZXRWZWxvY2l0eShpbnB1dC5kZWx0YVRpbWUsIGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcbiAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5WCA9IG92ZXJhbGxWZWxvY2l0eS54O1xuICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZID0gb3ZlcmFsbFZlbG9jaXR5Lnk7XG4gIGlucHV0Lm92ZXJhbGxWZWxvY2l0eSA9IGFicyQxKG92ZXJhbGxWZWxvY2l0eS54KSA+IGFicyQxKG92ZXJhbGxWZWxvY2l0eS55KSA/IG92ZXJhbGxWZWxvY2l0eS54IDogb3ZlcmFsbFZlbG9jaXR5Lnk7XG4gIGlucHV0LnNjYWxlID0gZmlyc3RNdWx0aXBsZSA/IGdldFNjYWxlKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDE7XG4gIGlucHV0LnJvdGF0aW9uID0gZmlyc3RNdWx0aXBsZSA/IGdldFJvdGF0aW9uKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDA7XG4gIGlucHV0Lm1heFBvaW50ZXJzID0gIXNlc3Npb24ucHJldklucHV0ID8gaW5wdXQucG9pbnRlcnMubGVuZ3RoIDogaW5wdXQucG9pbnRlcnMubGVuZ3RoID4gc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiBzZXNzaW9uLnByZXZJbnB1dC5tYXhQb2ludGVycztcbiAgY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KTsgLy8gZmluZCB0aGUgY29ycmVjdCB0YXJnZXRcblxuICB2YXIgdGFyZ2V0ID0gbWFuYWdlci5lbGVtZW50O1xuICB2YXIgc3JjRXZlbnQgPSBpbnB1dC5zcmNFdmVudDtcbiAgdmFyIHNyY0V2ZW50VGFyZ2V0O1xuXG4gIGlmIChzcmNFdmVudC5jb21wb3NlZFBhdGgpIHtcbiAgICBzcmNFdmVudFRhcmdldCA9IHNyY0V2ZW50LmNvbXBvc2VkUGF0aCgpWzBdO1xuICB9IGVsc2UgaWYgKHNyY0V2ZW50LnBhdGgpIHtcbiAgICBzcmNFdmVudFRhcmdldCA9IHNyY0V2ZW50LnBhdGhbMF07XG4gIH0gZWxzZSB7XG4gICAgc3JjRXZlbnRUYXJnZXQgPSBzcmNFdmVudC50YXJnZXQ7XG4gIH1cblxuICBpZiAoaGFzUGFyZW50KHNyY0V2ZW50VGFyZ2V0LCB0YXJnZXQpKSB7XG4gICAgdGFyZ2V0ID0gc3JjRXZlbnRUYXJnZXQ7XG4gIH1cblxuICBpbnB1dC50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGhhbmRsZSBpbnB1dCBldmVudHNcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZVxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cblxuZnVuY3Rpb24gaW5wdXRIYW5kbGVyKG1hbmFnZXIsIGV2ZW50VHlwZSwgaW5wdXQpIHtcbiAgdmFyIHBvaW50ZXJzTGVuID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoO1xuICB2YXIgY2hhbmdlZFBvaW50ZXJzTGVuID0gaW5wdXQuY2hhbmdlZFBvaW50ZXJzLmxlbmd0aDtcbiAgdmFyIGlzRmlyc3QgPSBldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiBwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMDtcbiAgdmFyIGlzRmluYWwgPSBldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiBwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMDtcbiAgaW5wdXQuaXNGaXJzdCA9ICEhaXNGaXJzdDtcbiAgaW5wdXQuaXNGaW5hbCA9ICEhaXNGaW5hbDtcblxuICBpZiAoaXNGaXJzdCkge1xuICAgIG1hbmFnZXIuc2Vzc2lvbiA9IHt9O1xuICB9IC8vIHNvdXJjZSBldmVudCBpcyB0aGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgZG9tRXZlbnRzXG4gIC8vIGxpa2UgJ3RvdWNoc3RhcnQsIG1vdXNldXAsIHBvaW50ZXJkb3duJ1xuXG5cbiAgaW5wdXQuZXZlbnRUeXBlID0gZXZlbnRUeXBlOyAvLyBjb21wdXRlIHNjYWxlLCByb3RhdGlvbiBldGNcblxuICBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KTsgLy8gZW1pdCBzZWNyZXQgZXZlbnRcblxuICBtYW5hZ2VyLmVtaXQoJ2hhbW1lci5pbnB1dCcsIGlucHV0KTtcbiAgbWFuYWdlci5yZWNvZ25pemUoaW5wdXQpO1xuICBtYW5hZ2VyLnNlc3Npb24ucHJldklucHV0ID0gaW5wdXQ7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIHNwbGl0IHN0cmluZyBvbiB3aGl0ZXNwYWNlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7QXJyYXl9IHdvcmRzXG4gKi9cbmZ1bmN0aW9uIHNwbGl0U3RyKHN0cikge1xuICByZXR1cm4gc3RyLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogYWRkRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogcmVtb3ZlRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IHRoZSB3aW5kb3cgb2JqZWN0IG9mIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtEb2N1bWVudFZpZXd8V2luZG93fVxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3dGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgdmFyIGRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudCB8fCBlbGVtZW50O1xuICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3cgfHwgd2luZG93O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0lucHV0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxudmFyIElucHV0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW5wdXQobWFuYWdlciwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5lbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuICAgIHRoaXMudGFyZ2V0ID0gbWFuYWdlci5vcHRpb25zLmlucHV0VGFyZ2V0OyAvLyBzbWFsbGVyIHdyYXBwZXIgYXJvdW5kIHRoZSBoYW5kbGVyLCBmb3IgdGhlIHNjb3BlIGFuZCB0aGUgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgbWFuYWdlcixcbiAgICAvLyBzbyB3aGVuIGRpc2FibGVkIHRoZSBpbnB1dCBldmVudHMgYXJlIGNvbXBsZXRlbHkgYnlwYXNzZWQuXG5cbiAgICB0aGlzLmRvbUhhbmRsZXIgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIGlmIChib29sT3JGbihtYW5hZ2VyLm9wdGlvbnMuZW5hYmxlLCBbbWFuYWdlcl0pKSB7XG4gICAgICAgIHNlbGYuaGFuZGxlcihldik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuaW5pdCgpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzaG91bGQgaGFuZGxlIHRoZSBpbnB1dEV2ZW50IGRhdGEgYW5kIHRyaWdnZXIgdGhlIGNhbGxiYWNrXG4gICAqIEB2aXJ0dWFsXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IElucHV0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoKSB7fTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGJpbmQgdGhlIGV2ZW50c1xuICAgKi9cblxuXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB0aGlzLmV2RWwgJiYgYWRkRXZlbnRMaXN0ZW5lcnModGhpcy5lbGVtZW50LCB0aGlzLmV2RWwsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgdGhpcy5ldlRhcmdldCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB0aGlzLmV2V2luICYmIGFkZEV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHVuYmluZCB0aGUgZXZlbnRzXG4gICAqL1xuXG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMuZXZFbCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB0aGlzLmV2VGFyZ2V0ICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIHRoaXMuZXZXaW4gJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xuICB9O1xuXG4gIHJldHVybiBJbnB1dDtcbn0oKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5RmlsbFxuICogQHBhcmFtIHtBcnJheX0gc3JjXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICogQHBhcmFtIHtTdHJpbmd9IFtmaW5kQnlLZXldXG4gKiBAcmV0dXJuIHtCb29sZWFufE51bWJlcn0gZmFsc2Ugd2hlbiBub3QgZm91bmQsIG9yIHRoZSBpbmRleFxuICovXG5mdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCwgZmluZEJ5S2V5KSB7XG4gIGlmIChzcmMuaW5kZXhPZiAmJiAhZmluZEJ5S2V5KSB7XG4gICAgcmV0dXJuIHNyYy5pbmRleE9mKGZpbmQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xuICAgICAgaWYgKGZpbmRCeUtleSAmJiBzcmNbaV1bZmluZEJ5S2V5XSA9PSBmaW5kIHx8ICFmaW5kQnlLZXkgJiYgc3JjW2ldID09PSBmaW5kKSB7XG4gICAgICAgIC8vIGRvIG5vdCB1c2UgPT09IGhlcmUsIHRlc3QgZmFpbHNcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cbn1cblxudmFyIFBPSU5URVJfSU5QVVRfTUFQID0ge1xuICBwb2ludGVyZG93bjogSU5QVVRfU1RBUlQsXG4gIHBvaW50ZXJtb3ZlOiBJTlBVVF9NT1ZFLFxuICBwb2ludGVydXA6IElOUFVUX0VORCxcbiAgcG9pbnRlcmNhbmNlbDogSU5QVVRfQ0FOQ0VMLFxuICBwb2ludGVyb3V0OiBJTlBVVF9DQU5DRUxcbn07IC8vIGluIElFMTAgdGhlIHBvaW50ZXIgdHlwZXMgaXMgZGVmaW5lZCBhcyBhbiBlbnVtXG5cbnZhciBJRTEwX1BPSU5URVJfVFlQRV9FTlVNID0ge1xuICAyOiBJTlBVVF9UWVBFX1RPVUNILFxuICAzOiBJTlBVVF9UWVBFX1BFTixcbiAgNDogSU5QVVRfVFlQRV9NT1VTRSxcbiAgNTogSU5QVVRfVFlQRV9LSU5FQ1QgLy8gc2VlIGh0dHBzOi8vdHdpdHRlci5jb20vamFjb2Jyb3NzaS9zdGF0dXMvNDgwNTk2NDM4NDg5ODkwODE2XG5cbn07XG52YXIgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdwb2ludGVyZG93bic7XG52YXIgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ3BvaW50ZXJtb3ZlIHBvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJzsgLy8gSUUxMCBoYXMgcHJlZml4ZWQgc3VwcG9ydCwgYW5kIGNhc2Utc2Vuc2l0aXZlXG5cbmlmICh3aW4uTVNQb2ludGVyRXZlbnQgJiYgIXdpbi5Qb2ludGVyRXZlbnQpIHtcbiAgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdNU1BvaW50ZXJEb3duJztcbiAgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ01TUG9pbnRlck1vdmUgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsJztcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIFBvaW50ZXIgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cblxuXG52YXIgUG9pbnRlckV2ZW50SW5wdXQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9JbnB1dCkge1xuICBfaW5oZXJpdHNMb29zZShQb2ludGVyRXZlbnRJbnB1dCwgX0lucHV0KTtcblxuICBmdW5jdGlvbiBQb2ludGVyRXZlbnRJbnB1dCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgcHJvdG8gPSBQb2ludGVyRXZlbnRJbnB1dC5wcm90b3R5cGU7XG4gICAgcHJvdG8uZXZFbCA9IFBPSU5URVJfRUxFTUVOVF9FVkVOVFM7XG4gICAgcHJvdG8uZXZXaW4gPSBQT0lOVEVSX1dJTkRPV19FVkVOVFM7XG4gICAgX3RoaXMgPSBfSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnN0b3JlID0gX3RoaXMubWFuYWdlci5zZXNzaW9uLnBvaW50ZXJFdmVudHMgPSBbXTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFBvaW50ZXJFdmVudElucHV0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZXYpIHtcbiAgICB2YXIgc3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgIHZhciByZW1vdmVQb2ludGVyID0gZmFsc2U7XG4gICAgdmFyIGV2ZW50VHlwZU5vcm1hbGl6ZWQgPSBldi50eXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnbXMnLCAnJyk7XG4gICAgdmFyIGV2ZW50VHlwZSA9IFBPSU5URVJfSU5QVVRfTUFQW2V2ZW50VHlwZU5vcm1hbGl6ZWRdO1xuICAgIHZhciBwb2ludGVyVHlwZSA9IElFMTBfUE9JTlRFUl9UWVBFX0VOVU1bZXYucG9pbnRlclR5cGVdIHx8IGV2LnBvaW50ZXJUeXBlO1xuICAgIHZhciBpc1RvdWNoID0gcG9pbnRlclR5cGUgPT09IElOUFVUX1RZUEVfVE9VQ0g7IC8vIGdldCBpbmRleCBvZiB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG5cbiAgICB2YXIgc3RvcmVJbmRleCA9IGluQXJyYXkoc3RvcmUsIGV2LnBvaW50ZXJJZCwgJ3BvaW50ZXJJZCcpOyAvLyBzdGFydCBhbmQgbW91c2UgbXVzdCBiZSBkb3duXG5cbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKGV2LmJ1dHRvbiA9PT0gMCB8fCBpc1RvdWNoKSkge1xuICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICAgIHN0b3JlLnB1c2goZXYpO1xuICAgICAgICBzdG9yZUluZGV4ID0gc3RvcmUubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICByZW1vdmVQb2ludGVyID0gdHJ1ZTtcbiAgICB9IC8vIGl0IG5vdCBmb3VuZCwgc28gdGhlIHBvaW50ZXIgaGFzbid0IGJlZW4gZG93biAoc28gaXQncyBwcm9iYWJseSBhIGhvdmVyKVxuXG5cbiAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHVwZGF0ZSB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG5cblxuICAgIHN0b3JlW3N0b3JlSW5kZXhdID0gZXY7XG4gICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgcG9pbnRlcnM6IHN0b3JlLFxuICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlLFxuICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgfSk7XG5cbiAgICBpZiAocmVtb3ZlUG9pbnRlcikge1xuICAgICAgLy8gcmVtb3ZlIGZyb20gdGhlIHN0b3JlXG4gICAgICBzdG9yZS5zcGxpY2Uoc3RvcmVJbmRleCwgMSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBQb2ludGVyRXZlbnRJbnB1dDtcbn0oSW5wdXQpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBjb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byByZWFsIGFycmF5c1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMge0FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqLCAwKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogdW5pcXVlIGFycmF5IHdpdGggb2JqZWN0cyBiYXNlZCBvbiBhIGtleSAobGlrZSAnaWQnKSBvciBqdXN0IGJ5IHRoZSBhcnJheSdzIHZhbHVlXG4gKiBAcGFyYW0ge0FycmF5fSBzcmMgW3tpZDoxfSx7aWQ6Mn0se2lkOjF9XVxuICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzb3J0PUZhbHNlXVxuICogQHJldHVybnMge0FycmF5fSBbe2lkOjF9LHtpZDoyfV1cbiAqL1xuXG5mdW5jdGlvbiB1bmlxdWVBcnJheShzcmMsIGtleSwgc29ydCkge1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICB2YXIgdmFsdWVzID0gW107XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICB2YXIgdmFsID0ga2V5ID8gc3JjW2ldW2tleV0gOiBzcmNbaV07XG5cbiAgICBpZiAoaW5BcnJheSh2YWx1ZXMsIHZhbCkgPCAwKSB7XG4gICAgICByZXN1bHRzLnB1c2goc3JjW2ldKTtcbiAgICB9XG5cbiAgICB2YWx1ZXNbaV0gPSB2YWw7XG4gICAgaSsrO1xuICB9XG5cbiAgaWYgKHNvcnQpIHtcbiAgICBpZiAoIWtleSkge1xuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhW2tleV0gPiBiW2tleV07XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxudmFyIFRPVUNIX0lOUFVUX01BUCA9IHtcbiAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgdG91Y2hlbmQ6IElOUFVUX0VORCxcbiAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxufTtcbnZhciBUT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcbi8qKlxuICogQHByaXZhdGVcbiAqIE11bHRpLXVzZXIgdG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cblxudmFyIFRvdWNoSW5wdXQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9JbnB1dCkge1xuICBfaW5oZXJpdHNMb29zZShUb3VjaElucHV0LCBfSW5wdXQpO1xuXG4gIGZ1bmN0aW9uIFRvdWNoSW5wdXQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgVG91Y2hJbnB1dC5wcm90b3R5cGUuZXZUYXJnZXQgPSBUT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIF90aGlzID0gX0lucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50YXJnZXRJZHMgPSB7fTsgLy8gdGhpcy5ldlRhcmdldCA9IFRPVUNIX1RBUkdFVF9FVkVOVFM7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVG91Y2hJbnB1dC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKGV2KSB7XG4gICAgdmFyIHR5cGUgPSBUT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG4gICAgdmFyIHRvdWNoZXMgPSBnZXRUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuXG4gICAgaWYgKCF0b3VjaGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIHR5cGUsIHtcbiAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgICBzcmNFdmVudDogZXZcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gVG91Y2hJbnB1dDtcbn0oSW5wdXQpO1xuXG5mdW5jdGlvbiBnZXRUb3VjaGVzKGV2LCB0eXBlKSB7XG4gIHZhciBhbGxUb3VjaGVzID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgdmFyIHRhcmdldElkcyA9IHRoaXMudGFyZ2V0SWRzOyAvLyB3aGVuIHRoZXJlIGlzIG9ubHkgb25lIHRvdWNoLCB0aGUgcHJvY2VzcyBjYW4gYmUgc2ltcGxpZmllZFxuXG4gIGlmICh0eXBlICYgKElOUFVUX1NUQVJUIHwgSU5QVVRfTU9WRSkgJiYgYWxsVG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICB0YXJnZXRJZHNbYWxsVG91Y2hlc1swXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgcmV0dXJuIFthbGxUb3VjaGVzLCBhbGxUb3VjaGVzXTtcbiAgfVxuXG4gIHZhciBpO1xuICB2YXIgdGFyZ2V0VG91Y2hlcztcbiAgdmFyIGNoYW5nZWRUb3VjaGVzID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyk7XG4gIHZhciBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyA9IFtdO1xuICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7IC8vIGdldCB0YXJnZXQgdG91Y2hlcyBmcm9tIHRvdWNoZXNcblxuICB0YXJnZXRUb3VjaGVzID0gYWxsVG91Y2hlcy5maWx0ZXIoZnVuY3Rpb24gKHRvdWNoKSB7XG4gICAgcmV0dXJuIGhhc1BhcmVudCh0b3VjaC50YXJnZXQsIHRhcmdldCk7XG4gIH0pOyAvLyBjb2xsZWN0IHRvdWNoZXNcblxuICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgdGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgIHRhcmdldElkc1t0YXJnZXRUb3VjaGVzW2ldLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICAgIGkrKztcbiAgICB9XG4gIH0gLy8gZmlsdGVyIGNoYW5nZWQgdG91Y2hlcyB0byBvbmx5IGNvbnRhaW4gdG91Y2hlcyB0aGF0IGV4aXN0IGluIHRoZSBjb2xsZWN0ZWQgdGFyZ2V0IGlkc1xuXG5cbiAgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcbiAgICBpZiAodGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5wdXNoKGNoYW5nZWRUb3VjaGVzW2ldKTtcbiAgICB9IC8vIGNsZWFudXAgcmVtb3ZlZCB0b3VjaGVzXG5cblxuICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl07XG4gICAgfVxuXG4gICAgaSsrO1xuICB9XG5cbiAgaWYgKCFjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gWy8vIG1lcmdlIHRhcmdldFRvdWNoZXMgd2l0aCBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyBzbyBpdCBjb250YWlucyBBTEwgdG91Y2hlcywgaW5jbHVkaW5nICdlbmQnIGFuZCAnY2FuY2VsJ1xuICB1bmlxdWVBcnJheSh0YXJnZXRUb3VjaGVzLmNvbmNhdChjaGFuZ2VkVGFyZ2V0VG91Y2hlcyksICdpZGVudGlmaWVyJywgdHJ1ZSksIGNoYW5nZWRUYXJnZXRUb3VjaGVzXTtcbn1cblxudmFyIE1PVVNFX0lOUFVUX01BUCA9IHtcbiAgbW91c2Vkb3duOiBJTlBVVF9TVEFSVCxcbiAgbW91c2Vtb3ZlOiBJTlBVVF9NT1ZFLFxuICBtb3VzZXVwOiBJTlBVVF9FTkRcbn07XG52YXIgTU9VU0VfRUxFTUVOVF9FVkVOVFMgPSAnbW91c2Vkb3duJztcbnZhciBNT1VTRV9XSU5ET1dfRVZFTlRTID0gJ21vdXNlbW92ZSBtb3VzZXVwJztcbi8qKlxuICogQHByaXZhdGVcbiAqIE1vdXNlIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5cbnZhciBNb3VzZUlucHV0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfSW5wdXQpIHtcbiAgX2luaGVyaXRzTG9vc2UoTW91c2VJbnB1dCwgX0lucHV0KTtcblxuICBmdW5jdGlvbiBNb3VzZUlucHV0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBwcm90byA9IE1vdXNlSW5wdXQucHJvdG90eXBlO1xuICAgIHByb3RvLmV2RWwgPSBNT1VTRV9FTEVNRU5UX0VWRU5UUztcbiAgICBwcm90by5ldldpbiA9IE1PVVNFX1dJTkRPV19FVkVOVFM7XG4gICAgX3RoaXMgPSBfSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnByZXNzZWQgPSBmYWxzZTsgLy8gbW91c2Vkb3duIHN0YXRlXG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IE1vdXNlSW5wdXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5oYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihldikge1xuICAgIHZhciBldmVudFR5cGUgPSBNT1VTRV9JTlBVVF9NQVBbZXYudHlwZV07IC8vIG9uIHN0YXJ0IHdlIHdhbnQgdG8gaGF2ZSB0aGUgbGVmdCBtb3VzZSBidXR0b24gZG93blxuXG4gICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIGV2LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgdGhpcy5wcmVzc2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfTU9WRSAmJiBldi53aGljaCAhPT0gMSkge1xuICAgICAgZXZlbnRUeXBlID0gSU5QVVRfRU5EO1xuICAgIH0gLy8gbW91c2UgbXVzdCBiZSBkb3duXG5cblxuICAgIGlmICghdGhpcy5wcmVzc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgcG9pbnRlcnM6IFtldl0sXG4gICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9NT1VTRSxcbiAgICAgIHNyY0V2ZW50OiBldlxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBNb3VzZUlucHV0O1xufShJbnB1dCk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENvbWJpbmVkIHRvdWNoIGFuZCBtb3VzZSBpbnB1dFxuICpcbiAqIFRvdWNoIGhhcyBhIGhpZ2hlciBwcmlvcml0eSB0aGVuIG1vdXNlLCBhbmQgd2hpbGUgdG91Y2hpbmcgbm8gbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkLlxuICogVGhpcyBiZWNhdXNlIHRvdWNoIGRldmljZXMgYWxzbyBlbWl0IG1vdXNlIGV2ZW50cyB3aGlsZSBkb2luZyBhIHRvdWNoLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuXG52YXIgREVEVVBfVElNRU9VVCA9IDI1MDA7XG52YXIgREVEVVBfRElTVEFOQ0UgPSAyNTtcblxuZnVuY3Rpb24gc2V0TGFzdFRvdWNoKGV2ZW50RGF0YSkge1xuICB2YXIgX2V2ZW50RGF0YSRjaGFuZ2VkUG9pID0gZXZlbnREYXRhLmNoYW5nZWRQb2ludGVycyxcbiAgICAgIHRvdWNoID0gX2V2ZW50RGF0YSRjaGFuZ2VkUG9pWzBdO1xuXG4gIGlmICh0b3VjaC5pZGVudGlmaWVyID09PSB0aGlzLnByaW1hcnlUb3VjaCkge1xuICAgIHZhciBsYXN0VG91Y2ggPSB7XG4gICAgICB4OiB0b3VjaC5jbGllbnRYLFxuICAgICAgeTogdG91Y2guY2xpZW50WVxuICAgIH07XG4gICAgdmFyIGx0cyA9IHRoaXMubGFzdFRvdWNoZXM7XG4gICAgdGhpcy5sYXN0VG91Y2hlcy5wdXNoKGxhc3RUb3VjaCk7XG5cbiAgICB2YXIgcmVtb3ZlTGFzdFRvdWNoID0gZnVuY3Rpb24gcmVtb3ZlTGFzdFRvdWNoKCkge1xuICAgICAgdmFyIGkgPSBsdHMuaW5kZXhPZihsYXN0VG91Y2gpO1xuXG4gICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgIGx0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNldFRpbWVvdXQocmVtb3ZlTGFzdFRvdWNoLCBERURVUF9USU1FT1VUKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRUb3VjaGVzKGV2ZW50VHlwZSwgZXZlbnREYXRhKSB7XG4gIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkge1xuICAgIHRoaXMucHJpbWFyeVRvdWNoID0gZXZlbnREYXRhLmNoYW5nZWRQb2ludGVyc1swXS5pZGVudGlmaWVyO1xuICAgIHNldExhc3RUb3VjaC5jYWxsKHRoaXMsIGV2ZW50RGF0YSk7XG4gIH0gZWxzZSBpZiAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3ludGhldGljRXZlbnQoZXZlbnREYXRhKSB7XG4gIHZhciB4ID0gZXZlbnREYXRhLnNyY0V2ZW50LmNsaWVudFg7XG4gIHZhciB5ID0gZXZlbnREYXRhLnNyY0V2ZW50LmNsaWVudFk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxhc3RUb3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHQgPSB0aGlzLmxhc3RUb3VjaGVzW2ldO1xuICAgIHZhciBkeCA9IE1hdGguYWJzKHggLSB0LngpO1xuICAgIHZhciBkeSA9IE1hdGguYWJzKHkgLSB0LnkpO1xuXG4gICAgaWYgKGR4IDw9IERFRFVQX0RJU1RBTkNFICYmIGR5IDw9IERFRFVQX0RJU1RBTkNFKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBUb3VjaE1vdXNlSW5wdXQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICB2YXIgVG91Y2hNb3VzZUlucHV0ID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0lucHV0KSB7XG4gICAgX2luaGVyaXRzTG9vc2UoVG91Y2hNb3VzZUlucHV0LCBfSW5wdXQpO1xuXG4gICAgZnVuY3Rpb24gVG91Y2hNb3VzZUlucHV0KF9tYW5hZ2VyLCBjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfdGhpcyA9IF9JbnB1dC5jYWxsKHRoaXMsIF9tYW5hZ2VyLCBjYWxsYmFjaykgfHwgdGhpcztcblxuICAgICAgX3RoaXMuaGFuZGxlciA9IGZ1bmN0aW9uIChtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpIHtcbiAgICAgICAgdmFyIGlzVG91Y2ggPSBpbnB1dERhdGEucG9pbnRlclR5cGUgPT09IElOUFVUX1RZUEVfVE9VQ0g7XG4gICAgICAgIHZhciBpc01vdXNlID0gaW5wdXREYXRhLnBvaW50ZXJUeXBlID09PSBJTlBVVF9UWVBFX01PVVNFO1xuXG4gICAgICAgIGlmIChpc01vdXNlICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMgJiYgaW5wdXREYXRhLnNvdXJjZUNhcGFiaWxpdGllcy5maXJlc1RvdWNoRXZlbnRzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIHdoZW4gd2UncmUgaW4gYSB0b3VjaCBldmVudCwgcmVjb3JkIHRvdWNoZXMgdG8gIGRlLWR1cGUgc3ludGhldGljIG1vdXNlIGV2ZW50XG5cblxuICAgICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICAgIHJlY29yZFRvdWNoZXMuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkJDEoX2Fzc2VydFRoaXNJbml0aWFsaXplZCQxKF90aGlzKSksIGlucHV0RXZlbnQsIGlucHV0RGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb3VzZSAmJiBpc1N5bnRoZXRpY0V2ZW50LmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZCQxKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQkMShfdGhpcykpLCBpbnB1dERhdGEpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuY2FsbGJhY2sobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICAgIH07XG5cbiAgICAgIF90aGlzLnRvdWNoID0gbmV3IFRvdWNoSW5wdXQoX3RoaXMubWFuYWdlciwgX3RoaXMuaGFuZGxlcik7XG4gICAgICBfdGhpcy5tb3VzZSA9IG5ldyBNb3VzZUlucHV0KF90aGlzLm1hbmFnZXIsIF90aGlzLmhhbmRsZXIpO1xuICAgICAgX3RoaXMucHJpbWFyeVRvdWNoID0gbnVsbDtcbiAgICAgIF90aGlzLmxhc3RUb3VjaGVzID0gW107XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogaGFuZGxlIG1vdXNlIGFuZCB0b3VjaCBldmVudHNcbiAgICAgKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dEV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuXG5cbiAgICB2YXIgX3Byb3RvID0gVG91Y2hNb3VzZUlucHV0LnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnRvdWNoLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMubW91c2UuZGVzdHJveSgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVG91Y2hNb3VzZUlucHV0O1xuICB9KElucHV0KTtcblxuICByZXR1cm4gVG91Y2hNb3VzZUlucHV0O1xufSgpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICogY2FsbGVkIGJ5IHRoZSBNYW5hZ2VyIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxuICogQHJldHVybnMge0lucHV0fVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0SW5zdGFuY2UobWFuYWdlcikge1xuICB2YXIgVHlwZTsgLy8gbGV0IGlucHV0Q2xhc3MgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRDbGFzcztcblxuICB2YXIgaW5wdXRDbGFzcyA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dENsYXNzO1xuXG4gIGlmIChpbnB1dENsYXNzKSB7XG4gICAgVHlwZSA9IGlucHV0Q2xhc3M7XG4gIH0gZWxzZSBpZiAoU1VQUE9SVF9QT0lOVEVSX0VWRU5UUykge1xuICAgIFR5cGUgPSBQb2ludGVyRXZlbnRJbnB1dDtcbiAgfSBlbHNlIGlmIChTVVBQT1JUX09OTFlfVE9VQ0gpIHtcbiAgICBUeXBlID0gVG91Y2hJbnB1dDtcbiAgfSBlbHNlIGlmICghU1VQUE9SVF9UT1VDSCkge1xuICAgIFR5cGUgPSBNb3VzZUlucHV0O1xuICB9IGVsc2Uge1xuICAgIFR5cGUgPSBUb3VjaE1vdXNlSW5wdXQ7XG4gIH1cblxuICByZXR1cm4gbmV3IFR5cGUobWFuYWdlciwgaW5wdXRIYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogaWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5LCB3ZSB3YW50IHRvIGV4ZWN1dGUgdGhlIGZuIG9uIGVhY2ggZW50cnlcbiAqIGlmIGl0IGFpbnQgYW4gYXJyYXkgd2UgZG9uJ3Qgd2FudCB0byBkbyBhIHRoaW5nLlxuICogdGhpcyBpcyB1c2VkIGJ5IGFsbCB0aGUgbWV0aG9kcyB0aGF0IGFjY2VwdCBhIHNpbmdsZSBhbmQgYXJyYXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp8QXJyYXl9IGFyZ1xuICogQHBhcmFtIHtTdHJpbmd9IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpbnZva2VBcnJheUFyZyhhcmcsIGZuLCBjb250ZXh0KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICBlYWNoKGFyZywgY29udGV4dFtmbl0sIGNvbnRleHQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgU1RBVEVfUE9TU0lCTEUgPSAxO1xudmFyIFNUQVRFX0JFR0FOID0gMjtcbnZhciBTVEFURV9DSEFOR0VEID0gNDtcbnZhciBTVEFURV9FTkRFRCA9IDg7XG52YXIgU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX0VOREVEO1xudmFyIFNUQVRFX0NBTkNFTExFRCA9IDE2O1xudmFyIFNUQVRFX0ZBSUxFRCA9IDMyO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgYSB1bmlxdWUgaWRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHVuaXF1ZUlkXG4gKi9cbnZhciBfdW5pcXVlSWQgPSAxO1xuZnVuY3Rpb24gdW5pcXVlSWQoKSB7XG4gIHJldHVybiBfdW5pcXVlSWQrKztcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IGEgcmVjb2duaXplciBieSBuYW1lIGlmIGl0IGlzIGJvdW5kIHRvIGEgbWFuYWdlclxuICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gb3RoZXJSZWNvZ25pemVyXG4gKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcbiAqIEByZXR1cm5zIHtSZWNvZ25pemVyfVxuICovXG5mdW5jdGlvbiBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgcmVjb2duaXplcikge1xuICB2YXIgbWFuYWdlciA9IHJlY29nbml6ZXIubWFuYWdlcjtcblxuICBpZiAobWFuYWdlcikge1xuICAgIHJldHVybiBtYW5hZ2VyLmdldChvdGhlclJlY29nbml6ZXIpO1xuICB9XG5cbiAgcmV0dXJuIG90aGVyUmVjb2duaXplcjtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IGEgdXNhYmxlIHN0cmluZywgdXNlZCBhcyBldmVudCBwb3N0Zml4XG4gKiBAcGFyYW0ge2NvbnN0YW50fSBzdGF0ZVxuICogQHJldHVybnMge1N0cmluZ30gc3RhdGVcbiAqL1xuXG5mdW5jdGlvbiBzdGF0ZVN0cihzdGF0ZSkge1xuICBpZiAoc3RhdGUgJiBTVEFURV9DQU5DRUxMRUQpIHtcbiAgICByZXR1cm4gJ2NhbmNlbCc7XG4gIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9FTkRFRCkge1xuICAgIHJldHVybiAnZW5kJztcbiAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0NIQU5HRUQpIHtcbiAgICByZXR1cm4gJ21vdmUnO1xuICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQkVHQU4pIHtcbiAgICByZXR1cm4gJ3N0YXJ0JztcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUmVjb2duaXplciBmbG93IGV4cGxhaW5lZDsgKlxuICogQWxsIHJlY29nbml6ZXJzIGhhdmUgdGhlIGluaXRpYWwgc3RhdGUgb2YgUE9TU0lCTEUgd2hlbiBhIGlucHV0IHNlc3Npb24gc3RhcnRzLlxuICogVGhlIGRlZmluaXRpb24gb2YgYSBpbnB1dCBzZXNzaW9uIGlzIGZyb20gdGhlIGZpcnN0IGlucHV0IHVudGlsIHRoZSBsYXN0IGlucHV0LCB3aXRoIGFsbCBpdCdzIG1vdmVtZW50IGluIGl0LiAqXG4gKiBFeGFtcGxlIHNlc3Npb24gZm9yIG1vdXNlLWlucHV0OiBtb3VzZWRvd24gLT4gbW91c2Vtb3ZlIC0+IG1vdXNldXBcbiAqXG4gKiBPbiBlYWNoIHJlY29nbml6aW5nIGN5Y2xlIChzZWUgTWFuYWdlci5yZWNvZ25pemUpIHRoZSAucmVjb2duaXplKCkgbWV0aG9kIGlzIGV4ZWN1dGVkXG4gKiB3aGljaCBkZXRlcm1pbmVzIHdpdGggc3RhdGUgaXQgc2hvdWxkIGJlLlxuICpcbiAqIElmIHRoZSByZWNvZ25pemVyIGhhcyB0aGUgc3RhdGUgRkFJTEVELCBDQU5DRUxMRUQgb3IgUkVDT0dOSVpFRCAoZXF1YWxzIEVOREVEKSwgaXQgaXMgcmVzZXQgdG9cbiAqIFBPU1NJQkxFIHRvIGdpdmUgaXQgYW5vdGhlciBjaGFuZ2Ugb24gdGhlIG5leHQgY3ljbGUuXG4gKlxuICogICAgICAgICAgICAgICBQb3NzaWJsZVxuICogICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICstLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gKiAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICstLS0tLSstLS0tLSsgICAgICAgICAgICAgICB8XG4gKiAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICB8XG4gKiAgIEZhaWxlZCAgICAgIENhbmNlbGxlZCAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0rLS0tLS0tK1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgIFJlY29nbml6ZWQgICAgICAgQmVnYW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hhbmdlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVuZGVkL1JlY29nbml6ZWRcbiAqL1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZWNvZ25pemVyXG4gKiBFdmVyeSByZWNvZ25pemVyIG5lZWRzIHRvIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxudmFyIFJlY29nbml6ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe1xuICAgICAgZW5hYmxlOiB0cnVlXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgdGhpcy5pZCA9IHVuaXF1ZUlkKCk7XG4gICAgdGhpcy5tYW5hZ2VyID0gbnVsbDsgLy8gZGVmYXVsdCBpcyBlbmFibGUgdHJ1ZVxuXG4gICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuICAgIHRoaXMuc2ltdWx0YW5lb3VzID0ge307XG4gICAgdGhpcy5yZXF1aXJlRmFpbCA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzZXQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtSZWNvZ25pemVyfVxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KG9wdGlvbnMpIHtcbiAgICBhc3NpZ24kMSh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpOyAvLyBhbHNvIHVwZGF0ZSB0aGUgdG91Y2hBY3Rpb24sIGluIGNhc2Ugc29tZXRoaW5nIGNoYW5nZWQgYWJvdXQgdGhlIGRpcmVjdGlvbnMvZW5hYmxlZCBzdGF0ZVxuXG4gICAgdGhpcy5tYW5hZ2VyICYmIHRoaXMubWFuYWdlci50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyLlxuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgKi9cblxuXG4gIF9wcm90by5yZWNvZ25pemVXaXRoID0gZnVuY3Rpb24gcmVjb2duaXplV2l0aChvdGhlclJlY29nbml6ZXIpIHtcbiAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgc2ltdWx0YW5lb3VzID0gdGhpcy5zaW11bHRhbmVvdXM7XG4gICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuXG4gICAgaWYgKCFzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSkge1xuICAgICAgc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0gPSBvdGhlclJlY29nbml6ZXI7XG4gICAgICBvdGhlclJlY29nbml6ZXIucmVjb2duaXplV2l0aCh0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGRyb3AgdGhlIHNpbXVsdGFuZW91cyBsaW5rLiBpdCBkb2VzbnQgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgKi9cblxuXG4gIF9wcm90by5kcm9wUmVjb2duaXplV2l0aCA9IGZ1bmN0aW9uIGRyb3BSZWNvZ25pemVXaXRoKG90aGVyUmVjb2duaXplcikge1xuICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdkcm9wUmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgZGVsZXRlIHRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiByZWNvZ25pemVyIGNhbiBvbmx5IHJ1biB3aGVuIGFuIG90aGVyIGlzIGZhaWxpbmdcbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICovXG5cblxuICBfcHJvdG8ucmVxdWlyZUZhaWx1cmUgPSBmdW5jdGlvbiByZXF1aXJlRmFpbHVyZShvdGhlclJlY29nbml6ZXIpIHtcbiAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHJlcXVpcmVGYWlsID0gdGhpcy5yZXF1aXJlRmFpbDtcbiAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG5cbiAgICBpZiAoaW5BcnJheShyZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKSA9PT0gLTEpIHtcbiAgICAgIHJlcXVpcmVGYWlsLnB1c2gob3RoZXJSZWNvZ25pemVyKTtcbiAgICAgIG90aGVyUmVjb2duaXplci5yZXF1aXJlRmFpbHVyZSh0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGRyb3AgdGhlIHJlcXVpcmVGYWlsdXJlIGxpbmsuIGl0IGRvZXMgbm90IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICovXG5cblxuICBfcHJvdG8uZHJvcFJlcXVpcmVGYWlsdXJlID0gZnVuY3Rpb24gZHJvcFJlcXVpcmVGYWlsdXJlKG90aGVyUmVjb2duaXplcikge1xuICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdkcm9wUmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgIHZhciBpbmRleCA9IGluQXJyYXkodGhpcy5yZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKTtcblxuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLnJlcXVpcmVGYWlsLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBoYXMgcmVxdWlyZSBmYWlsdXJlcyBib29sZWFuXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cblxuXG4gIF9wcm90by5oYXNSZXF1aXJlRmFpbHVyZXMgPSBmdW5jdGlvbiBoYXNSZXF1aXJlRmFpbHVyZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoID4gMDtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGlmIHRoZSByZWNvZ25pemVyIGNhbiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplclxuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG5cblxuICBfcHJvdG8uY2FuUmVjb2duaXplV2l0aCA9IGZ1bmN0aW9uIGNhblJlY29nbml6ZVdpdGgob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgcmV0dXJuICEhdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFlvdSBzaG91bGQgdXNlIGB0cnlFbWl0YCBpbnN0ZWFkIG9mIGBlbWl0YCBkaXJlY3RseSB0byBjaGVja1xuICAgKiB0aGF0IGFsbCB0aGUgbmVlZGVkIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQgYmVmb3JlIGVtaXR0aW5nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICovXG5cblxuICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoaW5wdXQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgIGZ1bmN0aW9uIGVtaXQoZXZlbnQpIHtcbiAgICAgIHNlbGYubWFuYWdlci5lbWl0KGV2ZW50LCBpbnB1dCk7XG4gICAgfSAvLyAncGFuc3RhcnQnIGFuZCAncGFubW92ZSdcblxuXG4gICAgaWYgKHN0YXRlIDwgU1RBVEVfRU5ERUQpIHtcbiAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgc3RhdGVTdHIoc3RhdGUpKTtcbiAgICB9XG5cbiAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCk7IC8vIHNpbXBsZSAnZXZlbnROYW1lJyBldmVudHNcblxuICAgIGlmIChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpIHtcbiAgICAgIC8vIGFkZGl0aW9uYWwgZXZlbnQocGFubGVmdCwgcGFucmlnaHQsIHBpbmNoaW4sIHBpbmNob3V0Li4uKVxuICAgICAgZW1pdChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpO1xuICAgIH0gLy8gcGFuZW5kIGFuZCBwYW5jYW5jZWxcblxuXG4gICAgaWYgKHN0YXRlID49IFNUQVRFX0VOREVEKSB7XG4gICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQ2hlY2sgdGhhdCBhbGwgdGhlIHJlcXVpcmUgZmFpbHVyZSByZWNvZ25pemVycyBoYXMgZmFpbGVkLFxuICAgKiBpZiB0cnVlLCBpdCBlbWl0cyBhIGdlc3R1cmUgZXZlbnQsXG4gICAqIG90aGVyd2lzZSwgc2V0dXAgdGhlIHN0YXRlIHRvIEZBSUxFRC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqL1xuXG5cbiAgX3Byb3RvLnRyeUVtaXQgPSBmdW5jdGlvbiB0cnlFbWl0KGlucHV0KSB7XG4gICAgaWYgKHRoaXMuY2FuRW1pdCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KGlucHV0KTtcbiAgICB9IC8vIGl0J3MgZmFpbGluZyBhbnl3YXlcblxuXG4gICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGNhbiB3ZSBlbWl0P1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG5cblxuICBfcHJvdG8uY2FuRW1pdCA9IGZ1bmN0aW9uIGNhbkVtaXQoKSB7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aCkge1xuICAgICAgaWYgKCEodGhpcy5yZXF1aXJlRmFpbFtpXS5zdGF0ZSAmIChTVEFURV9GQUlMRUQgfCBTVEFURV9QT1NTSUJMRSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogdXBkYXRlIHRoZSByZWNvZ25pemVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICovXG5cblxuICBfcHJvdG8ucmVjb2duaXplID0gZnVuY3Rpb24gcmVjb2duaXplKGlucHV0RGF0YSkge1xuICAgIC8vIG1ha2UgYSBuZXcgY29weSBvZiB0aGUgaW5wdXREYXRhXG4gICAgLy8gc28gd2UgY2FuIGNoYW5nZSB0aGUgaW5wdXREYXRhIHdpdGhvdXQgbWVzc2luZyB1cCB0aGUgb3RoZXIgcmVjb2duaXplcnNcbiAgICB2YXIgaW5wdXREYXRhQ2xvbmUgPSBhc3NpZ24kMSh7fSwgaW5wdXREYXRhKTsgLy8gaXMgaXMgZW5hYmxlZCBhbmQgYWxsb3cgcmVjb2duaXppbmc/XG5cbiAgICBpZiAoIWJvb2xPckZuKHRoaXMub3B0aW9ucy5lbmFibGUsIFt0aGlzLCBpbnB1dERhdGFDbG9uZV0pKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gcmVzZXQgd2hlbiB3ZSd2ZSByZWFjaGVkIHRoZSBlbmRcblxuXG4gICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfUkVDT0dOSVpFRCB8IFNUQVRFX0NBTkNFTExFRCB8IFNUQVRFX0ZBSUxFRCkpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QT1NTSUJMRTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gdGhpcy5wcm9jZXNzKGlucHV0RGF0YUNsb25lKTsgLy8gdGhlIHJlY29nbml6ZXIgaGFzIHJlY29nbml6ZWQgYSBnZXN0dXJlXG4gICAgLy8gc28gdHJpZ2dlciBhbiBldmVudFxuXG4gICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQgfCBTVEFURV9DQU5DRUxMRUQpKSB7XG4gICAgICB0aGlzLnRyeUVtaXQoaW5wdXREYXRhQ2xvbmUpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHJldHVybiB0aGUgc3RhdGUgb2YgdGhlIHJlY29nbml6ZXJcbiAgICogdGhlIGFjdHVhbCByZWNvZ25pemluZyBoYXBwZW5zIGluIHRoaXMgbWV0aG9kXG4gICAqIEB2aXJ0dWFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICogQHJldHVybnMge2NvbnN0YW50fSBTVEFURVxuICAgKi9cblxuICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG5cblxuICBfcHJvdG8ucHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MoaW5wdXREYXRhKSB7fTtcbiAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogcmV0dXJuIHRoZSBwcmVmZXJyZWQgdG91Y2gtYWN0aW9uXG4gICAqIEB2aXJ0dWFsXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG5cblxuICBfcHJvdG8uZ2V0VG91Y2hBY3Rpb24gPSBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHt9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogY2FsbGVkIHdoZW4gdGhlIGdlc3R1cmUgaXNuJ3QgYWxsb3dlZCB0byByZWNvZ25pemVcbiAgICogbGlrZSB3aGVuIGFub3RoZXIgaXMgYmVpbmcgcmVjb2duaXplZCBvciBpdCBpcyBkaXNhYmxlZFxuICAgKiBAdmlydHVhbFxuICAgKi9cblxuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge307XG5cbiAgcmV0dXJuIFJlY29nbml6ZXI7XG59KCk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEEgdGFwIGlzIHJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb2luZyBhIHNtYWxsIHRhcC9jbGljay4gTXVsdGlwbGUgdGFwcyBhcmUgcmVjb2duaXplZCBpZiB0aGV5IG9jY3VyXG4gKiBiZXR3ZWVuIHRoZSBnaXZlbiBpbnRlcnZhbCBhbmQgcG9zaXRpb24uIFRoZSBkZWxheSBvcHRpb24gY2FuIGJlIHVzZWQgdG8gcmVjb2duaXplIG11bHRpLXRhcHMgd2l0aG91dCBmaXJpbmdcbiAqIGEgc2luZ2xlIHRhcC5cbiAqXG4gKiBUaGUgZXZlbnREYXRhIGZyb20gdGhlIGVtaXR0ZWQgZXZlbnQgY29udGFpbnMgdGhlIHByb3BlcnR5IGB0YXBDb3VudGAsIHdoaWNoIGNvbnRhaW5zIHRoZSBhbW91bnQgb2ZcbiAqIG11bHRpLXRhcHMgYmVpbmcgcmVjb2duaXplZC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUmVjb2duaXplclxuICovXG5cbnZhciBUYXBSZWNvZ25pemVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVjb2duaXplcikge1xuICBfaW5oZXJpdHNMb29zZShUYXBSZWNvZ25pemVyLCBfUmVjb2duaXplcik7XG5cbiAgZnVuY3Rpb24gVGFwUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICBldmVudDogJ3RhcCcsXG4gICAgICBwb2ludGVyczogMSxcbiAgICAgIHRhcHM6IDEsXG4gICAgICBpbnRlcnZhbDogMzAwLFxuICAgICAgLy8gbWF4IHRpbWUgYmV0d2VlbiB0aGUgbXVsdGktdGFwIHRhcHNcbiAgICAgIHRpbWU6IDI1MCxcbiAgICAgIC8vIG1heCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIGRvd24gKGxpa2UgZmluZ2VyIG9uIHRoZSBzY3JlZW4pXG4gICAgICB0aHJlc2hvbGQ6IDksXG4gICAgICAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xuICAgICAgcG9zVGhyZXNob2xkOiAxMFxuICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzOyAvLyBwcmV2aW91cyB0aW1lIGFuZCBjZW50ZXIsXG4gICAgLy8gdXNlZCBmb3IgdGFwIGNvdW50aW5nXG5cbiAgICBfdGhpcy5wVGltZSA9IGZhbHNlO1xuICAgIF90aGlzLnBDZW50ZXIgPSBmYWxzZTtcbiAgICBfdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIF90aGlzLl9pbnB1dCA9IG51bGw7XG4gICAgX3RoaXMuY291bnQgPSAwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUYXBSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0VG91Y2hBY3Rpb24gPSBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9NQU5JUFVMQVRJT05dO1xuICB9O1xuXG4gIF9wcm90by5wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzcyhpbnB1dCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgIHZhciB2YWxpZFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IG9wdGlvbnMudGltZTtcbiAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgdGhpcy5jb3VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICB9IC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuXG5cbiAgICBpZiAodmFsaWRNb3ZlbWVudCAmJiB2YWxpZFRvdWNoVGltZSAmJiB2YWxpZFBvaW50ZXJzKSB7XG4gICAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9PSBJTlBVVF9FTkQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbGlkSW50ZXJ2YWwgPSB0aGlzLnBUaW1lID8gaW5wdXQudGltZVN0YW1wIC0gdGhpcy5wVGltZSA8IG9wdGlvbnMuaW50ZXJ2YWwgOiB0cnVlO1xuICAgICAgdmFyIHZhbGlkTXVsdGlUYXAgPSAhdGhpcy5wQ2VudGVyIHx8IGdldERpc3RhbmNlKHRoaXMucENlbnRlciwgaW5wdXQuY2VudGVyKSA8IG9wdGlvbnMucG9zVGhyZXNob2xkO1xuICAgICAgdGhpcy5wVGltZSA9IGlucHV0LnRpbWVTdGFtcDtcbiAgICAgIHRoaXMucENlbnRlciA9IGlucHV0LmNlbnRlcjtcblxuICAgICAgaWYgKCF2YWxpZE11bHRpVGFwIHx8ICF2YWxpZEludGVydmFsKSB7XG4gICAgICAgIHRoaXMuY291bnQgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb3VudCArPSAxO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbnB1dCA9IGlucHV0OyAvLyBpZiB0YXAgY291bnQgbWF0Y2hlcyB3ZSBoYXZlIHJlY29nbml6ZWQgaXQsXG4gICAgICAvLyBlbHNlIGl0IGhhcyBiZWdhbiByZWNvZ25pemluZy4uLlxuXG4gICAgICB2YXIgdGFwQ291bnQgPSB0aGlzLmNvdW50ICUgb3B0aW9ucy50YXBzO1xuXG4gICAgICBpZiAodGFwQ291bnQgPT09IDApIHtcbiAgICAgICAgLy8gbm8gZmFpbGluZyByZXF1aXJlbWVudHMsIGltbWVkaWF0ZWx5IHRyaWdnZXIgdGhlIHRhcCBldmVudFxuICAgICAgICAvLyBvciB3YWl0IGFzIGxvbmcgYXMgdGhlIG11bHRpdGFwIGludGVydmFsIHRvIHRyaWdnZXJcbiAgICAgICAgaWYgKCF0aGlzLmhhc1JlcXVpcmVGYWlsdXJlcygpKSB7XG4gICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMi5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG5cbiAgICAgICAgICAgIF90aGlzMi50cnlFbWl0KCk7XG4gICAgICAgICAgfSwgb3B0aW9ucy5pbnRlcnZhbCk7XG4gICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgfTtcblxuICBfcHJvdG8uZmFpbFRpbWVvdXQgPSBmdW5jdGlvbiBmYWlsVGltZW91dCgpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgfSwgdGhpcy5vcHRpb25zLmludGVydmFsKTtcbiAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICB9O1xuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gIH07XG5cbiAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICB0aGlzLl9pbnB1dC50YXBDb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRhcFJlY29nbml6ZXI7XG59KFJlY29nbml6ZXIpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBUaGlzIHJlY29nbml6ZXIgaXMganVzdCB1c2VkIGFzIGEgYmFzZSBmb3IgdGhlIHNpbXBsZSBhdHRyaWJ1dGUgcmVjb2duaXplcnMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuXG52YXIgQXR0clJlY29nbml6ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWNvZ25pemVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKEF0dHJSZWNvZ25pemVyLCBfUmVjb2duaXplcik7XG5cbiAgZnVuY3Rpb24gQXR0clJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gX1JlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICBwb2ludGVyczogMVxuICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBVc2VkIHRvIGNoZWNrIGlmIGl0IHRoZSByZWNvZ25pemVyIHJlY2VpdmVzIHZhbGlkIGlucHV0LCBsaWtlIGlucHV0LmRpc3RhbmNlID4gMTAuXG4gICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IHJlY29nbml6ZWRcbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gQXR0clJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5hdHRyVGVzdCA9IGZ1bmN0aW9uIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgdmFyIG9wdGlvblBvaW50ZXJzID0gdGhpcy5vcHRpb25zLnBvaW50ZXJzO1xuICAgIHJldHVybiBvcHRpb25Qb2ludGVycyA9PT0gMCB8fCBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvblBvaW50ZXJzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogUHJvY2VzcyB0aGUgaW5wdXQgYW5kIHJldHVybiB0aGUgc3RhdGUgZm9yIHRoZSByZWNvZ25pemVyXG4gICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICogQHJldHVybnMgeyp9IFN0YXRlXG4gICAqL1xuXG5cbiAgX3Byb3RvLnByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKGlucHV0KSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgZXZlbnRUeXBlID0gaW5wdXQuZXZlbnRUeXBlO1xuICAgIHZhciBpc1JlY29nbml6ZWQgPSBzdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQpO1xuICAgIHZhciBpc1ZhbGlkID0gdGhpcy5hdHRyVGVzdChpbnB1dCk7IC8vIG9uIGNhbmNlbCBpbnB1dCBhbmQgd2UndmUgcmVjb2duaXplZCBiZWZvcmUsIHJldHVybiBTVEFURV9DQU5DRUxMRURcblxuICAgIGlmIChpc1JlY29nbml6ZWQgJiYgKGV2ZW50VHlwZSAmIElOUFVUX0NBTkNFTCB8fCAhaXNWYWxpZCkpIHtcbiAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NBTkNFTExFRDtcbiAgICB9IGVsc2UgaWYgKGlzUmVjb2duaXplZCB8fCBpc1ZhbGlkKSB7XG4gICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0VOREVEO1xuICAgICAgfSBlbHNlIGlmICghKHN0YXRlICYgU1RBVEVfQkVHQU4pKSB7XG4gICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0hBTkdFRDtcbiAgICB9XG5cbiAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICB9O1xuXG4gIHJldHVybiBBdHRyUmVjb2duaXplcjtcbn0oUmVjb2duaXplcik7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGRpcmVjdGlvbiBjb25zIHRvIHN0cmluZ1xuICogQHBhcmFtIHtjb25zdGFudH0gZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGRpcmVjdGlvblN0cihkaXJlY3Rpb24pIHtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0RPV04pIHtcbiAgICByZXR1cm4gJ2Rvd24nO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX1VQKSB7XG4gICAgcmV0dXJuICd1cCc7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT05fTEVGVCkge1xuICAgIHJldHVybiAnbGVmdCc7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT05fUklHSFQpIHtcbiAgICByZXR1cm4gJ3JpZ2h0JztcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUGFuXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBhbmQgbW92ZWQgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5cbnZhciBQYW5SZWNvZ25pemVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQXR0clJlY29nbml6ZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoUGFuUmVjb2duaXplciwgX0F0dHJSZWNvZ25pemVyKTtcblxuICBmdW5jdGlvbiBQYW5SZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfQXR0clJlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICBldmVudDogJ3BhbicsXG4gICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9BTExcbiAgICB9LCBvcHRpb25zKSkgfHwgdGhpcztcbiAgICBfdGhpcy5wWCA9IG51bGw7XG4gICAgX3RoaXMucFkgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQYW5SZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0VG91Y2hBY3Rpb24gPSBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICB2YXIgYWN0aW9ucyA9IFtdO1xuXG4gICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcbiAgICB9XG5cbiAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aW9ucztcbiAgfTtcblxuICBfcHJvdG8uZGlyZWN0aW9uVGVzdCA9IGZ1bmN0aW9uIGRpcmVjdGlvblRlc3QoaW5wdXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgaGFzTW92ZWQgPSB0cnVlO1xuICAgIHZhciBkaXN0YW5jZSA9IGlucHV0LmRpc3RhbmNlO1xuICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5kaXJlY3Rpb247XG4gICAgdmFyIHggPSBpbnB1dC5kZWx0YVg7XG4gICAgdmFyIHkgPSBpbnB1dC5kZWx0YVk7IC8vIGxvY2sgdG8gYXhpcz9cblxuICAgIGlmICghKGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uKSkge1xuICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgZGlyZWN0aW9uID0geCA9PT0gMCA/IERJUkVDVElPTl9OT05FIDogeCA8IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICAgICAgaGFzTW92ZWQgPSB4ICE9PSB0aGlzLnBYO1xuICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXJlY3Rpb24gPSB5ID09PSAwID8gRElSRUNUSU9OX05PTkUgOiB5IDwgMCA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xuICAgICAgICBoYXNNb3ZlZCA9IHkgIT09IHRoaXMucFk7XG4gICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFZKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgcmV0dXJuIGhhc01vdmVkICYmIGRpc3RhbmNlID4gb3B0aW9ucy50aHJlc2hvbGQgJiYgZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb247XG4gIH07XG5cbiAgX3Byb3RvLmF0dHJUZXN0ID0gZnVuY3Rpb24gYXR0clRlc3QoaW5wdXQpIHtcbiAgICByZXR1cm4gQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmICggLy8gcmVwbGFjZSB3aXRoIGEgc3VwZXIgY2FsbFxuICAgIHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTiB8fCAhKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTikgJiYgdGhpcy5kaXJlY3Rpb25UZXN0KGlucHV0KSk7XG4gIH07XG5cbiAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGlucHV0KSB7XG4gICAgdGhpcy5wWCA9IGlucHV0LmRlbHRhWDtcbiAgICB0aGlzLnBZID0gaW5wdXQuZGVsdGFZO1xuICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQuZGlyZWN0aW9uKTtcblxuICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGRpcmVjdGlvbjtcbiAgICB9XG5cbiAgICBfQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XG4gIH07XG5cbiAgcmV0dXJuIFBhblJlY29nbml6ZXI7XG59KEF0dHJSZWNvZ25pemVyKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogU3dpcGVcbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBtb3ZpbmcgZmFzdCAodmVsb2NpdHkpLCB3aXRoIGVub3VnaCBkaXN0YW5jZSBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cblxudmFyIFN3aXBlUmVjb2duaXplciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0F0dHJSZWNvZ25pemVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFN3aXBlUmVjb2duaXplciwgX0F0dHJSZWNvZ25pemVyKTtcblxuICBmdW5jdGlvbiBTd2lwZVJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gX0F0dHJSZWNvZ25pemVyLmNhbGwodGhpcywgX2V4dGVuZHMoe1xuICAgICAgZXZlbnQ6ICdzd2lwZScsXG4gICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgdmVsb2NpdHk6IDAuMyxcbiAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgICBwb2ludGVyczogMVxuICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFN3aXBlUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFRvdWNoQWN0aW9uID0gZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgcmV0dXJuIFBhblJlY29nbml6ZXIucHJvdG90eXBlLmdldFRvdWNoQWN0aW9uLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmF0dHJUZXN0ID0gZnVuY3Rpb24gYXR0clRlc3QoaW5wdXQpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICB2YXIgdmVsb2NpdHk7XG5cbiAgICBpZiAoZGlyZWN0aW9uICYgKERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xuICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHk7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9BdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiYgZGlyZWN0aW9uICYgaW5wdXQub2Zmc2V0RGlyZWN0aW9uICYmIGlucHV0LmRpc3RhbmNlID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCAmJiBpbnB1dC5tYXhQb2ludGVycyA9PT0gdGhpcy5vcHRpb25zLnBvaW50ZXJzICYmIGFicyQxKHZlbG9jaXR5KSA+IHRoaXMub3B0aW9ucy52ZWxvY2l0eSAmJiBpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQ7XG4gIH07XG5cbiAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGlucHV0KSB7XG4gICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5vZmZzZXREaXJlY3Rpb24pO1xuXG4gICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uLCBpbnB1dCk7XG4gICAgfVxuXG4gICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCBpbnB1dCk7XG4gIH07XG5cbiAgcmV0dXJuIFN3aXBlUmVjb2duaXplcjtcbn0oQXR0clJlY29nbml6ZXIpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBQaW5jaFxuICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXJzIGFyZSBtb3ZpbmcgdG93YXJkICh6b29tLWluKSBvciBhd2F5IGZyb20gZWFjaCBvdGhlciAoem9vbS1vdXQpLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5cbnZhciBQaW5jaFJlY29nbml6ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9BdHRyUmVjb2duaXplcikge1xuICBfaW5oZXJpdHNMb29zZShQaW5jaFJlY29nbml6ZXIsIF9BdHRyUmVjb2duaXplcik7XG5cbiAgZnVuY3Rpb24gUGluY2hSZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIF9BdHRyUmVjb2duaXplci5jYWxsKHRoaXMsIF9leHRlbmRzKHtcbiAgICAgIGV2ZW50OiAncGluY2gnLFxuICAgICAgdGhyZXNob2xkOiAwLFxuICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LCBvcHRpb25zKSkgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQaW5jaFJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge1xuICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICB9O1xuXG4gIF9wcm90by5hdHRyVGVzdCA9IGZ1bmN0aW9uIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgcmV0dXJuIF9BdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiYgKE1hdGguYWJzKGlucHV0LnNjYWxlIC0gMSkgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gIH07XG5cbiAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGlucHV0KSB7XG4gICAgaWYgKGlucHV0LnNjYWxlICE9PSAxKSB7XG4gICAgICB2YXIgaW5PdXQgPSBpbnB1dC5zY2FsZSA8IDEgPyAnaW4nIDogJ291dCc7XG4gICAgICBpbnB1dC5hZGRpdGlvbmFsRXZlbnQgPSB0aGlzLm9wdGlvbnMuZXZlbnQgKyBpbk91dDtcbiAgICB9XG5cbiAgICBfQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XG4gIH07XG5cbiAgcmV0dXJuIFBpbmNoUmVjb2duaXplcjtcbn0oQXR0clJlY29nbml6ZXIpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSb3RhdGVcbiAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVyIGFyZSBtb3ZpbmcgaW4gYSBjaXJjdWxhciBtb3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cblxudmFyIFJvdGF0ZVJlY29nbml6ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9BdHRyUmVjb2duaXplcikge1xuICBfaW5oZXJpdHNMb29zZShSb3RhdGVSZWNvZ25pemVyLCBfQXR0clJlY29nbml6ZXIpO1xuXG4gIGZ1bmN0aW9uIFJvdGF0ZVJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gX0F0dHJSZWNvZ25pemVyLmNhbGwodGhpcywgX2V4dGVuZHMoe1xuICAgICAgZXZlbnQ6ICdyb3RhdGUnLFxuICAgICAgdGhyZXNob2xkOiAwLFxuICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LCBvcHRpb25zKSkgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBSb3RhdGVSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0VG91Y2hBY3Rpb24gPSBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgfTtcblxuICBfcHJvdG8uYXR0clRlc3QgPSBmdW5jdGlvbiBhdHRyVGVzdChpbnB1dCkge1xuICAgIHJldHVybiBfQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmIChNYXRoLmFicyhpbnB1dC5yb3RhdGlvbikgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gIH07XG5cbiAgcmV0dXJuIFJvdGF0ZVJlY29nbml6ZXI7XG59KEF0dHJSZWNvZ25pemVyKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUHJlc3NcbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGZvciB4IG1zIHdpdGhvdXQgYW55IG1vdmVtZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cblxudmFyIFByZXNzUmVjb2duaXplciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlY29nbml6ZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoUHJlc3NSZWNvZ25pemVyLCBfUmVjb2duaXplcik7XG5cbiAgZnVuY3Rpb24gUHJlc3NSZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfUmVjb2duaXplci5jYWxsKHRoaXMsIF9leHRlbmRzKHtcbiAgICAgIGV2ZW50OiAncHJlc3MnLFxuICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICB0aW1lOiAyNTEsXG4gICAgICAvLyBtaW5pbWFsIHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgcHJlc3NlZFxuICAgICAgdGhyZXNob2xkOiA5XG4gICAgfSwgb3B0aW9ucykpIHx8IHRoaXM7XG4gICAgX3RoaXMuX3RpbWVyID0gbnVsbDtcbiAgICBfdGhpcy5faW5wdXQgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQcmVzc1JlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge1xuICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX0FVVE9dO1xuICB9O1xuXG4gIF9wcm90by5wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzcyhpbnB1dCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgIHZhciB2YWxpZFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPiBvcHRpb25zLnRpbWU7XG4gICAgdGhpcy5faW5wdXQgPSBpbnB1dDsgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG5cbiAgICBpZiAoIXZhbGlkTW92ZW1lbnQgfHwgIXZhbGlkUG9pbnRlcnMgfHwgaW5wdXQuZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgIXZhbGlkVGltZSkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG5cbiAgICAgICAgX3RoaXMyLnRyeUVtaXQoKTtcbiAgICAgIH0sIG9wdGlvbnMudGltZSk7XG4gICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgIH1cblxuICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgfTtcblxuICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoaW5wdXQpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpbnB1dCAmJiBpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArIFwidXBcIiwgaW5wdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUHJlc3NSZWNvZ25pemVyO1xufShSZWNvZ25pemVyKTtcblxudmFyIGRlZmF1bHRzID0ge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogc2V0IGlmIERPTSBldmVudHMgYXJlIGJlaW5nIHRyaWdnZXJlZC5cbiAgICogQnV0IHRoaXMgaXMgc2xvd2VyIGFuZCB1bnVzZWQgYnkgc2ltcGxlIGltcGxlbWVudGF0aW9ucywgc28gZGlzYWJsZWQgYnkgZGVmYXVsdC5cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkb21FdmVudHM6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBUaGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eS9mYWxsYmFjay5cbiAgICogV2hlbiBzZXQgdG8gYGNvbXB1dGVgIGl0IHdpbGwgbWFnaWNhbGx5IHNldCB0aGUgY29ycmVjdCB2YWx1ZSBiYXNlZCBvbiB0aGUgYWRkZWQgcmVjb2duaXplcnMuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGNvbXB1dGVcbiAgICovXG4gIHRvdWNoQWN0aW9uOiBUT1VDSF9BQ1RJT05fQ09NUFVURSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGVuYWJsZTogdHJ1ZSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogRVhQRVJJTUVOVEFMIEZFQVRVUkUgLS0gY2FuIGJlIHJlbW92ZWQvY2hhbmdlZFxuICAgKiBDaGFuZ2UgdGhlIHBhcmVudCBpbnB1dCB0YXJnZXQgZWxlbWVudC5cbiAgICogSWYgTnVsbCwgdGhlbiBpdCBpcyBiZWluZyBzZXQgdGhlIHRvIG1haW4gZWxlbWVudC5cbiAgICogQHR5cGUge051bGx8RXZlbnRUYXJnZXR9XG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICovXG4gIGlucHV0VGFyZ2V0OiBudWxsLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBmb3JjZSBhbiBpbnB1dCBjbGFzc1xuICAgKiBAdHlwZSB7TnVsbHxGdW5jdGlvbn1cbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKi9cbiAgaW5wdXRDbGFzczogbnVsbCxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogU29tZSBDU1MgcHJvcGVydGllcyBjYW4gYmUgdXNlZCB0byBpbXByb3ZlIHRoZSB3b3JraW5nIG9mIEhhbW1lci5cbiAgICogQWRkIHRoZW0gdG8gdGhpcyBtZXRob2QgYW5kIHRoZXkgd2lsbCBiZSBzZXQgd2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyLlxuICAgKiBAbmFtZXNwYWNlXG4gICAqL1xuICBjc3NQcm9wczoge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogRGlzYWJsZXMgdGV4dCBzZWxlY3Rpb24gdG8gaW1wcm92ZSB0aGUgZHJhZ2dpbmcgZ2VzdHVyZS4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICovXG4gICAgdXNlclNlbGVjdDogXCJub25lXCIsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIERpc2FibGUgdGhlIFdpbmRvd3MgUGhvbmUgZ3JpcHBlcnMgd2hlbiBwcmVzc2luZyBhbiBlbGVtZW50LlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICovXG4gICAgdG91Y2hTZWxlY3Q6IFwibm9uZVwiLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBEaXNhYmxlcyB0aGUgZGVmYXVsdCBjYWxsb3V0IHNob3duIHdoZW4geW91IHRvdWNoIGFuZCBob2xkIGEgdG91Y2ggdGFyZ2V0LlxuICAgICAqIE9uIGlPUywgd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQgc3VjaCBhcyBhIGxpbmssIFNhZmFyaSBkaXNwbGF5c1xuICAgICAqIGEgY2FsbG91dCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsaW5rLiBUaGlzIHByb3BlcnR5IGFsbG93cyB5b3UgdG8gZGlzYWJsZSB0aGF0IGNhbGxvdXQuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgKi9cbiAgICB0b3VjaENhbGxvdXQ6IFwibm9uZVwiLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB6b29taW5nIGlzIGVuYWJsZWQuIFVzZWQgYnkgSUUxMD5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAqL1xuICAgIGNvbnRlbnRab29taW5nOiBcIm5vbmVcIixcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogU3BlY2lmaWVzIHRoYXQgYW4gZW50aXJlIGVsZW1lbnQgc2hvdWxkIGJlIGRyYWdnYWJsZSBpbnN0ZWFkIG9mIGl0cyBjb250ZW50cy4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICovXG4gICAgdXNlckRyYWc6IFwibm9uZVwiLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBPdmVycmlkZXMgdGhlIGhpZ2hsaWdodCBjb2xvciBzaG93biB3aGVuIHRoZSB1c2VyIHRhcHMgYSBsaW5rIG9yIGEgSmF2YVNjcmlwdFxuICAgICAqIGNsaWNrYWJsZSBlbGVtZW50IGluIGlPUy4gVGhpcyBwcm9wZXJ0eSBvYmV5cyB0aGUgYWxwaGEgdmFsdWUsIGlmIHNwZWNpZmllZC5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICdyZ2JhKDAsMCwwLDApJ1xuICAgICAqL1xuICAgIHRhcEhpZ2hsaWdodENvbG9yOiBcInJnYmEoMCwwLDAsMClcIlxuICB9XG59O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogRGVmYXVsdCByZWNvZ25pemVyIHNldHVwIHdoZW4gY2FsbGluZyBgSGFtbWVyKClgXG4gKiBXaGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIgdGhlc2Ugd2lsbCBiZSBza2lwcGVkLlxuICogVGhpcyBpcyBzZXBhcmF0ZWQgd2l0aCBvdGhlciBkZWZhdWx0cyBiZWNhdXNlIG9mIHRyZWUtc2hha2luZy5cbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuXG52YXIgcHJlc2V0ID0gW1tSb3RhdGVSZWNvZ25pemVyLCB7XG4gIGVuYWJsZTogZmFsc2Vcbn1dLCBbUGluY2hSZWNvZ25pemVyLCB7XG4gIGVuYWJsZTogZmFsc2Vcbn0sIFsncm90YXRlJ11dLCBbU3dpcGVSZWNvZ25pemVyLCB7XG4gIGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUxcbn1dLCBbUGFuUmVjb2duaXplciwge1xuICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMXG59LCBbJ3N3aXBlJ11dLCBbVGFwUmVjb2duaXplcl0sIFtUYXBSZWNvZ25pemVyLCB7XG4gIGV2ZW50OiAnZG91YmxldGFwJyxcbiAgdGFwczogMlxufSwgWyd0YXAnXV0sIFtQcmVzc1JlY29nbml6ZXJdXTtcblxudmFyIFNUT1AgPSAxO1xudmFyIEZPUkNFRF9TVE9QID0gMjtcbi8qKlxuICogQHByaXZhdGVcbiAqIGFkZC9yZW1vdmUgdGhlIGNzcyBwcm9wZXJ0aWVzIGFzIGRlZmluZWQgaW4gbWFuYWdlci5vcHRpb25zLmNzc1Byb3BzXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWRkXG4gKi9cblxuZnVuY3Rpb24gdG9nZ2xlQ3NzUHJvcHMobWFuYWdlciwgYWRkKSB7XG4gIHZhciBlbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuXG4gIGlmICghZWxlbWVudC5zdHlsZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwcm9wO1xuICBlYWNoKG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wcywgZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7XG4gICAgcHJvcCA9IHByZWZpeGVkKGVsZW1lbnQuc3R5bGUsIG5hbWUpO1xuXG4gICAgaWYgKGFkZCkge1xuICAgICAgbWFuYWdlci5vbGRDc3NQcm9wc1twcm9wXSA9IGVsZW1lbnQuc3R5bGVbcHJvcF07XG4gICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBtYW5hZ2VyLm9sZENzc1Byb3BzW3Byb3BdIHx8IFwiXCI7XG4gICAgfVxuICB9KTtcblxuICBpZiAoIWFkZCkge1xuICAgIG1hbmFnZXIub2xkQ3NzUHJvcHMgPSB7fTtcbiAgfVxufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogdHJpZ2dlciBkb20gZXZlbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSkge1xuICB2YXIgZ2VzdHVyZUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgZ2VzdHVyZUV2ZW50LmluaXRFdmVudChldmVudCwgdHJ1ZSwgdHJ1ZSk7XG4gIGdlc3R1cmVFdmVudC5nZXN0dXJlID0gZGF0YTtcbiAgZGF0YS50YXJnZXQuZGlzcGF0Y2hFdmVudChnZXN0dXJlRXZlbnQpO1xufVxuLyoqXG4qIEBwcml2YXRlXG4gKiBNYW5hZ2VyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5cbnZhciBNYW5hZ2VyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWFuYWdlcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbiQxKHt9LCBkZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG4gICAgdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0ID0gdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0IHx8IGVsZW1lbnQ7XG4gICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgIHRoaXMucmVjb2duaXplcnMgPSBbXTtcbiAgICB0aGlzLm9sZENzc1Byb3BzID0ge307XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmlucHV0ID0gY3JlYXRlSW5wdXRJbnN0YW5jZSh0aGlzKTtcbiAgICB0aGlzLnRvdWNoQWN0aW9uID0gbmV3IFRvdWNoQWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucy50b3VjaEFjdGlvbik7XG4gICAgdG9nZ2xlQ3NzUHJvcHModGhpcywgdHJ1ZSk7XG4gICAgZWFjaCh0aGlzLm9wdGlvbnMucmVjb2duaXplcnMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgcmVjb2duaXplciA9IF90aGlzLmFkZChuZXcgaXRlbVswXShpdGVtWzFdKSk7XG5cbiAgICAgIGl0ZW1bMl0gJiYgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKGl0ZW1bMl0pO1xuICAgICAgaXRlbVszXSAmJiByZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKGl0ZW1bM10pO1xuICAgIH0sIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzZXQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gTWFuYWdlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnNldCA9IGZ1bmN0aW9uIHNldChvcHRpb25zKSB7XG4gICAgYXNzaWduJDEodGhpcy5vcHRpb25zLCBvcHRpb25zKTsgLy8gT3B0aW9ucyB0aGF0IG5lZWQgYSBsaXR0bGUgbW9yZSBzZXR1cFxuXG4gICAgaWYgKG9wdGlvbnMudG91Y2hBY3Rpb24pIHtcbiAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5wdXRUYXJnZXQpIHtcbiAgICAgIC8vIENsZWFuIHVwIGV4aXN0aW5nIGV2ZW50IGxpc3RlbmVycyBhbmQgcmVpbml0aWFsaXplXG4gICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuaW5wdXQudGFyZ2V0ID0gb3B0aW9ucy5pbnB1dFRhcmdldDtcbiAgICAgIHRoaXMuaW5wdXQuaW5pdCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogc3RvcCByZWNvZ25pemluZyBmb3IgdGhpcyBzZXNzaW9uLlxuICAgKiBUaGlzIHNlc3Npb24gd2lsbCBiZSBkaXNjYXJkZWQsIHdoZW4gYSBuZXcgW2lucHV0XXN0YXJ0IGV2ZW50IGlzIGZpcmVkLlxuICAgKiBXaGVuIGZvcmNlZCwgdGhlIHJlY29nbml6ZXIgY3ljbGUgaXMgc3RvcHBlZCBpbW1lZGlhdGVseS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdXG4gICAqL1xuXG5cbiAgX3Byb3RvLnN0b3AgPSBmdW5jdGlvbiBzdG9wKGZvcmNlKSB7XG4gICAgdGhpcy5zZXNzaW9uLnN0b3BwZWQgPSBmb3JjZSA/IEZPUkNFRF9TVE9QIDogU1RPUDtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHJ1biB0aGUgcmVjb2duaXplcnMhXG4gICAqIGNhbGxlZCBieSB0aGUgaW5wdXRIYW5kbGVyIGZ1bmN0aW9uIG9uIGV2ZXJ5IG1vdmVtZW50IG9mIHRoZSBwb2ludGVycyAodG91Y2hlcylcbiAgICogaXQgd2Fsa3MgdGhyb3VnaCBhbGwgdGhlIHJlY29nbml6ZXJzIGFuZCB0cmllcyB0byBkZXRlY3QgdGhlIGdlc3R1cmUgdGhhdCBpcyBiZWluZyBtYWRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICovXG5cblxuICBfcHJvdG8ucmVjb2duaXplID0gZnVuY3Rpb24gcmVjb2duaXplKGlucHV0RGF0YSkge1xuICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuXG4gICAgaWYgKHNlc3Npb24uc3RvcHBlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gcnVuIHRoZSB0b3VjaC1hY3Rpb24gcG9seWZpbGxcblxuXG4gICAgdGhpcy50b3VjaEFjdGlvbi5wcmV2ZW50RGVmYXVsdHMoaW5wdXREYXRhKTtcbiAgICB2YXIgcmVjb2duaXplcjtcbiAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzOyAvLyB0aGlzIGhvbGRzIHRoZSByZWNvZ25pemVyIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cbiAgICAvLyBzbyB0aGUgcmVjb2duaXplcidzIHN0YXRlIG5lZWRzIHRvIGJlIEJFR0FOLCBDSEFOR0VELCBFTkRFRCBvciBSRUNPR05JWkVEXG4gICAgLy8gaWYgbm8gcmVjb2duaXplciBpcyBkZXRlY3RpbmcgYSB0aGluZywgaXQgaXMgc2V0IHRvIGBudWxsYFxuXG4gICAgdmFyIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXI7IC8vIHJlc2V0IHdoZW4gdGhlIGxhc3QgcmVjb2duaXplciBpcyByZWNvZ25pemVkXG4gICAgLy8gb3Igd2hlbiB3ZSdyZSBpbiBhIG5ldyBzZXNzaW9uXG5cbiAgICBpZiAoIWN1clJlY29nbml6ZXIgfHwgY3VyUmVjb2duaXplciAmJiBjdXJSZWNvZ25pemVyLnN0YXRlICYgU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gbnVsbDtcbiAgICAgIGN1clJlY29nbml6ZXIgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgcmVjb2duaXplcnMubGVuZ3RoKSB7XG4gICAgICByZWNvZ25pemVyID0gcmVjb2duaXplcnNbaV07IC8vIGZpbmQgb3V0IGlmIHdlIGFyZSBhbGxvd2VkIHRyeSB0byByZWNvZ25pemUgdGhlIGlucHV0IGZvciB0aGlzIG9uZS5cbiAgICAgIC8vIDEuICAgYWxsb3cgaWYgdGhlIHNlc3Npb24gaXMgTk9UIGZvcmNlZCBzdG9wcGVkIChzZWUgdGhlIC5zdG9wKCkgbWV0aG9kKVxuICAgICAgLy8gMi4gICBhbGxvdyBpZiB3ZSBzdGlsbCBoYXZlbid0IHJlY29nbml6ZWQgYSBnZXN0dXJlIGluIHRoaXMgc2Vzc2lvbiwgb3IgdGhlIHRoaXMgcmVjb2duaXplciBpcyB0aGUgb25lXG4gICAgICAvLyAgICAgIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cbiAgICAgIC8vIDMuICAgYWxsb3cgaWYgdGhlIHJlY29nbml6ZXIgaXMgYWxsb3dlZCB0byBydW4gc2ltdWx0YW5lb3VzIHdpdGggdGhlIGN1cnJlbnQgcmVjb2duaXplZCByZWNvZ25pemVyLlxuICAgICAgLy8gICAgICB0aGlzIGNhbiBiZSBzZXR1cCB3aXRoIHRoZSBgcmVjb2duaXplV2l0aCgpYCBtZXRob2Qgb24gdGhlIHJlY29nbml6ZXIuXG5cbiAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQgIT09IEZPUkNFRF9TVE9QICYmICggLy8gMVxuICAgICAgIWN1clJlY29nbml6ZXIgfHwgcmVjb2duaXplciA9PT0gY3VyUmVjb2duaXplciB8fCAvLyAyXG4gICAgICByZWNvZ25pemVyLmNhblJlY29nbml6ZVdpdGgoY3VyUmVjb2duaXplcikpKSB7XG4gICAgICAgIC8vIDNcbiAgICAgICAgcmVjb2duaXplci5yZWNvZ25pemUoaW5wdXREYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY29nbml6ZXIucmVzZXQoKTtcbiAgICAgIH0gLy8gaWYgdGhlIHJlY29nbml6ZXIgaGFzIGJlZW4gcmVjb2duaXppbmcgdGhlIGlucHV0IGFzIGEgdmFsaWQgZ2VzdHVyZSwgd2Ugd2FudCB0byBzdG9yZSB0aGlzIG9uZSBhcyB0aGVcbiAgICAgIC8vIGN1cnJlbnQgYWN0aXZlIHJlY29nbml6ZXIuIGJ1dCBvbmx5IGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhbiBhY3RpdmUgcmVjb2duaXplclxuXG5cbiAgICAgIGlmICghY3VyUmVjb2duaXplciAmJiByZWNvZ25pemVyLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEKSkge1xuICAgICAgICBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSByZWNvZ25pemVyO1xuICAgICAgICBjdXJSZWNvZ25pemVyID0gcmVjb2duaXplcjtcbiAgICAgIH1cblxuICAgICAgaSsrO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGdldCBhIHJlY29nbml6ZXIgYnkgaXRzIGV2ZW50IG5hbWUuXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcbiAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TnVsbH1cbiAgICovXG5cblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KHJlY29nbml6ZXIpIHtcbiAgICBpZiAocmVjb2duaXplciBpbnN0YW5jZW9mIFJlY29nbml6ZXIpIHtcbiAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgIH1cblxuICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY29nbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVjb2duaXplcnNbaV0ub3B0aW9ucy5ldmVudCA9PT0gcmVjb2duaXplcikge1xuICAgICAgICByZXR1cm4gcmVjb2duaXplcnNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZSBhZGQgYSByZWNvZ25pemVyIHRvIHRoZSBtYW5hZ2VyXG4gICAqIGV4aXN0aW5nIHJlY29nbml6ZXJzIHdpdGggdGhlIHNhbWUgZXZlbnQgbmFtZSB3aWxsIGJlIHJlbW92ZWRcbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE1hbmFnZXJ9XG4gICAqL1xuXG5cbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChyZWNvZ25pemVyKSB7XG4gICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsIFwiYWRkXCIsIHRoaXMpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IC8vIHJlbW92ZSBleGlzdGluZ1xuXG5cbiAgICB2YXIgZXhpc3RpbmcgPSB0aGlzLmdldChyZWNvZ25pemVyLm9wdGlvbnMuZXZlbnQpO1xuXG4gICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICB0aGlzLnJlbW92ZShleGlzdGluZyk7XG4gICAgfVxuXG4gICAgdGhpcy5yZWNvZ25pemVycy5wdXNoKHJlY29nbml6ZXIpO1xuICAgIHJlY29nbml6ZXIubWFuYWdlciA9IHRoaXM7XG4gICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHJlbW92ZSBhIHJlY29nbml6ZXIgYnkgbmFtZSBvciBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgKi9cblxuXG4gIF9wcm90by5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUocmVjb2duaXplcikge1xuICAgIGlmIChpbnZva2VBcnJheUFyZyhyZWNvZ25pemVyLCBcInJlbW92ZVwiLCB0aGlzKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldFJlY29nbml6ZXIgPSB0aGlzLmdldChyZWNvZ25pemVyKTsgLy8gbGV0J3MgbWFrZSBzdXJlIHRoaXMgcmVjb2duaXplciBleGlzdHNcblxuICAgIGlmIChyZWNvZ25pemVyKSB7XG4gICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuICAgICAgdmFyIGluZGV4ID0gaW5BcnJheShyZWNvZ25pemVycywgdGFyZ2V0UmVjb2duaXplcik7XG5cbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgcmVjb2duaXplcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGJpbmQgZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcbiAgICovXG5cblxuICBfcHJvdG8ub24gPSBmdW5jdGlvbiBvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQgfHwgaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBoYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyc1tldmVudF0gfHwgW107XG4gICAgICBoYW5kbGVyc1tldmVudF0ucHVzaChoYW5kbGVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlIHVuYmluZCBldmVudCwgbGVhdmUgZW1pdCBibGFuayB0byByZW1vdmUgYWxsIGhhbmRsZXJzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdXG4gICAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcbiAgICovXG5cblxuICBfcHJvdG8ub2ZmID0gZnVuY3Rpb24gb2ZmKGV2ZW50cywgaGFuZGxlcikge1xuICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgIGRlbGV0ZSBoYW5kbGVyc1tldmVudF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVyc1tldmVudF0gJiYgaGFuZGxlcnNbZXZlbnRdLnNwbGljZShpbkFycmF5KGhhbmRsZXJzW2V2ZW50XSwgaGFuZGxlciksIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGUgZW1pdCBldmVudCB0byB0aGUgbGlzdGVuZXJzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKi9cblxuXG4gIF9wcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgZGF0YSkge1xuICAgIC8vIHdlIGFsc28gd2FudCB0byB0cmlnZ2VyIGRvbSBldmVudHNcbiAgICBpZiAodGhpcy5vcHRpb25zLmRvbUV2ZW50cykge1xuICAgICAgdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKTtcbiAgICB9IC8vIG5vIGhhbmRsZXJzLCBzbyBza2lwIGl0IGFsbFxuXG5cbiAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XSAmJiB0aGlzLmhhbmRsZXJzW2V2ZW50XS5zbGljZSgpO1xuXG4gICAgaWYgKCFoYW5kbGVycyB8fCAhaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGF0YS50eXBlID0gZXZlbnQ7XG5cbiAgICBkYXRhLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZGF0YS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG5cbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgaGFuZGxlcnNbaV0oZGF0YSk7XG4gICAgICBpKys7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogZGVzdHJveSB0aGUgbWFuYWdlciBhbmQgdW5iaW5kcyBhbGwgZXZlbnRzXG4gICAqIGl0IGRvZXNuJ3QgdW5iaW5kIGRvbSBldmVudHMsIHRoYXQgaXMgdGhlIHVzZXIgb3duIHJlc3BvbnNpYmlsaXR5XG4gICAqL1xuXG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMuZWxlbWVudCAmJiB0b2dnbGVDc3NQcm9wcyh0aGlzLCBmYWxzZSk7XG4gICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIE1hbmFnZXI7XG59KCk7XG5cbnZhciBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQID0ge1xuICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcbiAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXG59O1xudmFyIFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQnO1xudmFyIFNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcbi8qKlxuICogQHByaXZhdGVcbiAqIFRvdWNoIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5cbnZhciBTaW5nbGVUb3VjaElucHV0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfSW5wdXQpIHtcbiAgX2luaGVyaXRzTG9vc2UoU2luZ2xlVG91Y2hJbnB1dCwgX0lucHV0KTtcblxuICBmdW5jdGlvbiBTaW5nbGVUb3VjaElucHV0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBwcm90byA9IFNpbmdsZVRvdWNoSW5wdXQucHJvdG90eXBlO1xuICAgIHByb3RvLmV2VGFyZ2V0ID0gU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgcHJvdG8uZXZXaW4gPSBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUztcbiAgICBfdGhpcyA9IF9JbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTaW5nbGVUb3VjaElucHV0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZXYpIHtcbiAgICB2YXIgdHlwZSA9IFNJTkdMRV9UT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07IC8vIHNob3VsZCB3ZSBoYW5kbGUgdGhlIHRvdWNoIGV2ZW50cz9cblxuICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0b3VjaGVzID0gbm9ybWFsaXplU2luZ2xlVG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTsgLy8gd2hlbiBkb25lLCByZXNldCB0aGUgc3RhcnRlZCBzdGF0ZVxuXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiB0b3VjaGVzWzBdLmxlbmd0aCAtIHRvdWNoZXNbMV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXG4gICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgIHNyY0V2ZW50OiBldlxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBTaW5nbGVUb3VjaElucHV0O1xufShJbnB1dCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMoZXYsIHR5cGUpIHtcbiAgdmFyIGFsbCA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XG4gIHZhciBjaGFuZ2VkID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyk7XG5cbiAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgIGFsbCA9IHVuaXF1ZUFycmF5KGFsbC5jb25jYXQoY2hhbmdlZCksICdpZGVudGlmaWVyJywgdHJ1ZSk7XG4gIH1cblxuICByZXR1cm4gW2FsbCwgY2hhbmdlZF07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIHdyYXAgYSBtZXRob2Qgd2l0aCBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgYW5kIHN0YWNrIHRyYWNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB3cmFwcGluZyB0aGUgc3VwcGxpZWQgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBkZXByZWNhdGUobWV0aG9kLCBuYW1lLCBtZXNzYWdlKSB7XG4gIHZhciBkZXByZWNhdGlvbk1lc3NhZ2UgPSBcIkRFUFJFQ0FURUQgTUVUSE9EOiBcIiArIG5hbWUgKyBcIlxcblwiICsgbWVzc2FnZSArIFwiIEFUIFxcblwiO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlID0gbmV3IEVycm9yKCdnZXQtc3RhY2stdHJhY2UnKTtcbiAgICB2YXIgc3RhY2sgPSBlICYmIGUuc3RhY2sgPyBlLnN0YWNrLnJlcGxhY2UoL15bXlxcKF0rP1tcXG4kXS9nbSwgJycpLnJlcGxhY2UoL15cXHMrYXRcXHMrL2dtLCAnJykucmVwbGFjZSgvXk9iamVjdC48YW5vbnltb3VzPlxccypcXCgvZ20sICd7YW5vbnltb3VzfSgpQCcpIDogJ1Vua25vd24gU3RhY2sgVHJhY2UnO1xuICAgIHZhciBsb2cgPSB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUud2FybiB8fCB3aW5kb3cuY29uc29sZS5sb2cpO1xuXG4gICAgaWYgKGxvZykge1xuICAgICAgbG9nLmNhbGwod2luZG93LmNvbnNvbGUsIGRlcHJlY2F0aW9uTWVzc2FnZSwgc3RhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZXh0ZW5kIG9iamVjdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyBpbiBkZXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIG9uZXMgaW4gc3JjLlxuICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW21lcmdlPWZhbHNlXVxuICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICovXG5cbnZhciBleHRlbmQgPSBkZXByZWNhdGUoZnVuY3Rpb24gKGRlc3QsIHNyYywgbWVyZ2UpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcmMpO1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBrZXlzLmxlbmd0aCkge1xuICAgIGlmICghbWVyZ2UgfHwgbWVyZ2UgJiYgZGVzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZXN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xuICAgIH1cblxuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufSwgJ2V4dGVuZCcsICdVc2UgYGFzc2lnbmAuJyk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIG1lcmdlIHRoZSB2YWx1ZXMgZnJvbSBzcmMgaW4gdGhlIGRlc3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgdGhhdCBleGlzdCBpbiBkZXN0IHdpbGwgbm90IGJlIG92ZXJ3cml0dGVuIGJ5IHNyY1xuICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqL1xuXG52YXIgbWVyZ2UkMiA9IGRlcHJlY2F0ZShmdW5jdGlvbiAoZGVzdCwgc3JjKSB7XG4gIHJldHVybiBleHRlbmQoZGVzdCwgc3JjLCB0cnVlKTtcbn0sICdtZXJnZScsICdVc2UgYGFzc2lnbmAuJyk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIHNpbXBsZSBjbGFzcyBpbmhlcml0YW5jZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hpbGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc11cbiAqL1xuXG5mdW5jdGlvbiBpbmhlcml0KGNoaWxkLCBiYXNlLCBwcm9wZXJ0aWVzKSB7XG4gIHZhciBiYXNlUCA9IGJhc2UucHJvdG90eXBlO1xuICB2YXIgY2hpbGRQO1xuICBjaGlsZFAgPSBjaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VQKTtcbiAgY2hpbGRQLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gIGNoaWxkUC5fc3VwZXIgPSBiYXNlUDtcblxuICBpZiAocHJvcGVydGllcykge1xuICAgIGFzc2lnbiQxKGNoaWxkUCwgcHJvcGVydGllcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogc2ltcGxlIGZ1bmN0aW9uIGJpbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBiaW5kRm4oZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kRm4oKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFNpbXBsZSB3YXkgdG8gY3JlYXRlIGEgbWFuYWdlciB3aXRoIGEgZGVmYXVsdCBzZXQgb2YgcmVjb2duaXplcnMuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG52YXIgSGFtbWVyJDIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICB2YXIgSGFtbWVyID1cbiAgLyoqXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQGNvbnN0IHtzdHJpbmd9XG4gICAgKi9cbiAgZnVuY3Rpb24gSGFtbWVyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBNYW5hZ2VyKGVsZW1lbnQsIF9leHRlbmRzKHtcbiAgICAgIHJlY29nbml6ZXJzOiBwcmVzZXQuY29uY2F0KClcbiAgICB9LCBvcHRpb25zKSk7XG4gIH07XG5cbiAgSGFtbWVyLlZFUlNJT04gPSBcIjIuMC4xNy1yY1wiO1xuICBIYW1tZXIuRElSRUNUSU9OX0FMTCA9IERJUkVDVElPTl9BTEw7XG4gIEhhbW1lci5ESVJFQ1RJT05fRE9XTiA9IERJUkVDVElPTl9ET1dOO1xuICBIYW1tZXIuRElSRUNUSU9OX0xFRlQgPSBESVJFQ1RJT05fTEVGVDtcbiAgSGFtbWVyLkRJUkVDVElPTl9SSUdIVCA9IERJUkVDVElPTl9SSUdIVDtcbiAgSGFtbWVyLkRJUkVDVElPTl9VUCA9IERJUkVDVElPTl9VUDtcbiAgSGFtbWVyLkRJUkVDVElPTl9IT1JJWk9OVEFMID0gRElSRUNUSU9OX0hPUklaT05UQUw7XG4gIEhhbW1lci5ESVJFQ1RJT05fVkVSVElDQUwgPSBESVJFQ1RJT05fVkVSVElDQUw7XG4gIEhhbW1lci5ESVJFQ1RJT05fTk9ORSA9IERJUkVDVElPTl9OT05FO1xuICBIYW1tZXIuRElSRUNUSU9OX0RPV04gPSBESVJFQ1RJT05fRE9XTjtcbiAgSGFtbWVyLklOUFVUX1NUQVJUID0gSU5QVVRfU1RBUlQ7XG4gIEhhbW1lci5JTlBVVF9NT1ZFID0gSU5QVVRfTU9WRTtcbiAgSGFtbWVyLklOUFVUX0VORCA9IElOUFVUX0VORDtcbiAgSGFtbWVyLklOUFVUX0NBTkNFTCA9IElOUFVUX0NBTkNFTDtcbiAgSGFtbWVyLlNUQVRFX1BPU1NJQkxFID0gU1RBVEVfUE9TU0lCTEU7XG4gIEhhbW1lci5TVEFURV9CRUdBTiA9IFNUQVRFX0JFR0FOO1xuICBIYW1tZXIuU1RBVEVfQ0hBTkdFRCA9IFNUQVRFX0NIQU5HRUQ7XG4gIEhhbW1lci5TVEFURV9FTkRFRCA9IFNUQVRFX0VOREVEO1xuICBIYW1tZXIuU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gIEhhbW1lci5TVEFURV9DQU5DRUxMRUQgPSBTVEFURV9DQU5DRUxMRUQ7XG4gIEhhbW1lci5TVEFURV9GQUlMRUQgPSBTVEFURV9GQUlMRUQ7XG4gIEhhbW1lci5NYW5hZ2VyID0gTWFuYWdlcjtcbiAgSGFtbWVyLklucHV0ID0gSW5wdXQ7XG4gIEhhbW1lci5Ub3VjaEFjdGlvbiA9IFRvdWNoQWN0aW9uO1xuICBIYW1tZXIuVG91Y2hJbnB1dCA9IFRvdWNoSW5wdXQ7XG4gIEhhbW1lci5Nb3VzZUlucHV0ID0gTW91c2VJbnB1dDtcbiAgSGFtbWVyLlBvaW50ZXJFdmVudElucHV0ID0gUG9pbnRlckV2ZW50SW5wdXQ7XG4gIEhhbW1lci5Ub3VjaE1vdXNlSW5wdXQgPSBUb3VjaE1vdXNlSW5wdXQ7XG4gIEhhbW1lci5TaW5nbGVUb3VjaElucHV0ID0gU2luZ2xlVG91Y2hJbnB1dDtcbiAgSGFtbWVyLlJlY29nbml6ZXIgPSBSZWNvZ25pemVyO1xuICBIYW1tZXIuQXR0clJlY29nbml6ZXIgPSBBdHRyUmVjb2duaXplcjtcbiAgSGFtbWVyLlRhcCA9IFRhcFJlY29nbml6ZXI7XG4gIEhhbW1lci5QYW4gPSBQYW5SZWNvZ25pemVyO1xuICBIYW1tZXIuU3dpcGUgPSBTd2lwZVJlY29nbml6ZXI7XG4gIEhhbW1lci5QaW5jaCA9IFBpbmNoUmVjb2duaXplcjtcbiAgSGFtbWVyLlJvdGF0ZSA9IFJvdGF0ZVJlY29nbml6ZXI7XG4gIEhhbW1lci5QcmVzcyA9IFByZXNzUmVjb2duaXplcjtcbiAgSGFtbWVyLm9uID0gYWRkRXZlbnRMaXN0ZW5lcnM7XG4gIEhhbW1lci5vZmYgPSByZW1vdmVFdmVudExpc3RlbmVycztcbiAgSGFtbWVyLmVhY2ggPSBlYWNoO1xuICBIYW1tZXIubWVyZ2UgPSBtZXJnZSQyO1xuICBIYW1tZXIuZXh0ZW5kID0gZXh0ZW5kO1xuICBIYW1tZXIuYmluZEZuID0gYmluZEZuO1xuICBIYW1tZXIuYXNzaWduID0gYXNzaWduJDE7XG4gIEhhbW1lci5pbmhlcml0ID0gaW5oZXJpdDtcbiAgSGFtbWVyLmJpbmRGbiA9IGJpbmRGbjtcbiAgSGFtbWVyLnByZWZpeGVkID0gcHJlZml4ZWQ7XG4gIEhhbW1lci50b0FycmF5ID0gdG9BcnJheTtcbiAgSGFtbWVyLmluQXJyYXkgPSBpbkFycmF5O1xuICBIYW1tZXIudW5pcXVlQXJyYXkgPSB1bmlxdWVBcnJheTtcbiAgSGFtbWVyLnNwbGl0U3RyID0gc3BsaXRTdHI7XG4gIEhhbW1lci5ib29sT3JGbiA9IGJvb2xPckZuO1xuICBIYW1tZXIuaGFzUGFyZW50ID0gaGFzUGFyZW50O1xuICBIYW1tZXIuYWRkRXZlbnRMaXN0ZW5lcnMgPSBhZGRFdmVudExpc3RlbmVycztcbiAgSGFtbWVyLnJlbW92ZUV2ZW50TGlzdGVuZXJzID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcnM7XG4gIEhhbW1lci5kZWZhdWx0cyA9IGFzc2lnbiQxKHt9LCBkZWZhdWx0cywge1xuICAgIHByZXNldDogcHJlc2V0XG4gIH0pO1xuICByZXR1cm4gSGFtbWVyO1xufSgpO1xuXG4vLyAgc3R5bGUgbG9hZGVyIGJ1dCBieSBzY3JpcHQgdGFnLCBub3QgYnkgdGhlIGxvYWRlci5cblxuSGFtbWVyJDIuZGVmYXVsdHM7XG5cbnZhciBSZWFsSGFtbWVyID0gSGFtbWVyJDI7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDYobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIF9TeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgX2dldEl0ZXJhdG9yTWV0aG9kKG8pIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChfQXJyYXkkaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNihvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNihvLCBtaW5MZW4pIHsgdmFyIF9jb250ZXh0MTc7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ2KG8sIG1pbkxlbik7IHZhciBuID0gX3NsaWNlSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDE3ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pKS5jYWxsKF9jb250ZXh0MTcsIDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIF9BcnJheSRmcm9tJDEobyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNihvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQ2KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG5cbi8qKlxyXG4gKiBVc2UgdGhpcyBzeW1ib2wgdG8gZGVsZXRlIHByb3BlcmllcyBpbiBkZWVwT2JqZWN0QXNzaWduLlxyXG4gKi9cbl9TeW1ib2woXCJERUxFVEVcIik7XG5cbi8qKlxyXG4gKiBTZWVkYWJsZSwgZmFzdCBhbmQgcmVhc29uYWJseSBnb29kIChub3QgY3J5cHRvIGJ1dCBtb3JlIHRoYW4gb2theSBmb3Igb3VyXHJcbiAqIG5lZWRzKSByYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cclxuICpcclxuICogQHJlbWFya3NcclxuICogQWRhcHRlZCBmcm9tIHtAbGluayBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMTA0MjkxMDA3MzYvaHR0cDovL2JhYWdvZS5jb206ODAvZW4vUmFuZG9tTXVzaW5ncy9qYXZhc2NyaXB0fS5cclxuICogT3JpZ2luYWwgYWxnb3JpdGhtIGNyZWF0ZWQgYnkgSm9oYW5uZXMgQmFhZ8O4ZSBcXDxiYWFnb2VcXEBiYWFnb2UuY29tXFw+IGluIDIwMTAuXHJcbiAqL1xuLyoqXHJcbiAqIENyZWF0ZSBhIHNlZWRlZCBwc2V1ZG8gcmFuZG9tIGdlbmVyYXRvciBiYXNlZCBvbiBBbGVhIGJ5IEpvaGFubmVzIEJhYWfDuGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBzZWVkIC0gQWxsIHN1cHBsaWVkIGFyZ3VtZW50cyB3aWxsIGJlIHVzZWQgYXMgYSBzZWVkLiBJbiBjYXNlIG5vdGhpbmdcclxuICogaXMgc3VwcGxpZWQgdGhlIGN1cnJlbnQgdGltZSB3aWxsIGJlIHVzZWQgdG8gc2VlZCB0aGUgZ2VuZXJhdG9yLlxyXG4gKiBAcmV0dXJucyBBIHJlYWR5IHRvIHVzZSBzZWVkZWQgZ2VuZXJhdG9yLlxyXG4gKi9cbmZ1bmN0aW9uIEFsZWEoKSB7XG4gIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgc2VlZCA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIHNlZWRbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgfVxuICByZXR1cm4gQWxlYUltcGxlbWVudGF0aW9uKHNlZWQubGVuZ3RoID8gc2VlZCA6IFtfRGF0ZSRub3coKV0pO1xufVxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIFtbQWxlYV1dIHdpdGhvdXQgdXNlciBpbnB1dCB2YWxpZGF0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gc2VlZCAtIFRoZSBkYXRhIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHNlZWQgdGhlIGdlbmVyYXRvci5cclxuICogQHJldHVybnMgQSByZWFkeSB0byB1c2Ugc2VlZGVkIGdlbmVyYXRvci5cclxuICovXG5mdW5jdGlvbiBBbGVhSW1wbGVtZW50YXRpb24oc2VlZCkge1xuICB2YXIgX21hc2hTZWVkID0gbWFzaFNlZWQoc2VlZCksXG4gICAgX21hc2hTZWVkMiA9IF9zbGljZWRUb0FycmF5KF9tYXNoU2VlZCwgMyksXG4gICAgczAgPSBfbWFzaFNlZWQyWzBdLFxuICAgIHMxID0gX21hc2hTZWVkMlsxXSxcbiAgICBzMiA9IF9tYXNoU2VlZDJbMl07XG4gIHZhciBjID0gMTtcbiAgdmFyIHJhbmRvbSA9IGZ1bmN0aW9uIHJhbmRvbSgpIHtcbiAgICB2YXIgdCA9IDIwOTE2MzkgKiBzMCArIGMgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICAgIHMwID0gczE7XG4gICAgczEgPSBzMjtcbiAgICByZXR1cm4gczIgPSB0IC0gKGMgPSB0IHwgMCk7XG4gIH07XG4gIHJhbmRvbS51aW50MzIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gIH07IC8vIDJeMzJcbiAgcmFuZG9tLmZyYWN0NTMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJhbmRvbSgpICsgKHJhbmRvbSgpICogMHgyMDAwMDAgfCAwKSAqIDEuMTEwMjIzMDI0NjI1MTU2NWUtMTY7XG4gIH07IC8vIDJeLTUzXG4gIHJhbmRvbS5hbGdvcml0aG0gPSBcIkFsZWFcIjtcbiAgcmFuZG9tLnNlZWQgPSBzZWVkO1xuICByYW5kb20udmVyc2lvbiA9IFwiMC45XCI7XG4gIHJldHVybiByYW5kb207XG59XG4vKipcclxuICogVHVybiBhcmJpdHJhcnkgZGF0YSBpbnRvIHZhbHVlcyBbW0FsZWFJbXBsZW1lbnRhdGlvbl1dIGNhbiB1c2UgdG8gZ2VuZXJhdGVcclxuICogcmFuZG9tIG51bWJlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBzZWVkIC0gQXJiaXRyYXJ5IGRhdGEgdGhhdCB3aWxsIGJlIHVzZWQgYXMgdGhlIHNlZWQuXHJcbiAqIEByZXR1cm5zIFRocmVlIG51bWJlcnMgdG8gdXNlIGFzIGluaXRpYWwgdmFsdWVzIGZvciBbW0FsZWFJbXBsZW1lbnRhdGlvbl1dLlxyXG4gKi9cbmZ1bmN0aW9uIG1hc2hTZWVkKCkge1xuICB2YXIgbWFzaCA9IE1hc2goKTtcbiAgdmFyIHMwID0gbWFzaChcIiBcIik7XG4gIHZhciBzMSA9IG1hc2goXCIgXCIpO1xuICB2YXIgczIgPSBtYXNoKFwiIFwiKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBzMCAtPSBtYXNoKGkgPCAwIHx8IGFyZ3VtZW50cy5sZW5ndGggPD0gaSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1tpXSk7XG4gICAgaWYgKHMwIDwgMCkge1xuICAgICAgczAgKz0gMTtcbiAgICB9XG4gICAgczEgLT0gbWFzaChpIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGkgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaV0pO1xuICAgIGlmIChzMSA8IDApIHtcbiAgICAgIHMxICs9IDE7XG4gICAgfVxuICAgIHMyIC09IG1hc2goaSA8IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBpID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW2ldKTtcbiAgICBpZiAoczIgPCAwKSB7XG4gICAgICBzMiArPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW3MwLCBzMSwgczJdO1xufVxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBtYXNoIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBIG5vbnB1cmUgZnVuY3Rpb24gdGhhdCB0YWtlcyBhcmJpdHJhcnkgW1tNYXNoYWJsZV1dIGRhdGEgYW5kIHR1cm5zXHJcbiAqIHRoZW0gaW50byBudW1iZXJzLlxyXG4gKi9cbmZ1bmN0aW9uIE1hc2goKSB7XG4gIHZhciBuID0gMHhlZmM4MjQ5ZDtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHN0cmluZyA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgbiArPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgIHZhciBoID0gMC4wMjUxOTYwMzI4MjQxNjkzOCAqIG47XG4gICAgICBuID0gaCA+Pj4gMDtcbiAgICAgIGggLT0gbjtcbiAgICAgIGggKj0gbjtcbiAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgaCAtPSBuO1xuICAgICAgbiArPSBoICogMHgxMDAwMDAwMDA7IC8vIDJeMzJcbiAgICB9XG5cbiAgICByZXR1cm4gKG4gPj4+IDApICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcbiAgfTtcbn1cblxuLyoqXG4gKiBTZXR1cCBhIG1vY2sgaGFtbWVyLmpzIG9iamVjdCwgZm9yIHVuaXQgdGVzdGluZy5cbiAqXG4gKiBJbnNwaXJhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL3ViZXIvZGVjay5nbC9wdWxsLzY1OFxuICpcbiAqIEByZXR1cm5zIHt7b246IG5vb3AsIG9mZjogbm9vcCwgZGVzdHJveTogbm9vcCwgZW1pdDogbm9vcCwgZ2V0OiBnZXR9fVxuICovXG5mdW5jdGlvbiBoYW1tZXJNb2NrKCkge1xuICB2YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbiAgcmV0dXJuIHtcbiAgICBvbjogbm9vcCxcbiAgICBvZmY6IG5vb3AsXG4gICAgZGVzdHJveTogbm9vcCxcbiAgICBlbWl0OiBub29wLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2V0OiBub29wXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cbnZhciBIYW1tZXIkMSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuSGFtbWVyIHx8IFJlYWxIYW1tZXIgOiBmdW5jdGlvbiAoKSB7XG4gIC8vIGhhbW1lci5qcyBpcyBvbmx5IGF2YWlsYWJsZSBpbiBhIGJyb3dzZXIsIG5vdCBpbiBub2RlLmpzLiBSZXBsYWNpbmcgaXQgd2l0aCBhIG1vY2sgb2JqZWN0LlxuICByZXR1cm4gaGFtbWVyTW9jaygpO1xufTtcblxuLyoqXG4gKiBUdXJuIGFuIGVsZW1lbnQgaW50byBhbiBjbGlja1RvVXNlIGVsZW1lbnQuXG4gKiBXaGVuIG5vdCBhY3RpdmUsIHRoZSBlbGVtZW50IGhhcyBhIHRyYW5zcGFyZW50IG92ZXJsYXkuIFdoZW4gdGhlIG92ZXJsYXkgaXNcbiAqIGNsaWNrZWQsIHRoZSBtb2RlIGlzIGNoYW5nZWQgdG8gYWN0aXZlLlxuICogV2hlbiBhY3RpdmUsIHRoZSBlbGVtZW50IGlzIGRpc3BsYXllZCB3aXRoIGEgYmx1ZSBib3JkZXIgYXJvdW5kIGl0LCBhbmRcbiAqIHRoZSBpbnRlcmFjdGl2ZSBjb250ZW50cyBvZiB0aGUgZWxlbWVudCBjYW4gYmUgdXNlZC4gV2hlbiBjbGlja2VkIG91dHNpZGVcbiAqIHRoZSBlbGVtZW50LCB0aGUgZWxlbWVudHMgbW9kZSBpcyBjaGFuZ2VkIHRvIGluYWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyXG4gKiBAY2xhc3MgQWN0aXZhdG9yXG4gKi9cbmZ1bmN0aW9uIEFjdGl2YXRvciQxKGNvbnRhaW5lcikge1xuICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgIF9jb250ZXh0MztcbiAgdGhpcy5fY2xlYW51cFF1ZXVlID0gW107XG4gIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIHRoaXMuX2RvbSA9IHtcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICBvdmVybGF5OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gIH07XG4gIHRoaXMuX2RvbS5vdmVybGF5LmNsYXNzTGlzdC5hZGQoXCJ2aXMtb3ZlcmxheVwiKTtcbiAgdGhpcy5fZG9tLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9kb20ub3ZlcmxheSk7XG4gIHRoaXMuX2NsZWFudXBRdWV1ZS5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5fZG9tLm92ZXJsYXkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfdGhpcy5fZG9tLm92ZXJsYXkpO1xuICB9KTtcbiAgdmFyIGhhbW1lciA9IEhhbW1lciQxKHRoaXMuX2RvbS5vdmVybGF5KTtcbiAgaGFtbWVyLm9uKFwidGFwXCIsIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MyA9IHRoaXMuX29uVGFwT3ZlcmxheSkuY2FsbChfY29udGV4dDMsIHRoaXMpKTtcbiAgdGhpcy5fY2xlYW51cFF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuICAgIGhhbW1lci5kZXN0cm95KCk7XG4gICAgLy8gRklYTUU6IGNsZWFuaW5nIHVwIGhhbW1lciBpbnN0YW5jZXMgZG9lc24ndCB3b3JrIChUaW1lbGluZSBub3QgcmVtb3ZlZFxuICAgIC8vIGZyb20gbWVtb3J5KVxuICB9KTtcblxuICAvLyBibG9jayBhbGwgdG91Y2ggZXZlbnRzIChleGNlcHQgdGFwKVxuICB2YXIgZXZlbnRzID0gW1widGFwXCIsIFwiZG91YmxldGFwXCIsIFwicHJlc3NcIiwgXCJwaW5jaFwiLCBcInBhblwiLCBcInBhbnN0YXJ0XCIsIFwicGFubW92ZVwiLCBcInBhbmVuZFwiXTtcbiAgX2ZvckVhY2hJbnN0YW5jZVByb3BlcnR5KGV2ZW50cykuY2FsbChldmVudHMsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGhhbW1lci5vbihldmVudCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBldmVudC5zcmNFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gYXR0YWNoIGEgY2xpY2sgZXZlbnQgdG8gdGhlIHdpbmRvdywgaW4gb3JkZXIgdG8gZGVhY3RpdmF0ZSB3aGVuIGNsaWNraW5nIG91dHNpZGUgdGhlIHRpbWVsaW5lXG4gIGlmIChkb2N1bWVudCAmJiBkb2N1bWVudC5ib2R5KSB7XG4gICAgdGhpcy5fb25DbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKCFfaGFzUGFyZW50KGV2ZW50LnRhcmdldCwgY29udGFpbmVyKSkge1xuICAgICAgICBfdGhpcy5kZWFjdGl2YXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9vbkNsaWNrKTtcbiAgICB0aGlzLl9jbGVhbnVwUXVldWUucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBfdGhpcy5fb25DbGljayk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBwcmVwYXJlIGVzY2FwZSBrZXkgbGlzdGVuZXIgZm9yIGRlYWN0aXZhdGluZyB3aGVuIGFjdGl2ZVxuICB0aGlzLl9lc2NMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChcImtleVwiIGluIGV2ZW50ID8gZXZlbnQua2V5ID09PSBcIkVzY2FwZVwiIDogZXZlbnQua2V5Q29kZSA9PT0gMjcgLyogdGhlIGtleUNvZGUgaXMgZm9yIElFMTEgKi8pIHtcbiAgICAgIF90aGlzLmRlYWN0aXZhdGUoKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHR1cm4gaW50byBhbiBldmVudCBlbWl0dGVyXG5FbWl0dGVyKEFjdGl2YXRvciQxLnByb3RvdHlwZSk7XG5cbi8vIFRoZSBjdXJyZW50bHkgYWN0aXZlIGFjdGl2YXRvclxuQWN0aXZhdG9yJDEuY3VycmVudCA9IG51bGw7XG5cbi8qKlxuICogRGVzdHJveSB0aGUgYWN0aXZhdG9yLiBDbGVhbnMgdXAgYWxsIGNyZWF0ZWQgRE9NIGFuZCBldmVudCBsaXN0ZW5lcnNcbiAqL1xuQWN0aXZhdG9yJDEucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfY29udGV4dDQsIF9jb250ZXh0NTtcbiAgdGhpcy5kZWFjdGl2YXRlKCk7XG4gIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNihfcmV2ZXJzZUluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQ0ID0gX3NwbGljZUluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQ1ID0gdGhpcy5fY2xlYW51cFF1ZXVlKS5jYWxsKF9jb250ZXh0NSwgMCkpLmNhbGwoX2NvbnRleHQ0KSksXG4gICAgX3N0ZXAyO1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBfc3RlcDIudmFsdWU7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMi5mKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQWN0aXZhdGUgdGhlIGVsZW1lbnRcbiAqIE92ZXJsYXkgaXMgaGlkZGVuLCBlbGVtZW50IGlzIGRlY29yYXRlZCB3aXRoIGEgYmx1ZSBzaGFkb3cgYm9yZGVyXG4gKi9cbkFjdGl2YXRvciQxLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gd2UgYWxsb3cgb25seSBvbmUgYWN0aXZlIGFjdGl2YXRvciBhdCBhIHRpbWVcbiAgaWYgKEFjdGl2YXRvciQxLmN1cnJlbnQpIHtcbiAgICBBY3RpdmF0b3IkMS5jdXJyZW50LmRlYWN0aXZhdGUoKTtcbiAgfVxuICBBY3RpdmF0b3IkMS5jdXJyZW50ID0gdGhpcztcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLl9kb20ub3ZlcmxheS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gIHRoaXMuX2RvbS5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInZpcy1hY3RpdmVcIik7XG4gIHRoaXMuZW1pdChcImNoYW5nZVwiKTtcbiAgdGhpcy5lbWl0KFwiYWN0aXZhdGVcIik7XG5cbiAgLy8gdWdseSBoYWNrOiBiaW5kIEVTQyBhZnRlciBlbWl0dGluZyB0aGUgZXZlbnRzLCBhcyB0aGUgTmV0d29yayByZWJpbmRzIGFsbFxuICAvLyBrZXlib2FyZCBldmVudHMgb24gYSAnY2hhbmdlJyBldmVudFxuICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2VzY0xpc3RlbmVyKTtcbn07XG5cbi8qKlxuICogRGVhY3RpdmF0ZSB0aGUgZWxlbWVudFxuICogT3ZlcmxheSBpcyBkaXNwbGF5ZWQgb24gdG9wIG9mIHRoZSBlbGVtZW50XG4gKi9cbkFjdGl2YXRvciQxLnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB0aGlzLl9kb20ub3ZlcmxheS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICB0aGlzLl9kb20uY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJ2aXMtYWN0aXZlXCIpO1xuICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2VzY0xpc3RlbmVyKTtcbiAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICB0aGlzLmVtaXQoXCJkZWFjdGl2YXRlXCIpO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgYSB0YXAgZXZlbnQ6IGFjdGl2YXRlIHRoZSBjb250YWluZXJcbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkFjdGl2YXRvciQxLnByb3RvdHlwZS5fb25UYXBPdmVybGF5ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIGFjdGl2YXRlIHRoZSBjb250YWluZXJcbiAgdGhpcy5hY3RpdmF0ZSgpO1xuICBldmVudC5zcmNFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIHRoZSBlbGVtZW50IGhhcyB0aGUgcmVxdWVzdGVkIHBhcmVudCBlbGVtZW50IHNvbWV3aGVyZSBpblxuICogaXRzIGNoYWluIG9mIHBhcmVudCBub2Rlcy5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgd2hlbiB0aGUgcGFyZW50IGlzIGZvdW5kIHNvbWV3aGVyZSBpbiB0aGVcbiAqICAgICAgICAgICAgICAgICAgICBjaGFpbiBvZiBwYXJlbnQgbm9kZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfaGFzUGFyZW50KGVsZW1lbnQsIHBhcmVudCkge1xuICB3aGlsZSAoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50ID09PSBwYXJlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbi8vIENvbG9yIFJFc1xudmFyIGZ1bGxIZXhSRSA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2k7XG52YXIgc2hvcnRIZXhSRSA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2k7XG52YXIgcmdiUkUgPSAvXnJnYlxcKCAqKDE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pICosICooMT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkgKiwgKigxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSAqXFwpJC9pO1xudmFyIHJnYmFSRSA9IC9ecmdiYVxcKCAqKDE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pICosICooMT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkgKiwgKigxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSAqLCAqKFswMV18MD9cXC5cXGQrKSAqXFwpJC9pO1xuLyoqXHJcbiAqIFJlbW92ZSBldmVyeXRoaW5nIGluIHRoZSBET00gb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0gRE9Nb2JqZWN0IC0gTm9kZSB3aG9zZSBjaGlsZCBub2RlcyB3aWxsIGJlIHJlY3Vyc2l2ZWx5IGRlbGV0ZWQuXHJcbiAqL1xuZnVuY3Rpb24gcmVjdXJzaXZlRE9NRGVsZXRlKERPTW9iamVjdCkge1xuICBpZiAoRE9Nb2JqZWN0KSB7XG4gICAgd2hpbGUgKERPTW9iamVjdC5oYXNDaGlsZE5vZGVzKCkgPT09IHRydWUpIHtcbiAgICAgIHZhciBjaGlsZCA9IERPTW9iamVjdC5maXJzdENoaWxkO1xuICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgIHJlY3Vyc2l2ZURPTURlbGV0ZShjaGlsZCk7XG4gICAgICAgIERPTW9iamVjdC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcclxuICogVGVzdCB3aGV0aGVyIGdpdmVuIG9iamVjdCBpcyBhIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gSW5wdXQgdmFsdWUgb2YgdW5rbm93biB0eXBlLlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHN0cmluZywgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZyB8fCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59XG4vKipcclxuICogVGVzdCB3aGV0aGVyIGdpdmVuIG9iamVjdCBpcyBhIG9iamVjdCAobm90IHByaW1pdGl2ZSBvciBudWxsKS5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gSW5wdXQgdmFsdWUgb2YgdW5rbm93biB0eXBlLlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIG5vdCBudWxsIG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0JDcodmFsdWUpIHtcbiAgcmV0dXJuIF90eXBlb2YodmFsdWUpID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsO1xufVxuLyoqXHJcbiAqIENvcHkgcHJvcGVydHkgZnJvbSBiIHRvIGEgaWYgcHJvcGVydHkgcHJlc2VudCBpbiBhLlxyXG4gKiBJZiBwcm9wZXJ0eSBpbiBiIGV4cGxpY2l0bHkgc2V0IHRvIG51bGwsIGRlbGV0ZSBpdCBpZiBgYWxsb3dEZWxldGlvbmAgc2V0LlxyXG4gKlxyXG4gKiBJbnRlcm5hbCBoZWxwZXIgcm91dGluZSwgc2hvdWxkIG5vdCBiZSBleHBvcnRlZC4gTm90IGFkZGVkIHRvIGBleHBvcnRzYCBmb3IgdGhhdCByZWFzb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBhIC0gVGFyZ2V0IG9iamVjdC5cclxuICogQHBhcmFtIGIgLSBTb3VyY2Ugb2JqZWN0LlxyXG4gKiBAcGFyYW0gcHJvcCAtIE5hbWUgb2YgcHJvcGVydHkgdG8gY29weSBmcm9tIGIgdG8gYS5cclxuICogQHBhcmFtIGFsbG93RGVsZXRpb24gLSBJZiB0cnVlLCBkZWxldGUgcHJvcGVydHkgaW4gYSBpZiBleHBsaWNpdGx5IHNldCB0byBudWxsIGluIGIuXHJcbiAqL1xuZnVuY3Rpb24gY29weU9yRGVsZXRlKGEsIGIsIHByb3AsIGFsbG93RGVsZXRpb24pIHtcbiAgdmFyIGRvRGVsZXRpb24gPSBmYWxzZTtcbiAgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUpIHtcbiAgICBkb0RlbGV0aW9uID0gYltwcm9wXSA9PT0gbnVsbCAmJiBhW3Byb3BdICE9PSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGRvRGVsZXRpb24pIHtcbiAgICBkZWxldGUgYVtwcm9wXTtcbiAgfSBlbHNlIHtcbiAgICBhW3Byb3BdID0gYltwcm9wXTsgLy8gUmVtZW1iZXIsIHRoaXMgaXMgYSByZWZlcmVuY2UgY29weSFcbiAgfVxufVxuLyoqXHJcbiAqIEZpbGwgYW4gb2JqZWN0IHdpdGggYSBwb3NzaWJseSBwYXJ0aWFsbHkgZGVmaW5lZCBvdGhlciBvYmplY3QuXHJcbiAqXHJcbiAqIE9ubHkgY29waWVzIHZhbHVlcyBmb3IgdGhlIHByb3BlcnRpZXMgYWxyZWFkeSBwcmVzZW50IGluIGEuXHJcbiAqIFRoYXQgbWVhbnMgYW4gb2JqZWN0IGlzIG5vdCBjcmVhdGVkIG9uIGEgcHJvcGVydHkgaWYgb25seSB0aGUgYiBvYmplY3QgaGFzIGl0LlxyXG4gKlxyXG4gKiBAcGFyYW0gYSAtIFRoZSBvYmplY3QgdGhhdCB3aWxsIGhhdmUgaXQncyBwcm9wZXJ0aWVzIHVwZGF0ZWQuXHJcbiAqIEBwYXJhbSBiIC0gVGhlIG9iamVjdCB3aXRoIHByb3BlcnR5IHVwZGF0ZXMuXHJcbiAqIEBwYXJhbSBhbGxvd0RlbGV0aW9uIC0gSWYgdHJ1ZSwgZGVsZXRlIHByb3BlcnRpZXMgaW4gYSB0aGF0IGFyZSBleHBsaWNpdGx5IHNldCB0byBudWxsIGluIGIuXHJcbiAqL1xuZnVuY3Rpb24gZmlsbElmRGVmaW5lZChhLCBiKSB7XG4gIHZhciBhbGxvd0RlbGV0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgLy8gTk9URTogaXRlcmF0aW9uIG9mIHByb3BlcnRpZXMgb2YgYVxuICAvLyBOT1RFOiBwcm90b3R5cGUgcHJvcGVydGllcyBpdGVyYXRlZCBvdmVyIGFzIHdlbGxcbiAgZm9yICh2YXIgcHJvcCBpbiBhKSB7XG4gICAgaWYgKGJbcHJvcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGJbcHJvcF0gPT09IG51bGwgfHwgX3R5cGVvZihiW3Byb3BdKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAvLyBOb3RlOiB0eXBlb2YgbnVsbCA9PT0gJ29iamVjdCdcbiAgICAgICAgY29weU9yRGVsZXRlKGEsIGIsIHByb3AsIGFsbG93RGVsZXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGFQcm9wID0gYVtwcm9wXTtcbiAgICAgICAgdmFyIGJQcm9wID0gYltwcm9wXTtcbiAgICAgICAgaWYgKGlzT2JqZWN0JDcoYVByb3ApICYmIGlzT2JqZWN0JDcoYlByb3ApKSB7XG4gICAgICAgICAgZmlsbElmRGVmaW5lZChhUHJvcCwgYlByb3AsIGFsbG93RGVsZXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcclxuICogRXh0ZW5kIG9iamVjdCBhIHdpdGggc2VsZWN0ZWQgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cclxuICogT25seSBwcm9wZXJ0aWVzIHdpdGggZGVmaW5lZCB2YWx1ZXMgYXJlIGNvcGllZC5cclxuICpcclxuICogQHJlbWFya3NcclxuICogUHJldmlvdXMgdmVyc2lvbiBvZiB0aGlzIHJvdXRpbmUgaW1wbGllZCB0aGF0IG11bHRpcGxlIHNvdXJjZSBvYmplY3RzIGNvdWxkXHJcbiAqIGJlIHVzZWQ7IGhvd2V2ZXIsIHRoZSBpbXBsZW1lbnRhdGlvbiB3YXMgKip3cm9uZyoqLiBTaW5jZSBtdWx0aXBsZSAoXFw+MSlcclxuICogc291cmNlcyB3ZXJlbid0IHVzZWQgYW55d2hlcmUgaW4gdGhlIGB2aXMuanNgIGNvZGUsIHRoaXMgaGFzIGJlZW4gcmVtb3ZlZFxyXG4gKiBAcGFyYW0gcHJvcHMgLSBOYW1lcyBvZiBmaXJzdC1sZXZlbCBwcm9wZXJ0aWVzIHRvIGNvcHkgb3Zlci5cclxuICogQHBhcmFtIGEgLSBUYXJnZXQgb2JqZWN0LlxyXG4gKiBAcGFyYW0gYiAtIFNvdXJjZSBvYmplY3QuXHJcbiAqIEBwYXJhbSBhbGxvd0RlbGV0aW9uIC0gSWYgdHJ1ZSwgZGVsZXRlIHByb3BlcnR5IGluIGEgaWYgZXhwbGljaXRseSBzZXQgdG8gbnVsbCBpbiBiLlxyXG4gKiBAcmV0dXJucyBBcmd1bWVudCBhLlxyXG4gKi9cbmZ1bmN0aW9uIHNlbGVjdGl2ZURlZXBFeHRlbmQocHJvcHMsIGEsIGIpIHtcbiAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgQXJyYXlzIHRvIGRlZXBFeHRlbmRcbiAgaWYgKF9BcnJheSRpc0FycmF5KGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBieSBkZWVwRXh0ZW5kXCIpO1xuICB9XG4gIGZvciAodmFyIHAgPSAwOyBwIDwgcHJvcHMubGVuZ3RoOyBwKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW3BdO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcHJvcCkpIHtcbiAgICAgIGlmIChiW3Byb3BdICYmIGJbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICBpZiAoYVtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYVtwcm9wXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICBkZWVwRXh0ZW5kKGFbcHJvcF0sIGJbcHJvcF0sIGZhbHNlLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoX0FycmF5JGlzQXJyYXkoYltwcm9wXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBieSBkZWVwRXh0ZW5kXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weU9yRGVsZXRlKGEsIGIsIHByb3AsIGFsbG93RGVsZXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn1cbi8qKlxyXG4gKiBFeHRlbmQgb2JqZWN0IGBhYCB3aXRoIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGBiYCwgaWdub3JpbmcgcHJvcGVydGllcyB3aGljaFxyXG4gKiBhcmUgZXhwbGljaXRseSBzcGVjaWZpZWQgdG8gYmUgZXhjbHVkZWQuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFRoZSBwcm9wZXJ0aWVzIG9mIGBiYCBhcmUgY29uc2lkZXJlZCBmb3IgY29weWluZy4gUHJvcGVydGllcyB3aGljaCBhcmVcclxuICogdGhlbXNlbHZlcyBvYmplY3RzIGFyZSBhcmUgYWxzbyBleHRlbmRlZC4gT25seSBwcm9wZXJ0aWVzIHdpdGggZGVmaW5lZFxyXG4gKiB2YWx1ZXMgYXJlIGNvcGllZC5cclxuICogQHBhcmFtIHByb3BzVG9FeGNsdWRlIC0gTmFtZXMgb2YgcHJvcGVydGllcyB3aGljaCBzaG91bGQgKm5vdCogYmUgY29waWVkLlxyXG4gKiBAcGFyYW0gYSAtIE9iamVjdCB0byBleHRlbmQuXHJcbiAqIEBwYXJhbSBiIC0gT2JqZWN0IHRvIHRha2UgcHJvcGVydGllcyBmcm9tIGZvciBleHRlbnNpb24uXHJcbiAqIEBwYXJhbSBhbGxvd0RlbGV0aW9uIC0gSWYgdHJ1ZSwgZGVsZXRlIHByb3BlcnRpZXMgaW4gYSB0aGF0IGFyZSBleHBsaWNpdGx5XHJcbiAqIHNldCB0byBudWxsIGluIGIuXHJcbiAqIEByZXR1cm5zIEFyZ3VtZW50IGEuXHJcbiAqL1xuZnVuY3Rpb24gc2VsZWN0aXZlTm90RGVlcEV4dGVuZChwcm9wc1RvRXhjbHVkZSwgYSwgYikge1xuICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gIC8vIFRPRE86IGFkZCBzdXBwb3J0IGZvciBBcnJheXMgdG8gZGVlcEV4dGVuZFxuICAvLyBOT1RFOiBhcnJheSBwcm9wZXJ0aWVzIGhhdmUgYW4gZWxzZS1iZWxvdzsgYXBwYXJlbnRseSwgdGhlcmUgaXMgYSBwcm9ibGVtIGhlcmUuXG4gIGlmIChfQXJyYXkkaXNBcnJheShiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZFwiKTtcbiAgfVxuICBmb3IgKHZhciBwcm9wIGluIGIpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwcm9wKSkge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBIYW5kbGUgbG9jYWwgcHJvcGVydGllcyBvbmx5XG4gICAgaWYgKF9pbmNsdWRlc0luc3RhbmNlUHJvcGVydHkocHJvcHNUb0V4Y2x1ZGUpLmNhbGwocHJvcHNUb0V4Y2x1ZGUsIHByb3ApKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIEluIGV4Y2x1c2lvbiBsaXN0LCBza2lwXG4gICAgaWYgKGJbcHJvcF0gJiYgYltwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICBpZiAoYVtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFbcHJvcF0gPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChhW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgZGVlcEV4dGVuZChhW3Byb3BdLCBiW3Byb3BdKTsgLy8gTk9URTogYWxsb3dEZWxldGlvbiBub3QgcHJvcGFnYXRlZCFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvcHlPckRlbGV0ZShhLCBiLCBwcm9wLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9BcnJheSRpc0FycmF5KGJbcHJvcF0pKSB7XG4gICAgICBhW3Byb3BdID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJbcHJvcF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYVtwcm9wXS5wdXNoKGJbcHJvcF1baV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufVxuLyoqXHJcbiAqIERlZXAgZXh0ZW5kIGFuIG9iamVjdCBhIHdpdGggdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIC0gVGFyZ2V0IG9iamVjdC5cclxuICogQHBhcmFtIGIgLSBTb3VyY2Ugb2JqZWN0LlxyXG4gKiBAcGFyYW0gcHJvdG9FeHRlbmQgLSBJZiB0cnVlLCB0aGUgcHJvdG90eXBlIHZhbHVlcyB3aWxsIGFsc28gYmUgZXh0ZW5kZWQuXHJcbiAqIChUaGF0IGlzIHRoZSBvcHRpb25zIG9iamVjdHMgdGhhdCBpbmhlcml0IGZyb20gb3RoZXJzIHdpbGwgYWxzbyBnZXQgdGhlXHJcbiAqIGluaGVyaXRlZCBvcHRpb25zKS5cclxuICogQHBhcmFtIGFsbG93RGVsZXRpb24gLSBJZiB0cnVlLCB0aGUgdmFsdWVzIG9mIGZpZWxkcyB0aGF0IGFyZSBudWxsIHdpbGwgYmUgZGVsZXRlZC5cclxuICogQHJldHVybnMgQXJndW1lbnQgYS5cclxuICovXG5mdW5jdGlvbiBkZWVwRXh0ZW5kKGEsIGIpIHtcbiAgdmFyIHByb3RvRXh0ZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuICBmb3IgKHZhciBwcm9wIGluIGIpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHByb3ApIHx8IHByb3RvRXh0ZW5kID09PSB0cnVlKSB7XG4gICAgICBpZiAoX3R5cGVvZihiW3Byb3BdKSA9PT0gXCJvYmplY3RcIiAmJiBiW3Byb3BdICE9PSBudWxsICYmIF9PYmplY3QkZ2V0UHJvdG90eXBlT2YkMShiW3Byb3BdKSA9PT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAoYVtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYVtwcm9wXSA9IGRlZXBFeHRlbmQoe30sIGJbcHJvcF0sIHByb3RvRXh0ZW5kKTsgLy8gTk9URTogYWxsb3dEZWxldGlvbiBub3QgcHJvcGFnYXRlZCFcbiAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKGFbcHJvcF0pID09PSBcIm9iamVjdFwiICYmIGFbcHJvcF0gIT09IG51bGwgJiYgX09iamVjdCRnZXRQcm90b3R5cGVPZiQxKGFbcHJvcF0pID09PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgICAgICAgZGVlcEV4dGVuZChhW3Byb3BdLCBiW3Byb3BdLCBwcm90b0V4dGVuZCk7IC8vIE5PVEU6IGFsbG93RGVsZXRpb24gbm90IHByb3BhZ2F0ZWQhXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29weU9yRGVsZXRlKGEsIGIsIHByb3AsIGFsbG93RGVsZXRpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKF9BcnJheSRpc0FycmF5KGJbcHJvcF0pKSB7XG4gICAgICAgIHZhciBfY29udGV4dDY7XG4gICAgICAgIGFbcHJvcF0gPSBfc2xpY2VJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0NiA9IGJbcHJvcF0pLmNhbGwoX2NvbnRleHQ2KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvcHlPckRlbGV0ZShhLCBiLCBwcm9wLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59XG4vKipcclxuICogVXNlZCB0byBleHRlbmQgYW4gYXJyYXkgYW5kIGNvcHkgaXQuIFRoaXMgaXMgdXNlZCB0byBwcm9wYWdhdGUgcGF0aHMgcmVjdXJzaXZlbHkuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnIgLSBGaXJzdCBwYXJ0LlxyXG4gKiBAcGFyYW0gbmV3VmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgYWFkZGVkIGludG8gdGhlIGFycmF5LlxyXG4gKiBAcmV0dXJucyBBIG5ldyBhcnJheSB3aXRoIGFsbCBpdGVtcyBmcm9tIGFyciBhbmQgbmV3VmFsdWUgKHdoaWNoIGlzIGxhc3QpLlxyXG4gKi9cbmZ1bmN0aW9uIGNvcHlBbmRFeHRlbmRBcnJheShhcnIsIG5ld1ZhbHVlKSB7XG4gIHZhciBfY29udGV4dDc7XG4gIHJldHVybiBfY29uY2F0SW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDcgPSBbXSkuY2FsbChfY29udGV4dDcsIF90b0NvbnN1bWFibGVBcnJheShhcnIpLCBbbmV3VmFsdWVdKTtcbn1cbi8qKlxyXG4gKiBVc2VkIHRvIGV4dGVuZCBhbiBhcnJheSBhbmQgY29weSBpdC4gVGhpcyBpcyB1c2VkIHRvIHByb3BhZ2F0ZSBwYXRocyByZWN1cnNpdmVseS5cclxuICpcclxuICogQHBhcmFtIGFyciAtIFRoZSBhcnJheSB0byBiZSBjb3BpZWQuXHJcbiAqIEByZXR1cm5zIFNoYWxsb3cgY29weSBvZiBhcnIuXHJcbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KGFycikge1xuICByZXR1cm4gX3NsaWNlSW5zdGFuY2VQcm9wZXJ0eShhcnIpLmNhbGwoYXJyKTtcbn1cbi8qKlxyXG4gKiBSZXRyaWV2ZSB0aGUgYWJzb2x1dGUgbGVmdCB2YWx1ZSBvZiBhIERPTSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gZWxlbSAtIEEgZG9tIGVsZW1lbnQsIGZvciBleGFtcGxlIGEgZGl2LlxyXG4gKiBAcmV0dXJucyBUaGUgYWJzb2x1dGUgbGVmdCBwb3NpdGlvbiBvZiB0aGlzIGVsZW1lbnQgaW4gdGhlIGJyb3dzZXIgcGFnZS5cclxuICovXG5mdW5jdGlvbiBnZXRBYnNvbHV0ZUxlZnQoZWxlbSkge1xuICByZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xufVxuLyoqXHJcbiAqIFJldHJpZXZlIHRoZSBhYnNvbHV0ZSB0b3AgdmFsdWUgb2YgYSBET00gZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIGVsZW0gLSBBIGRvbSBlbGVtZW50LCBmb3IgZXhhbXBsZSBhIGRpdi5cclxuICogQHJldHVybnMgVGhlIGFic29sdXRlIHRvcCBwb3NpdGlvbiBvZiB0aGlzIGVsZW1lbnQgaW4gdGhlIGJyb3dzZXIgcGFnZS5cclxuICovXG5mdW5jdGlvbiBnZXRBYnNvbHV0ZVRvcChlbGVtKSB7XG4gIHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbn1cbi8qKlxyXG4gKiBGb3IgZWFjaCBtZXRob2QgZm9yIGJvdGggYXJyYXlzIGFuZCBvYmplY3RzLlxyXG4gKiBJbiBjYXNlIG9mIGFuIGFycmF5LCB0aGUgYnVpbHQtaW4gQXJyYXkuZm9yRWFjaCgpIGlzIGFwcGxpZWQgKCoqTm8sIGl0J3Mgbm90ISoqKS5cclxuICogSW4gY2FzZSBvZiBhbiBPYmplY3QsIHRoZSBtZXRob2QgbG9vcHMgb3ZlciBhbGwgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0gb2JqZWN0IC0gQW4gT2JqZWN0IG9yIEFycmF5IHRvIGJlIGl0ZXJhdGVkIG92ZXIuXHJcbiAqIEBwYXJhbSBjYWxsYmFjayAtIEFycmF5LmZvckVhY2gtbGlrZSBjYWxsYmFjay5cclxuICovXG5mdW5jdGlvbiBmb3JFYWNoJDEob2JqZWN0LCBjYWxsYmFjaykge1xuICBpZiAoX0FycmF5JGlzQXJyYXkob2JqZWN0KSkge1xuICAgIC8vIGFycmF5XG4gICAgdmFyIGxlbiA9IG9iamVjdC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2FsbGJhY2sob2JqZWN0W2ldLCBpLCBvYmplY3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBvYmplY3RcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICBjYWxsYmFjayhvYmplY3Rba2V5XSwga2V5LCBvYmplY3QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXHJcbiAqIENvbnZlcnQgaGV4IGNvbG9yIHN0cmluZyBpbnRvIFJHQiBjb2xvciBvYmplY3QuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIHtAbGluayBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU2MjM4MzgvcmdiLXRvLWhleC1hbmQtaGV4LXRvLXJnYn1cclxuICogQHBhcmFtIGhleCAtIEhleCBjb2xvciBzdHJpbmcgKDMgb3IgNiBkaWdpdHMsIHdpdGggb3Igd2l0aG91dCAjKS5cclxuICogQHJldHVybnMgUkdCIGNvbG9yIG9iamVjdC5cclxuICovXG5mdW5jdGlvbiBoZXhUb1JHQihoZXgpIHtcbiAgdmFyIHJlc3VsdDtcbiAgc3dpdGNoIChoZXgubGVuZ3RoKSB7XG4gICAgY2FzZSAzOlxuICAgIGNhc2UgNDpcbiAgICAgIHJlc3VsdCA9IHNob3J0SGV4UkUuZXhlYyhoZXgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA/IHtcbiAgICAgICAgcjogX3BhcnNlSW50JDEocmVzdWx0WzFdICsgcmVzdWx0WzFdLCAxNiksXG4gICAgICAgIGc6IF9wYXJzZUludCQxKHJlc3VsdFsyXSArIHJlc3VsdFsyXSwgMTYpLFxuICAgICAgICBiOiBfcGFyc2VJbnQkMShyZXN1bHRbM10gKyByZXN1bHRbM10sIDE2KVxuICAgICAgfSA6IG51bGw7XG4gICAgY2FzZSA2OlxuICAgIGNhc2UgNzpcbiAgICAgIHJlc3VsdCA9IGZ1bGxIZXhSRS5leGVjKGhleCk7XG4gICAgICByZXR1cm4gcmVzdWx0ID8ge1xuICAgICAgICByOiBfcGFyc2VJbnQkMShyZXN1bHRbMV0sIDE2KSxcbiAgICAgICAgZzogX3BhcnNlSW50JDEocmVzdWx0WzJdLCAxNiksXG4gICAgICAgIGI6IF9wYXJzZUludCQxKHJlc3VsdFszXSwgMTYpXG4gICAgICB9IDogbnVsbDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIHN0cmluZyBjb2xvciBpbiBoZXggb3IgUkdCIGZvcm1hdCBhbmQgYWRkcyB0aGUgb3BhY2l0eSwgUkdCQSBpcyBwYXNzZWQgdGhyb3VnaCB1bmNoYW5nZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb2xvciAtIFRoZSBjb2xvciBzdHJpbmcgKGhleCwgUkdCLCBSR0JBKS5cclxuICogQHBhcmFtIG9wYWNpdHkgLSBUaGUgbmV3IG9wYWNpdHkuXHJcbiAqIEByZXR1cm5zIFJHQkEgc3RyaW5nLCBmb3IgZXhhbXBsZSAncmdiYSgyNTUsIDAsIDEyNywgMC4zKScuXHJcbiAqL1xuZnVuY3Rpb24gb3ZlcnJpZGVPcGFjaXR5KGNvbG9yLCBvcGFjaXR5KSB7XG4gIGlmIChfaW5jbHVkZXNJbnN0YW5jZVByb3BlcnR5KGNvbG9yKS5jYWxsKGNvbG9yLCBcInJnYmFcIikpIHtcbiAgICByZXR1cm4gY29sb3I7XG4gIH0gZWxzZSBpZiAoX2luY2x1ZGVzSW5zdGFuY2VQcm9wZXJ0eShjb2xvcikuY2FsbChjb2xvciwgXCJyZ2JcIikpIHtcbiAgICB2YXIgcmdiID0gY29sb3Iuc3Vic3RyKF9pbmRleE9mSW5zdGFuY2VQcm9wZXJ0eShjb2xvcikuY2FsbChjb2xvciwgXCIoXCIpICsgMSkucmVwbGFjZShcIilcIiwgXCJcIikuc3BsaXQoXCIsXCIpO1xuICAgIHJldHVybiBcInJnYmEoXCIgKyByZ2JbMF0gKyBcIixcIiArIHJnYlsxXSArIFwiLFwiICsgcmdiWzJdICsgXCIsXCIgKyBvcGFjaXR5ICsgXCIpXCI7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9yZ2IgPSBoZXhUb1JHQihjb2xvcik7XG4gICAgaWYgKF9yZ2IgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJyZ2JhKFwiICsgX3JnYi5yICsgXCIsXCIgKyBfcmdiLmcgKyBcIixcIiArIF9yZ2IuYiArIFwiLFwiICsgb3BhY2l0eSArIFwiKVwiO1xuICAgIH1cbiAgfVxufVxuLyoqXHJcbiAqIENvbnZlcnQgUkdCIFxcPDAsIDI1NVxcPiBpbnRvIGhleCBjb2xvciBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSByZWQgLSBSZWQgY2hhbm5lbC5cclxuICogQHBhcmFtIGdyZWVuIC0gR3JlZW4gY2hhbm5lbC5cclxuICogQHBhcmFtIGJsdWUgLSBCbHVlIGNoYW5uZWwuXHJcbiAqIEByZXR1cm5zIEhleCBjb2xvciBzdHJpbmcgKGZvciBleGFtcGxlOiAnIzBhY2RjMCcpLlxyXG4gKi9cbmZ1bmN0aW9uIFJHQlRvSGV4KHJlZCwgZ3JlZW4sIGJsdWUpIHtcbiAgdmFyIF9jb250ZXh0MTA7XG4gIHJldHVybiBcIiNcIiArIF9zbGljZUluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQxMCA9ICgoMSA8PCAyNCkgKyAocmVkIDw8IDE2KSArIChncmVlbiA8PCA4KSArIGJsdWUpLnRvU3RyaW5nKDE2KSkuY2FsbChfY29udGV4dDEwLCAxKTtcbn1cbi8qKlxyXG4gKiBQYXJzZSBhIGNvbG9yIHByb3BlcnR5IGludG8gYW4gb2JqZWN0IHdpdGggYm9yZGVyLCBiYWNrZ3JvdW5kLCBhbmQgaGlnaGxpZ2h0IGNvbG9ycy5cclxuICpcclxuICogQHBhcmFtIGlucHV0Q29sb3IgLSBTaG9ydGhhbmQgY29sb3Igc3RyaW5nIG9yIGlucHV0IGNvbG9yIG9iamVjdC5cclxuICogQHBhcmFtIGRlZmF1bHRDb2xvciAtIEZ1bGwgY29sb3Igb2JqZWN0IHRvIGZpbGwgaW4gbWlzc2luZyB2YWx1ZXMgaW4gaW5wdXRDb2xvci5cclxuICogQHJldHVybnMgQ29sb3Igb2JqZWN0LlxyXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ29sb3IoaW5wdXRDb2xvciwgZGVmYXVsdENvbG9yKSB7XG4gIGlmIChpc1N0cmluZyhpbnB1dENvbG9yKSkge1xuICAgIHZhciBjb2xvclN0ciA9IGlucHV0Q29sb3I7XG4gICAgaWYgKGlzVmFsaWRSR0IoY29sb3JTdHIpKSB7XG4gICAgICB2YXIgX2NvbnRleHQxMTtcbiAgICAgIHZhciByZ2IgPSBfbWFwSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDExID0gY29sb3JTdHIuc3Vic3RyKDQpLnN1YnN0cigwLCBjb2xvclN0ci5sZW5ndGggLSA1KS5zcGxpdChcIixcIikpLmNhbGwoX2NvbnRleHQxMSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfcGFyc2VJbnQkMSh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIGNvbG9yU3RyID0gUkdCVG9IZXgocmdiWzBdLCByZ2JbMV0sIHJnYlsyXSk7XG4gICAgfVxuICAgIGlmIChpc1ZhbGlkSGV4KGNvbG9yU3RyKSA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIGhzdiA9IGhleFRvSFNWKGNvbG9yU3RyKTtcbiAgICAgIHZhciBsaWdodGVyQ29sb3JIU1YgPSB7XG4gICAgICAgIGg6IGhzdi5oLFxuICAgICAgICBzOiBoc3YucyAqIDAuOCxcbiAgICAgICAgdjogTWF0aC5taW4oMSwgaHN2LnYgKiAxLjAyKVxuICAgICAgfTtcbiAgICAgIHZhciBkYXJrZXJDb2xvckhTViA9IHtcbiAgICAgICAgaDogaHN2LmgsXG4gICAgICAgIHM6IE1hdGgubWluKDEsIGhzdi5zICogMS4yNSksXG4gICAgICAgIHY6IGhzdi52ICogMC44XG4gICAgICB9O1xuICAgICAgdmFyIGRhcmtlckNvbG9ySGV4ID0gSFNWVG9IZXgoZGFya2VyQ29sb3JIU1YuaCwgZGFya2VyQ29sb3JIU1YucywgZGFya2VyQ29sb3JIU1Yudik7XG4gICAgICB2YXIgbGlnaHRlckNvbG9ySGV4ID0gSFNWVG9IZXgobGlnaHRlckNvbG9ySFNWLmgsIGxpZ2h0ZXJDb2xvckhTVi5zLCBsaWdodGVyQ29sb3JIU1Yudik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvclN0cixcbiAgICAgICAgYm9yZGVyOiBkYXJrZXJDb2xvckhleCxcbiAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogbGlnaHRlckNvbG9ySGV4LFxuICAgICAgICAgIGJvcmRlcjogZGFya2VyQ29sb3JIZXhcbiAgICAgICAgfSxcbiAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBsaWdodGVyQ29sb3JIZXgsXG4gICAgICAgICAgYm9yZGVyOiBkYXJrZXJDb2xvckhleFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvclN0cixcbiAgICAgICAgYm9yZGVyOiBjb2xvclN0cixcbiAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogY29sb3JTdHIsXG4gICAgICAgICAgYm9yZGVyOiBjb2xvclN0clxuICAgICAgICB9LFxuICAgICAgICBob3Zlcjoge1xuICAgICAgICAgIGJhY2tncm91bmQ6IGNvbG9yU3RyLFxuICAgICAgICAgIGJvcmRlcjogY29sb3JTdHJcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlZmF1bHRDb2xvcikge1xuICAgICAgdmFyIGNvbG9yID0ge1xuICAgICAgICBiYWNrZ3JvdW5kOiBpbnB1dENvbG9yLmJhY2tncm91bmQgfHwgZGVmYXVsdENvbG9yLmJhY2tncm91bmQsXG4gICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5ib3JkZXIgfHwgZGVmYXVsdENvbG9yLmJvcmRlcixcbiAgICAgICAgaGlnaGxpZ2h0OiBpc1N0cmluZyhpbnB1dENvbG9yLmhpZ2hsaWdodCkgPyB7XG4gICAgICAgICAgYm9yZGVyOiBpbnB1dENvbG9yLmhpZ2hsaWdodCxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBpbnB1dENvbG9yLmhpZ2hsaWdodFxuICAgICAgICB9IDoge1xuICAgICAgICAgIGJhY2tncm91bmQ6IGlucHV0Q29sb3IuaGlnaGxpZ2h0ICYmIGlucHV0Q29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQgfHwgZGVmYXVsdENvbG9yLmhpZ2hsaWdodC5iYWNrZ3JvdW5kLFxuICAgICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5oaWdobGlnaHQgJiYgaW5wdXRDb2xvci5oaWdobGlnaHQuYm9yZGVyIHx8IGRlZmF1bHRDb2xvci5oaWdobGlnaHQuYm9yZGVyXG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyOiBpc1N0cmluZyhpbnB1dENvbG9yLmhvdmVyKSA/IHtcbiAgICAgICAgICBib3JkZXI6IGlucHV0Q29sb3IuaG92ZXIsXG4gICAgICAgICAgYmFja2dyb3VuZDogaW5wdXRDb2xvci5ob3ZlclxuICAgICAgICB9IDoge1xuICAgICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5ob3ZlciAmJiBpbnB1dENvbG9yLmhvdmVyLmJvcmRlciB8fCBkZWZhdWx0Q29sb3IuaG92ZXIuYm9yZGVyLFxuICAgICAgICAgIGJhY2tncm91bmQ6IGlucHV0Q29sb3IuaG92ZXIgJiYgaW5wdXRDb2xvci5ob3Zlci5iYWNrZ3JvdW5kIHx8IGRlZmF1bHRDb2xvci5ob3Zlci5iYWNrZ3JvdW5kXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY29sb3IgPSB7XG4gICAgICAgIGJhY2tncm91bmQ6IGlucHV0Q29sb3IuYmFja2dyb3VuZCB8fCB1bmRlZmluZWQsXG4gICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5ib3JkZXIgfHwgdW5kZWZpbmVkLFxuICAgICAgICBoaWdobGlnaHQ6IGlzU3RyaW5nKGlucHV0Q29sb3IuaGlnaGxpZ2h0KSA/IHtcbiAgICAgICAgICBib3JkZXI6IGlucHV0Q29sb3IuaGlnaGxpZ2h0LFxuICAgICAgICAgIGJhY2tncm91bmQ6IGlucHV0Q29sb3IuaGlnaGxpZ2h0XG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogaW5wdXRDb2xvci5oaWdobGlnaHQgJiYgaW5wdXRDb2xvci5oaWdobGlnaHQuYmFja2dyb3VuZCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgYm9yZGVyOiBpbnB1dENvbG9yLmhpZ2hsaWdodCAmJiBpbnB1dENvbG9yLmhpZ2hsaWdodC5ib3JkZXIgfHwgdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyOiBpc1N0cmluZyhpbnB1dENvbG9yLmhvdmVyKSA/IHtcbiAgICAgICAgICBib3JkZXI6IGlucHV0Q29sb3IuaG92ZXIsXG4gICAgICAgICAgYmFja2dyb3VuZDogaW5wdXRDb2xvci5ob3ZlclxuICAgICAgICB9IDoge1xuICAgICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5ob3ZlciAmJiBpbnB1dENvbG9yLmhvdmVyLmJvcmRlciB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgYmFja2dyb3VuZDogaW5wdXRDb2xvci5ob3ZlciAmJiBpbnB1dENvbG9yLmhvdmVyLmJhY2tncm91bmQgfHwgdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gX2NvbG9yO1xuICAgIH1cbiAgfVxufVxuLyoqXHJcbiAqIENvbnZlcnQgUkdCIFxcPDAsIDI1NVxcPiBpbnRvIEhTViBvYmplY3QuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIHtAbGluayBodHRwOi8vd3d3LmphdmFzY3JpcHRlci5uZXQvZmFxL3JnYjJoc3YuaHRtfVxyXG4gKiBAcGFyYW0gcmVkIC0gUmVkIGNoYW5uZWwuXHJcbiAqIEBwYXJhbSBncmVlbiAtIEdyZWVuIGNoYW5uZWwuXHJcbiAqIEBwYXJhbSBibHVlIC0gQmx1ZSBjaGFubmVsLlxyXG4gKiBAcmV0dXJucyBIU1YgY29sb3Igb2JqZWN0LlxyXG4gKi9cbmZ1bmN0aW9uIFJHQlRvSFNWKHJlZCwgZ3JlZW4sIGJsdWUpIHtcbiAgcmVkID0gcmVkIC8gMjU1O1xuICBncmVlbiA9IGdyZWVuIC8gMjU1O1xuICBibHVlID0gYmx1ZSAvIDI1NTtcbiAgdmFyIG1pblJHQiA9IE1hdGgubWluKHJlZCwgTWF0aC5taW4oZ3JlZW4sIGJsdWUpKTtcbiAgdmFyIG1heFJHQiA9IE1hdGgubWF4KHJlZCwgTWF0aC5tYXgoZ3JlZW4sIGJsdWUpKTtcbiAgLy8gQmxhY2stZ3JheS13aGl0ZVxuICBpZiAobWluUkdCID09PSBtYXhSR0IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaDogMCxcbiAgICAgIHM6IDAsXG4gICAgICB2OiBtaW5SR0JcbiAgICB9O1xuICB9XG4gIC8vIENvbG9ycyBvdGhlciB0aGFuIGJsYWNrLWdyYXktd2hpdGU6XG4gIHZhciBkID0gcmVkID09PSBtaW5SR0IgPyBncmVlbiAtIGJsdWUgOiBibHVlID09PSBtaW5SR0IgPyByZWQgLSBncmVlbiA6IGJsdWUgLSByZWQ7XG4gIHZhciBoID0gcmVkID09PSBtaW5SR0IgPyAzIDogYmx1ZSA9PT0gbWluUkdCID8gMSA6IDU7XG4gIHZhciBodWUgPSA2MCAqIChoIC0gZCAvIChtYXhSR0IgLSBtaW5SR0IpKSAvIDM2MDtcbiAgdmFyIHNhdHVyYXRpb24gPSAobWF4UkdCIC0gbWluUkdCKSAvIG1heFJHQjtcbiAgdmFyIHZhbHVlID0gbWF4UkdCO1xuICByZXR1cm4ge1xuICAgIGg6IGh1ZSxcbiAgICBzOiBzYXR1cmF0aW9uLFxuICAgIHY6IHZhbHVlXG4gIH07XG59XG4vKipcclxuICogQ29udmVydCBIU1YgXFw8MCwgMVxcPiBpbnRvIFJHQiBjb2xvciBvYmplY3QuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIHtAbGluayBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9tamlqYWNrc29uLzUzMTEyNTZ9XHJcbiAqIEBwYXJhbSBoIC0gSHVlLlxyXG4gKiBAcGFyYW0gcyAtIFNhdHVyYXRpb24uXHJcbiAqIEBwYXJhbSB2IC0gVmFsdWUuXHJcbiAqIEByZXR1cm5zIFJHQiBjb2xvciBvYmplY3QuXHJcbiAqL1xuZnVuY3Rpb24gSFNWVG9SR0IoaCwgcywgdikge1xuICB2YXIgcjtcbiAgdmFyIGc7XG4gIHZhciBiO1xuICB2YXIgaSA9IE1hdGguZmxvb3IoaCAqIDYpO1xuICB2YXIgZiA9IGggKiA2IC0gaTtcbiAgdmFyIHAgPSB2ICogKDEgLSBzKTtcbiAgdmFyIHEgPSB2ICogKDEgLSBmICogcyk7XG4gIHZhciB0ID0gdiAqICgxIC0gKDEgLSBmKSAqIHMpO1xuICBzd2l0Y2ggKGkgJSA2KSB7XG4gICAgY2FzZSAwOlxuICAgICAgciA9IHYsIGcgPSB0LCBiID0gcDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHIgPSBxLCBnID0gdiwgYiA9IHA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICByID0gcCwgZyA9IHYsIGIgPSB0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgciA9IHAsIGcgPSBxLCBiID0gdjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIHIgPSB0LCBnID0gcCwgYiA9IHY7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDU6XG4gICAgICByID0gdiwgZyA9IHAsIGIgPSBxO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByOiBNYXRoLmZsb29yKHIgKiAyNTUpLFxuICAgIGc6IE1hdGguZmxvb3IoZyAqIDI1NSksXG4gICAgYjogTWF0aC5mbG9vcihiICogMjU1KVxuICB9O1xufVxuLyoqXHJcbiAqIENvbnZlcnQgSFNWIFxcPDAsIDFcXD4gaW50byBoZXggY29sb3Igc3RyaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0gaCAtIEh1ZS5cclxuICogQHBhcmFtIHMgLSBTYXR1cmF0aW9uLlxyXG4gKiBAcGFyYW0gdiAtIFZhbHVlLlxyXG4gKiBAcmV0dXJucyBIZXggY29sb3Igc3RyaW5nLlxyXG4gKi9cbmZ1bmN0aW9uIEhTVlRvSGV4KGgsIHMsIHYpIHtcbiAgdmFyIHJnYiA9IEhTVlRvUkdCKGgsIHMsIHYpO1xuICByZXR1cm4gUkdCVG9IZXgocmdiLnIsIHJnYi5nLCByZ2IuYik7XG59XG4vKipcclxuICogQ29udmVydCBoZXggY29sb3Igc3RyaW5nIGludG8gSFNWIFxcPDAsIDFcXD4uXHJcbiAqXHJcbiAqIEBwYXJhbSBoZXggLSBIZXggY29sb3Igc3RyaW5nLlxyXG4gKiBAcmV0dXJucyBIU1YgY29sb3Igb2JqZWN0LlxyXG4gKi9cbmZ1bmN0aW9uIGhleFRvSFNWKGhleCkge1xuICB2YXIgcmdiID0gaGV4VG9SR0IoaGV4KTtcbiAgaWYgKCFyZ2IpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ1wiLmNvbmNhdChoZXgsIFwiJyBpcyBub3QgYSB2YWxpZCBjb2xvci5cIikpO1xuICB9XG4gIHJldHVybiBSR0JUb0hTVihyZ2IuciwgcmdiLmcsIHJnYi5iKTtcbn1cbi8qKlxyXG4gKiBWYWxpZGF0ZSBoZXggY29sb3Igc3RyaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0gaGV4IC0gVW5rbm93biBzdHJpbmcgdGhhdCBtYXkgY29udGFpbiBhIGNvbG9yLlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5mdW5jdGlvbiBpc1ZhbGlkSGV4KGhleCkge1xuICB2YXIgaXNPayA9IC8oXiNbMC05QS1GXXs2fSQpfCheI1swLTlBLUZdezN9JCkvaS50ZXN0KGhleCk7XG4gIHJldHVybiBpc09rO1xufVxuLyoqXHJcbiAqIFZhbGlkYXRlIFJHQiBjb2xvciBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSByZ2IgLSBVbmtub3duIHN0cmluZyB0aGF0IG1heSBjb250YWluIGEgY29sb3IuXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHN0cmluZyBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRSR0IocmdiKSB7XG4gIHJldHVybiByZ2JSRS50ZXN0KHJnYik7XG59XG4vKipcclxuICogVmFsaWRhdGUgUkdCQSBjb2xvciBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSByZ2JhIC0gVW5rbm93biBzdHJpbmcgdGhhdCBtYXkgY29udGFpbiBhIGNvbG9yLlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5mdW5jdGlvbiBpc1ZhbGlkUkdCQShyZ2JhKSB7XG4gIHJldHVybiByZ2JhUkUudGVzdChyZ2JhKTtcbn1cbi8qKlxyXG4gKiBUaGlzIHJlY3Vyc2l2ZWx5IHJlZGlyZWN0cyB0aGUgcHJvdG90eXBlIG9mIEpTT04gb2JqZWN0cyB0byB0aGUgcmVmZXJlbmNlT2JqZWN0LlxyXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGRlZmF1bHQgb3B0aW9ucy5cclxuICpcclxuICogQHBhcmFtIHJlZmVyZW5jZU9iamVjdCAtIFRoZSBvcmlnaW5hbCBvYmplY3QuXHJcbiAqIEByZXR1cm5zIFRoZSBFbGVtZW50IGlmIHRoZSByZWZlcmVuY2VPYmplY3QgaXMgYW4gRWxlbWVudCwgb3IgYSBuZXcgb2JqZWN0IGluaGVyaXRpbmcgZnJvbSB0aGUgcmVmZXJlbmNlT2JqZWN0LlxyXG4gKi9cbmZ1bmN0aW9uIGJyaWRnZU9iamVjdChyZWZlcmVuY2VPYmplY3QpIHtcbiAgaWYgKHJlZmVyZW5jZU9iamVjdCA9PT0gbnVsbCB8fCBfdHlwZW9mKHJlZmVyZW5jZU9iamVjdCkgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocmVmZXJlbmNlT2JqZWN0IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgIC8vIEF2b2lkIGJyaWRnaW5nIERPTSBvYmplY3RzXG4gICAgcmV0dXJuIHJlZmVyZW5jZU9iamVjdDtcbiAgfVxuICB2YXIgb2JqZWN0VG8gPSBfT2JqZWN0JGNyZWF0ZSQxKHJlZmVyZW5jZU9iamVjdCk7XG4gIGZvciAodmFyIGkgaW4gcmVmZXJlbmNlT2JqZWN0KSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZWZlcmVuY2VPYmplY3QsIGkpKSB7XG4gICAgICBpZiAoX3R5cGVvZihyZWZlcmVuY2VPYmplY3RbaV0pID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgb2JqZWN0VG9baV0gPSBicmlkZ2VPYmplY3QocmVmZXJlbmNlT2JqZWN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdFRvO1xufVxuLyoqXHJcbiAqIFRoaXMgaXMgdXNlZCB0byBzZXQgdGhlIG9wdGlvbnMgb2Ygc3Vib2JqZWN0cyBpbiB0aGUgb3B0aW9ucyBvYmplY3QuXHJcbiAqXHJcbiAqIEEgcmVxdWlyZW1lbnQgb2YgdGhlc2Ugc3Vib2JqZWN0cyBpcyB0aGF0IHRoZXkgaGF2ZSBhbiAnZW5hYmxlZCcgZWxlbWVudFxyXG4gKiB3aGljaCBpcyBvcHRpb25hbCBmb3IgdGhlIHVzZXIgYnV0IG1hbmRhdG9yeSBmb3IgdGhlIHByb2dyYW0uXHJcbiAqXHJcbiAqIFRoZSBhZGRlZCB2YWx1ZSBoZXJlIG9mIHRoZSBtZXJnZSBpcyB0aGF0IG9wdGlvbiAnZW5hYmxlZCcgaXMgc2V0IGFzIHJlcXVpcmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gbWVyZ2VUYXJnZXQgLSBFaXRoZXIgdGhpcy5vcHRpb25zIG9yIHRoZSBvcHRpb25zIHVzZWQgZm9yIHRoZSBncm91cHMuXHJcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cclxuICogQHBhcmFtIG9wdGlvbiAtIE9wdGlvbiBrZXkgaW4gdGhlIG9wdGlvbnMgYXJndW1lbnQuXHJcbiAqIEBwYXJhbSBnbG9iYWxPcHRpb25zIC0gR2xvYmFsIG9wdGlvbnMsIHBhc3NlZCBpbiB0byBkZXRlcm1pbmUgdmFsdWUgb2Ygb3B0aW9uICdlbmFibGVkJy5cclxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMobWVyZ2VUYXJnZXQsIG9wdGlvbnMsIG9wdGlvbikge1xuICB2YXIgZ2xvYmFsT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gIC8vIExvY2FsIGhlbHBlcnNcbiAgdmFyIGlzUHJlc2VudCA9IGZ1bmN0aW9uIGlzUHJlc2VudChvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIG9iaiAhPT0gdW5kZWZpbmVkO1xuICB9O1xuICB2YXIgaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIF90eXBlb2Yob2JqKSA9PT0gXCJvYmplY3RcIjtcbiAgfTtcbiAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM0NDkxMjg3LzEyMjM1MzFcbiAgdmFyIGlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICAgIGZvciAodmFyIHggaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgeCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgLy8gR3VhcmRzXG4gIGlmICghaXNPYmplY3QobWVyZ2VUYXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIG1lcmdlVGFyZ2V0IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICB9XG4gIGlmICghaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgfVxuICBpZiAoIWlzUHJlc2VudChvcHRpb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIG9wdGlvbiBtdXN0IGhhdmUgYSB2YWx1ZVwiKTtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KGdsb2JhbE9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIGdsb2JhbE9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gIH1cbiAgLy9cbiAgLy8gQWN0dWFsIG1lcmdlIHJvdXRpbmUsIHNlcGFyYXRlZCBmcm9tIG1haW4gbG9naWNcbiAgLy8gT25seSBhIHNpbmdsZSBsZXZlbCBvZiBvcHRpb25zIGlzIG1lcmdlZC4gRGVlcGVyIGxldmVscyBhcmUgcmVmJ2QuIFRoaXMgbWF5IGFjdHVhbGx5IGJlIGFuIGlzc3VlLlxuICAvL1xuICB2YXIgZG9NZXJnZSA9IGZ1bmN0aW9uIGRvTWVyZ2UodGFyZ2V0LCBvcHRpb25zLCBvcHRpb24pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHRhcmdldFtvcHRpb25dKSkge1xuICAgICAgdGFyZ2V0W29wdGlvbl0gPSB7fTtcbiAgICB9XG4gICAgdmFyIHNyYyA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgICB2YXIgZHN0ID0gdGFyZ2V0W29wdGlvbl07XG4gICAgZm9yICh2YXIgcHJvcCBpbiBzcmMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3JjLCBwcm9wKSkge1xuICAgICAgICBkc3RbcHJvcF0gPSBzcmNbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBMb2NhbCBpbml0aWFsaXphdGlvblxuICB2YXIgc3JjT3B0aW9uID0gb3B0aW9uc1tvcHRpb25dO1xuICB2YXIgZ2xvYmFsUGFzc2VkID0gaXNPYmplY3QoZ2xvYmFsT3B0aW9ucykgJiYgIWlzRW1wdHkoZ2xvYmFsT3B0aW9ucyk7XG4gIHZhciBnbG9iYWxPcHRpb24gPSBnbG9iYWxQYXNzZWQgPyBnbG9iYWxPcHRpb25zW29wdGlvbl0gOiB1bmRlZmluZWQ7XG4gIHZhciBnbG9iYWxFbmFibGVkID0gZ2xvYmFsT3B0aW9uID8gZ2xvYmFsT3B0aW9uLmVuYWJsZWQgOiB1bmRlZmluZWQ7XG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIE1haW4gcm91dGluZVxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBpZiAoc3JjT3B0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG9cbiAgfVxuXG4gIGlmICh0eXBlb2Ygc3JjT3B0aW9uID09PSBcImJvb2xlYW5cIikge1xuICAgIGlmICghaXNPYmplY3QobWVyZ2VUYXJnZXRbb3B0aW9uXSkpIHtcbiAgICAgIG1lcmdlVGFyZ2V0W29wdGlvbl0gPSB7fTtcbiAgICB9XG4gICAgbWVyZ2VUYXJnZXRbb3B0aW9uXS5lbmFibGVkID0gc3JjT3B0aW9uO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc3JjT3B0aW9uID09PSBudWxsICYmICFpc09iamVjdChtZXJnZVRhcmdldFtvcHRpb25dKSkge1xuICAgIC8vIElmIHBvc3NpYmxlLCBleHBsaWNpdCBjb3B5IGZyb20gZ2xvYmFsc1xuICAgIGlmIChpc1ByZXNlbnQoZ2xvYmFsT3B0aW9uKSkge1xuICAgICAgbWVyZ2VUYXJnZXRbb3B0aW9uXSA9IF9PYmplY3QkY3JlYXRlJDEoZ2xvYmFsT3B0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuOyAvLyBOb3RoaW5nIHRvIGRvXG4gICAgfVxuICB9XG5cbiAgaWYgKCFpc09iamVjdChzcmNPcHRpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vXG4gIC8vIEVuc3VyZSB0aGF0ICdlbmFibGVkJyBpcyBwcm9wZXJseSBzZXQuIEl0IGlzIHJlcXVpcmVkIGludGVybmFsbHlcbiAgLy8gTm90ZSB0aGF0IHRoZSB2YWx1ZSBmcm9tIG9wdGlvbnMgd2lsbCBhbHdheXMgb3ZlcndyaXRlIHRoZSBleGlzdGluZyB2YWx1ZVxuICAvL1xuICB2YXIgZW5hYmxlZCA9IHRydWU7IC8vIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHNyY09wdGlvbi5lbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmFibGVkID0gc3JjT3B0aW9uLmVuYWJsZWQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGFrZSBmcm9tIGdsb2JhbHMsIGlmIHByZXNlbnRcbiAgICBpZiAoZ2xvYmFsRW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmFibGVkID0gZ2xvYmFsT3B0aW9uLmVuYWJsZWQ7XG4gICAgfVxuICB9XG4gIGRvTWVyZ2UobWVyZ2VUYXJnZXQsIG9wdGlvbnMsIG9wdGlvbik7XG4gIG1lcmdlVGFyZ2V0W29wdGlvbl0uZW5hYmxlZCA9IGVuYWJsZWQ7XG59XG4vKlxyXG4gKiBFYXNpbmcgRnVuY3Rpb25zLlxyXG4gKiBPbmx5IGNvbnNpZGVyaW5nIHRoZSB0IHZhbHVlIGZvciB0aGUgcmFuZ2UgWzAsIDFdID0+IFswLCAxXS5cclxuICpcclxuICogSW5zcGlyYXRpb246IGZyb20gaHR0cDovL2dpem1hLmNvbS9lYXNpbmcvXHJcbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2dyZS8xNjUwMjk0XHJcbiAqL1xudmFyIGVhc2luZ0Z1bmN0aW9ucyA9IHtcbiAgLyoqXHJcbiAgICogUHJvdmlkZXMgbm8gZWFzaW5nIGFuZCBubyBhY2NlbGVyYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAqL1xuICBsaW5lYXI6IGZ1bmN0aW9uIGxpbmVhcih0KSB7XG4gICAgcmV0dXJuIHQ7XG4gIH0sXG4gIC8qKlxyXG4gICAqIEFjY2VsZXJhdGUgZnJvbSB6ZXJvIHZlbG9jaXR5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZUluUXVhZDogZnVuY3Rpb24gZWFzZUluUXVhZCh0KSB7XG4gICAgcmV0dXJuIHQgKiB0O1xuICB9LFxuICAvKipcclxuICAgKiBEZWNlbGVyYXRlIHRvIHplcm8gdmVsb2NpdHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAqL1xuICBlYXNlT3V0UXVhZDogZnVuY3Rpb24gZWFzZU91dFF1YWQodCkge1xuICAgIHJldHVybiB0ICogKDIgLSB0KTtcbiAgfSxcbiAgLyoqXHJcbiAgICogQWNjZWxlcmF0ZSB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAqL1xuICBlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbiBlYXNlSW5PdXRRdWFkKHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDIgKiB0ICogdCA6IC0xICsgKDQgLSAyICogdCkgKiB0O1xuICB9LFxuICAvKipcclxuICAgKiBBY2NlbGVyYXRlIGZyb20gemVybyB2ZWxvY2l0eS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGVhc2VJbkN1YmljOiBmdW5jdGlvbiBlYXNlSW5DdWJpYyh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdDtcbiAgfSxcbiAgLyoqXHJcbiAgICogRGVjZWxlcmF0ZSB0byB6ZXJvIHZlbG9jaXR5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZU91dEN1YmljOiBmdW5jdGlvbiBlYXNlT3V0Q3ViaWModCkge1xuICAgIHJldHVybiAtLXQgKiB0ICogdCArIDE7XG4gIH0sXG4gIC8qKlxyXG4gICAqIEFjY2VsZXJhdGUgdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZUluT3V0Q3ViaWM6IGZ1bmN0aW9uIGVhc2VJbk91dEN1YmljKHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDQgKiB0ICogdCAqIHQgOiAodCAtIDEpICogKDIgKiB0IC0gMikgKiAoMiAqIHQgLSAyKSArIDE7XG4gIH0sXG4gIC8qKlxyXG4gICAqIEFjY2VsZXJhdGUgZnJvbSB6ZXJvIHZlbG9jaXR5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZUluUXVhcnQ6IGZ1bmN0aW9uIGVhc2VJblF1YXJ0KHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0ICogdDtcbiAgfSxcbiAgLyoqXHJcbiAgICogRGVjZWxlcmF0ZSB0byB6ZXJvIHZlbG9jaXR5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZU91dFF1YXJ0OiBmdW5jdGlvbiBlYXNlT3V0UXVhcnQodCkge1xuICAgIHJldHVybiAxIC0gLS10ICogdCAqIHQgKiB0O1xuICB9LFxuICAvKipcclxuICAgKiBBY2NlbGVyYXRlIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGVhc2VJbk91dFF1YXJ0OiBmdW5jdGlvbiBlYXNlSW5PdXRRdWFydCh0KSB7XG4gICAgcmV0dXJuIHQgPCAwLjUgPyA4ICogdCAqIHQgKiB0ICogdCA6IDEgLSA4ICogLS10ICogdCAqIHQgKiB0O1xuICB9LFxuICAvKipcclxuICAgKiBBY2NlbGVyYXRlIGZyb20gemVybyB2ZWxvY2l0eS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGVhc2VJblF1aW50OiBmdW5jdGlvbiBlYXNlSW5RdWludCh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0O1xuICB9LFxuICAvKipcclxuICAgKiBEZWNlbGVyYXRlIHRvIHplcm8gdmVsb2NpdHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAqL1xuICBlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uIGVhc2VPdXRRdWludCh0KSB7XG4gICAgcmV0dXJuIDEgKyAtLXQgKiB0ICogdCAqIHQgKiB0O1xuICB9LFxuICAvKipcclxuICAgKiBBY2NlbGVyYXRlIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGVhc2VJbk91dFF1aW50OiBmdW5jdGlvbiBlYXNlSW5PdXRRdWludCh0KSB7XG4gICAgcmV0dXJuIHQgPCAwLjUgPyAxNiAqIHQgKiB0ICogdCAqIHQgKiB0IDogMSArIDE2ICogLS10ICogdCAqIHQgKiB0ICogdDtcbiAgfVxufTtcbi8vIEBUT0RPOiBUaGlzIGRvZXNuJ3Qgd29yayBwcm9wZXJseS5cbi8vIEl0IHdvcmtzIG9ubHkgZm9yIHNpbmdsZSBwcm9wZXJ0eSBvYmplY3RzLFxuLy8gb3RoZXJ3aXNlIGl0IGNvbWJpbmVzIGFsbCBvZiB0aGUgdHlwZXMgaW4gYSB1bmlvbi5cbi8vIGV4cG9ydCBmdW5jdGlvbiB0b3BNb3N0PEsxIGV4dGVuZHMgc3RyaW5nLCBWMT4gKFxuLy8gICBwaWxlOiBSZWNvcmQ8SzEsIHVuZGVmaW5lZCB8IFYxPltdLFxuLy8gICBhY2Nlc3NvcnM6IEsxIHwgW0sxXVxuLy8gKTogdW5kZWZpbmVkIHwgVjFcbi8vIGV4cG9ydCBmdW5jdGlvbiB0b3BNb3N0PEsxIGV4dGVuZHMgc3RyaW5nLCBLMiBleHRlbmRzIHN0cmluZywgVjEsIFYyPiAoXG4vLyAgIHBpbGU6IFJlY29yZDxLMSwgdW5kZWZpbmVkIHwgVjEgfCBSZWNvcmQ8SzIsIHVuZGVmaW5lZCB8IFYyPj5bXSxcbi8vICAgYWNjZXNzb3JzOiBbSzEsIEsyXVxuLy8gKTogdW5kZWZpbmVkIHwgVjEgfCBWMlxuLy8gZXhwb3J0IGZ1bmN0aW9uIHRvcE1vc3Q8SzEgZXh0ZW5kcyBzdHJpbmcsIEsyIGV4dGVuZHMgc3RyaW5nLCBLMyBleHRlbmRzIHN0cmluZywgVjEsIFYyLCBWMz4gKFxuLy8gICBwaWxlOiBSZWNvcmQ8SzEsIHVuZGVmaW5lZCB8IFYxIHwgUmVjb3JkPEsyLCB1bmRlZmluZWQgfCBWMiB8IFJlY29yZDxLMywgdW5kZWZpbmVkIHwgVjM+Pj5bXSxcbi8vICAgYWNjZXNzb3JzOiBbSzEsIEsyLCBLM11cbi8vICk6IHVuZGVmaW5lZCB8IFYxIHwgVjIgfCBWM1xuLyoqXHJcbiAqIEdldCB0aGUgdG9wIG1vc3QgcHJvcGVydHkgdmFsdWUgZnJvbSBhIHBpbGUgb2Ygb2JqZWN0cy5cclxuICpcclxuICogQHBhcmFtIHBpbGUgLSBBcnJheSBvZiBvYmplY3RzLCBubyByZXF1aXJlZCBmb3JtYXQuXHJcbiAqIEBwYXJhbSBhY2Nlc3NvcnMgLSBBcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cclxuICogRm9yIGV4YW1wbGUgYG9iamVjdFsnZm9vJ11bJ2JhciddYCDihpIgYFsnZm9vJywgJ2JhciddYC5cclxuICogQHJldHVybnMgVmFsdWUgb2YgdGhlIHByb3BlcnR5IHdpdGggZ2l2ZW4gYWNjZXNzb3JzIHBhdGggZnJvbSB0aGUgZmlyc3QgcGlsZSBpdGVtIHdoZXJlIGl0J3Mgbm90IHVuZGVmaW5lZC5cclxuICovXG5mdW5jdGlvbiB0b3BNb3N0KHBpbGUsIGFjY2Vzc29ycykge1xuICB2YXIgY2FuZGlkYXRlO1xuICBpZiAoIV9BcnJheSRpc0FycmF5KGFjY2Vzc29ycykpIHtcbiAgICBhY2Nlc3NvcnMgPSBbYWNjZXNzb3JzXTtcbiAgfVxuICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDYocGlsZSksXG4gICAgX3N0ZXAzO1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgbWVtYmVyID0gX3N0ZXAzLnZhbHVlO1xuICAgICAgaWYgKG1lbWJlcikge1xuICAgICAgICBjYW5kaWRhdGUgPSBtZW1iZXJbYWNjZXNzb3JzWzBdXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhY2Nlc3NvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICBjYW5kaWRhdGUgPSBjYW5kaWRhdGVbYWNjZXNzb3JzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjYW5kaWRhdGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMy5mKCk7XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZTtcbn1cbnZhciBodG1sQ29sb3JzID0ge1xuICBibGFjazogXCIjMDAwMDAwXCIsXG4gIG5hdnk6IFwiIzAwMDA4MFwiLFxuICBkYXJrYmx1ZTogXCIjMDAwMDhCXCIsXG4gIG1lZGl1bWJsdWU6IFwiIzAwMDBDRFwiLFxuICBibHVlOiBcIiMwMDAwRkZcIixcbiAgZGFya2dyZWVuOiBcIiMwMDY0MDBcIixcbiAgZ3JlZW46IFwiIzAwODAwMFwiLFxuICB0ZWFsOiBcIiMwMDgwODBcIixcbiAgZGFya2N5YW46IFwiIzAwOEI4QlwiLFxuICBkZWVwc2t5Ymx1ZTogXCIjMDBCRkZGXCIsXG4gIGRhcmt0dXJxdW9pc2U6IFwiIzAwQ0VEMVwiLFxuICBtZWRpdW1zcHJpbmdncmVlbjogXCIjMDBGQTlBXCIsXG4gIGxpbWU6IFwiIzAwRkYwMFwiLFxuICBzcHJpbmdncmVlbjogXCIjMDBGRjdGXCIsXG4gIGFxdWE6IFwiIzAwRkZGRlwiLFxuICBjeWFuOiBcIiMwMEZGRkZcIixcbiAgbWlkbmlnaHRibHVlOiBcIiMxOTE5NzBcIixcbiAgZG9kZ2VyYmx1ZTogXCIjMUU5MEZGXCIsXG4gIGxpZ2h0c2VhZ3JlZW46IFwiIzIwQjJBQVwiLFxuICBmb3Jlc3RncmVlbjogXCIjMjI4QjIyXCIsXG4gIHNlYWdyZWVuOiBcIiMyRThCNTdcIixcbiAgZGFya3NsYXRlZ3JheTogXCIjMkY0RjRGXCIsXG4gIGxpbWVncmVlbjogXCIjMzJDRDMyXCIsXG4gIG1lZGl1bXNlYWdyZWVuOiBcIiMzQ0IzNzFcIixcbiAgdHVycXVvaXNlOiBcIiM0MEUwRDBcIixcbiAgcm95YWxibHVlOiBcIiM0MTY5RTFcIixcbiAgc3RlZWxibHVlOiBcIiM0NjgyQjRcIixcbiAgZGFya3NsYXRlYmx1ZTogXCIjNDgzRDhCXCIsXG4gIG1lZGl1bXR1cnF1b2lzZTogXCIjNDhEMUNDXCIsXG4gIGluZGlnbzogXCIjNEIwMDgyXCIsXG4gIGRhcmtvbGl2ZWdyZWVuOiBcIiM1NTZCMkZcIixcbiAgY2FkZXRibHVlOiBcIiM1RjlFQTBcIixcbiAgY29ybmZsb3dlcmJsdWU6IFwiIzY0OTVFRFwiLFxuICBtZWRpdW1hcXVhbWFyaW5lOiBcIiM2NkNEQUFcIixcbiAgZGltZ3JheTogXCIjNjk2OTY5XCIsXG4gIHNsYXRlYmx1ZTogXCIjNkE1QUNEXCIsXG4gIG9saXZlZHJhYjogXCIjNkI4RTIzXCIsXG4gIHNsYXRlZ3JheTogXCIjNzA4MDkwXCIsXG4gIGxpZ2h0c2xhdGVncmF5OiBcIiM3Nzg4OTlcIixcbiAgbWVkaXVtc2xhdGVibHVlOiBcIiM3QjY4RUVcIixcbiAgbGF3bmdyZWVuOiBcIiM3Q0ZDMDBcIixcbiAgY2hhcnRyZXVzZTogXCIjN0ZGRjAwXCIsXG4gIGFxdWFtYXJpbmU6IFwiIzdGRkZENFwiLFxuICBtYXJvb246IFwiIzgwMDAwMFwiLFxuICBwdXJwbGU6IFwiIzgwMDA4MFwiLFxuICBvbGl2ZTogXCIjODA4MDAwXCIsXG4gIGdyYXk6IFwiIzgwODA4MFwiLFxuICBza3libHVlOiBcIiM4N0NFRUJcIixcbiAgbGlnaHRza3libHVlOiBcIiM4N0NFRkFcIixcbiAgYmx1ZXZpb2xldDogXCIjOEEyQkUyXCIsXG4gIGRhcmtyZWQ6IFwiIzhCMDAwMFwiLFxuICBkYXJrbWFnZW50YTogXCIjOEIwMDhCXCIsXG4gIHNhZGRsZWJyb3duOiBcIiM4QjQ1MTNcIixcbiAgZGFya3NlYWdyZWVuOiBcIiM4RkJDOEZcIixcbiAgbGlnaHRncmVlbjogXCIjOTBFRTkwXCIsXG4gIG1lZGl1bXB1cnBsZTogXCIjOTM3MEQ4XCIsXG4gIGRhcmt2aW9sZXQ6IFwiIzk0MDBEM1wiLFxuICBwYWxlZ3JlZW46IFwiIzk4RkI5OFwiLFxuICBkYXJrb3JjaGlkOiBcIiM5OTMyQ0NcIixcbiAgeWVsbG93Z3JlZW46IFwiIzlBQ0QzMlwiLFxuICBzaWVubmE6IFwiI0EwNTIyRFwiLFxuICBicm93bjogXCIjQTUyQTJBXCIsXG4gIGRhcmtncmF5OiBcIiNBOUE5QTlcIixcbiAgbGlnaHRibHVlOiBcIiNBREQ4RTZcIixcbiAgZ3JlZW55ZWxsb3c6IFwiI0FERkYyRlwiLFxuICBwYWxldHVycXVvaXNlOiBcIiNBRkVFRUVcIixcbiAgbGlnaHRzdGVlbGJsdWU6IFwiI0IwQzRERVwiLFxuICBwb3dkZXJibHVlOiBcIiNCMEUwRTZcIixcbiAgZmlyZWJyaWNrOiBcIiNCMjIyMjJcIixcbiAgZGFya2dvbGRlbnJvZDogXCIjQjg4NjBCXCIsXG4gIG1lZGl1bW9yY2hpZDogXCIjQkE1NUQzXCIsXG4gIHJvc3licm93bjogXCIjQkM4RjhGXCIsXG4gIGRhcmtraGFraTogXCIjQkRCNzZCXCIsXG4gIHNpbHZlcjogXCIjQzBDMEMwXCIsXG4gIG1lZGl1bXZpb2xldHJlZDogXCIjQzcxNTg1XCIsXG4gIGluZGlhbnJlZDogXCIjQ0Q1QzVDXCIsXG4gIHBlcnU6IFwiI0NEODUzRlwiLFxuICBjaG9jb2xhdGU6IFwiI0QyNjkxRVwiLFxuICB0YW46IFwiI0QyQjQ4Q1wiLFxuICBsaWdodGdyZXk6IFwiI0QzRDNEM1wiLFxuICBwYWxldmlvbGV0cmVkOiBcIiNEODcwOTNcIixcbiAgdGhpc3RsZTogXCIjRDhCRkQ4XCIsXG4gIG9yY2hpZDogXCIjREE3MEQ2XCIsXG4gIGdvbGRlbnJvZDogXCIjREFBNTIwXCIsXG4gIGNyaW1zb246IFwiI0RDMTQzQ1wiLFxuICBnYWluc2Jvcm86IFwiI0RDRENEQ1wiLFxuICBwbHVtOiBcIiNEREEwRERcIixcbiAgYnVybHl3b29kOiBcIiNERUI4ODdcIixcbiAgbGlnaHRjeWFuOiBcIiNFMEZGRkZcIixcbiAgbGF2ZW5kZXI6IFwiI0U2RTZGQVwiLFxuICBkYXJrc2FsbW9uOiBcIiNFOTk2N0FcIixcbiAgdmlvbGV0OiBcIiNFRTgyRUVcIixcbiAgcGFsZWdvbGRlbnJvZDogXCIjRUVFOEFBXCIsXG4gIGxpZ2h0Y29yYWw6IFwiI0YwODA4MFwiLFxuICBraGFraTogXCIjRjBFNjhDXCIsXG4gIGFsaWNlYmx1ZTogXCIjRjBGOEZGXCIsXG4gIGhvbmV5ZGV3OiBcIiNGMEZGRjBcIixcbiAgYXp1cmU6IFwiI0YwRkZGRlwiLFxuICBzYW5keWJyb3duOiBcIiNGNEE0NjBcIixcbiAgd2hlYXQ6IFwiI0Y1REVCM1wiLFxuICBiZWlnZTogXCIjRjVGNURDXCIsXG4gIHdoaXRlc21va2U6IFwiI0Y1RjVGNVwiLFxuICBtaW50Y3JlYW06IFwiI0Y1RkZGQVwiLFxuICBnaG9zdHdoaXRlOiBcIiNGOEY4RkZcIixcbiAgc2FsbW9uOiBcIiNGQTgwNzJcIixcbiAgYW50aXF1ZXdoaXRlOiBcIiNGQUVCRDdcIixcbiAgbGluZW46IFwiI0ZBRjBFNlwiLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogXCIjRkFGQUQyXCIsXG4gIG9sZGxhY2U6IFwiI0ZERjVFNlwiLFxuICByZWQ6IFwiI0ZGMDAwMFwiLFxuICBmdWNoc2lhOiBcIiNGRjAwRkZcIixcbiAgbWFnZW50YTogXCIjRkYwMEZGXCIsXG4gIGRlZXBwaW5rOiBcIiNGRjE0OTNcIixcbiAgb3JhbmdlcmVkOiBcIiNGRjQ1MDBcIixcbiAgdG9tYXRvOiBcIiNGRjYzNDdcIixcbiAgaG90cGluazogXCIjRkY2OUI0XCIsXG4gIGNvcmFsOiBcIiNGRjdGNTBcIixcbiAgZGFya29yYW5nZTogXCIjRkY4QzAwXCIsXG4gIGxpZ2h0c2FsbW9uOiBcIiNGRkEwN0FcIixcbiAgb3JhbmdlOiBcIiNGRkE1MDBcIixcbiAgbGlnaHRwaW5rOiBcIiNGRkI2QzFcIixcbiAgcGluazogXCIjRkZDMENCXCIsXG4gIGdvbGQ6IFwiI0ZGRDcwMFwiLFxuICBwZWFjaHB1ZmY6IFwiI0ZGREFCOVwiLFxuICBuYXZham93aGl0ZTogXCIjRkZERUFEXCIsXG4gIG1vY2Nhc2luOiBcIiNGRkU0QjVcIixcbiAgYmlzcXVlOiBcIiNGRkU0QzRcIixcbiAgbWlzdHlyb3NlOiBcIiNGRkU0RTFcIixcbiAgYmxhbmNoZWRhbG1vbmQ6IFwiI0ZGRUJDRFwiLFxuICBwYXBheWF3aGlwOiBcIiNGRkVGRDVcIixcbiAgbGF2ZW5kZXJibHVzaDogXCIjRkZGMEY1XCIsXG4gIHNlYXNoZWxsOiBcIiNGRkY1RUVcIixcbiAgY29ybnNpbGs6IFwiI0ZGRjhEQ1wiLFxuICBsZW1vbmNoaWZmb246IFwiI0ZGRkFDRFwiLFxuICBmbG9yYWx3aGl0ZTogXCIjRkZGQUYwXCIsXG4gIHNub3c6IFwiI0ZGRkFGQVwiLFxuICB5ZWxsb3c6IFwiI0ZGRkYwMFwiLFxuICBsaWdodHllbGxvdzogXCIjRkZGRkUwXCIsXG4gIGl2b3J5OiBcIiNGRkZGRjBcIixcbiAgd2hpdGU6IFwiI0ZGRkZGRlwiXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGl4ZWxSYXRpbz0xXVxuICovXG52YXIgQ29sb3JQaWNrZXIkMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3BpeGVsUmF0aW89MV1cbiAgICovXG4gIGZ1bmN0aW9uIENvbG9yUGlja2VyKCkge1xuICAgIHZhciBwaXhlbFJhdGlvID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb2xvclBpY2tlcik7XG4gICAgdGhpcy5waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgICB0aGlzLmdlbmVyYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMgPSB7XG4gICAgICB4OiAyODkgLyAyLFxuICAgICAgeTogMjg5IC8gMlxuICAgIH07XG4gICAgdGhpcy5yID0gMjg5ICogMC40OTtcbiAgICB0aGlzLmNvbG9yID0ge1xuICAgICAgcjogMjU1LFxuICAgICAgZzogMjU1LFxuICAgICAgYjogMjU1LFxuICAgICAgYTogMS4wXG4gICAgfTtcbiAgICB0aGlzLmh1ZUNpcmNsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmluaXRpYWxDb2xvciA9IHtcbiAgICAgIHI6IDI1NSxcbiAgICAgIGc6IDI1NSxcbiAgICAgIGI6IDI1NSxcbiAgICAgIGE6IDEuMFxuICAgIH07XG4gICAgdGhpcy5wcmV2aW91c0NvbG9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYXBwbGllZCA9IGZhbHNlO1xuXG4gICAgLy8gYm91bmQgYnlcbiAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgdGhpcy5jbG9zZUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBjcmVhdGUgYWxsIERPTSBlbGVtZW50c1xuICAgIHRoaXMuX2NyZWF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIHRoaXMgaW5zZXJ0cyB0aGUgY29sb3JQaWNrZXIgaW50byBhIGRpdiBmcm9tIHRoZSBET01cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXJcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhDb2xvclBpY2tlciwgW3tcbiAgICBrZXk6IFwiaW5zZXJ0VG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0VG8oY29udGFpbmVyKSB7XG4gICAgICBpZiAodGhpcy5oYW1tZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmhhbW1lci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaGFtbWVyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lKTtcbiAgICAgIHRoaXMuX2JpbmRIYW1tZXIoKTtcbiAgICAgIHRoaXMuX3NldFNpemUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0aGUgY2FsbGJhY2sgaXMgZXhlY3V0ZWQgb24gYXBwbHkgYW5kIHNhdmUuIEJpbmQgaXQgdG8gdGhlIGFwcGxpY2F0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldFVwZGF0ZUNhbGxiYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gYXR0ZW1wdGVkIHRvIHNldCBhcyBjb2xvclBpY2tlciB1cGRhdGUgY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb24uXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRoZSBjYWxsYmFjayBpcyBleGVjdXRlZCBvbiBhcHBseSBhbmQgc2F2ZS4gQmluZCBpdCB0byB0aGUgYXBwbGljYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q2xvc2VDYWxsYmFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDbG9zZUNhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5jbG9zZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBhdHRlbXB0ZWQgdG8gc2V0IGFzIGNvbG9yUGlja2VyIGNsb3NpbmcgY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb24uXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9pc0NvbG9yU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc0NvbG9yU3RyaW5nKGNvbG9yKSB7XG4gICAgICBpZiAodHlwZW9mIGNvbG9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBodG1sQ29sb3JzW2NvbG9yXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNvbG9yIG9mIHRoZSBjb2xvclBpY2tlclxuICAgICAqIFN1cHBvcnRlZCBmb3JtYXRzOlxuICAgICAqICdyZWQnICAgICAgICAgICAgICAgICAgIC0tPiBIVE1MIGNvbG9yIHN0cmluZ1xuICAgICAqICcjZmZmZmZmJyAgICAgICAgICAgICAgIC0tPiBoZXggc3RyaW5nXG4gICAgICogJ3JnYigyNTUsMjU1LDI1NSknICAgICAgLS0+IHJnYiBzdHJpbmdcbiAgICAgKiAncmdiYSgyNTUsMjU1LDI1NSwxLjApJyAtLT4gcmdiYSBzdHJpbmdcbiAgICAgKiB7cjoyNTUsZzoyNTUsYjoyNTV9ICAgICAtLT4gcmdiIG9iamVjdFxuICAgICAqIHtyOjI1NSxnOjI1NSxiOjI1NSxhOjEuMH0gLS0+IHJnYmEgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG9iamVjdH0gY29sb3JcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZXRJbml0aWFsPXRydWVdXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q29sb3IoY29sb3IpIHtcbiAgICAgIHZhciBzZXRJbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgaWYgKGNvbG9yID09PSBcIm5vbmVcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcmdiYTtcblxuICAgICAgLy8gaWYgYSBodG1sIGNvbG9yIHNob3J0aGFuZCBpcyB1c2VkLCBjb252ZXJ0IHRvIGhleFxuICAgICAgdmFyIGh0bWxDb2xvciA9IHRoaXMuX2lzQ29sb3JTdHJpbmcoY29sb3IpO1xuICAgICAgaWYgKGh0bWxDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbG9yID0gaHRtbENvbG9yO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBmb3JtYXRcbiAgICAgIGlmIChpc1N0cmluZyhjb2xvcikgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKGlzVmFsaWRSR0IoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHJnYmFBcnJheSA9IGNvbG9yLnN1YnN0cig0KS5zdWJzdHIoMCwgY29sb3IubGVuZ3RoIC0gNSkuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgIHJnYmEgPSB7XG4gICAgICAgICAgICByOiByZ2JhQXJyYXlbMF0sXG4gICAgICAgICAgICBnOiByZ2JhQXJyYXlbMV0sXG4gICAgICAgICAgICBiOiByZ2JhQXJyYXlbMl0sXG4gICAgICAgICAgICBhOiAxLjBcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGlzVmFsaWRSR0JBKGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBfcmdiYUFycmF5ID0gY29sb3Iuc3Vic3RyKDUpLnN1YnN0cigwLCBjb2xvci5sZW5ndGggLSA2KS5zcGxpdChcIixcIik7XG4gICAgICAgICAgcmdiYSA9IHtcbiAgICAgICAgICAgIHI6IF9yZ2JhQXJyYXlbMF0sXG4gICAgICAgICAgICBnOiBfcmdiYUFycmF5WzFdLFxuICAgICAgICAgICAgYjogX3JnYmFBcnJheVsyXSxcbiAgICAgICAgICAgIGE6IF9yZ2JhQXJyYXlbM11cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGlzVmFsaWRIZXgoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHJnYk9iaiA9IGhleFRvUkdCKGNvbG9yKTtcbiAgICAgICAgICByZ2JhID0ge1xuICAgICAgICAgICAgcjogcmdiT2JqLnIsXG4gICAgICAgICAgICBnOiByZ2JPYmouZyxcbiAgICAgICAgICAgIGI6IHJnYk9iai5iLFxuICAgICAgICAgICAgYTogMS4wXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvbG9yIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgaWYgKGNvbG9yLnIgIT09IHVuZGVmaW5lZCAmJiBjb2xvci5nICE9PSB1bmRlZmluZWQgJiYgY29sb3IuYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBjb2xvci5hICE9PSB1bmRlZmluZWQgPyBjb2xvci5hIDogXCIxLjBcIjtcbiAgICAgICAgICAgIHJnYmEgPSB7XG4gICAgICAgICAgICAgIHI6IGNvbG9yLnIsXG4gICAgICAgICAgICAgIGc6IGNvbG9yLmcsXG4gICAgICAgICAgICAgIGI6IGNvbG9yLmIsXG4gICAgICAgICAgICAgIGE6IGFscGhhXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBzZXQgY29sb3JcbiAgICAgIGlmIChyZ2JhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjb2xvciBwYXNzZWQgdG8gdGhlIGNvbG9yUGlja2VyLiBTdXBwb3J0ZWQgYXJlIHN0cmluZ3M6IHJnYiwgaGV4LCByZ2JhLiBPYmplY3Q6IHJnYiAoe3I6cixnOmcsYjpiLFthOmFdfSkuIFN1cHBsaWVkOiBcIiArIF9KU09OJHN0cmluZ2lmeShjb2xvcikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2V0Q29sb3IocmdiYSwgc2V0SW5pdGlhbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhpcyBzaG93cyB0aGUgY29sb3IgcGlja2VyLlxuICAgICAqIFRoZSBodWUgY2lyY2xlIGlzIGNvbnN0cnVjdGVkIG9uY2UgYW5kIHN0b3JlZC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzaG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICBpZiAodGhpcy5jbG9zZUNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jbG9zZUNhbGxiYWNrKCk7XG4gICAgICAgIHRoaXMuY2xvc2VDYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwbGllZCA9IGZhbHNlO1xuICAgICAgdGhpcy5mcmFtZS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgdGhpcy5fZ2VuZXJhdGVIdWVDaXJjbGUoKTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUFJJVkFURSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4gICAgLyoqXG4gICAgICogSGlkZSB0aGUgcGlja2VyLiBJcyBjYWxsZWQgYnkgdGhlIGNhbmNlbCBidXR0b24uXG4gICAgICogT3B0aW9uYWwgYm9vbGVhbiB0byBzdG9yZSB0aGUgcHJldmlvdXMgY29sb3IgZm9yIGVhc3kgYWNjZXNzIGxhdGVyIG9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc3RvcmVQcmV2aW91cz10cnVlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hpZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hpZGUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBzdG9yZVByZXZpb3VzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgICAgLy8gc3RvcmUgdGhlIHByZXZpb3VzIGNvbG9yIGZvciBuZXh0IHRpbWU7XG4gICAgICBpZiAoc3RvcmVQcmV2aW91cyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnByZXZpb3VzQ29sb3IgPSBfT2JqZWN0JGFzc2lnbih7fSwgdGhpcy5jb2xvcik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5hcHBsaWVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sodGhpcy5pbml0aWFsQ29sb3IpO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmFtZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cbiAgICAgIC8vIGNhbGwgdGhlIGNsb3NpbmcgY2FsbGJhY2ssIHJlc3RvcmluZyB0aGUgb25jbGljayBtZXRob2QuXG4gICAgICAvLyB0aGlzIGlzIGluIGEgc2V0VGltZW91dCBiZWNhdXNlIGl0IHdpbGwgdHJpZ2dlciB0aGUgc2hvdyBhZ2FpbiBiZWZvcmUgdGhlIGNsaWNrIGlzIGRvbmUuXG4gICAgICBfc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpczIuY2xvc2VDYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgX3RoaXMyLmNsb3NlQ2FsbGJhY2soKTtcbiAgICAgICAgICBfdGhpczIuY2xvc2VDYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYm91bmQgdG8gdGhlIHNhdmUgYnV0dG9uLiBTYXZlcyBhbmQgaGlkZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9zYXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zYXZlKCkge1xuICAgICAgdGhpcy51cGRhdGVDYWxsYmFjayh0aGlzLmNvbG9yKTtcbiAgICAgIHRoaXMuYXBwbGllZCA9IGZhbHNlO1xuICAgICAgdGhpcy5faGlkZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJvdW5kIHRvIGFwcGx5IGJ1dHRvbi4gU2F2ZXMgYnV0IGRvZXMgbm90IGNsb3NlLiBJcyB1bmRvbmUgYnkgdGhlIGNhbmNlbCBidXR0b24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9hcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwbHkoKSB7XG4gICAgICB0aGlzLmFwcGxpZWQgPSB0cnVlO1xuICAgICAgdGhpcy51cGRhdGVDYWxsYmFjayh0aGlzLmNvbG9yKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVBpY2tlcih0aGlzLmNvbG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBsb2FkIHRoZSBjb2xvciBmcm9tIHRoZSBwcmV2aW91cyBzZXNzaW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfbG9hZExhc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xvYWRMYXN0KCkge1xuICAgICAgaWYgKHRoaXMucHJldmlvdXNDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc2V0Q29sb3IodGhpcy5wcmV2aW91c0NvbG9yLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGVydChcIlRoZXJlIGlzIG5vIGxhc3QgY29sb3IgdG8gbG9hZC4uLlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIGNvbG9yLCBwbGFjZSB0aGUgcGlja2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmdiYVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NldEluaXRpYWw9dHJ1ZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9zZXRDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0Q29sb3IocmdiYSkge1xuICAgICAgdmFyIHNldEluaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICAvLyBzdG9yZSB0aGUgaW5pdGlhbCBjb2xvclxuICAgICAgaWYgKHNldEluaXRpYWwgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsQ29sb3IgPSBfT2JqZWN0JGFzc2lnbih7fSwgcmdiYSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbG9yID0gcmdiYTtcbiAgICAgIHZhciBoc3YgPSBSR0JUb0hTVihyZ2JhLnIsIHJnYmEuZywgcmdiYS5iKTtcbiAgICAgIHZhciBhbmdsZUNvbnZlcnQgPSAyICogTWF0aC5QSTtcbiAgICAgIHZhciByYWRpdXMgPSB0aGlzLnIgKiBoc3YucztcbiAgICAgIHZhciB4ID0gdGhpcy5jZW50ZXJDb29yZGluYXRlcy54ICsgcmFkaXVzICogTWF0aC5zaW4oYW5nbGVDb252ZXJ0ICogaHN2LmgpO1xuICAgICAgdmFyIHkgPSB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnkgKyByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZUNvbnZlcnQgKiBoc3YuaCk7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUubGVmdCA9IHggLSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xpZW50V2lkdGggKyBcInB4XCI7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUudG9wID0geSAtIDAuNSAqIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRIZWlnaHQgKyBcInB4XCI7XG4gICAgICB0aGlzLl91cGRhdGVQaWNrZXIocmdiYSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYm91bmQgdG8gb3BhY2l0eSBjb250cm9sXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9zZXRPcGFjaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRPcGFjaXR5KHZhbHVlKSB7XG4gICAgICB0aGlzLmNvbG9yLmEgPSB2YWx1ZSAvIDEwMDtcbiAgICAgIHRoaXMuX3VwZGF0ZVBpY2tlcih0aGlzLmNvbG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBib3VuZCB0byBicmlnaHRuZXNzIGNvbnRyb2xcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldEJyaWdodG5lc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEJyaWdodG5lc3ModmFsdWUpIHtcbiAgICAgIHZhciBoc3YgPSBSR0JUb0hTVih0aGlzLmNvbG9yLnIsIHRoaXMuY29sb3IuZywgdGhpcy5jb2xvci5iKTtcbiAgICAgIGhzdi52ID0gdmFsdWUgLyAxMDA7XG4gICAgICB2YXIgcmdiYSA9IEhTVlRvUkdCKGhzdi5oLCBoc3YucywgaHN2LnYpO1xuICAgICAgcmdiYVtcImFcIl0gPSB0aGlzLmNvbG9yLmE7XG4gICAgICB0aGlzLmNvbG9yID0gcmdiYTtcbiAgICAgIHRoaXMuX3VwZGF0ZVBpY2tlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgY29sb3IgcGlja2VyLiBBIGJsYWNrIGNpcmNsZSBvdmVybGF5cyB0aGUgaHVlIGNpcmNsZSB0byBtaW1pYyB0aGUgYnJpZ2h0bmVzcyBkZWNyZWFzaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJnYmFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVQaWNrZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVBpY2tlcigpIHtcbiAgICAgIHZhciByZ2JhID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLmNvbG9yO1xuICAgICAgdmFyIGhzdiA9IFJHQlRvSFNWKHJnYmEuciwgcmdiYS5nLCByZ2JhLmIpO1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgaWYgKHRoaXMucGl4ZWxSYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyAoY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgICB9XG4gICAgICBjdHguc2V0VHJhbnNmb3JtKHRoaXMucGl4ZWxSYXRpbywgMCwgMCwgdGhpcy5waXhlbFJhdGlvLCAwLCAwKTtcblxuICAgICAgLy8gY2xlYXIgdGhlIGNhbnZhc1xuICAgICAgdmFyIHcgPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgdmFyIGggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmNsaWVudEhlaWdodDtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKHRoaXMuaHVlQ2lyY2xlLCAwLCAwKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYmEoMCwwLDAsXCIgKyAoMSAtIGhzdi52KSArIFwiKVwiO1xuICAgICAgY3R4LmNpcmNsZSh0aGlzLmNlbnRlckNvb3JkaW5hdGVzLngsIHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSwgdGhpcy5yKTtcbiAgICAgIF9maWxsSW5zdGFuY2VQcm9wZXJ0eShjdHgpLmNhbGwoY3R4KTtcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLnZhbHVlID0gMTAwICogaHN2LnY7XG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZS52YWx1ZSA9IDEwMCAqIHJnYmEuYTtcbiAgICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwicmdiYShcIiArIHRoaXMuaW5pdGlhbENvbG9yLnIgKyBcIixcIiArIHRoaXMuaW5pdGlhbENvbG9yLmcgKyBcIixcIiArIHRoaXMuaW5pdGlhbENvbG9yLmIgKyBcIixcIiArIHRoaXMuaW5pdGlhbENvbG9yLmEgKyBcIilcIjtcbiAgICAgIHRoaXMubmV3Q29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJyZ2JhKFwiICsgdGhpcy5jb2xvci5yICsgXCIsXCIgKyB0aGlzLmNvbG9yLmcgKyBcIixcIiArIHRoaXMuY29sb3IuYiArIFwiLFwiICsgdGhpcy5jb2xvci5hICsgXCIpXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdXNlZCBieSBjcmVhdGUgdG8gc2V0IHRoZSBzaXplIG9mIHRoZSBjYW52YXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9zZXRTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRTaXplKCkge1xuICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMud2lkdGggPSAyODkgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmhlaWdodCA9IDI4OSAqIHRoaXMucGl4ZWxSYXRpbztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgYWxsIGRvbSBlbGVtZW50c1xuICAgICAqIFRPRE86IGNsZWFudXAsIGxvdHMgb2Ygc2ltaWxhciBkb20gZWxlbWVudHNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xuICAgICAgdmFyIF9jb250ZXh0MTIsIF9jb250ZXh0MTMsIF9jb250ZXh0MTQsIF9jb250ZXh0MTU7XG4gICAgICB0aGlzLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuZnJhbWUuY2xhc3NOYW1lID0gXCJ2aXMtY29sb3ItcGlja2VyXCI7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3RvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xhc3NOYW1lID0gXCJ2aXMtc2VsZWN0b3JcIjtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJEaXYuYXBwZW5kQ2hpbGQodGhpcy5jb2xvclBpY2tlclNlbGVjdG9yKTtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgdGhpcy5jb2xvclBpY2tlckRpdi5hcHBlbmRDaGlsZCh0aGlzLmNvbG9yUGlja2VyQ2FudmFzKTtcbiAgICAgIGlmICghdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KSB7XG4gICAgICAgIHZhciBub0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7XG4gICAgICAgIG5vQ2FudmFzLnN0eWxlLmNvbG9yID0gXCJyZWRcIjtcbiAgICAgICAgbm9DYW52YXMuc3R5bGUuZm9udFdlaWdodCA9IFwiYm9sZFwiO1xuICAgICAgICBub0NhbnZhcy5zdHlsZS5wYWRkaW5nID0gXCIxMHB4XCI7XG4gICAgICAgIG5vQ2FudmFzLmlubmVyVGV4dCA9IFwiRXJyb3I6IHlvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IEhUTUwgY2FudmFzXCI7XG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuYXBwZW5kQ2hpbGQobm9DYW52YXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyAoY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbG9yUGlja2VyRGl2LmNsYXNzTmFtZSA9IFwidmlzLWNvbG9yXCI7XG4gICAgICB0aGlzLm9wYWNpdHlEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5vcGFjaXR5RGl2LmNsYXNzTmFtZSA9IFwidmlzLW9wYWNpdHlcIjtcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLmJyaWdodG5lc3NEaXYuY2xhc3NOYW1lID0gXCJ2aXMtYnJpZ2h0bmVzc1wiO1xuICAgICAgdGhpcy5hcnJvd0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLmFycm93RGl2LmNsYXNzTmFtZSA9IFwidmlzLWFycm93XCI7XG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMub3BhY2l0eVJhbmdlLnR5cGUgPSBcInJhbmdlXCI7IC8vIE5vdCBzdXBwb3J0ZWQgb24gSUU5XG4gICAgICAgIHRoaXMub3BhY2l0eVJhbmdlLm1pbiA9IFwiMFwiO1xuICAgICAgICB0aGlzLm9wYWNpdHlSYW5nZS5tYXggPSBcIjEwMFwiO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIFRPRE86IEFkZCBzb21lIGVycm9yIGhhbmRsaW5nLlxuICAgICAgfVxuICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UudmFsdWUgPSBcIjEwMFwiO1xuICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UuY2xhc3NOYW1lID0gXCJ2aXMtcmFuZ2VcIjtcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UudHlwZSA9IFwicmFuZ2VcIjsgLy8gTm90IHN1cHBvcnRlZCBvbiBJRTlcbiAgICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UubWluID0gXCIwXCI7XG4gICAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm1heCA9IFwiMTAwXCI7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gVE9ETzogQWRkIHNvbWUgZXJyb3IgaGFuZGxpbmcuXG4gICAgICB9XG4gICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS52YWx1ZSA9IFwiMTAwXCI7XG4gICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5jbGFzc05hbWUgPSBcInZpcy1yYW5nZVwiO1xuICAgICAgdGhpcy5vcGFjaXR5RGl2LmFwcGVuZENoaWxkKHRoaXMub3BhY2l0eVJhbmdlKTtcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc0Rpdi5hcHBlbmRDaGlsZCh0aGlzLmJyaWdodG5lc3NSYW5nZSk7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdGhpcy5vcGFjaXR5UmFuZ2Uub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1lLl9zZXRPcGFjaXR5KHRoaXMudmFsdWUpO1xuICAgICAgfTtcbiAgICAgIHRoaXMub3BhY2l0eVJhbmdlLm9uaW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1lLl9zZXRPcGFjaXR5KHRoaXMudmFsdWUpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtZS5fc2V0QnJpZ2h0bmVzcyh0aGlzLnZhbHVlKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5vbmlucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtZS5fc2V0QnJpZ2h0bmVzcyh0aGlzLnZhbHVlKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmJyaWdodG5lc3NMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLmJyaWdodG5lc3NMYWJlbC5jbGFzc05hbWUgPSBcInZpcy1sYWJlbCB2aXMtYnJpZ2h0bmVzc1wiO1xuICAgICAgdGhpcy5icmlnaHRuZXNzTGFiZWwuaW5uZXJUZXh0ID0gXCJicmlnaHRuZXNzOlwiO1xuICAgICAgdGhpcy5vcGFjaXR5TGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5vcGFjaXR5TGFiZWwuY2xhc3NOYW1lID0gXCJ2aXMtbGFiZWwgdmlzLW9wYWNpdHlcIjtcbiAgICAgIHRoaXMub3BhY2l0eUxhYmVsLmlubmVyVGV4dCA9IFwib3BhY2l0eTpcIjtcbiAgICAgIHRoaXMubmV3Q29sb3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5uZXdDb2xvckRpdi5jbGFzc05hbWUgPSBcInZpcy1uZXctY29sb3JcIjtcbiAgICAgIHRoaXMubmV3Q29sb3JEaXYuaW5uZXJUZXh0ID0gXCJuZXdcIjtcbiAgICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2LmNsYXNzTmFtZSA9IFwidmlzLWluaXRpYWwtY29sb3JcIjtcbiAgICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2LmlubmVyVGV4dCA9IFwiaW5pdGlhbFwiO1xuICAgICAgdGhpcy5jYW5jZWxCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5jYW5jZWxCdXR0b24uY2xhc3NOYW1lID0gXCJ2aXMtYnV0dG9uIHZpcy1jYW5jZWxcIjtcbiAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLmlubmVyVGV4dCA9IFwiY2FuY2VsXCI7XG4gICAgICB0aGlzLmNhbmNlbEJ1dHRvbi5vbmNsaWNrID0gX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQxMiA9IHRoaXMuX2hpZGUpLmNhbGwoX2NvbnRleHQxMiwgdGhpcywgZmFsc2UpO1xuICAgICAgdGhpcy5hcHBseUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLmFwcGx5QnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWJ1dHRvbiB2aXMtYXBwbHlcIjtcbiAgICAgIHRoaXMuYXBwbHlCdXR0b24uaW5uZXJUZXh0ID0gXCJhcHBseVwiO1xuICAgICAgdGhpcy5hcHBseUJ1dHRvbi5vbmNsaWNrID0gX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQxMyA9IHRoaXMuX2FwcGx5KS5jYWxsKF9jb250ZXh0MTMsIHRoaXMpO1xuICAgICAgdGhpcy5zYXZlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuc2F2ZUJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1idXR0b24gdmlzLXNhdmVcIjtcbiAgICAgIHRoaXMuc2F2ZUJ1dHRvbi5pbm5lclRleHQgPSBcInNhdmVcIjtcbiAgICAgIHRoaXMuc2F2ZUJ1dHRvbi5vbmNsaWNrID0gX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQxNCA9IHRoaXMuX3NhdmUpLmNhbGwoX2NvbnRleHQxNCwgdGhpcyk7XG4gICAgICB0aGlzLmxvYWRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5sb2FkQnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWJ1dHRvbiB2aXMtbG9hZFwiO1xuICAgICAgdGhpcy5sb2FkQnV0dG9uLmlubmVyVGV4dCA9IFwibG9hZCBsYXN0XCI7XG4gICAgICB0aGlzLmxvYWRCdXR0b24ub25jbGljayA9IF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MTUgPSB0aGlzLl9sb2FkTGFzdCkuY2FsbChfY29udGV4dDE1LCB0aGlzKTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5jb2xvclBpY2tlckRpdik7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuYXJyb3dEaXYpO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmJyaWdodG5lc3NMYWJlbCk7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuYnJpZ2h0bmVzc0Rpdik7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMub3BhY2l0eUxhYmVsKTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5vcGFjaXR5RGl2KTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5uZXdDb2xvckRpdik7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuaW5pdGlhbENvbG9yRGl2KTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5jYW5jZWxCdXR0b24pO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmFwcGx5QnV0dG9uKTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5zYXZlQnV0dG9uKTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5sb2FkQnV0dG9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBiaW5kIGhhbW1lciB0byB0aGUgY29sb3IgcGlja2VyXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9iaW5kSGFtbWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iaW5kSGFtbWVyKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB0aGlzLmRyYWcgPSB7fTtcbiAgICAgIHRoaXMucGluY2ggPSB7fTtcbiAgICAgIHRoaXMuaGFtbWVyID0gbmV3IEhhbW1lciQxKHRoaXMuY29sb3JQaWNrZXJDYW52YXMpO1xuICAgICAgdGhpcy5oYW1tZXIuZ2V0KFwicGluY2hcIikuc2V0KHtcbiAgICAgICAgZW5hYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwiaGFtbWVyLmlucHV0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuaXNGaXJzdCkge1xuICAgICAgICAgIF90aGlzMy5fbW92ZVNlbGVjdG9yKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcInRhcFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLl9tb3ZlU2VsZWN0b3IoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcInBhbnN0YXJ0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuX21vdmVTZWxlY3RvcihldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwicGFubW92ZVwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLl9tb3ZlU2VsZWN0b3IoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcInBhbmVuZFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLl9tb3ZlU2VsZWN0b3IoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2VuZXJhdGUgdGhlIGh1ZSBjaXJjbGUuIFRoaXMgaXMgcmVsYXRpdmVseSBoZWF2eSAoMjAwbXMpIGFuZCBpcyBkb25lIG9ubHkgb25jZSBvbiB0aGUgZmlyc3QgdGltZSBpdCBpcyBzaG93bi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dlbmVyYXRlSHVlQ2lyY2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZW5lcmF0ZUh1ZUNpcmNsZSgpIHtcbiAgICAgIGlmICh0aGlzLmdlbmVyYXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICBpZiAodGhpcy5waXhlbFJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5waXhlbFJhdGlvID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gKGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDEpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0odGhpcy5waXhlbFJhdGlvLCAwLCAwLCB0aGlzLnBpeGVsUmF0aW8sIDAsIDApO1xuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBjYW52YXNcbiAgICAgICAgdmFyIHcgPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgICB2YXIgaCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuXG4gICAgICAgIC8vIGRyYXcgaHVlIGNpcmNsZVxuICAgICAgICB2YXIgeCwgeSwgaHVlLCBzYXQ7XG4gICAgICAgIHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMgPSB7XG4gICAgICAgICAgeDogdyAqIDAuNSxcbiAgICAgICAgICB5OiBoICogMC41XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuciA9IDAuNDkgKiB3O1xuICAgICAgICB2YXIgYW5nbGVDb252ZXJ0ID0gMiAqIE1hdGguUEkgLyAzNjA7XG4gICAgICAgIHZhciBoZmFjID0gMSAvIDM2MDtcbiAgICAgICAgdmFyIHNmYWMgPSAxIC8gdGhpcy5yO1xuICAgICAgICB2YXIgcmdiO1xuICAgICAgICBmb3IgKGh1ZSA9IDA7IGh1ZSA8IDM2MDsgaHVlKyspIHtcbiAgICAgICAgICBmb3IgKHNhdCA9IDA7IHNhdCA8IHRoaXMucjsgc2F0KyspIHtcbiAgICAgICAgICAgIHggPSB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnggKyBzYXQgKiBNYXRoLnNpbihhbmdsZUNvbnZlcnQgKiBodWUpO1xuICAgICAgICAgICAgeSA9IHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSArIHNhdCAqIE1hdGguY29zKGFuZ2xlQ29udmVydCAqIGh1ZSk7XG4gICAgICAgICAgICByZ2IgPSBIU1ZUb1JHQihodWUgKiBoZmFjLCBzYXQgKiBzZmFjLCAxKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYihcIiArIHJnYi5yICsgXCIsXCIgKyByZ2IuZyArIFwiLFwiICsgcmdiLmIgKyBcIilcIjtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCh4IC0gMC41LCB5IC0gMC41LCAyLCAyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJyZ2JhKDAsMCwwLDEpXCI7XG4gICAgICAgIGN0eC5jaXJjbGUodGhpcy5jZW50ZXJDb29yZGluYXRlcy54LCB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnksIHRoaXMucik7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgdGhpcy5odWVDaXJjbGUgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHcsIGgpO1xuICAgICAgfVxuICAgICAgdGhpcy5nZW5lcmF0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1vdmUgdGhlIHNlbGVjdG9yLiBUaGlzIGlzIGNhbGxlZCBieSBoYW1tZXIgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50ICAgVGhlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfbW92ZVNlbGVjdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlU2VsZWN0b3IoZXZlbnQpIHtcbiAgICAgIHZhciByZWN0ID0gdGhpcy5jb2xvclBpY2tlckRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBsZWZ0ID0gZXZlbnQuY2VudGVyLnggLSByZWN0LmxlZnQ7XG4gICAgICB2YXIgdG9wID0gZXZlbnQuY2VudGVyLnkgLSByZWN0LnRvcDtcbiAgICAgIHZhciBjZW50ZXJZID0gMC41ICogdGhpcy5jb2xvclBpY2tlckRpdi5jbGllbnRIZWlnaHQ7XG4gICAgICB2YXIgY2VudGVyWCA9IDAuNSAqIHRoaXMuY29sb3JQaWNrZXJEaXYuY2xpZW50V2lkdGg7XG4gICAgICB2YXIgeCA9IGxlZnQgLSBjZW50ZXJYO1xuICAgICAgdmFyIHkgPSB0b3AgLSBjZW50ZXJZO1xuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih4LCB5KTtcbiAgICAgIHZhciByYWRpdXMgPSAwLjk4ICogTWF0aC5taW4oTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpLCBjZW50ZXJYKTtcbiAgICAgIHZhciBuZXdUb3AgPSBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMgKyBjZW50ZXJZO1xuICAgICAgdmFyIG5ld0xlZnQgPSBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMgKyBjZW50ZXJYO1xuICAgICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLnN0eWxlLnRvcCA9IG5ld1RvcCAtIDAuNSAqIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRIZWlnaHQgKyBcInB4XCI7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUubGVmdCA9IG5ld0xlZnQgLSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xpZW50V2lkdGggKyBcInB4XCI7XG5cbiAgICAgIC8vIHNldCBjb2xvclxuICAgICAgdmFyIGggPSBhbmdsZSAvICgyICogTWF0aC5QSSk7XG4gICAgICBoID0gaCA8IDAgPyBoICsgMSA6IGg7XG4gICAgICB2YXIgcyA9IHJhZGl1cyAvIHRoaXMucjtcbiAgICAgIHZhciBoc3YgPSBSR0JUb0hTVih0aGlzLmNvbG9yLnIsIHRoaXMuY29sb3IuZywgdGhpcy5jb2xvci5iKTtcbiAgICAgIGhzdi5oID0gaDtcbiAgICAgIGhzdi5zID0gcztcbiAgICAgIHZhciByZ2JhID0gSFNWVG9SR0IoaHN2LmgsIGhzdi5zLCBoc3Yudik7XG4gICAgICByZ2JhW1wiYVwiXSA9IHRoaXMuY29sb3IuYTtcbiAgICAgIHRoaXMuY29sb3IgPSByZ2JhO1xuXG4gICAgICAvLyB1cGRhdGUgcHJldmlld3NcbiAgICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwicmdiYShcIiArIHRoaXMuaW5pdGlhbENvbG9yLnIgKyBcIixcIiArIHRoaXMuaW5pdGlhbENvbG9yLmcgKyBcIixcIiArIHRoaXMuaW5pdGlhbENvbG9yLmIgKyBcIixcIiArIHRoaXMuaW5pdGlhbENvbG9yLmEgKyBcIilcIjtcbiAgICAgIHRoaXMubmV3Q29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJyZ2JhKFwiICsgdGhpcy5jb2xvci5yICsgXCIsXCIgKyB0aGlzLmNvbG9yLmcgKyBcIixcIiArIHRoaXMuY29sb3IuYiArIFwiLFwiICsgdGhpcy5jb2xvci5hICsgXCIpXCI7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb2xvclBpY2tlcjtcbn0oKTtcblxuLyoqXG4gKiBXcmFwIGdpdmVuIHRleHQgKGxhc3QgYXJndW1lbnQpIGluIEhUTUwgZWxlbWVudHMgKGFsbCBwcmVjZWRpbmcgYXJndW1lbnRzKS5cbiAqXG4gKiBAcGFyYW0gey4uLmFueX0gcmVzdCAtIExpc3Qgb2YgdGFnIG5hbWVzIGZvbGxvd2VkIGJ5IGlubmVyIHRleHQuXG4gKiBAcmV0dXJucyBBbiBlbGVtZW50IG9yIGEgdGV4dCBub2RlLlxuICovXG5mdW5jdGlvbiB3cmFwSW5UYWcoKSB7XG4gIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuNSksIF9rZXk1ID0gMDsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgIHJlc3RbX2tleTVdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgfVxuICBpZiAocmVzdC5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXJndW1lbnRzLlwiKTtcbiAgfSBlbHNlIGlmIChyZXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShyZXN0WzBdKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocmVzdFswXSk7XG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZCh3cmFwSW5UYWcuYXBwbHkodm9pZCAwLCBfdG9Db25zdW1hYmxlQXJyYXkoX3NsaWNlSW5zdGFuY2VQcm9wZXJ0eShyZXN0KS5jYWxsKHJlc3QsIDEpKSkpO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59XG5cbi8qKlxuICogVGhlIHdheSB0aGlzIHdvcmtzIGlzIGZvciBhbGwgcHJvcGVydGllcyBvZiB0aGlzLnBvc3NpYmxlIG9wdGlvbnMsIHlvdSBjYW4gc3VwcGx5IHRoZSBwcm9wZXJ0eSBuYW1lIGluIGFueSBmb3JtIHRvIGxpc3QgdGhlIG9wdGlvbnMuXG4gKiBCb29sZWFuIG9wdGlvbnMgYXJlIHJlY29nbmlzZWQgYXMgQm9vbGVhblxuICogTnVtYmVyIG9wdGlvbnMgc2hvdWxkIGJlIHdyaXR0ZW4gYXMgYXJyYXk6IFtkZWZhdWx0IHZhbHVlLCBtaW4gdmFsdWUsIG1heCB2YWx1ZSwgc3RlcHNpemVdXG4gKiBDb2xvcnMgc2hvdWxkIGJlIHdyaXR0ZW4gYXMgYXJyYXk6IFsnY29sb3InLCAnI2ZmZmZmZiddXG4gKiBTdHJpbmdzIHdpdGggc2hvdWxkIGJlIHdyaXR0ZW4gYXMgYXJyYXk6IFtvcHRpb24xLCBvcHRpb24yLCBvcHRpb24zLCAuLl1cbiAqXG4gKiBUaGUgb3B0aW9ucyBhcmUgbWF0Y2hlZCB3aXRoIHRoZWlyIGNvdW50ZXJwYXJ0cyBpbiBlYWNoIG9mIHRoZSBtb2R1bGVzIGFuZCB0aGUgdmFsdWVzIHVzZWQgaW4gdGhlIGNvbmZpZ3VyYXRpb24gYXJlXG4gKi9cbnZhciBDb25maWd1cmF0b3IkMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50TW9kdWxlICAgICAgICB8IHRoZSBsb2NhdGlvbiB3aGVyZSBwYXJlbnRNb2R1bGUuc2V0T3B0aW9ucygpIGNhbiBiZSBjYWxsZWRcbiAgICogQHBhcmFtIHtvYmplY3R9IGRlZmF1bHRDb250YWluZXIgICAgfCB0aGUgZGVmYXVsdCBjb250YWluZXIgb2YgdGhlIG1vZHVsZVxuICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlndXJlT3B0aW9ucyAgICB8IHRoZSBmdWxseSBjb25maWd1cmVkIGFuZCBwcmVkZWZpbmVkIG9wdGlvbnMgc2V0IGZvdW5kIGluIGFsbE9wdGlvbnMuanNcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gICAgICAgICAgfCBjYW52YXMgcGl4ZWwgcmF0aW9cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGlkZU9wdGlvbiAgICAgICAgfCBjdXN0b20gbG9naWMgdG8gZHluYW1pY2FsbHkgaGlkZSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBDb25maWd1cmF0b3IocGFyZW50TW9kdWxlLCBkZWZhdWx0Q29udGFpbmVyLCBjb25maWd1cmVPcHRpb25zKSB7XG4gICAgdmFyIHBpeGVsUmF0aW8gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDE7XG4gICAgdmFyIGhpZGVPcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25maWd1cmF0b3IpO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50TW9kdWxlO1xuICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMgPSBbXTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGRlZmF1bHRDb250YWluZXI7XG4gICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gZmFsc2U7XG4gICAgdGhpcy5oaWRlT3B0aW9uID0gaGlkZU9wdGlvbjtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5wb3B1cENvdW50ZXIgPSAwO1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGZpbHRlcjogdHJ1ZSxcbiAgICAgIGNvbnRhaW5lcjogdW5kZWZpbmVkLFxuICAgICAgc2hvd0J1dHRvbjogdHJ1ZVxuICAgIH07XG4gICAgX09iamVjdCRhc3NpZ24odGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgICB0aGlzLmNvbmZpZ3VyZU9wdGlvbnMgPSBjb25maWd1cmVPcHRpb25zO1xuICAgIHRoaXMubW9kdWxlT3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZG9tRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLnBvcHVwRGl2ID0ge307XG4gICAgdGhpcy5wb3B1cExpbWl0ID0gNTtcbiAgICB0aGlzLnBvcHVwSGlzdG9yeSA9IHt9O1xuICAgIHRoaXMuY29sb3JQaWNrZXIgPSBuZXcgQ29sb3JQaWNrZXIkMShwaXhlbFJhdGlvKTtcbiAgICB0aGlzLndyYXBwZXIgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogcmVmcmVzaCBhbGwgb3B0aW9ucy5cbiAgICogQmVjYXVzZSBhbGwgbW9kdWxlcyBwYXJzZSB0aGVpciBvcHRpb25zIGJ5IHRoZW1zZWx2ZXMsIHdlIGp1c3QgdXNlIHRoZWlyIG9wdGlvbnMuIFdlIGNvcHkgdGhlbSBoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKENvbmZpZ3VyYXRvciwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gcmVzZXQgdGhlIHBvcHVwIGhpc3RvcnkgYmVjYXVzZSB0aGUgaW5kaWNlcyBtYXkgaGF2ZSBiZWVuIGNoYW5nZWQuXG4gICAgICAgIHRoaXMucG9wdXBIaXN0b3J5ID0ge307XG4gICAgICAgIHRoaXMuX3JlbW92ZVBvcHVwKCk7XG4gICAgICAgIHZhciBlbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlciA9IG9wdGlvbnM7XG4gICAgICAgIH0gZWxzZSBpZiAoX0FycmF5JGlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gb3B0aW9ucy5qb2luKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihvcHRpb25zKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvcHRpb25zIGNhbm5vdCBiZSBudWxsXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy5jb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX2ZpbHRlckluc3RhbmNlUHJvcGVydHkob3B0aW9ucykgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlciA9IF9maWx0ZXJJbnN0YW5jZVByb3BlcnR5KG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy5zaG93QnV0dG9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zaG93QnV0dG9uID0gb3B0aW9ucy5zaG93QnV0dG9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy5lbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVuYWJsZWQgPSBvcHRpb25zLmVuYWJsZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSB0cnVlO1xuICAgICAgICAgIGVuYWJsZWQgPSBvcHRpb25zO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gb3B0aW9ucztcbiAgICAgICAgICBlbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2ZpbHRlckluc3RhbmNlUHJvcGVydHkodGhpcy5vcHRpb25zKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBlbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2xlYW4oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtb2R1bGVPcHRpb25zXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TW9kdWxlT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNb2R1bGVPcHRpb25zKG1vZHVsZU9wdGlvbnMpIHtcbiAgICAgIHRoaXMubW9kdWxlT3B0aW9ucyA9IG1vZHVsZU9wdGlvbnM7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fY2xlYW4oKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5vcHRpb25zLmNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jcmVhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYWxsIERPTSBlbGVtZW50c1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XG4gICAgICB0aGlzLl9jbGVhbigpO1xuICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucyA9IFtdO1xuICAgICAgdmFyIGZpbHRlciA9IF9maWx0ZXJJbnN0YW5jZVByb3BlcnR5KHRoaXMub3B0aW9ucyk7XG4gICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICB2YXIgc2hvdyA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgX29wdGlvbiBpbiB0aGlzLmNvbmZpZ3VyZU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNvbmZpZ3VyZU9wdGlvbnMsIF9vcHRpb24pKSB7XG4gICAgICAgICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgc2hvdyA9IGZhbHNlO1xuICAgICAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHNob3cgPSBmaWx0ZXIoX29wdGlvbiwgW10pO1xuICAgICAgICAgICAgc2hvdyA9IHNob3cgfHwgdGhpcy5faGFuZGxlT2JqZWN0KHRoaXMuY29uZmlndXJlT3B0aW9uc1tfb3B0aW9uXSwgW19vcHRpb25dLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZpbHRlciA9PT0gdHJ1ZSB8fCBfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkoZmlsdGVyKS5jYWxsKGZpbHRlciwgX29wdGlvbikgIT09IC0xKSB7XG4gICAgICAgICAgICBzaG93ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNob3cgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLmFsbG93Q3JlYXRpb24gPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBsaW5lYnJlYWsgYmV0d2VlbiBjYXRlZ29yaWVzXG4gICAgICAgICAgICBpZiAoY291bnRlciA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5fbWFrZUl0ZW0oW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYSBoZWFkZXIgZm9yIHRoZSBjYXRlZ29yeVxuICAgICAgICAgICAgdGhpcy5fbWFrZUhlYWRlcihfb3B0aW9uKTtcblxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBzdWIgb3B0aW9uc1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlT2JqZWN0KHRoaXMuY29uZmlndXJlT3B0aW9uc1tfb3B0aW9uXSwgW19vcHRpb25dKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY291bnRlcisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9tYWtlQnV0dG9uKCk7XG4gICAgICB0aGlzLl9wdXNoKCk7XG4gICAgICAvL34gdGhpcy5jb2xvclBpY2tlci5pbnNlcnRUbyh0aGlzLmNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZHJhdyBhbGwgRE9NIGVsZW1lbnRzIG9uIHRoZSBzY3JlZW5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3B1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3B1c2goKSB7XG4gICAgICB0aGlzLndyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy53cmFwcGVyLmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24td3JhcHBlclwiO1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy53cmFwcGVyKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kb21FbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5kb21FbGVtZW50c1tpXSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zaG93UG9wdXBJZk5lZWRlZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGRlbGV0ZSBhbGwgRE9NIGVsZW1lbnRzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jbGVhblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xlYW4oKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZG9tRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53cmFwcGVyLnJlbW92ZUNoaWxkKHRoaXMuZG9tRWxlbWVudHNbaV0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMud3JhcHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMud3JhcHBlcik7XG4gICAgICAgIHRoaXMud3JhcHBlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZG9tRWxlbWVudHMgPSBbXTtcbiAgICAgIHRoaXMuX3JlbW92ZVBvcHVwKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBhY3R1YWxPcHRpb25zIGlmIGl0IGV4aXN0c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0VmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFZhbHVlKHBhdGgpIHtcbiAgICAgIHZhciBiYXNlID0gdGhpcy5tb2R1bGVPcHRpb25zO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChiYXNlW3BhdGhbaV1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBiYXNlID0gYmFzZVtwYXRoW2ldXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiYXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhbGwgb3B0aW9uIGVsZW1lbnRzIGFyZSB3cmFwcGVkIGluIGFuIGl0ZW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEVsZW1lbnQ+fSBkb21FbGVtZW50c1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfbWFrZUl0ZW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VJdGVtKHBhdGgpIHtcbiAgICAgIGlmICh0aGlzLmFsbG93Q3JlYXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBpdGVtLmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1pdGVtIHZpcy1jb25maWctc1wiICsgcGF0aC5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIF9sZW42ID0gYXJndW1lbnRzLmxlbmd0aCwgZG9tRWxlbWVudHMgPSBuZXcgQXJyYXkoX2xlbjYgPiAxID8gX2xlbjYgLSAxIDogMCksIF9rZXk2ID0gMTsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgICAgICAgIGRvbUVsZW1lbnRzW19rZXk2IC0gMV0gPSBhcmd1bWVudHNbX2tleTZdO1xuICAgICAgICB9XG4gICAgICAgIF9mb3JFYWNoSW5zdGFuY2VQcm9wZXJ0eShkb21FbGVtZW50cykuY2FsbChkb21FbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICBpdGVtLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50cy5wdXNoKGl0ZW0pO1xuICAgICAgICByZXR1cm4gdGhpcy5kb21FbGVtZW50cy5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoZWFkZXIgZm9yIG1ham9yIHN1YmplY3RzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX21ha2VIZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VIZWFkZXIobmFtZSkge1xuICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBkaXYuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWhlYWRlclwiO1xuICAgICAgZGl2LmlubmVyVGV4dCA9IG5hbWU7XG4gICAgICB0aGlzLl9tYWtlSXRlbShbXSwgZGl2KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgbGFiZWwsIGlmIGl0IGlzIGFuIG9iamVjdCBsYWJlbCwgaXQgZ2V0cyBkaWZmZXJlbnQgc3R5bGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9iamVjdExhYmVsXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX21ha2VMYWJlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZUxhYmVsKG5hbWUsIHBhdGgpIHtcbiAgICAgIHZhciBvYmplY3RMYWJlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGRpdi5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctbGFiZWwgdmlzLWNvbmZpZy1zXCIgKyBwYXRoLmxlbmd0aDtcbiAgICAgIGlmIChvYmplY3RMYWJlbCA9PT0gdHJ1ZSkge1xuICAgICAgICB3aGlsZSAoZGl2LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBkaXYucmVtb3ZlQ2hpbGQoZGl2LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZCh3cmFwSW5UYWcoXCJpXCIsIFwiYlwiLCBuYW1lKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXYuaW5uZXJUZXh0ID0gbmFtZSArIFwiOlwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRpdjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgZHJvcGRvd24gbGlzdCBmb3IgbXVsdGlwbGUgcG9zc2libGUgc3RyaW5nIG9wdG9pbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGFyclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX21ha2VEcm9wZG93blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZURyb3Bkb3duKGFyciwgdmFsdWUsIHBhdGgpIHtcbiAgICAgIHZhciBzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO1xuICAgICAgc2VsZWN0LmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1zZWxlY3RcIjtcbiAgICAgIHZhciBzZWxlY3RlZFZhbHVlID0gMDtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkoYXJyKS5jYWxsKGFyciwgdmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgIHNlbGVjdGVkVmFsdWUgPSBfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkoYXJyKS5jYWxsKGFyciwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX29wdGlvbjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICBfb3B0aW9uMi52YWx1ZSA9IGFycltpXTtcbiAgICAgICAgaWYgKGkgPT09IHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgICBfb3B0aW9uMi5zZWxlY3RlZCA9IFwic2VsZWN0ZWRcIjtcbiAgICAgICAgfVxuICAgICAgICBfb3B0aW9uMi5pbm5lclRleHQgPSBhcnJbaV07XG4gICAgICAgIHNlbGVjdC5hcHBlbmRDaGlsZChfb3B0aW9uMik7XG4gICAgICB9XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgc2VsZWN0Lm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtZS5fdXBkYXRlKHRoaXMudmFsdWUsIHBhdGgpO1xuICAgICAgfTtcbiAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuICAgICAgdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIHNlbGVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbWFrZSBhIHJhbmdlIG9iamVjdCBmb3IgbnVtZXJpYyBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhcnJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9tYWtlUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VSYW5nZShhcnIsIHZhbHVlLCBwYXRoKSB7XG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gYXJyWzBdO1xuICAgICAgdmFyIG1pbiA9IGFyclsxXTtcbiAgICAgIHZhciBtYXggPSBhcnJbMl07XG4gICAgICB2YXIgc3RlcCA9IGFyclszXTtcbiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgIHJhbmdlLmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1yYW5nZVwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmFuZ2UudHlwZSA9IFwicmFuZ2VcIjsgLy8gbm90IHN1cHBvcnRlZCBvbiBJRTlcbiAgICAgICAgcmFuZ2UubWluID0gbWluO1xuICAgICAgICByYW5nZS5tYXggPSBtYXg7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gVE9ETzogQWRkIHNvbWUgZXJyb3IgaGFuZGxpbmcuXG4gICAgICB9XG4gICAgICByYW5nZS5zdGVwID0gc3RlcDtcblxuICAgICAgLy8gc2V0IHVwIHRoZSBwb3B1cCBzZXR0aW5ncyBpbiBjYXNlIHRoZXkgYXJlIG5lZWRlZC5cbiAgICAgIHZhciBwb3B1cFN0cmluZyA9IFwiXCI7XG4gICAgICB2YXIgcG9wdXBWYWx1ZSA9IDA7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZmFjdG9yID0gMS4yO1xuICAgICAgICBpZiAodmFsdWUgPCAwICYmIHZhbHVlICogZmFjdG9yIDwgbWluKSB7XG4gICAgICAgICAgcmFuZ2UubWluID0gTWF0aC5jZWlsKHZhbHVlICogZmFjdG9yKTtcbiAgICAgICAgICBwb3B1cFZhbHVlID0gcmFuZ2UubWluO1xuICAgICAgICAgIHBvcHVwU3RyaW5nID0gXCJyYW5nZSBpbmNyZWFzZWRcIjtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAvIGZhY3RvciA8IG1pbikge1xuICAgICAgICAgIHJhbmdlLm1pbiA9IE1hdGguY2VpbCh2YWx1ZSAvIGZhY3Rvcik7XG4gICAgICAgICAgcG9wdXBWYWx1ZSA9IHJhbmdlLm1pbjtcbiAgICAgICAgICBwb3B1cFN0cmluZyA9IFwicmFuZ2UgaW5jcmVhc2VkXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICogZmFjdG9yID4gbWF4ICYmIG1heCAhPT0gMSkge1xuICAgICAgICAgIHJhbmdlLm1heCA9IE1hdGguY2VpbCh2YWx1ZSAqIGZhY3Rvcik7XG4gICAgICAgICAgcG9wdXBWYWx1ZSA9IHJhbmdlLm1heDtcbiAgICAgICAgICBwb3B1cFN0cmluZyA9IFwicmFuZ2UgaW5jcmVhc2VkXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ2UudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlLnZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgaW5wdXQuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXJhbmdlaW5wdXRcIjtcbiAgICAgIGlucHV0LnZhbHVlID0gcmFuZ2UudmFsdWU7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgcmFuZ2Uub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlucHV0LnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbWUuX3VwZGF0ZShOdW1iZXIodGhpcy52YWx1ZSksIHBhdGgpO1xuICAgICAgfTtcbiAgICAgIHJhbmdlLm9uaW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlucHV0LnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIH07XG4gICAgICB2YXIgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBwYXRoKTtcbiAgICAgIHZhciBpdGVtSW5kZXggPSB0aGlzLl9tYWtlSXRlbShwYXRoLCBsYWJlbCwgcmFuZ2UsIGlucHV0KTtcblxuICAgICAgLy8gaWYgYSBwb3B1cCBpcyBuZWVkZWQgQU5EIGl0IGhhcyBub3QgYmVlbiBzaG93biBmb3IgdGhpcyB2YWx1ZSwgc2hvdyBpdC5cbiAgICAgIGlmIChwb3B1cFN0cmluZyAhPT0gXCJcIiAmJiB0aGlzLnBvcHVwSGlzdG9yeVtpdGVtSW5kZXhdICE9PSBwb3B1cFZhbHVlKSB7XG4gICAgICAgIHRoaXMucG9wdXBIaXN0b3J5W2l0ZW1JbmRleF0gPSBwb3B1cFZhbHVlO1xuICAgICAgICB0aGlzLl9zZXR1cFBvcHVwKHBvcHVwU3RyaW5nLCBpdGVtSW5kZXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1ha2UgYSBidXR0b24gb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9tYWtlQnV0dG9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlQnV0dG9uKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNob3dCdXR0b24gPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGdlbmVyYXRlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZ2VuZXJhdGVCdXR0b24uY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWJ1dHRvblwiO1xuICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5pbm5lclRleHQgPSBcImdlbmVyYXRlIG9wdGlvbnNcIjtcbiAgICAgICAgZ2VuZXJhdGVCdXR0b24ub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczQuX3ByaW50T3B0aW9ucygpO1xuICAgICAgICB9O1xuICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5vbm1vdXNlb3ZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctYnV0dG9uIGhvdmVyXCI7XG4gICAgICAgIH07XG4gICAgICAgIGdlbmVyYXRlQnV0dG9uLm9ubW91c2VvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZ2VuZXJhdGVCdXR0b24uY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWJ1dHRvblwiO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9wdGlvbnNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLm9wdGlvbnNDb250YWluZXIuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLW9wdGlvbi1jb250YWluZXJcIjtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50cy5wdXNoKHRoaXMub3B0aW9uc0NvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHMucHVzaChnZW5lcmF0ZUJ1dHRvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJlcGFyZSB0aGUgcG9wdXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9zZXR1cFBvcHVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cFBvcHVwKHN0cmluZywgaW5kZXgpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQgPT09IHRydWUgJiYgdGhpcy5hbGxvd0NyZWF0aW9uID09PSB0cnVlICYmIHRoaXMucG9wdXBDb3VudGVyIDwgdGhpcy5wb3B1cExpbWl0KSB7XG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkaXYuaWQgPSBcInZpcy1jb25maWd1cmF0aW9uLXBvcHVwXCI7XG4gICAgICAgIGRpdi5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uLXBvcHVwXCI7XG4gICAgICAgIGRpdi5pbm5lclRleHQgPSBzdHJpbmc7XG4gICAgICAgIGRpdi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNS5fcmVtb3ZlUG9wdXAoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wb3B1cENvdW50ZXIgKz0gMTtcbiAgICAgICAgdGhpcy5wb3B1cERpdiA9IHtcbiAgICAgICAgICBodG1sOiBkaXYsXG4gICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIHRoZSBwb3B1cCBmcm9tIHRoZSBkb21cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZVBvcHVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVQb3B1cCgpIHtcbiAgICAgIGlmICh0aGlzLnBvcHVwRGl2Lmh0bWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnBvcHVwRGl2Lmh0bWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHVwRGl2Lmh0bWwpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wb3B1cERpdi5oaWRlVGltZW91dCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBvcHVwRGl2LmRlbGV0ZVRpbWVvdXQpO1xuICAgICAgICB0aGlzLnBvcHVwRGl2ID0ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvdyB0aGUgcG9wdXAgaWYgaXQgaXMgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfc2hvd1BvcHVwSWZOZWVkZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Nob3dQb3B1cElmTmVlZGVkKCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5wb3B1cERpdi5odG1sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGNvcnJlc3BvbmRpbmdFbGVtZW50ID0gdGhpcy5kb21FbGVtZW50c1t0aGlzLnBvcHVwRGl2LmluZGV4XTtcbiAgICAgICAgdmFyIHJlY3QgPSBjb3JyZXNwb25kaW5nRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5wb3B1cERpdi5odG1sLnN0eWxlLmxlZnQgPSByZWN0LmxlZnQgKyBcInB4XCI7XG4gICAgICAgIHRoaXMucG9wdXBEaXYuaHRtbC5zdHlsZS50b3AgPSByZWN0LnRvcCAtIDMwICsgXCJweFwiOyAvLyAzMCBpcyB0aGUgaGVpZ2h0O1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMucG9wdXBEaXYuaHRtbCk7XG4gICAgICAgIHRoaXMucG9wdXBEaXYuaGlkZVRpbWVvdXQgPSBfc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM2LnBvcHVwRGl2Lmh0bWwuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIH0sIDE1MDApO1xuICAgICAgICB0aGlzLnBvcHVwRGl2LmRlbGV0ZVRpbWVvdXQgPSBfc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM2Ll9yZW1vdmVQb3B1cCgpO1xuICAgICAgICB9LCAxODAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgY2hlY2tib3ggZm9yIGJvb2xlYW4gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0VmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9tYWtlQ2hlY2tib3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VDaGVja2JveChkZWZhdWx0VmFsdWUsIHZhbHVlLCBwYXRoKSB7XG4gICAgICB2YXIgY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICBjaGVja2JveC50eXBlID0gXCJjaGVja2JveFwiO1xuICAgICAgY2hlY2tib3guY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWNoZWNrYm94XCI7XG4gICAgICBjaGVja2JveC5jaGVja2VkID0gZGVmYXVsdFZhbHVlO1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgIT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgIGlmIChfdHlwZW9mKGRlZmF1bHRWYWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gZGVmYXVsdFZhbHVlLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICBjaGVja2JveC5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUuX3VwZGF0ZSh0aGlzLmNoZWNrZWQsIHBhdGgpO1xuICAgICAgfTtcbiAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuICAgICAgdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIGNoZWNrYm94KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgdGV4dCBpbnB1dCBmaWVsZCBmb3Igc3RyaW5nIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVmYXVsdFZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfbWFrZVRleHRJbnB1dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZVRleHRJbnB1dChkZWZhdWx0VmFsdWUsIHZhbHVlLCBwYXRoKSB7XG4gICAgICB2YXIgY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICBjaGVja2JveC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICBjaGVja2JveC5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctdGV4dFwiO1xuICAgICAgY2hlY2tib3gudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7XG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgY2hlY2tib3gub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1lLl91cGRhdGUodGhpcy52YWx1ZSwgcGF0aCk7XG4gICAgICB9O1xuICAgICAgdmFyIGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHBhdGhbcGF0aC5sZW5ndGggLSAxXSwgcGF0aCk7XG4gICAgICB0aGlzLl9tYWtlSXRlbShwYXRoLCBsYWJlbCwgY2hlY2tib3gpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1ha2UgYSBjb2xvciBmaWVsZCB3aXRoIGEgY29sb3IgcGlja2VyIGZvciBjb2xvciBmaWVsZHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGFyclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX21ha2VDb2xvckZpZWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlQ29sb3JGaWVsZChhcnIsIHZhbHVlLCBwYXRoKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcbiAgICAgIHZhciBkZWZhdWx0Q29sb3IgPSBhcnJbMV07XG4gICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb2xvciA6IHZhbHVlO1xuICAgICAgaWYgKHZhbHVlICE9PSBcIm5vbmVcIikge1xuICAgICAgICBkaXYuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWNvbG9yQmxvY2tcIjtcbiAgICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGl2LmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1jb2xvckJsb2NrIG5vbmVcIjtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb2xvciA6IHZhbHVlO1xuICAgICAgZGl2Lm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNy5fc2hvd0NvbG9yUGlja2VyKHZhbHVlLCBkaXYsIHBhdGgpO1xuICAgICAgfTtcbiAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuICAgICAgdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIGRpdik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdXNlZCBieSB0aGUgY29sb3IgYnV0dG9ucyB0byBjYWxsIHRoZSBjb2xvciBwaWNrZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkaXZcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9zaG93Q29sb3JQaWNrZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Nob3dDb2xvclBpY2tlcih2YWx1ZSwgZGl2LCBwYXRoKSB7XG4gICAgICB2YXIgX3RoaXM4ID0gdGhpcztcbiAgICAgIC8vIGNsZWFyIHRoZSBjYWxsYmFjayBmcm9tIHRoaXMgZGl2XG4gICAgICBkaXYub25jbGljayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgdGhpcy5jb2xvclBpY2tlci5pbnNlcnRUbyhkaXYpO1xuICAgICAgdGhpcy5jb2xvclBpY2tlci5zaG93KCk7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyLnNldENvbG9yKHZhbHVlKTtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXIuc2V0VXBkYXRlQ2FsbGJhY2soZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHZhciBjb2xvclN0cmluZyA9IFwicmdiYShcIiArIGNvbG9yLnIgKyBcIixcIiArIGNvbG9yLmcgKyBcIixcIiArIGNvbG9yLmIgKyBcIixcIiArIGNvbG9yLmEgKyBcIilcIjtcbiAgICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yU3RyaW5nO1xuICAgICAgICBfdGhpczguX3VwZGF0ZShjb2xvclN0cmluZywgcGF0aCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gb24gY2xvc2Ugb2YgdGhlIGNvbG9ycGlja2VyLCByZXN0b3JlIHRoZSBjYWxsYmFjay5cbiAgICAgIHRoaXMuY29sb3JQaWNrZXIuc2V0Q2xvc2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRpdi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzOC5fc2hvd0NvbG9yUGlja2VyKHZhbHVlLCBkaXYsIHBhdGgpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcGFyc2UgYW4gb2JqZWN0IGFuZCBkcmF3IHRoZSBjb3JyZWN0IGl0ZW1zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhdGg9W11dICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjaGVja09ubHk9ZmFsc2VdXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlT2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVPYmplY3Qob2JqKSB7XG4gICAgICB2YXIgcGF0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgICB2YXIgY2hlY2tPbmx5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIHZhciBzaG93ID0gZmFsc2U7XG4gICAgICB2YXIgZmlsdGVyID0gX2ZpbHRlckluc3RhbmNlUHJvcGVydHkodGhpcy5vcHRpb25zKTtcbiAgICAgIHZhciB2aXNpYmxlSW5TZXQgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIHN1Yk9iaiBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHN1Yk9iaikpIHtcbiAgICAgICAgICBzaG93ID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgaXRlbSA9IG9ialtzdWJPYmpdO1xuICAgICAgICAgIHZhciBuZXdQYXRoID0gY29weUFuZEV4dGVuZEFycmF5KHBhdGgsIHN1Yk9iaik7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgc2hvdyA9IGZpbHRlcihzdWJPYmosIHBhdGgpO1xuXG4gICAgICAgICAgICAvLyBpZiBuZWVkZWQgd2UgbXVzdCBnbyBkZWVwZXIgaW50byB0aGUgb2JqZWN0LlxuICAgICAgICAgICAgaWYgKHNob3cgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGlmICghX0FycmF5JGlzQXJyYXkoaXRlbSkgJiYgdHlwZW9mIGl0ZW0gIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGl0ZW0gIT09IFwiYm9vbGVhblwiICYmIGl0ZW0gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFsbG93Q3JlYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzaG93ID0gdGhpcy5faGFuZGxlT2JqZWN0KGl0ZW0sIG5ld1BhdGgsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IGNoZWNrT25seSA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNob3cgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2aXNpYmxlSW5TZXQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZ2V0VmFsdWUobmV3UGF0aCk7XG4gICAgICAgICAgICBpZiAoX0FycmF5JGlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5faGFuZGxlQXJyYXkoaXRlbSwgdmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICB0aGlzLl9tYWtlVGV4dElucHV0KGl0ZW0sIHZhbHVlLCBuZXdQYXRoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21ha2VDaGVja2JveChpdGVtLCB2YWx1ZSwgbmV3UGF0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gc2tpcCB0aGUgb3B0aW9ucyB0aGF0IGFyZSBub3QgZW5hYmxlZFxuICAgICAgICAgICAgICBpZiAoIXRoaXMuaGlkZU9wdGlvbihwYXRoLCBzdWJPYmosIHRoaXMubW9kdWxlT3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsbHkgY29sbGFwc2Ugb3B0aW9ucyB3aXRoIGFuIGRpc2FibGVkIGVuYWJsZWQgb3B0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmVuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGVuYWJsZWRQYXRoID0gY29weUFuZEV4dGVuZEFycmF5KG5ld1BhdGgsIFwiZW5hYmxlZFwiKTtcbiAgICAgICAgICAgICAgICAgIHZhciBlbmFibGVkVmFsdWUgPSB0aGlzLl9nZXRWYWx1ZShlbmFibGVkUGF0aCk7XG4gICAgICAgICAgICAgICAgICBpZiAoZW5hYmxlZFZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChzdWJPYmosIG5ld1BhdGgsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlSXRlbShuZXdQYXRoLCBsYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgIHZpc2libGVJblNldCA9IHRoaXMuX2hhbmRsZU9iamVjdChpdGVtLCBuZXdQYXRoKSB8fCB2aXNpYmxlSW5TZXQ7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlQ2hlY2tib3goaXRlbSwgZW5hYmxlZFZhbHVlLCBuZXdQYXRoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIF9sYWJlbCA9IHRoaXMuX21ha2VMYWJlbChzdWJPYmosIG5ld1BhdGgsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbWFrZUl0ZW0obmV3UGF0aCwgX2xhYmVsKTtcbiAgICAgICAgICAgICAgICAgIHZpc2libGVJblNldCA9IHRoaXMuX2hhbmRsZU9iamVjdChpdGVtLCBuZXdQYXRoKSB8fCB2aXNpYmxlSW5TZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiZG9udCBrbm93IGhvdyB0byBoYW5kbGVcIiwgaXRlbSwgc3ViT2JqLCBuZXdQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2aXNpYmxlSW5TZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGFuZGxlIHRoZSBhcnJheSB0eXBlIG9mIG9wdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUFycmF5KGFyciwgdmFsdWUsIHBhdGgpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJyWzBdID09PSBcInN0cmluZ1wiICYmIGFyclswXSA9PT0gXCJjb2xvclwiKSB7XG4gICAgICAgIHRoaXMuX21ha2VDb2xvckZpZWxkKGFyciwgdmFsdWUsIHBhdGgpO1xuICAgICAgICBpZiAoYXJyWzFdICE9PSB2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyclswXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aGlzLl9tYWtlRHJvcGRvd24oYXJyLCB2YWx1ZSwgcGF0aCk7XG4gICAgICAgIGlmIChhcnJbMF0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJyWzBdID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRoaXMuX21ha2VSYW5nZShhcnIsIHZhbHVlLCBwYXRoKTtcbiAgICAgICAgaWYgKGFyclswXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIodmFsdWUpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjYWxsZWQgdG8gdXBkYXRlIHRoZSBuZXR3b3JrIHdpdGggdGhlIG5ldyBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKHZhbHVlLCBwYXRoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX2NvbnN0cnVjdE9wdGlvbnModmFsdWUsIHBhdGgpO1xuICAgICAgaWYgKHRoaXMucGFyZW50LmJvZHkgJiYgdGhpcy5wYXJlbnQuYm9keS5lbWl0dGVyICYmIHRoaXMucGFyZW50LmJvZHkuZW1pdHRlci5lbWl0KSB7XG4gICAgICAgIHRoaXMucGFyZW50LmJvZHkuZW1pdHRlci5lbWl0KFwiY29uZmlnQ2hhbmdlXCIsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB0aGlzLnBhcmVudC5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBib29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHBhdGhcbiAgICAgKiBAcGFyYW0ge3t9fSBvcHRpb25zT2JqXG4gICAgICogQHJldHVybnMge3t9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NvbnN0cnVjdE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbnN0cnVjdE9wdGlvbnModmFsdWUsIHBhdGgpIHtcbiAgICAgIHZhciBvcHRpb25zT2JqID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIHZhciBwb2ludGVyID0gb3B0aW9uc09iajtcblxuICAgICAgLy8gd2hlbiBkcm9wZG93biBib3hlcyBjYW4gYmUgc3RyaW5nIG9yIGJvb2xlYW4sIHdlIHR5cGVjYXN0IGl0IGludG8gY29ycmVjdCB0eXBlc1xuICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gXCJ0cnVlXCIgPyB0cnVlIDogdmFsdWU7XG4gICAgICB2YWx1ZSA9IHZhbHVlID09PSBcImZhbHNlXCIgPyBmYWxzZSA6IHZhbHVlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwYXRoW2ldICE9PSBcImdsb2JhbFwiKSB7XG4gICAgICAgICAgaWYgKHBvaW50ZXJbcGF0aFtpXV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcG9pbnRlcltwYXRoW2ldXSA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaSAhPT0gcGF0aC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBwb2ludGVyID0gcG9pbnRlcltwYXRoW2ldXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9pbnRlcltwYXRoW2ldXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnNPYmo7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfcHJpbnRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wcmludE9wdGlvbnMoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgICAgd2hpbGUgKHRoaXMub3B0aW9uc0NvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gICAgICAgIHRoaXMub3B0aW9uc0NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLm9wdGlvbnNDb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICB0aGlzLm9wdGlvbnNDb250YWluZXIuYXBwZW5kQ2hpbGQod3JhcEluVGFnKFwicHJlXCIsIFwiY29uc3Qgb3B0aW9ucyA9IFwiICsgX0pTT04kc3RyaW5naWZ5KG9wdGlvbnMsIG51bGwsIDIpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7e319IG9wdGlvbnNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoYW5nZWRPcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2NvbnN0cnVjdE9wdGlvbnModGhpcy5jaGFuZ2VkT3B0aW9uc1tpXS52YWx1ZSwgdGhpcy5jaGFuZ2VkT3B0aW9uc1tpXS5wYXRoLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29uZmlndXJhdG9yO1xufSgpO1xuXG4vKipcbiAqIFBvcHVwIGlzIGEgY2xhc3MgdG8gY3JlYXRlIGEgcG9wdXAgd2luZG93IHdpdGggc29tZSB0ZXh0XG4gKi9cbnZhciBQb3B1cCQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyICAgICAgIFRoZSBjb250YWluZXIgb2JqZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gIG92ZXJmbG93TWV0aG9kICBIb3cgdGhlIHBvcHVwIHNob3VsZCBhY3QgdG8gb3ZlcmZsb3dpbmcgKCdmbGlwJyBvciAnY2FwJylcbiAgICovXG4gIGZ1bmN0aW9uIFBvcHVwKGNvbnRhaW5lciwgb3ZlcmZsb3dNZXRob2QpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wdXApO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMub3ZlcmZsb3dNZXRob2QgPSBvdmVyZmxvd01ldGhvZCB8fCBcImNhcFwiO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLnBhZGRpbmcgPSA1O1xuICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG5cbiAgICAvLyBjcmVhdGUgdGhlIGZyYW1lXG4gICAgdGhpcy5mcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5mcmFtZS5jbGFzc05hbWUgPSBcInZpcy10b29sdGlwXCI7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggICBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBwb3B1cCB3aW5kb3dcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgICBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgcG9wdXAgd2luZG93XG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoUG9wdXAsIFt7XG4gICAga2V5OiBcInNldFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBvc2l0aW9uKHgsIHkpIHtcbiAgICAgIHRoaXMueCA9IF9wYXJzZUludCQxKHgpO1xuICAgICAgdGhpcy55ID0gX3BhcnNlSW50JDEoeSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjb250ZW50IGZvciB0aGUgcG9wdXAgd2luZG93LiBUaGlzIGNhbiBiZSBIVE1MIGNvZGUgb3IgdGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgRWxlbWVudH0gY29udGVudFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldFRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VGV4dChjb250ZW50KSB7XG4gICAgICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuZnJhbWUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIHRoaXMuZnJhbWUucmVtb3ZlQ2hpbGQodGhpcy5mcmFtZS5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3RyaW5nIGNvbnRhaW5pbmcgbGl0ZXJhbCB0ZXh0LCBlbGVtZW50IGhhcyB0byBiZSB1c2VkIGZvciBIVE1MIGR1ZSB0b1xuICAgICAgICAvLyBYU1Mgcmlza3MgYXNzb2NpYXRlZCB3aXRoIGlubmVySFRNTCAoaS5lLiBwcmV2ZW50IFhTUyBieSBhY2NpZGVudCkuXG4gICAgICAgIHRoaXMuZnJhbWUuaW5uZXJUZXh0ID0gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93IHRoZSBwb3B1cCB3aW5kb3dcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RvU2hvd10gICAgU2hvdyBvciBoaWRlIHRoZSB3aW5kb3dcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzaG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coZG9TaG93KSB7XG4gICAgICBpZiAoZG9TaG93ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZG9TaG93ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChkb1Nob3cgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZnJhbWUuY2xpZW50SGVpZ2h0O1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmZyYW1lLmNsaWVudFdpZHRoO1xuICAgICAgICB2YXIgbWF4SGVpZ2h0ID0gdGhpcy5mcmFtZS5wYXJlbnROb2RlLmNsaWVudEhlaWdodDtcbiAgICAgICAgdmFyIG1heFdpZHRoID0gdGhpcy5mcmFtZS5wYXJlbnROb2RlLmNsaWVudFdpZHRoO1xuICAgICAgICB2YXIgbGVmdCA9IDAsXG4gICAgICAgICAgdG9wID0gMDtcbiAgICAgICAgaWYgKHRoaXMub3ZlcmZsb3dNZXRob2QgPT0gXCJmbGlwXCIpIHtcbiAgICAgICAgICB2YXIgaXNMZWZ0ID0gZmFsc2UsXG4gICAgICAgICAgICBpc1RvcCA9IHRydWU7IC8vIFdoZXJlIGFyb3VuZCB0aGUgcG9zaXRpb24gaXQncyBsb2NhdGVkXG5cbiAgICAgICAgICBpZiAodGhpcy55IC0gaGVpZ2h0IDwgdGhpcy5wYWRkaW5nKSB7XG4gICAgICAgICAgICBpc1RvcCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy54ICsgd2lkdGggPiBtYXhXaWR0aCAtIHRoaXMucGFkZGluZykge1xuICAgICAgICAgICAgaXNMZWZ0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzTGVmdCkge1xuICAgICAgICAgICAgbGVmdCA9IHRoaXMueCAtIHdpZHRoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWZ0ID0gdGhpcy54O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUb3ApIHtcbiAgICAgICAgICAgIHRvcCA9IHRoaXMueSAtIGhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9wID0gdGhpcy55O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3AgPSB0aGlzLnkgLSBoZWlnaHQ7XG4gICAgICAgICAgaWYgKHRvcCArIGhlaWdodCArIHRoaXMucGFkZGluZyA+IG1heEhlaWdodCkge1xuICAgICAgICAgICAgdG9wID0gbWF4SGVpZ2h0IC0gaGVpZ2h0IC0gdGhpcy5wYWRkaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodG9wIDwgdGhpcy5wYWRkaW5nKSB7XG4gICAgICAgICAgICB0b3AgPSB0aGlzLnBhZGRpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlZnQgPSB0aGlzLng7XG4gICAgICAgICAgaWYgKGxlZnQgKyB3aWR0aCArIHRoaXMucGFkZGluZyA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICBsZWZ0ID0gbWF4V2lkdGggLSB3aWR0aCAtIHRoaXMucGFkZGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxlZnQgPCB0aGlzLnBhZGRpbmcpIHtcbiAgICAgICAgICAgIGxlZnQgPSB0aGlzLnBhZGRpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJhbWUuc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZnJhbWUuc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIjtcbiAgICAgICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhpZGUgdGhlIHBvcHVwIHdpbmRvd1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImhpZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIHRoaXMuZnJhbWUuc3R5bGUubGVmdCA9IFwiMFwiO1xuICAgICAgdGhpcy5mcmFtZS5zdHlsZS50b3AgPSBcIjBcIjtcbiAgICAgIHRoaXMuZnJhbWUuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBwb3B1cCB3aW5kb3dcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5mcmFtZSk7IC8vIFJlbW92ZSBlbGVtZW50IGZyb20gRE9NXG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBQb3B1cDtcbn0oKTtcbnZhciBlcnJvckZvdW5kID0gZmFsc2U7XG52YXIgYWxsT3B0aW9ucyQxO1xudmFyIFZBTElEQVRPUl9QUklOVF9TVFlMRSQxID0gXCJiYWNrZ3JvdW5kOiAjRkZlZWVlOyBjb2xvcjogI2RkMDAwMFwiO1xuXG4vKipcbiAqICBVc2VkIHRvIHZhbGlkYXRlIG9wdGlvbnMuXG4gKi9cbnZhciBWYWxpZGF0b3IkMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZhbGlkYXRvcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmFsaWRhdG9yKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoVmFsaWRhdG9yLCBudWxsLCBbe1xuICAgIGtleTogXCJ2YWxpZGF0ZVwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIE1haW4gZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZWZlcmVuY2VPcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHN1Yk9iamVjdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCBzdWJPYmplY3QpIHtcbiAgICAgIGVycm9yRm91bmQgPSBmYWxzZTtcbiAgICAgIGFsbE9wdGlvbnMkMSA9IHJlZmVyZW5jZU9wdGlvbnM7XG4gICAgICB2YXIgdXNlZE9wdGlvbnMgPSByZWZlcmVuY2VPcHRpb25zO1xuICAgICAgaWYgKHN1Yk9iamVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVzZWRPcHRpb25zID0gcmVmZXJlbmNlT3B0aW9uc1tzdWJPYmplY3RdO1xuICAgICAgfVxuICAgICAgVmFsaWRhdG9yLnBhcnNlKG9wdGlvbnMsIHVzZWRPcHRpb25zLCBbXSk7XG4gICAgICByZXR1cm4gZXJyb3JGb3VuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaWxsIHRyYXZlcnNlIGFuIG9iamVjdCByZWN1cnNpdmVseSBhbmQgY2hlY2sgZXZlcnkgdmFsdWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJlZmVyZW5jZU9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2Uob3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgcGF0aCkge1xuICAgICAgZm9yICh2YXIgX29wdGlvbjMgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIF9vcHRpb24zKSkge1xuICAgICAgICAgIFZhbGlkYXRvci5jaGVjayhfb3B0aW9uMywgb3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBldmVyeSB2YWx1ZS4gSWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCwgY2FsbCB0aGUgcGFyc2UgZnVuY3Rpb24gb24gdGhhdCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVmZXJlbmNlT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjaGVja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVjayhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHBhdGgpIHtcbiAgICAgIGlmIChyZWZlcmVuY2VPcHRpb25zW29wdGlvbl0gPT09IHVuZGVmaW5lZCAmJiByZWZlcmVuY2VPcHRpb25zLl9fYW55X18gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBWYWxpZGF0b3IuZ2V0U3VnZ2VzdGlvbihvcHRpb24sIHJlZmVyZW5jZU9wdGlvbnMsIHBhdGgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcmVmZXJlbmNlT3B0aW9uID0gb3B0aW9uO1xuICAgICAgdmFyIGlzX29iamVjdCA9IHRydWU7XG4gICAgICBpZiAocmVmZXJlbmNlT3B0aW9uc1tvcHRpb25dID09PSB1bmRlZmluZWQgJiYgcmVmZXJlbmNlT3B0aW9ucy5fX2FueV9fICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTk9URTogVGhpcyBvbmx5IHRyaWdnZXJzIGlmIHRoZSBfX2FueV9fIGlzIGluIHRoZSB0b3AgbGV2ZWwgb2YgdGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAgICAvLyAgICAgICBUSEFUJ1MgQSBSRUFMTFkgQkFEIFBMQUNFIFRPIEFMTE9XIElUISEhIVxuICAgICAgICAvLyBUT0RPOiBFeGFtaW5lIGlmIG5lZWRlZCwgcmVtb3ZlIGlmIHBvc3NpYmxlXG5cbiAgICAgICAgLy8gX19hbnlfXyBpcyBhIHdpbGRjYXJkLiBBbnkgdmFsdWUgaXMgYWNjZXB0ZWQgYW5kIHdpbGwgYmUgZnVydGhlciBhbmFseXNlZCBieSByZWZlcmVuY2UuXG4gICAgICAgIHJlZmVyZW5jZU9wdGlvbiA9IFwiX19hbnlfX1wiO1xuXG4gICAgICAgIC8vIGlmIHRoZSBhbnktc3ViZ3JvdXAgaXMgbm90IGEgcHJlZGVmaW5lZCBvYmplY3QgaW4gdGhlIGNvbmZpZ3VyYXRvcixcbiAgICAgICAgLy8gd2UgZG8gbm90IGxvb2sgZGVlcGVyIGludG8gdGhlIG9iamVjdC5cbiAgICAgICAgaXNfb2JqZWN0ID0gVmFsaWRhdG9yLmdldFR5cGUob3B0aW9uc1tvcHRpb25dKSA9PT0gXCJvYmplY3RcIjtcbiAgICAgIH1cbiAgICAgIHZhciByZWZPcHRpb25PYmogPSByZWZlcmVuY2VPcHRpb25zW3JlZmVyZW5jZU9wdGlvbl07XG4gICAgICBpZiAoaXNfb2JqZWN0ICYmIHJlZk9wdGlvbk9iai5fX3R5cGVfXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlZk9wdGlvbk9iaiA9IHJlZk9wdGlvbk9iai5fX3R5cGVfXztcbiAgICAgIH1cbiAgICAgIFZhbGlkYXRvci5jaGVja0ZpZWxkcyhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbiwgcmVmT3B0aW9uT2JqLCBwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgb3B0aW9uICAgICAgICAgICB8IHRoZSBvcHRpb24gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gIG9wdGlvbnMgICAgICAgICAgfCBUaGUgc3VwcGxpZWQgb3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gIHJlZmVyZW5jZU9wdGlvbnMgfCBUaGUgcmVmZXJlbmNlIG9wdGlvbnMgY29udGFpbmluZyBhbGwgb3B0aW9ucyBhbmQgdGhlaXIgYWxsb3dlZCBmb3JtYXRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICByZWZlcmVuY2VPcHRpb24gIHwgVXN1YWxseSB0aGlzIGlzIHRoZSBzYW1lIGFzIG9wdGlvbiwgZXhjZXB0IHdoZW4gaGFuZGxpbmcgYW4gX19hbnlfXyB0YWcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICByZWZPcHRpb25PYmogICAgIHwgVGhpcyBpcyB0aGUgdHlwZSBvYmplY3QgZnJvbSB0aGUgcmVmZXJlbmNlIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgIHBhdGggICAgICAgICAgICAgfCB3aGVyZSBpbiB0aGUgb2JqZWN0IGlzIHRoZSBvcHRpb25cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tGaWVsZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tGaWVsZHMob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCByZWZlcmVuY2VPcHRpb24sIHJlZk9wdGlvbk9iaiwgcGF0aCkge1xuICAgICAgdmFyIGxvZyA9IGZ1bmN0aW9uIGxvZyhtZXNzYWdlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCIlY1wiICsgbWVzc2FnZSArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKHBhdGgsIG9wdGlvbiksIFZBTElEQVRPUl9QUklOVF9TVFlMRSQxKTtcbiAgICAgIH07XG4gICAgICB2YXIgb3B0aW9uVHlwZSA9IFZhbGlkYXRvci5nZXRUeXBlKG9wdGlvbnNbb3B0aW9uXSk7XG4gICAgICB2YXIgcmVmT3B0aW9uVHlwZSA9IHJlZk9wdGlvbk9ialtvcHRpb25UeXBlXTtcbiAgICAgIGlmIChyZWZPcHRpb25UeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gaWYgdGhlIHR5cGUgaXMgY29ycmVjdCwgd2UgY2hlY2sgaWYgaXQgaXMgc3VwcG9zZWQgdG8gYmUgb25lIG9mIGEgZmV3IHNlbGVjdCB2YWx1ZXNcbiAgICAgICAgaWYgKFZhbGlkYXRvci5nZXRUeXBlKHJlZk9wdGlvblR5cGUpID09PSBcImFycmF5XCIgJiYgX2luZGV4T2ZJbnN0YW5jZVByb3BlcnR5KHJlZk9wdGlvblR5cGUpLmNhbGwocmVmT3B0aW9uVHlwZSwgb3B0aW9uc1tvcHRpb25dKSA9PT0gLTEpIHtcbiAgICAgICAgICBsb2coJ0ludmFsaWQgb3B0aW9uIGRldGVjdGVkIGluIFwiJyArIG9wdGlvbiArICdcIi4nICsgXCIgQWxsb3dlZCB2YWx1ZXMgYXJlOlwiICsgVmFsaWRhdG9yLnByaW50KHJlZk9wdGlvblR5cGUpICsgJyBub3QgXCInICsgb3B0aW9uc1tvcHRpb25dICsgJ1wiLiAnKTtcbiAgICAgICAgICBlcnJvckZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25UeXBlID09PSBcIm9iamVjdFwiICYmIHJlZmVyZW5jZU9wdGlvbiAhPT0gXCJfX2FueV9fXCIpIHtcbiAgICAgICAgICBwYXRoID0gY29weUFuZEV4dGVuZEFycmF5KHBhdGgsIG9wdGlvbik7XG4gICAgICAgICAgVmFsaWRhdG9yLnBhcnNlKG9wdGlvbnNbb3B0aW9uXSwgcmVmZXJlbmNlT3B0aW9uc1tyZWZlcmVuY2VPcHRpb25dLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZWZPcHRpb25PYmpbXCJhbnlcIl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB0eXBlIG9mIHRoZSBmaWVsZCBpcyBpbmNvcnJlY3QgYW5kIHRoZSBmaWVsZCBjYW5ub3QgYmUgYW55XG4gICAgICAgIGxvZygnSW52YWxpZCB0eXBlIHJlY2VpdmVkIGZvciBcIicgKyBvcHRpb24gKyAnXCIuIEV4cGVjdGVkOiAnICsgVmFsaWRhdG9yLnByaW50KF9PYmplY3Qka2V5cyhyZWZPcHRpb25PYmopKSArIFwiLiBSZWNlaXZlZCBbXCIgKyBvcHRpb25UeXBlICsgJ10gXCInICsgb3B0aW9uc1tvcHRpb25dICsgJ1wiJyk7XG4gICAgICAgIGVycm9yRm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3QgfCBib29sZWFuIHwgbnVtYmVyIHwgc3RyaW5nIHwgQXJyYXkuPG51bWJlcj4gfCBEYXRlIHwgTm9kZSB8IE1vbWVudCB8IHVuZGVmaW5lZCB8IG51bGx9IG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHlwZShvYmplY3QpIHtcbiAgICAgIHZhciB0eXBlID0gX3R5cGVvZihvYmplY3QpO1xuICAgICAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgICAgICAgIHJldHVybiBcImJvb2xlYW5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfQXJyYXkkaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgIHJldHVybiBcImRhdGVcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0Lm5vZGVUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gXCJkb21cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0Ll9pc0FNb21lbnRPYmplY3QgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gXCJtb21lbnRcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJvYmplY3RcIjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiYm9vbGVhblwiO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBwYXRoXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFN1Z2dlc3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3VnZ2VzdGlvbihvcHRpb24sIG9wdGlvbnMsIHBhdGgpIHtcbiAgICAgIHZhciBsb2NhbFNlYXJjaCA9IFZhbGlkYXRvci5maW5kSW5PcHRpb25zKG9wdGlvbiwgb3B0aW9ucywgcGF0aCwgZmFsc2UpO1xuICAgICAgdmFyIGdsb2JhbFNlYXJjaCA9IFZhbGlkYXRvci5maW5kSW5PcHRpb25zKG9wdGlvbiwgYWxsT3B0aW9ucyQxLCBbXSwgdHJ1ZSk7XG4gICAgICB2YXIgbG9jYWxTZWFyY2hUaHJlc2hvbGQgPSA4O1xuICAgICAgdmFyIGdsb2JhbFNlYXJjaFRocmVzaG9sZCA9IDQ7XG4gICAgICB2YXIgbXNnO1xuICAgICAgaWYgKGxvY2FsU2VhcmNoLmluZGV4TWF0Y2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtc2cgPSBcIiBpbiBcIiArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKGxvY2FsU2VhcmNoLnBhdGgsIG9wdGlvbiwgXCJcIikgKyAnUGVyaGFwcyBpdCB3YXMgaW5jb21wbGV0ZT8gRGlkIHlvdSBtZWFuOiBcIicgKyBsb2NhbFNlYXJjaC5pbmRleE1hdGNoICsgJ1wiP1xcblxcbic7XG4gICAgICB9IGVsc2UgaWYgKGdsb2JhbFNlYXJjaC5kaXN0YW5jZSA8PSBnbG9iYWxTZWFyY2hUaHJlc2hvbGQgJiYgbG9jYWxTZWFyY2guZGlzdGFuY2UgPiBnbG9iYWxTZWFyY2guZGlzdGFuY2UpIHtcbiAgICAgICAgbXNnID0gXCIgaW4gXCIgKyBWYWxpZGF0b3IucHJpbnRMb2NhdGlvbihsb2NhbFNlYXJjaC5wYXRoLCBvcHRpb24sIFwiXCIpICsgXCJQZXJoYXBzIGl0IHdhcyBtaXNwbGFjZWQ/IE1hdGNoaW5nIG9wdGlvbiBmb3VuZCBhdDogXCIgKyBWYWxpZGF0b3IucHJpbnRMb2NhdGlvbihnbG9iYWxTZWFyY2gucGF0aCwgZ2xvYmFsU2VhcmNoLmNsb3Nlc3RNYXRjaCwgXCJcIik7XG4gICAgICB9IGVsc2UgaWYgKGxvY2FsU2VhcmNoLmRpc3RhbmNlIDw9IGxvY2FsU2VhcmNoVGhyZXNob2xkKSB7XG4gICAgICAgIG1zZyA9ICcuIERpZCB5b3UgbWVhbiBcIicgKyBsb2NhbFNlYXJjaC5jbG9zZXN0TWF0Y2ggKyAnXCI/JyArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKGxvY2FsU2VhcmNoLnBhdGgsIG9wdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtc2cgPSBcIi4gRGlkIHlvdSBtZWFuIG9uZSBvZiB0aGVzZTogXCIgKyBWYWxpZGF0b3IucHJpbnQoX09iamVjdCRrZXlzKG9wdGlvbnMpKSArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKHBhdGgsIG9wdGlvbik7XG4gICAgICB9XG4gICAgICBjb25zb2xlLmVycm9yKCclY1Vua25vd24gb3B0aW9uIGRldGVjdGVkOiBcIicgKyBvcHRpb24gKyAnXCInICsgbXNnLCBWQUxJREFUT1JfUFJJTlRfU1RZTEUkMSk7XG4gICAgICBlcnJvckZvdW5kID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0cmF2ZXJzZSB0aGUgb3B0aW9ucyBpbiBzZWFyY2ggZm9yIGEgbWF0Y2guXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWN1cnNpdmU9ZmFsc2VdXG4gICAgICogQHJldHVybnMge3tjbG9zZXN0TWF0Y2g6IHN0cmluZywgcGF0aDogQXJyYXksIGRpc3RhbmNlOiBudW1iZXJ9fVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJmaW5kSW5PcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRJbk9wdGlvbnMob3B0aW9uLCBvcHRpb25zLCBwYXRoKSB7XG4gICAgICB2YXIgcmVjdXJzaXZlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgICAgIHZhciBtaW4gPSAxZTk7XG4gICAgICB2YXIgY2xvc2VzdE1hdGNoID0gXCJcIjtcbiAgICAgIHZhciBjbG9zZXN0TWF0Y2hQYXRoID0gW107XG4gICAgICB2YXIgbG93ZXJDYXNlT3B0aW9uID0gb3B0aW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgaW5kZXhNYXRjaCA9IHVuZGVmaW5lZDtcbiAgICAgIGZvciAodmFyIG9wIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gdm9pZCAwO1xuICAgICAgICBpZiAob3B0aW9uc1tvcF0uX190eXBlX18gIT09IHVuZGVmaW5lZCAmJiByZWN1cnNpdmUgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gVmFsaWRhdG9yLmZpbmRJbk9wdGlvbnMob3B0aW9uLCBvcHRpb25zW29wXSwgY29weUFuZEV4dGVuZEFycmF5KHBhdGgsIG9wKSk7XG4gICAgICAgICAgaWYgKG1pbiA+IHJlc3VsdC5kaXN0YW5jZSkge1xuICAgICAgICAgICAgY2xvc2VzdE1hdGNoID0gcmVzdWx0LmNsb3Nlc3RNYXRjaDtcbiAgICAgICAgICAgIGNsb3Nlc3RNYXRjaFBhdGggPSByZXN1bHQucGF0aDtcbiAgICAgICAgICAgIG1pbiA9IHJlc3VsdC5kaXN0YW5jZTtcbiAgICAgICAgICAgIGluZGV4TWF0Y2ggPSByZXN1bHQuaW5kZXhNYXRjaDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0MTY7XG4gICAgICAgICAgaWYgKF9pbmRleE9mSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDE2ID0gb3AudG9Mb3dlckNhc2UoKSkuY2FsbChfY29udGV4dDE2LCBsb3dlckNhc2VPcHRpb24pICE9PSAtMSkge1xuICAgICAgICAgICAgaW5kZXhNYXRjaCA9IG9wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaXN0YW5jZSA9IFZhbGlkYXRvci5sZXZlbnNodGVpbkRpc3RhbmNlKG9wdGlvbiwgb3ApO1xuICAgICAgICAgIGlmIChtaW4gPiBkaXN0YW5jZSkge1xuICAgICAgICAgICAgY2xvc2VzdE1hdGNoID0gb3A7XG4gICAgICAgICAgICBjbG9zZXN0TWF0Y2hQYXRoID0gY29weUFycmF5KHBhdGgpO1xuICAgICAgICAgICAgbWluID0gZGlzdGFuY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjbG9zZXN0TWF0Y2g6IGNsb3Nlc3RNYXRjaCxcbiAgICAgICAgcGF0aDogY2xvc2VzdE1hdGNoUGF0aCxcbiAgICAgICAgZGlzdGFuY2U6IG1pbixcbiAgICAgICAgaW5kZXhNYXRjaDogaW5kZXhNYXRjaFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBwYXRoXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwcmludExvY2F0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByaW50TG9jYXRpb24ocGF0aCwgb3B0aW9uKSB7XG4gICAgICB2YXIgcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBcIlByb2JsZW0gdmFsdWUgZm91bmQgYXQ6IFxcblwiO1xuICAgICAgdmFyIHN0ciA9IFwiXFxuXFxuXCIgKyBwcmVmaXggKyBcIm9wdGlvbnMgPSB7XFxuXCI7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpICsgMTsgaisrKSB7XG4gICAgICAgICAgc3RyICs9IFwiICBcIjtcbiAgICAgICAgfVxuICAgICAgICBzdHIgKz0gcGF0aFtpXSArIFwiOiB7XFxuXCI7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgcGF0aC5sZW5ndGggKyAxOyBfaisrKSB7XG4gICAgICAgIHN0ciArPSBcIiAgXCI7XG4gICAgICB9XG4gICAgICBzdHIgKz0gb3B0aW9uICsgXCJcXG5cIjtcbiAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IHBhdGgubGVuZ3RoICsgMTsgX2k1KyspIHtcbiAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgcGF0aC5sZW5ndGggLSBfaTU7IF9qMisrKSB7XG4gICAgICAgICAgc3RyICs9IFwiICBcIjtcbiAgICAgICAgfVxuICAgICAgICBzdHIgKz0gXCJ9XFxuXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyICsgXCJcXG5cXG5cIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInByaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByaW50KG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBfSlNPTiRzdHJpbmdpZnkob3B0aW9ucykucmVwbGFjZSgvKFwiKXwoXFxbKXwoXFxdKXwoLFwiX190eXBlX19cIikvZywgXCJcIikucmVwbGFjZSgvKCwpL2csIFwiLCBcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIGVkaXQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHN0cmluZ3NcbiAgICAgKiBodHRwOi8vZW4ud2lraWJvb2tzLm9yZy93aWtpL0FsZ29yaXRobV9JbXBsZW1lbnRhdGlvbi9TdHJpbmdzL0xldmVuc2h0ZWluX2Rpc3RhbmNlI0phdmFTY3JpcHRcbiAgICAgKlxuICAgICAqIENvcHlyaWdodCAoYykgMjAxMSBBbmRyZWkgTWFja2VuemllXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn19XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImxldmVuc2h0ZWluRGlzdGFuY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGV2ZW5zaHRlaW5EaXN0YW5jZShhLCBiKSB7XG4gICAgICBpZiAoYS5sZW5ndGggPT09IDApIHJldHVybiBiLmxlbmd0aDtcbiAgICAgIGlmIChiLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGEubGVuZ3RoO1xuICAgICAgdmFyIG1hdHJpeCA9IFtdO1xuXG4gICAgICAvLyBpbmNyZW1lbnQgYWxvbmcgdGhlIGZpcnN0IGNvbHVtbiBvZiBlYWNoIHJvd1xuICAgICAgdmFyIGk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDw9IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWF0cml4W2ldID0gW2ldO1xuICAgICAgfVxuXG4gICAgICAvLyBpbmNyZW1lbnQgZWFjaCBjb2x1bW4gaW4gdGhlIGZpcnN0IHJvd1xuICAgICAgdmFyIGo7XG4gICAgICBmb3IgKGogPSAwOyBqIDw9IGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbWF0cml4WzBdW2pdID0gajtcbiAgICAgIH1cblxuICAgICAgLy8gRmlsbCBpbiB0aGUgcmVzdCBvZiB0aGUgbWF0cml4XG4gICAgICBmb3IgKGkgPSAxOyBpIDw9IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8PSBhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKGIuY2hhckF0KGkgLSAxKSA9PSBhLmNoYXJBdChqIC0gMSkpIHtcbiAgICAgICAgICAgIG1hdHJpeFtpXVtqXSA9IG1hdHJpeFtpIC0gMV1baiAtIDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRyaXhbaV1bal0gPSBNYXRoLm1pbihtYXRyaXhbaSAtIDFdW2ogLSAxXSArIDEsXG4gICAgICAgICAgICAvLyBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgIE1hdGgubWluKG1hdHJpeFtpXVtqIC0gMV0gKyAxLFxuICAgICAgICAgICAgLy8gaW5zZXJ0aW9uXG4gICAgICAgICAgICBtYXRyaXhbaSAtIDFdW2pdICsgMSkpOyAvLyBkZWxldGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF0cml4W2IubGVuZ3RoXVthLmxlbmd0aF07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBWYWxpZGF0b3I7XG59KCk7XG52YXIgQWN0aXZhdG9yID0gQWN0aXZhdG9yJDE7XG52YXIgQ29uZmlndXJhdG9yID0gQ29uZmlndXJhdG9yJDE7XG52YXIgSGFtbWVyID0gSGFtbWVyJDE7XG52YXIgUG9wdXAgPSBQb3B1cCQxO1xudmFyIFZBTElEQVRPUl9QUklOVF9TVFlMRSA9IFZBTElEQVRPUl9QUklOVF9TVFlMRSQxO1xudmFyIFZhbGlkYXRvciA9IFZhbGlkYXRvciQxO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby12YXIgKi9cblxuLyoqXG4gKiBQYXJzZSBhIHRleHQgc291cmNlIGNvbnRhaW5pbmcgZGF0YSBpbiBET1QgbGFuZ3VhZ2UgaW50byBhIEpTT04gb2JqZWN0LlxuICogVGhlIG9iamVjdCBjb250YWlucyB0d28gbGlzdHM6IG9uZSB3aXRoIG5vZGVzIGFuZCBvbmUgd2l0aCBlZGdlcy5cbiAqXG4gKiBET1QgbGFuZ3VhZ2UgcmVmZXJlbmNlOiBodHRwOi8vd3d3LmdyYXBodml6Lm9yZy9kb2MvaW5mby9sYW5nLmh0bWxcbiAqXG4gKiBET1QgbGFuZ3VhZ2UgYXR0cmlidXRlczogaHR0cDovL2dyYXBodml6Lm9yZy9jb250ZW50L2F0dHJzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgICAgIFRleHQgY29udGFpbmluZyBhIGdyYXBoIGluIERPVC1ub3RhdGlvblxuICogQHJldHVybnMge29iamVjdH0gZ3JhcGggICBBbiBvYmplY3QgY29udGFpbmluZyB0d28gcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0W119IG5vZGVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdFtdfSBlZGdlc1xuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRPRE9cbiAqID09PT1cbiAqXG4gKiBGb3IgbGFiZWwgaGFuZGxpbmcsIHRoaXMgaXMgYW4gaW5jb21wbGV0ZSBpbXBsZW1lbnRhdGlvbi4gRnJvbSBkb2NzIChxdW90ZSAjMzAxNSk6XG4gKlxuICogPiB0aGUgZXNjYXBlIHNlcXVlbmNlcyBcIlxcblwiLCBcIlxcbFwiIGFuZCBcIlxcclwiIGRpdmlkZSB0aGUgbGFiZWwgaW50byBsaW5lcywgY2VudGVyZWQsXG4gKiA+IGxlZnQtanVzdGlmaWVkLCBhbmQgcmlnaHQtanVzdGlmaWVkLCByZXNwZWN0aXZlbHkuXG4gKlxuICogU291cmNlOiBodHRwOi8vd3d3LmdyYXBodml6Lm9yZy9jb250ZW50L2F0dHJzI2tlc2NTdHJpbmdcbiAqXG4gKiA+IEFzIGFub3RoZXIgYWlkIGZvciByZWFkYWJpbGl0eSwgZG90IGFsbG93cyBkb3VibGUtcXVvdGVkIHN0cmluZ3MgdG8gc3BhbiBtdWx0aXBsZSBwaHlzaWNhbFxuICogPiBsaW5lcyB1c2luZyB0aGUgc3RhbmRhcmQgQyBjb252ZW50aW9uIG9mIGEgYmFja3NsYXNoIGltbWVkaWF0ZWx5IHByZWNlZGluZyBhIG5ld2xpbmVcbiAqID4gY2hhcmFjdGVyXG4gKiA+IEluIGFkZGl0aW9uLCBkb3VibGUtcXVvdGVkIHN0cmluZ3MgY2FuIGJlIGNvbmNhdGVuYXRlZCB1c2luZyBhICcrJyBvcGVyYXRvci5cbiAqID4gQXMgSFRNTCBzdHJpbmdzIGNhbiBjb250YWluIG5ld2xpbmUgY2hhcmFjdGVycywgd2hpY2ggYXJlIHVzZWQgc29sZWx5IGZvciBmb3JtYXR0aW5nLFxuICogPiB0aGUgbGFuZ3VhZ2UgZG9lcyBub3QgYWxsb3cgZXNjYXBlZCBuZXdsaW5lcyBvciBjb25jYXRlbmF0aW9uIG9wZXJhdG9ycyB0byBiZSB1c2VkXG4gKiA+IHdpdGhpbiB0aGVtLlxuICpcbiAqIC0gQ3VycmVudGx5LCBvbmx5ICdcXFxcbicgaXMgaGFuZGxlZFxuICogLSBOb3RlIHRoYXQgdGV4dCBleHBsaWNpdGx5IHNheXMgJ2xhYmVscyc7IHRoZSBkb3QgcGFyc2VyIGN1cnJlbnRseSBoYW5kbGVzIGVzY2FwZVxuICogICBzZXF1ZW5jZXMgaW4gKiphbGwqKiBzdHJpbmdzLlxuICovXG5mdW5jdGlvbiBwYXJzZURPVChkYXRhKSB7XG4gIGRvdCA9IGRhdGE7XG4gIHJldHVybiBwYXJzZUdyYXBoKCk7XG59XG5cbi8vIG1hcHBpbmcgb2YgYXR0cmlidXRlcyBmcm9tIERPVCAodGhlIGtleXMpIHRvIHZpcy5qcyAodGhlIHZhbHVlcylcbnZhciBOT0RFX0FUVFJfTUFQUElORyA9IHtcbiAgZm9udHNpemU6IFwiZm9udC5zaXplXCIsXG4gIGZvbnRjb2xvcjogXCJmb250LmNvbG9yXCIsXG4gIGxhYmVsZm9udGNvbG9yOiBcImZvbnQuY29sb3JcIixcbiAgZm9udG5hbWU6IFwiZm9udC5mYWNlXCIsXG4gIGNvbG9yOiBbXCJjb2xvci5ib3JkZXJcIiwgXCJjb2xvci5iYWNrZ3JvdW5kXCJdLFxuICBmaWxsY29sb3I6IFwiY29sb3IuYmFja2dyb3VuZFwiLFxuICB0b29sdGlwOiBcInRpdGxlXCIsXG4gIGxhYmVsdG9vbHRpcDogXCJ0aXRsZVwiXG59O1xudmFyIEVER0VfQVRUUl9NQVBQSU5HID0gX09iamVjdCRjcmVhdGUkMShOT0RFX0FUVFJfTUFQUElORyk7XG5FREdFX0FUVFJfTUFQUElORy5jb2xvciA9IFwiY29sb3IuY29sb3JcIjtcbkVER0VfQVRUUl9NQVBQSU5HLnN0eWxlID0gXCJkYXNoZXNcIjtcblxuLy8gdG9rZW4gdHlwZXMgZW51bWVyYXRpb25cbnZhciBUT0tFTlRZUEUgPSB7XG4gIE5VTEw6IDAsXG4gIERFTElNSVRFUjogMSxcbiAgSURFTlRJRklFUjogMixcbiAgVU5LTk9XTjogM1xufTtcblxuLy8gbWFwIHdpdGggYWxsIGRlbGltaXRlcnNcbnZhciBERUxJTUlURVJTID0ge1xuICBcIntcIjogdHJ1ZSxcbiAgXCJ9XCI6IHRydWUsXG4gIFwiW1wiOiB0cnVlLFxuICBcIl1cIjogdHJ1ZSxcbiAgXCI7XCI6IHRydWUsXG4gIFwiPVwiOiB0cnVlLFxuICBcIixcIjogdHJ1ZSxcbiAgXCItPlwiOiB0cnVlLFxuICBcIi0tXCI6IHRydWVcbn07XG52YXIgZG90ID0gXCJcIjsgLy8gY3VycmVudCBkb3QgZmlsZVxudmFyIGluZGV4ID0gMDsgLy8gY3VycmVudCBpbmRleCBpbiBkb3QgZmlsZVxudmFyIGMgPSBcIlwiOyAvLyBjdXJyZW50IHRva2VuIGNoYXJhY3RlciBpbiBleHByXG52YXIgdG9rZW4gPSBcIlwiOyAvLyBjdXJyZW50IHRva2VuXG52YXIgdG9rZW5UeXBlID0gVE9LRU5UWVBFLk5VTEw7IC8vIHR5cGUgb2YgdGhlIHRva2VuXG5cbi8qKlxuICogR2V0IHRoZSBmaXJzdCBjaGFyYWN0ZXIgZnJvbSB0aGUgZG90IGZpbGUuXG4gKiBUaGUgY2hhcmFjdGVyIGlzIHN0b3JlZCBpbnRvIHRoZSBjaGFyIGMuIElmIHRoZSBlbmQgb2YgdGhlIGRvdCBmaWxlIGlzXG4gKiByZWFjaGVkLCB0aGUgZnVuY3Rpb24gcHV0cyBhbiBlbXB0eSBzdHJpbmcgaW4gYy5cbiAqL1xuZnVuY3Rpb24gZmlyc3QoKSB7XG4gIGluZGV4ID0gMDtcbiAgYyA9IGRvdC5jaGFyQXQoMCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IGNoYXJhY3RlciBmcm9tIHRoZSBkb3QgZmlsZS5cbiAqIFRoZSBjaGFyYWN0ZXIgaXMgc3RvcmVkIGludG8gdGhlIGNoYXIgYy4gSWYgdGhlIGVuZCBvZiB0aGUgZG90IGZpbGUgaXNcbiAqIHJlYWNoZWQsIHRoZSBmdW5jdGlvbiBwdXRzIGFuIGVtcHR5IHN0cmluZyBpbiBjLlxuICovXG5mdW5jdGlvbiBuZXh0KCkge1xuICBpbmRleCsrO1xuICBjID0gZG90LmNoYXJBdChpbmRleCk7XG59XG5cbi8qKlxuICogUHJldmlldyB0aGUgbmV4dCBjaGFyYWN0ZXIgZnJvbSB0aGUgZG90IGZpbGUuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gY05leHRcbiAqL1xuZnVuY3Rpb24gbmV4dFByZXZpZXcoKSB7XG4gIHJldHVybiBkb3QuY2hhckF0KGluZGV4ICsgMSk7XG59XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGdpdmVuIGNoYXJhY3RlciBpcyBhbHBoYWJldGljIG9yIG51bWVyaWMgKCBhLXpBLVpfMC05LjojIClcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY1xuICogQHJldHVybnMge2Jvb2xlYW59IGlzQWxwaGFOdW1lcmljXG4gKi9cbmZ1bmN0aW9uIGlzQWxwaGFOdW1lcmljKGMpIHtcbiAgdmFyIGNoYXJDb2RlID0gYy5jaGFyQ29kZUF0KDApO1xuICBpZiAoY2hhckNvZGUgPCA0Nykge1xuICAgIC8vICMuXG4gICAgcmV0dXJuIGNoYXJDb2RlID09PSAzNSB8fCBjaGFyQ29kZSA9PT0gNDY7XG4gIH1cbiAgaWYgKGNoYXJDb2RlIDwgNTkpIHtcbiAgICAvLyAwLTkgYW5kIDpcbiAgICByZXR1cm4gY2hhckNvZGUgPiA0NztcbiAgfVxuICBpZiAoY2hhckNvZGUgPCA5MSkge1xuICAgIC8vIEEtWlxuICAgIHJldHVybiBjaGFyQ29kZSA+IDY0O1xuICB9XG4gIGlmIChjaGFyQ29kZSA8IDk2KSB7XG4gICAgLy8gX1xuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gOTU7XG4gIH1cbiAgaWYgKGNoYXJDb2RlIDwgMTIzKSB7XG4gICAgLy8gYS16XG4gICAgcmV0dXJuIGNoYXJDb2RlID4gOTY7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIE1lcmdlIGFsbCBvcHRpb25zIG9mIG9iamVjdCBiIGludG8gb2JqZWN0IGJcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYVxuICogQHBhcmFtIHtvYmplY3R9IGJcbiAqIEByZXR1cm5zIHtvYmplY3R9IGFcbiAqL1xuZnVuY3Rpb24gbWVyZ2UkMShhLCBiKSB7XG4gIGlmICghYSkge1xuICAgIGEgPSB7fTtcbiAgfVxuICBpZiAoYikge1xuICAgIGZvciAodmFyIG5hbWUgaW4gYikge1xuICAgICAgaWYgKGIuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgYVtuYW1lXSA9IGJbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIFNldCBhIHZhbHVlIGluIGFuIG9iamVjdCwgd2hlcmUgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBuYW1lIGNhbiBiZSBhXG4gKiBwYXRoIHdpdGggbmVzdGVkIHBhcmFtZXRlcnMuIEZvciBleGFtcGxlOlxuICpcbiAqICAgICB2YXIgb2JqID0ge2E6IDJ9O1xuICogICAgIHNldFZhbHVlKG9iaiwgJ2IuYycsIDMpOyAgICAgLy8gb2JqID0ge2E6IDIsIGI6IHtjOiAzfX1cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAgQSBwYXJhbWV0ZXIgbmFtZSBvciBkb3Qtc2VwYXJhdGVkIHBhcmFtZXRlciBwYXRoLFxuICogICAgICAgICAgICAgICAgICAgICAgbGlrZSBcImNvbG9yLmhpZ2hsaWdodC5ib3JkZXJcIi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gc2V0VmFsdWUob2JqLCBwYXRoLCB2YWx1ZSkge1xuICB2YXIga2V5cyA9IHBhdGguc3BsaXQoXCIuXCIpO1xuICB2YXIgbyA9IG9iajtcbiAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IGtleXMuc2hpZnQoKTtcbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIC8vIHRoaXMgaXNuJ3QgdGhlIGVuZCBwb2ludFxuICAgICAgaWYgKCFvW2tleV0pIHtcbiAgICAgICAgb1trZXldID0ge307XG4gICAgICB9XG4gICAgICBvID0gb1trZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGlzIGlzIHRoZSBlbmQgcG9pbnRcbiAgICAgIG9ba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFkZCBhIG5vZGUgdG8gYSBncmFwaCBvYmplY3QuIElmIHRoZXJlIGlzIGFscmVhZHkgYSBub2RlIHdpdGhcbiAqIHRoZSBzYW1lIGlkLCB0aGVpciBhdHRyaWJ1dGVzIHdpbGwgYmUgbWVyZ2VkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBncmFwaFxuICogQHBhcmFtIHtvYmplY3R9IG5vZGVcbiAqL1xuZnVuY3Rpb24gYWRkTm9kZShncmFwaCwgbm9kZSkge1xuICB2YXIgaSwgbGVuO1xuICB2YXIgY3VycmVudCA9IG51bGw7XG5cbiAgLy8gZmluZCByb290IGdyYXBoIChpbiBjYXNlIG9mIHN1YmdyYXBoKVxuICB2YXIgZ3JhcGhzID0gW2dyYXBoXTsgLy8gbGlzdCB3aXRoIGFsbCBncmFwaHMgZnJvbSBjdXJyZW50IGdyYXBoIHRvIHJvb3QgZ3JhcGhcbiAgdmFyIHJvb3QgPSBncmFwaDtcbiAgd2hpbGUgKHJvb3QucGFyZW50KSB7XG4gICAgZ3JhcGhzLnB1c2gocm9vdC5wYXJlbnQpO1xuICAgIHJvb3QgPSByb290LnBhcmVudDtcbiAgfVxuXG4gIC8vIGZpbmQgZXhpc3Rpbmcgbm9kZSAoYXQgcm9vdCBsZXZlbCkgYnkgaXRzIGlkXG4gIGlmIChyb290Lm5vZGVzKSB7XG4gICAgZm9yIChpID0gMCwgbGVuID0gcm9vdC5ub2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKG5vZGUuaWQgPT09IHJvb3Qubm9kZXNbaV0uaWQpIHtcbiAgICAgICAgY3VycmVudCA9IHJvb3Qubm9kZXNbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWN1cnJlbnQpIHtcbiAgICAvLyB0aGlzIGlzIGEgbmV3IG5vZGVcbiAgICBjdXJyZW50ID0ge1xuICAgICAgaWQ6IG5vZGUuaWRcbiAgICB9O1xuICAgIGlmIChncmFwaC5ub2RlKSB7XG4gICAgICAvLyBjbG9uZSBkZWZhdWx0IGF0dHJpYnV0ZXNcbiAgICAgIGN1cnJlbnQuYXR0ciA9IG1lcmdlJDEoY3VycmVudC5hdHRyLCBncmFwaC5ub2RlKTtcbiAgICB9XG4gIH1cblxuICAvLyBhZGQgbm9kZSB0byB0aGlzIChzdWIpZ3JhcGggYW5kIGFsbCBpdHMgcGFyZW50IGdyYXBoc1xuICBmb3IgKGkgPSBncmFwaHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgX2NvbnRleHQ7XG4gICAgdmFyIGcgPSBncmFwaHNbaV07XG4gICAgaWYgKCFnLm5vZGVzKSB7XG4gICAgICBnLm5vZGVzID0gW107XG4gICAgfVxuICAgIGlmIChfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQgPSBnLm5vZGVzKS5jYWxsKF9jb250ZXh0LCBjdXJyZW50KSA9PT0gLTEpIHtcbiAgICAgIGcubm9kZXMucHVzaChjdXJyZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBtZXJnZSBhdHRyaWJ1dGVzXG4gIGlmIChub2RlLmF0dHIpIHtcbiAgICBjdXJyZW50LmF0dHIgPSBtZXJnZSQxKGN1cnJlbnQuYXR0ciwgbm9kZS5hdHRyKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZCBhbiBlZGdlIHRvIGEgZ3JhcGggb2JqZWN0XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdyYXBoXG4gKiBAcGFyYW0ge29iamVjdH0gZWRnZVxuICovXG5mdW5jdGlvbiBhZGRFZGdlKGdyYXBoLCBlZGdlKSB7XG4gIGlmICghZ3JhcGguZWRnZXMpIHtcbiAgICBncmFwaC5lZGdlcyA9IFtdO1xuICB9XG4gIGdyYXBoLmVkZ2VzLnB1c2goZWRnZSk7XG4gIGlmIChncmFwaC5lZGdlKSB7XG4gICAgdmFyIGF0dHIgPSBtZXJnZSQxKHt9LCBncmFwaC5lZGdlKTsgLy8gY2xvbmUgZGVmYXVsdCBhdHRyaWJ1dGVzXG4gICAgZWRnZS5hdHRyID0gbWVyZ2UkMShhdHRyLCBlZGdlLmF0dHIpOyAvLyBtZXJnZSBhdHRyaWJ1dGVzXG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gZWRnZSB0byBhIGdyYXBoIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBncmFwaFxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXIgfCBvYmplY3R9IGZyb21cbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyIHwgb2JqZWN0fSB0b1xuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0IHwgbnVsbH0gYXR0clxuICogQHJldHVybnMge29iamVjdH0gZWRnZVxuICovXG5mdW5jdGlvbiBjcmVhdGVFZGdlKGdyYXBoLCBmcm9tLCB0bywgdHlwZSwgYXR0cikge1xuICB2YXIgZWRnZSA9IHtcbiAgICBmcm9tOiBmcm9tLFxuICAgIHRvOiB0byxcbiAgICB0eXBlOiB0eXBlXG4gIH07XG4gIGlmIChncmFwaC5lZGdlKSB7XG4gICAgZWRnZS5hdHRyID0gbWVyZ2UkMSh7fSwgZ3JhcGguZWRnZSk7IC8vIGNsb25lIGRlZmF1bHQgYXR0cmlidXRlc1xuICB9XG5cbiAgZWRnZS5hdHRyID0gbWVyZ2UkMShlZGdlLmF0dHIgfHwge30sIGF0dHIpOyAvLyBtZXJnZSBhdHRyaWJ1dGVzXG5cbiAgLy8gTW92ZSBhcnJvd3MgYXR0cmlidXRlIGZyb20gYXR0ciB0byBlZGdlIHRlbXBvcmFsbHkgY3JlYXRlZCBpblxuICAvLyBwYXJzZUF0dHJpYnV0ZUxpc3QoKS5cbiAgaWYgKGF0dHIgIT0gbnVsbCkge1xuICAgIGlmIChhdHRyLmhhc093blByb3BlcnR5KFwiYXJyb3dzXCIpICYmIGF0dHJbXCJhcnJvd3NcIl0gIT0gbnVsbCkge1xuICAgICAgZWRnZVtcImFycm93c1wiXSA9IHtcbiAgICAgICAgdG86IHtcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgIHR5cGU6IGF0dHIuYXJyb3dzLnR5cGVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGF0dHJbXCJhcnJvd3NcIl0gPSBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWRnZTtcbn1cblxuLyoqXG4gKiBHZXQgbmV4dCB0b2tlbiBpbiB0aGUgY3VycmVudCBkb3QgZmlsZS5cbiAqIFRoZSB0b2tlbiBhbmQgdG9rZW4gdHlwZSBhcmUgYXZhaWxhYmxlIGFzIHRva2VuIGFuZCB0b2tlblR5cGVcbiAqL1xuZnVuY3Rpb24gZ2V0VG9rZW4oKSB7XG4gIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5OVUxMO1xuICB0b2tlbiA9IFwiXCI7XG5cbiAgLy8gc2tpcCBvdmVyIHdoaXRlc3BhY2VzXG4gIHdoaWxlIChjID09PSBcIiBcIiB8fCBjID09PSBcIlxcdFwiIHx8IGMgPT09IFwiXFxuXCIgfHwgYyA9PT0gXCJcXHJcIikge1xuICAgIC8vIHNwYWNlLCB0YWIsIGVudGVyXG4gICAgbmV4dCgpO1xuICB9XG4gIGRvIHtcbiAgICB2YXIgaXNDb21tZW50ID0gZmFsc2U7XG5cbiAgICAvLyBza2lwIGNvbW1lbnRcbiAgICBpZiAoYyA9PT0gXCIjXCIpIHtcbiAgICAgIC8vIGZpbmQgdGhlIHByZXZpb3VzIG5vbi1zcGFjZSBjaGFyYWN0ZXJcbiAgICAgIHZhciBpID0gaW5kZXggLSAxO1xuICAgICAgd2hpbGUgKGRvdC5jaGFyQXQoaSkgPT09IFwiIFwiIHx8IGRvdC5jaGFyQXQoaSkgPT09IFwiXFx0XCIpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgaWYgKGRvdC5jaGFyQXQoaSkgPT09IFwiXFxuXCIgfHwgZG90LmNoYXJBdChpKSA9PT0gXCJcIikge1xuICAgICAgICAvLyB0aGUgIyBpcyBhdCB0aGUgc3RhcnQgb2YgYSBsaW5lLCB0aGlzIGlzIGluZGVlZCBhIGxpbmUgY29tbWVudFxuICAgICAgICB3aGlsZSAoYyAhPSBcIlwiICYmIGMgIT0gXCJcXG5cIikge1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpc0NvbW1lbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYyA9PT0gXCIvXCIgJiYgbmV4dFByZXZpZXcoKSA9PT0gXCIvXCIpIHtcbiAgICAgIC8vIHNraXAgbGluZSBjb21tZW50XG4gICAgICB3aGlsZSAoYyAhPSBcIlwiICYmIGMgIT0gXCJcXG5cIikge1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG4gICAgICBpc0NvbW1lbnQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoYyA9PT0gXCIvXCIgJiYgbmV4dFByZXZpZXcoKSA9PT0gXCIqXCIpIHtcbiAgICAgIC8vIHNraXAgYmxvY2sgY29tbWVudFxuICAgICAgd2hpbGUgKGMgIT0gXCJcIikge1xuICAgICAgICBpZiAoYyA9PT0gXCIqXCIgJiYgbmV4dFByZXZpZXcoKSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAvLyBlbmQgb2YgYmxvY2sgY29tbWVudCBmb3VuZC4gc2tpcCB0aGVzZSBsYXN0IHR3byBjaGFyYWN0ZXJzXG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlzQ29tbWVudCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gc2tpcCBvdmVyIHdoaXRlc3BhY2VzXG4gICAgd2hpbGUgKGMgPT09IFwiIFwiIHx8IGMgPT09IFwiXFx0XCIgfHwgYyA9PT0gXCJcXG5cIiB8fCBjID09PSBcIlxcclwiKSB7XG4gICAgICAvLyBzcGFjZSwgdGFiLCBlbnRlclxuICAgICAgbmV4dCgpO1xuICAgIH1cbiAgfSB3aGlsZSAoaXNDb21tZW50KTtcblxuICAvLyBjaGVjayBmb3IgZW5kIG9mIGRvdCBmaWxlXG4gIGlmIChjID09PSBcIlwiKSB7XG4gICAgLy8gdG9rZW4gaXMgc3RpbGwgZW1wdHlcbiAgICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuREVMSU1JVEVSO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBkZWxpbWl0ZXJzIGNvbnNpc3Rpbmcgb2YgMiBjaGFyYWN0ZXJzXG4gIHZhciBjMiA9IGMgKyBuZXh0UHJldmlldygpO1xuICBpZiAoREVMSU1JVEVSU1tjMl0pIHtcbiAgICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuREVMSU1JVEVSO1xuICAgIHRva2VuID0gYzI7XG4gICAgbmV4dCgpO1xuICAgIG5leHQoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBjaGVjayBmb3IgZGVsaW1pdGVycyBjb25zaXN0aW5nIG9mIDEgY2hhcmFjdGVyXG4gIGlmIChERUxJTUlURVJTW2NdKSB7XG4gICAgdG9rZW5UeXBlID0gVE9LRU5UWVBFLkRFTElNSVRFUjtcbiAgICB0b2tlbiA9IGM7XG4gICAgbmV4dCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBhbiBpZGVudGlmaWVyIChudW1iZXIgb3Igc3RyaW5nKVxuICAvLyBUT0RPOiBtb3JlIHByZWNpc2UgcGFyc2luZyBvZiBudW1iZXJzL3N0cmluZ3MgKGFuZCB0aGUgcG9ydCBzZXBhcmF0b3IgJzonKVxuICBpZiAoaXNBbHBoYU51bWVyaWMoYykgfHwgYyA9PT0gXCItXCIpIHtcbiAgICB0b2tlbiArPSBjO1xuICAgIG5leHQoKTtcbiAgICB3aGlsZSAoaXNBbHBoYU51bWVyaWMoYykpIHtcbiAgICAgIHRva2VuICs9IGM7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuICAgIGlmICh0b2tlbiA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICB0b2tlbiA9IGZhbHNlOyAvLyBjb252ZXJ0IHRvIGJvb2xlYW5cbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSBcInRydWVcIikge1xuICAgICAgdG9rZW4gPSB0cnVlOyAvLyBjb252ZXJ0IHRvIGJvb2xlYW5cbiAgICB9IGVsc2UgaWYgKCFpc05hTihOdW1iZXIodG9rZW4pKSkge1xuICAgICAgdG9rZW4gPSBOdW1iZXIodG9rZW4pOyAvLyBjb252ZXJ0IHRvIG51bWJlclxuICAgIH1cblxuICAgIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5JREVOVElGSUVSO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBhIHN0cmluZyBlbmNsb3NlZCBieSBkb3VibGUgcXVvdGVzXG4gIGlmIChjID09PSAnXCInKSB7XG4gICAgbmV4dCgpO1xuICAgIHdoaWxlIChjICE9IFwiXCIgJiYgKGMgIT0gJ1wiJyB8fCBjID09PSAnXCInICYmIG5leHRQcmV2aWV3KCkgPT09ICdcIicpKSB7XG4gICAgICBpZiAoYyA9PT0gJ1wiJykge1xuICAgICAgICAvLyBza2lwIHRoZSBlc2NhcGUgY2hhcmFjdGVyXG4gICAgICAgIHRva2VuICs9IGM7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gXCJcXFxcXCIgJiYgbmV4dFByZXZpZXcoKSA9PT0gXCJuXCIpIHtcbiAgICAgICAgLy8gSG9ub3IgYSBuZXdsaW5lIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICB0b2tlbiArPSBcIlxcblwiO1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b2tlbiArPSBjO1xuICAgICAgfVxuICAgICAgbmV4dCgpO1xuICAgIH1cbiAgICBpZiAoYyAhPSAnXCInKSB7XG4gICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignRW5kIG9mIHN0cmluZyBcIiBleHBlY3RlZCcpO1xuICAgIH1cbiAgICBuZXh0KCk7XG4gICAgdG9rZW5UeXBlID0gVE9LRU5UWVBFLklERU5USUZJRVI7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc29tZXRoaW5nIHVua25vd24gaXMgZm91bmQsIHdyb25nIGNoYXJhY3RlcnMsIGEgc3ludGF4IGVycm9yXG4gIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5VTktOT1dOO1xuICB3aGlsZSAoYyAhPSBcIlwiKSB7XG4gICAgdG9rZW4gKz0gYztcbiAgICBuZXh0KCk7XG4gIH1cbiAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdTeW50YXggZXJyb3IgaW4gcGFydCBcIicgKyBjaG9wKHRva2VuLCAzMCkgKyAnXCInKTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIGdyYXBoLlxuICpcbiAqIEByZXR1cm5zIHtvYmplY3R9IGdyYXBoXG4gKi9cbmZ1bmN0aW9uIHBhcnNlR3JhcGgoKSB7XG4gIHZhciBncmFwaCA9IHt9O1xuICBmaXJzdCgpO1xuICBnZXRUb2tlbigpO1xuXG4gIC8vIG9wdGlvbmFsIHN0cmljdCBrZXl3b3JkXG4gIGlmICh0b2tlbiA9PT0gXCJzdHJpY3RcIikge1xuICAgIGdyYXBoLnN0cmljdCA9IHRydWU7XG4gICAgZ2V0VG9rZW4oKTtcbiAgfVxuXG4gIC8vIGdyYXBoIG9yIGRpZ3JhcGgga2V5d29yZFxuICBpZiAodG9rZW4gPT09IFwiZ3JhcGhcIiB8fCB0b2tlbiA9PT0gXCJkaWdyYXBoXCIpIHtcbiAgICBncmFwaC50eXBlID0gdG9rZW47XG4gICAgZ2V0VG9rZW4oKTtcbiAgfVxuXG4gIC8vIG9wdGlvbmFsIGdyYXBoIGlkXG4gIGlmICh0b2tlblR5cGUgPT09IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgZ3JhcGguaWQgPSB0b2tlbjtcbiAgICBnZXRUb2tlbigpO1xuICB9XG5cbiAgLy8gb3BlbiBhbmdsZSBicmFja2V0XG4gIGlmICh0b2tlbiAhPSBcIntcIikge1xuICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiQW5nbGUgYnJhY2tldCB7IGV4cGVjdGVkXCIpO1xuICB9XG4gIGdldFRva2VuKCk7XG5cbiAgLy8gc3RhdGVtZW50c1xuICBwYXJzZVN0YXRlbWVudHMoZ3JhcGgpO1xuXG4gIC8vIGNsb3NlIGFuZ2xlIGJyYWNrZXRcbiAgaWYgKHRva2VuICE9IFwifVwiKSB7XG4gICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoXCJBbmdsZSBicmFja2V0IH0gZXhwZWN0ZWRcIik7XG4gIH1cbiAgZ2V0VG9rZW4oKTtcblxuICAvLyBlbmQgb2YgZmlsZVxuICBpZiAodG9rZW4gIT09IFwiXCIpIHtcbiAgICB0aHJvdyBuZXdTeW50YXhFcnJvcihcIkVuZCBvZiBmaWxlIGV4cGVjdGVkXCIpO1xuICB9XG4gIGdldFRva2VuKCk7XG5cbiAgLy8gcmVtb3ZlIHRlbXBvcmFyeSBkZWZhdWx0IG9wdGlvbnNcbiAgZGVsZXRlIGdyYXBoLm5vZGU7XG4gIGRlbGV0ZSBncmFwaC5lZGdlO1xuICBkZWxldGUgZ3JhcGguZ3JhcGg7XG4gIHJldHVybiBncmFwaDtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIGxpc3Qgd2l0aCBzdGF0ZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBncmFwaFxuICovXG5mdW5jdGlvbiBwYXJzZVN0YXRlbWVudHMoZ3JhcGgpIHtcbiAgd2hpbGUgKHRva2VuICE9PSBcIlwiICYmIHRva2VuICE9IFwifVwiKSB7XG4gICAgcGFyc2VTdGF0ZW1lbnQoZ3JhcGgpO1xuICAgIGlmICh0b2tlbiA9PT0gXCI7XCIpIHtcbiAgICAgIGdldFRva2VuKCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYSBzaW5nbGUgc3RhdGVtZW50LiBDYW4gYmUgYSBhbiBhdHRyaWJ1dGUgc3RhdGVtZW50LCBub2RlXG4gKiBzdGF0ZW1lbnQsIGEgc2VyaWVzIG9mIG5vZGUgc3RhdGVtZW50cyBhbmQgZWRnZSBzdGF0ZW1lbnRzLCBvciBhXG4gKiBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdyYXBoXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50KGdyYXBoKSB7XG4gIC8vIHBhcnNlIHN1YmdyYXBoXG4gIHZhciBzdWJncmFwaCA9IHBhcnNlU3ViZ3JhcGgoZ3JhcGgpO1xuICBpZiAoc3ViZ3JhcGgpIHtcbiAgICAvLyBlZGdlIHN0YXRlbWVudHNcbiAgICBwYXJzZUVkZ2UoZ3JhcGgsIHN1YmdyYXBoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBwYXJzZSBhbiBhdHRyaWJ1dGUgc3RhdGVtZW50XG4gIHZhciBhdHRyID0gcGFyc2VBdHRyaWJ1dGVTdGF0ZW1lbnQoZ3JhcGgpO1xuICBpZiAoYXR0cikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHBhcnNlIG5vZGVcbiAgaWYgKHRva2VuVHlwZSAhPSBUT0tFTlRZUEUuSURFTlRJRklFUikge1xuICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiSWRlbnRpZmllciBleHBlY3RlZFwiKTtcbiAgfVxuICB2YXIgaWQgPSB0b2tlbjsgLy8gaWQgY2FuIGJlIGEgc3RyaW5nIG9yIGEgbnVtYmVyXG4gIGdldFRva2VuKCk7XG4gIGlmICh0b2tlbiA9PT0gXCI9XCIpIHtcbiAgICAvLyBpZCBzdGF0ZW1lbnRcbiAgICBnZXRUb2tlbigpO1xuICAgIGlmICh0b2tlblR5cGUgIT0gVE9LRU5UWVBFLklERU5USUZJRVIpIHtcbiAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiSWRlbnRpZmllciBleHBlY3RlZFwiKTtcbiAgICB9XG4gICAgZ3JhcGhbaWRdID0gdG9rZW47XG4gICAgZ2V0VG9rZW4oKTtcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgY29tbWEgc2VwYXJhdGVkIGxpc3Qgd2l0aCBcImFfbGlzdDogSUQ9SUQgWycsJ10gW2FfbGlzdF0gXCJcbiAgfSBlbHNlIHtcbiAgICBwYXJzZU5vZGVTdGF0ZW1lbnQoZ3JhcGgsIGlkKTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgc3ViZ3JhcGhcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZ3JhcGggICAgcGFyZW50IGdyYXBoIG9iamVjdFxuICogQHJldHVybnMge29iamVjdCB8IG51bGx9IHN1YmdyYXBoXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU3ViZ3JhcGgoZ3JhcGgpIHtcbiAgdmFyIHN1YmdyYXBoID0gbnVsbDtcblxuICAvLyBvcHRpb25hbCBzdWJncmFwaCBrZXl3b3JkXG4gIGlmICh0b2tlbiA9PT0gXCJzdWJncmFwaFwiKSB7XG4gICAgc3ViZ3JhcGggPSB7fTtcbiAgICBzdWJncmFwaC50eXBlID0gXCJzdWJncmFwaFwiO1xuICAgIGdldFRva2VuKCk7XG5cbiAgICAvLyBvcHRpb25hbCBncmFwaCBpZFxuICAgIGlmICh0b2tlblR5cGUgPT09IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgICBzdWJncmFwaC5pZCA9IHRva2VuO1xuICAgICAgZ2V0VG9rZW4oKTtcbiAgICB9XG4gIH1cblxuICAvLyBvcGVuIGFuZ2xlIGJyYWNrZXRcbiAgaWYgKHRva2VuID09PSBcIntcIikge1xuICAgIGdldFRva2VuKCk7XG4gICAgaWYgKCFzdWJncmFwaCkge1xuICAgICAgc3ViZ3JhcGggPSB7fTtcbiAgICB9XG4gICAgc3ViZ3JhcGgucGFyZW50ID0gZ3JhcGg7XG4gICAgc3ViZ3JhcGgubm9kZSA9IGdyYXBoLm5vZGU7XG4gICAgc3ViZ3JhcGguZWRnZSA9IGdyYXBoLmVkZ2U7XG4gICAgc3ViZ3JhcGguZ3JhcGggPSBncmFwaC5ncmFwaDtcblxuICAgIC8vIHN0YXRlbWVudHNcbiAgICBwYXJzZVN0YXRlbWVudHMoc3ViZ3JhcGgpO1xuXG4gICAgLy8gY2xvc2UgYW5nbGUgYnJhY2tldFxuICAgIGlmICh0b2tlbiAhPSBcIn1cIikge1xuICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoXCJBbmdsZSBicmFja2V0IH0gZXhwZWN0ZWRcIik7XG4gICAgfVxuICAgIGdldFRva2VuKCk7XG5cbiAgICAvLyByZW1vdmUgdGVtcG9yYXJ5IGRlZmF1bHQgb3B0aW9uc1xuICAgIGRlbGV0ZSBzdWJncmFwaC5ub2RlO1xuICAgIGRlbGV0ZSBzdWJncmFwaC5lZGdlO1xuICAgIGRlbGV0ZSBzdWJncmFwaC5ncmFwaDtcbiAgICBkZWxldGUgc3ViZ3JhcGgucGFyZW50O1xuXG4gICAgLy8gcmVnaXN0ZXIgYXQgdGhlIHBhcmVudCBncmFwaFxuICAgIGlmICghZ3JhcGguc3ViZ3JhcGhzKSB7XG4gICAgICBncmFwaC5zdWJncmFwaHMgPSBbXTtcbiAgICB9XG4gICAgZ3JhcGguc3ViZ3JhcGhzLnB1c2goc3ViZ3JhcGgpO1xuICB9XG4gIHJldHVybiBzdWJncmFwaDtcbn1cblxuLyoqXG4gKiBwYXJzZSBhbiBhdHRyaWJ1dGUgc3RhdGVtZW50IGxpa2UgXCJub2RlIFtzaGFwZT1jaXJjbGUgZm9udFNpemU9MTZdXCIuXG4gKiBBdmFpbGFibGUga2V5d29yZHMgYXJlICdub2RlJywgJ2VkZ2UnLCAnZ3JhcGgnLlxuICogVGhlIHByZXZpb3VzIGxpc3Qgd2l0aCBkZWZhdWx0IGF0dHJpYnV0ZXMgd2lsbCBiZSByZXBsYWNlZFxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBncmFwaFxuICogQHJldHVybnMge3N0cmluZyB8IG51bGx9IGtleXdvcmQgUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgcGFyc2VkIGF0dHJpYnV0ZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGUsIGVkZ2UsIGdyYXBoKSwgb3IgbnVsbCBpZiBub3RoaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBwYXJzZWQuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlU3RhdGVtZW50KGdyYXBoKSB7XG4gIC8vIGF0dHJpYnV0ZSBzdGF0ZW1lbnRzXG4gIGlmICh0b2tlbiA9PT0gXCJub2RlXCIpIHtcbiAgICBnZXRUb2tlbigpO1xuXG4gICAgLy8gbm9kZSBhdHRyaWJ1dGVzXG4gICAgZ3JhcGgubm9kZSA9IHBhcnNlQXR0cmlidXRlTGlzdCgpO1xuICAgIHJldHVybiBcIm5vZGVcIjtcbiAgfSBlbHNlIGlmICh0b2tlbiA9PT0gXCJlZGdlXCIpIHtcbiAgICBnZXRUb2tlbigpO1xuXG4gICAgLy8gZWRnZSBhdHRyaWJ1dGVzXG4gICAgZ3JhcGguZWRnZSA9IHBhcnNlQXR0cmlidXRlTGlzdCgpO1xuICAgIHJldHVybiBcImVkZ2VcIjtcbiAgfSBlbHNlIGlmICh0b2tlbiA9PT0gXCJncmFwaFwiKSB7XG4gICAgZ2V0VG9rZW4oKTtcblxuICAgIC8vIGdyYXBoIGF0dHJpYnV0ZXNcbiAgICBncmFwaC5ncmFwaCA9IHBhcnNlQXR0cmlidXRlTGlzdCgpO1xuICAgIHJldHVybiBcImdyYXBoXCI7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogcGFyc2UgYSBub2RlIHN0YXRlbWVudFxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBncmFwaFxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IGlkXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTm9kZVN0YXRlbWVudChncmFwaCwgaWQpIHtcbiAgLy8gbm9kZSBzdGF0ZW1lbnRcbiAgdmFyIG5vZGUgPSB7XG4gICAgaWQ6IGlkXG4gIH07XG4gIHZhciBhdHRyID0gcGFyc2VBdHRyaWJ1dGVMaXN0KCk7XG4gIGlmIChhdHRyKSB7XG4gICAgbm9kZS5hdHRyID0gYXR0cjtcbiAgfVxuICBhZGROb2RlKGdyYXBoLCBub2RlKTtcblxuICAvLyBlZGdlIHN0YXRlbWVudHNcbiAgcGFyc2VFZGdlKGdyYXBoLCBpZCk7XG59XG5cbi8qKlxuICogUGFyc2UgYW4gZWRnZSBvciBhIHNlcmllcyBvZiBlZGdlc1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBncmFwaFxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IGZyb20gICAgICAgIElkIG9mIHRoZSBmcm9tIG5vZGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VFZGdlKGdyYXBoLCBmcm9tKSB7XG4gIHdoaWxlICh0b2tlbiA9PT0gXCItPlwiIHx8IHRva2VuID09PSBcIi0tXCIpIHtcbiAgICB2YXIgdG87XG4gICAgdmFyIHR5cGUgPSB0b2tlbjtcbiAgICBnZXRUb2tlbigpO1xuICAgIHZhciBzdWJncmFwaCA9IHBhcnNlU3ViZ3JhcGgoZ3JhcGgpO1xuICAgIGlmIChzdWJncmFwaCkge1xuICAgICAgdG8gPSBzdWJncmFwaDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRva2VuVHlwZSAhPSBUT0tFTlRZUEUuSURFTlRJRklFUikge1xuICAgICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcihcIklkZW50aWZpZXIgb3Igc3ViZ3JhcGggZXhwZWN0ZWRcIik7XG4gICAgICB9XG4gICAgICB0byA9IHRva2VuO1xuICAgICAgYWRkTm9kZShncmFwaCwge1xuICAgICAgICBpZDogdG9cbiAgICAgIH0pO1xuICAgICAgZ2V0VG9rZW4oKTtcbiAgICB9XG5cbiAgICAvLyBwYXJzZSBlZGdlIGF0dHJpYnV0ZXNcbiAgICB2YXIgYXR0ciA9IHBhcnNlQXR0cmlidXRlTGlzdCgpO1xuXG4gICAgLy8gY3JlYXRlIGVkZ2VcbiAgICB2YXIgZWRnZSA9IGNyZWF0ZUVkZ2UoZ3JhcGgsIGZyb20sIHRvLCB0eXBlLCBhdHRyKTtcbiAgICBhZGRFZGdlKGdyYXBoLCBlZGdlKTtcbiAgICBmcm9tID0gdG87XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIHNldCB3aXRoIGF0dHJpYnV0ZXMsXG4gKiBmb3IgZXhhbXBsZSBbbGFiZWw9XCIxLjAwMFwiLCBzaGFwZT1zb2xpZF1cbiAqXG4gKiBAcmV0dXJucyB7b2JqZWN0IHwgbnVsbH0gYXR0clxuICovXG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZUxpc3QoKSB7XG4gIHZhciBpO1xuICB2YXIgYXR0ciA9IG51bGw7XG5cbiAgLy8gZWRnZSBzdHlsZXMgb2YgZG90IGFuZCB2aXNcbiAgdmFyIGVkZ2VTdHlsZXMgPSB7XG4gICAgZGFzaGVkOiB0cnVlLFxuICAgIHNvbGlkOiBmYWxzZSxcbiAgICBkb3R0ZWQ6IFsxLCA1XVxuICB9O1xuXG4gIC8qKlxuICAgKiBEZWZpbmUgYXJyb3cgdHlwZXMuXG4gICAqIHZpcyBjdXJyZW50bHkgc3VwcG9ydHMgdHlwZXMgZGVmaW5lZCBpbiAnYXJyb3dUeXBlcycuXG4gICAqIERldGFpbHMgb2YgYXJyb3cgc2hhcGVzIGFyZSBkZXNjcmliZWQgaW5cbiAgICogaHR0cDovL3d3dy5ncmFwaHZpei5vcmcvY29udGVudC9hcnJvdy1zaGFwZXNcbiAgICovXG4gIHZhciBhcnJvd1R5cGVzID0ge1xuICAgIGRvdDogXCJjaXJjbGVcIixcbiAgICBib3g6IFwiYm94XCIsXG4gICAgY3JvdzogXCJjcm93XCIsXG4gICAgY3VydmU6IFwiY3VydmVcIixcbiAgICBpY3VydmU6IFwiaW52X2N1cnZlXCIsXG4gICAgbm9ybWFsOiBcInRyaWFuZ2xlXCIsXG4gICAgaW52OiBcImludl90cmlhbmdsZVwiLFxuICAgIGRpYW1vbmQ6IFwiZGlhbW9uZFwiLFxuICAgIHRlZTogXCJiYXJcIixcbiAgICB2ZWU6IFwidmVlXCJcbiAgfTtcblxuICAvKipcbiAgICogJ2F0dHJfbGlzdCcgY29udGFpbnMgYXR0cmlidXRlcyBmb3IgY2hlY2tpbmcgaWYgc29tZSBvZiB0aGVtIGFyZSBhZmZlY3RlZFxuICAgKiBsYXRlci4gRm9yIGluc3RhbmNlLCBib3RoIG9mICdhcnJvd2hlYWQnIGFuZCAnZGlyJyAoZWRnZSBzdHlsZSBkZWZpbmVkXG4gICAqIGluIERPVCkgbWFrZSBjaGFuZ2VzIHRvICdhcnJvd3MnIGF0dHJpYnV0ZSBpbiB2aXMuXG4gICAqL1xuICB2YXIgYXR0cl9saXN0ID0gbmV3IEFycmF5KCk7XG4gIHZhciBhdHRyX25hbWVzID0gbmV3IEFycmF5KCk7IC8vIHVzZWQgZm9yIGNoZWNraW5nIHRoZSBjYXNlLlxuXG4gIC8vIHBhcnNlIGF0dHJpYnV0ZXNcbiAgd2hpbGUgKHRva2VuID09PSBcIltcIikge1xuICAgIGdldFRva2VuKCk7XG4gICAgYXR0ciA9IHt9O1xuICAgIHdoaWxlICh0b2tlbiAhPT0gXCJcIiAmJiB0b2tlbiAhPSBcIl1cIikge1xuICAgICAgaWYgKHRva2VuVHlwZSAhPSBUT0tFTlRZUEUuSURFTlRJRklFUikge1xuICAgICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcihcIkF0dHJpYnV0ZSBuYW1lIGV4cGVjdGVkXCIpO1xuICAgICAgfVxuICAgICAgdmFyIG5hbWUgPSB0b2tlbjtcbiAgICAgIGdldFRva2VuKCk7XG4gICAgICBpZiAodG9rZW4gIT0gXCI9XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoXCJFcXVhbCBzaWduID0gZXhwZWN0ZWRcIik7XG4gICAgICB9XG4gICAgICBnZXRUb2tlbigpO1xuICAgICAgaWYgKHRva2VuVHlwZSAhPSBUT0tFTlRZUEUuSURFTlRJRklFUikge1xuICAgICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcihcIkF0dHJpYnV0ZSB2YWx1ZSBleHBlY3RlZFwiKTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IHRva2VuO1xuXG4gICAgICAvLyBjb252ZXJ0IGZyb20gZG90IHN0eWxlIHRvIHZpc1xuICAgICAgaWYgKG5hbWUgPT09IFwic3R5bGVcIikge1xuICAgICAgICB2YWx1ZSA9IGVkZ2VTdHlsZXNbdmFsdWVdO1xuICAgICAgfVxuICAgICAgdmFyIGFycm93VHlwZTtcbiAgICAgIGlmIChuYW1lID09PSBcImFycm93aGVhZFwiKSB7XG4gICAgICAgIGFycm93VHlwZSA9IGFycm93VHlwZXNbdmFsdWVdO1xuICAgICAgICBuYW1lID0gXCJhcnJvd3NcIjtcbiAgICAgICAgdmFsdWUgPSB7XG4gICAgICAgICAgdG86IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB0eXBlOiBhcnJvd1R5cGVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAobmFtZSA9PT0gXCJhcnJvd3RhaWxcIikge1xuICAgICAgICBhcnJvd1R5cGUgPSBhcnJvd1R5cGVzW3ZhbHVlXTtcbiAgICAgICAgbmFtZSA9IFwiYXJyb3dzXCI7XG4gICAgICAgIHZhbHVlID0ge1xuICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB0eXBlOiBhcnJvd1R5cGVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBhdHRyX2xpc3QucHVzaCh7XG4gICAgICAgIGF0dHI6IGF0dHIsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgICBhdHRyX25hbWVzLnB1c2gobmFtZSk7XG4gICAgICBnZXRUb2tlbigpO1xuICAgICAgaWYgKHRva2VuID09IFwiLFwiKSB7XG4gICAgICAgIGdldFRva2VuKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0b2tlbiAhPSBcIl1cIikge1xuICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoXCJCcmFja2V0IF0gZXhwZWN0ZWRcIik7XG4gICAgfVxuICAgIGdldFRva2VuKCk7XG4gIH1cblxuICAvKipcbiAgICogQXMgZXhwbGFpbmVkIGluIFsxXSwgZ3JhcGh2aXogaGFzIGxpbWl0YXRpb25zIGZvciBjb21iaW5hdGlvbiBvZlxuICAgKiBhcnJvd1toZWFkfHRhaWxdIGFuZCBkaXIuIElmIGF0dHJpYnV0ZSBsaXN0IGluY2x1ZGVzICdkaXInLFxuICAgKiBmb2xsb3dpbmcgY2FzZXMganVzdCBiZSBzdXBwb3J0ZWQuXG4gICAqICAgMS4gYm90aCBvciBub25lICsgYXJyb3doZWFkLCBhcnJvd3RhaWxcbiAgICogICAyLiBmb3J3YXJkICsgYXJyb3doZWFkIChhcnJvd3RhaWwgaXMgbm90IGFmZmVkdGVkKVxuICAgKiAgIDMuIGJhY2sgKyBhcnJvd3RhaWwgKGFycm93aGVhZCBpcyBub3QgYWZmZWN0ZWQpXG4gICAqIFsxXSBodHRwczovL3d3dy5ncmFwaHZpei5vcmcvZG9jL2luZm8vYXR0cnMuaHRtbCNoOnVuZGlyX25vdGVcbiAgICovXG4gIGlmIChfaW5jbHVkZXNJbnN0YW5jZVByb3BlcnR5KGF0dHJfbmFtZXMpLmNhbGwoYXR0cl9uYW1lcywgXCJkaXJcIikpIHtcbiAgICB2YXIgaWR4ID0ge307IC8vIGdldCBpbmRleCBvZiAnYXJyb3dzJyBhbmQgJ2RpcidcbiAgICBpZHguYXJyb3dzID0ge307XG4gICAgZm9yIChpID0gMDsgaSA8IGF0dHJfbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGF0dHJfbGlzdFtpXS5uYW1lID09PSBcImFycm93c1wiKSB7XG4gICAgICAgIGlmIChhdHRyX2xpc3RbaV0udmFsdWUudG8gIT0gbnVsbCkge1xuICAgICAgICAgIGlkeC5hcnJvd3MudG8gPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGF0dHJfbGlzdFtpXS52YWx1ZS5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgICBpZHguYXJyb3dzLmZyb20gPSBpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiSW52YWxpZCB2YWx1ZSBvZiBhcnJvd3NcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXR0cl9saXN0W2ldLm5hbWUgPT09IFwiZGlyXCIpIHtcbiAgICAgICAgaWR4LmRpciA9IGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmlyc3QsIGFkZCBkZWZhdWx0IGFycm93IHNoYXBlIGlmIGl0IGlzIG5vdCBhc3NpZ25lZCB0byBhdm9pZCBlcnJvclxuICAgIHZhciBkaXJfdHlwZSA9IGF0dHJfbGlzdFtpZHguZGlyXS52YWx1ZTtcbiAgICBpZiAoIV9pbmNsdWRlc0luc3RhbmNlUHJvcGVydHkoYXR0cl9uYW1lcykuY2FsbChhdHRyX25hbWVzLCBcImFycm93c1wiKSkge1xuICAgICAgaWYgKGRpcl90eXBlID09PSBcImJvdGhcIikge1xuICAgICAgICBhdHRyX2xpc3QucHVzaCh7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5kaXJdLmF0dHIsXG4gICAgICAgICAgbmFtZTogXCJhcnJvd3NcIixcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlkeC5hcnJvd3MudG8gPSBhdHRyX2xpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgYXR0cl9saXN0LnB1c2goe1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguZGlyXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IFwiYXJyb3dzXCIsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlkeC5hcnJvd3MuZnJvbSA9IGF0dHJfbGlzdC5sZW5ndGggLSAxO1xuICAgICAgfSBlbHNlIGlmIChkaXJfdHlwZSA9PT0gXCJmb3J3YXJkXCIpIHtcbiAgICAgICAgYXR0cl9saXN0LnB1c2goe1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguZGlyXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IFwiYXJyb3dzXCIsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZHguYXJyb3dzLnRvID0gYXR0cl9saXN0Lmxlbmd0aCAtIDE7XG4gICAgICB9IGVsc2UgaWYgKGRpcl90eXBlID09PSBcImJhY2tcIikge1xuICAgICAgICBhdHRyX2xpc3QucHVzaCh7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5kaXJdLmF0dHIsXG4gICAgICAgICAgbmFtZTogXCJhcnJvd3NcIixcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWR4LmFycm93cy5mcm9tID0gYXR0cl9saXN0Lmxlbmd0aCAtIDE7XG4gICAgICB9IGVsc2UgaWYgKGRpcl90eXBlID09PSBcIm5vbmVcIikge1xuICAgICAgICBhdHRyX2xpc3QucHVzaCh7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5kaXJdLmF0dHIsXG4gICAgICAgICAgbmFtZTogXCJhcnJvd3NcIixcbiAgICAgICAgICB2YWx1ZTogXCJcIlxuICAgICAgICB9KTtcbiAgICAgICAgaWR4LmFycm93cy50byA9IGF0dHJfbGlzdC5sZW5ndGggLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0ludmFsaWQgZGlyIHR5cGUgXCInICsgZGlyX3R5cGUgKyAnXCInKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGZyb21fdHlwZTtcbiAgICB2YXIgdG9fdHlwZTtcbiAgICAvLyB1cGRhdGUgJ2Fycm93cycgYXR0cmlidXRlIGZyb20gJ2RpcicuXG4gICAgaWYgKGRpcl90eXBlID09PSBcImJvdGhcIikge1xuICAgICAgLy8gYm90aCBvZiBzaGFwZXMgb2YgJ2Zyb20nIGFuZCAndG8nIGFyZSBnaXZlblxuICAgICAgaWYgKGlkeC5hcnJvd3MudG8gJiYgaWR4LmFycm93cy5mcm9tKSB7XG4gICAgICAgIHRvX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy50b10udmFsdWUudG8udHlwZTtcbiAgICAgICAgZnJvbV90eXBlID0gYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0udmFsdWUuZnJvbS50eXBlO1xuICAgICAgICBhdHRyX2xpc3RbaWR4LmFycm93cy50b10gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLmF0dHIsXG4gICAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IHRvX3R5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IGZyb21fdHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3NwbGljZUluc3RhbmNlUHJvcGVydHkoYXR0cl9saXN0KS5jYWxsKGF0dHJfbGlzdCwgaWR4LmFycm93cy5mcm9tLCAxKTtcblxuICAgICAgICAvLyBzaGFwZSBvZiAndG8nIGlzIGFzc2lnbmVkIGFuZCB1c2UgZGVmYXVsdCB0byAnZnJvbSdcbiAgICAgIH0gZWxzZSBpZiAoaWR4LmFycm93cy50bykge1xuICAgICAgICB0b190eXBlID0gYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLnZhbHVlLnRvLnR5cGU7XG4gICAgICAgIGZyb21fdHlwZSA9IFwiYXJyb3dcIjtcbiAgICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dID0ge1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiB0b190eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiBmcm9tX3R5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gb25seSBzaGFwZSBvZiAnZnJvbScgaXMgYXNzaWduZWQgYW5kIHVzZSBkZWZhdWx0IGZvciAndG8nXG4gICAgICB9IGVsc2UgaWYgKGlkeC5hcnJvd3MuZnJvbSkge1xuICAgICAgICB0b190eXBlID0gXCJhcnJvd1wiO1xuICAgICAgICBmcm9tX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS52YWx1ZS5mcm9tLnR5cGU7XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dID0ge1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLmF0dHIsXG4gICAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0ubmFtZSxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogdG9fdHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogZnJvbV90eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGlyX3R5cGUgPT09IFwiYmFja1wiKSB7XG4gICAgICAvLyBnaXZlbiBib3RoIG9mIHNoYXBlcywgYnV0IHVzZSBvbmx5ICdmcm9tJ1xuICAgICAgaWYgKGlkeC5hcnJvd3MudG8gJiYgaWR4LmFycm93cy5mcm9tKSB7XG4gICAgICAgIHRvX3R5cGUgPSBcIlwiO1xuICAgICAgICBmcm9tX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS52YWx1ZS5mcm9tLnR5cGU7XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dID0ge1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLmF0dHIsXG4gICAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0ubmFtZSxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogdG9fdHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogZnJvbV90eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGdpdmVuIHNoYXBlIG9mICd0bycsIGJ1dCBkb2VzIG5vdCB1c2UgaXRcbiAgICAgIH0gZWxzZSBpZiAoaWR4LmFycm93cy50bykge1xuICAgICAgICB0b190eXBlID0gXCJcIjtcbiAgICAgICAgZnJvbV90eXBlID0gXCJhcnJvd1wiO1xuICAgICAgICBpZHguYXJyb3dzLmZyb20gPSBpZHguYXJyb3dzLnRvO1xuICAgICAgICBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXSA9IHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IHRvX3R5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IGZyb21fdHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBhc3NpZ24gZ2l2ZW4gJ2Zyb20nIHNoYXBlXG4gICAgICB9IGVsc2UgaWYgKGlkeC5hcnJvd3MuZnJvbSkge1xuICAgICAgICB0b190eXBlID0gXCJcIjtcbiAgICAgICAgZnJvbV90eXBlID0gYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0udmFsdWUuZnJvbS50eXBlO1xuICAgICAgICBhdHRyX2xpc3RbaWR4LmFycm93cy50b10gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiB0b190eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiBmcm9tX3R5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXSA9IHtcbiAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0uYXR0cixcbiAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0ubmFtZSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgdHlwZTogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0udmFsdWUuZnJvbS50eXBlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZGlyX3R5cGUgPT09IFwibm9uZVwiKSB7XG4gICAgICB2YXIgaWR4X2Fycm93O1xuICAgICAgaWYgKGlkeC5hcnJvd3MudG8pIHtcbiAgICAgICAgaWR4X2Fycm93ID0gaWR4LmFycm93cy50bztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkeF9hcnJvdyA9IGlkeC5hcnJvd3MuZnJvbTtcbiAgICAgIH1cbiAgICAgIGF0dHJfbGlzdFtpZHhfYXJyb3ddID0ge1xuICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4X2Fycm93XS5hdHRyLFxuICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4X2Fycm93XS5uYW1lLFxuICAgICAgICB2YWx1ZTogXCJcIlxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRpcl90eXBlID09PSBcImZvcndhcmRcIikge1xuICAgICAgLy8gZ2l2ZW4gYm90aCBvZiBzaGFwZXMsIGJ1dCB1c2Ugb25seSAndG8nXG4gICAgICBpZiAoaWR4LmFycm93cy50byAmJiBpZHguYXJyb3dzLmZyb20pIHtcbiAgICAgICAgdG9fdHlwZSA9IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS52YWx1ZS50by50eXBlO1xuICAgICAgICBmcm9tX3R5cGUgPSBcIlwiO1xuICAgICAgICBhdHRyX2xpc3RbaWR4LmFycm93cy50b10gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLmF0dHIsXG4gICAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IHRvX3R5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IGZyb21fdHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBhc3NpZ24gZ2l2ZW4gJ3RvJyBzaGFwZVxuICAgICAgfSBlbHNlIGlmIChpZHguYXJyb3dzLnRvKSB7XG4gICAgICAgIHRvX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy50b10udmFsdWUudG8udHlwZTtcbiAgICAgICAgZnJvbV90eXBlID0gXCJcIjtcbiAgICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dID0ge1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiB0b190eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiBmcm9tX3R5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZ2l2ZW4gc2hhcGUgb2YgJ2Zyb20nLCBidXQgZG9lcyBub3QgdXNlIGl0XG4gICAgICB9IGVsc2UgaWYgKGlkeC5hcnJvd3MuZnJvbSkge1xuICAgICAgICB0b190eXBlID0gXCJhcnJvd1wiO1xuICAgICAgICBmcm9tX3R5cGUgPSBcIlwiO1xuICAgICAgICBpZHguYXJyb3dzLnRvID0gaWR4LmFycm93cy5mcm9tO1xuICAgICAgICBhdHRyX2xpc3RbaWR4LmFycm93cy50b10gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLmF0dHIsXG4gICAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IHRvX3R5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IGZyb21fdHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXSA9IHtcbiAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLmF0dHIsXG4gICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5uYW1lLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgdHlwZTogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLnZhbHVlLnRvLnR5cGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdJbnZhbGlkIGRpciB0eXBlIFwiJyArIGRpcl90eXBlICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlICdkaXInIGF0dHJpYnV0ZSBubyBuZWVkIGFueW1vcmVcbiAgICBfc3BsaWNlSW5zdGFuY2VQcm9wZXJ0eShhdHRyX2xpc3QpLmNhbGwoYXR0cl9saXN0LCBpZHguZGlyLCAxKTtcbiAgfVxuXG4gIC8vIHBhcnNlICdwZW53aWR0aCdcbiAgdmFyIG5vZl9hdHRyX2xpc3Q7XG4gIGlmIChfaW5jbHVkZXNJbnN0YW5jZVByb3BlcnR5KGF0dHJfbmFtZXMpLmNhbGwoYXR0cl9uYW1lcywgXCJwZW53aWR0aFwiKSkge1xuICAgIHZhciB0bXBfYXR0cl9saXN0ID0gW107XG4gICAgbm9mX2F0dHJfbGlzdCA9IGF0dHJfbGlzdC5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IG5vZl9hdHRyX2xpc3Q7IGkrKykge1xuICAgICAgLy8gZXhjbHVkZSAnd2lkdGgnIGZyb20gYXR0cl9saXN0IGlmICdwZW53aWR0aCcgZXhpc3RzXG4gICAgICBpZiAoYXR0cl9saXN0W2ldLm5hbWUgIT09IFwid2lkdGhcIikge1xuICAgICAgICBpZiAoYXR0cl9saXN0W2ldLm5hbWUgPT09IFwicGVud2lkdGhcIikge1xuICAgICAgICAgIGF0dHJfbGlzdFtpXS5uYW1lID0gXCJ3aWR0aFwiO1xuICAgICAgICB9XG4gICAgICAgIHRtcF9hdHRyX2xpc3QucHVzaChhdHRyX2xpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBhdHRyX2xpc3QgPSB0bXBfYXR0cl9saXN0O1xuICB9XG4gIG5vZl9hdHRyX2xpc3QgPSBhdHRyX2xpc3QubGVuZ3RoO1xuICBmb3IgKGkgPSAwOyBpIDwgbm9mX2F0dHJfbGlzdDsgaSsrKSB7XG4gICAgc2V0VmFsdWUoYXR0cl9saXN0W2ldLmF0dHIsIGF0dHJfbGlzdFtpXS5uYW1lLCBhdHRyX2xpc3RbaV0udmFsdWUpO1xuICB9XG4gIHJldHVybiBhdHRyO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHN5bnRheCBlcnJvciB3aXRoIGV4dHJhIGluZm9ybWF0aW9uIG9uIGN1cnJlbnQgdG9rZW4gYW5kIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7U3ludGF4RXJyb3J9IGVyclxuICovXG5mdW5jdGlvbiBuZXdTeW50YXhFcnJvcihtZXNzYWdlKSB7XG4gIHJldHVybiBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSArICcsIGdvdCBcIicgKyBjaG9wKHRva2VuLCAzMCkgKyAnXCIgKGNoYXIgJyArIGluZGV4ICsgXCIpXCIpO1xufVxuXG4vKipcbiAqIENob3Agb2ZmIHRleHQgYWZ0ZXIgYSBtYXhpbXVtIGxlbmd0aFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge251bWJlcn0gbWF4TGVuZ3RoXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjaG9wKHRleHQsIG1heExlbmd0aCkge1xuICByZXR1cm4gdGV4dC5sZW5ndGggPD0gbWF4TGVuZ3RoID8gdGV4dCA6IHRleHQuc3Vic3RyKDAsIDI3KSArIFwiLi4uXCI7XG59XG5cbi8qKlxuICogRXhlY3V0ZSBhIGZ1bmN0aW9uIGZuIGZvciBlYWNoIHBhaXIgb2YgZWxlbWVudHMgaW4gdHdvIGFycmF5c1xuICpcbiAqIEBwYXJhbSB7QXJyYXkgfCAqfSBhcnJheTFcbiAqIEBwYXJhbSB7QXJyYXkgfCAqfSBhcnJheTJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gyKGFycmF5MSwgYXJyYXkyLCBmbikge1xuICBpZiAoX0FycmF5JGlzQXJyYXkoYXJyYXkxKSkge1xuICAgIF9mb3JFYWNoSW5zdGFuY2VQcm9wZXJ0eShhcnJheTEpLmNhbGwoYXJyYXkxLCBmdW5jdGlvbiAoZWxlbTEpIHtcbiAgICAgIGlmIChfQXJyYXkkaXNBcnJheShhcnJheTIpKSB7XG4gICAgICAgIF9mb3JFYWNoSW5zdGFuY2VQcm9wZXJ0eShhcnJheTIpLmNhbGwoYXJyYXkyLCBmdW5jdGlvbiAoZWxlbTIpIHtcbiAgICAgICAgICBmbihlbGVtMSwgZWxlbTIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuKGVsZW0xLCBhcnJheTIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChfQXJyYXkkaXNBcnJheShhcnJheTIpKSB7XG4gICAgICBfZm9yRWFjaEluc3RhbmNlUHJvcGVydHkoYXJyYXkyKS5jYWxsKGFycmF5MiwgZnVuY3Rpb24gKGVsZW0yKSB7XG4gICAgICAgIGZuKGFycmF5MSwgZWxlbTIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuKGFycmF5MSwgYXJyYXkyKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgYSBuZXN0ZWQgcHJvcGVydHkgb24gYW4gb2JqZWN0XG4gKiBXaGVuIG5lc3RlZCBvYmplY3RzIGFyZSBtaXNzaW5nLCB0aGV5IHdpbGwgYmUgY3JlYXRlZC5cbiAqIEZvciBleGFtcGxlIHNldFByb3Aoe30sICdmb250LmNvbG9yJywgJ3JlZCcpIHdpbGwgcmV0dXJuIHtmb250OiB7Y29sb3I6ICdyZWQnfX1cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAgIEEgZG90IHNlcGFyYXRlZCBzdHJpbmcgbGlrZSAnZm9udC5jb2xvcidcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgICAgICAgVmFsdWUgZm9yIHRoZSBwcm9wZXJ0eVxuICogQHJldHVybnMge29iamVjdH0gUmV0dXJucyB0aGUgb3JpZ2luYWwgb2JqZWN0LCBhbGxvd3MgZm9yIGNoYWluaW5nLlxuICovXG5mdW5jdGlvbiBzZXRQcm9wKG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcbiAgdmFyIG5hbWVzID0gcGF0aC5zcGxpdChcIi5cIik7XG4gIHZhciBwcm9wID0gbmFtZXMucG9wKCk7XG5cbiAgLy8gdHJhdmVyc2Ugb3ZlciB0aGUgbmVzdGVkIG9iamVjdHNcbiAgdmFyIG9iaiA9IG9iamVjdDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgaWYgKCEobmFtZSBpbiBvYmopKSB7XG4gICAgICBvYmpbbmFtZV0gPSB7fTtcbiAgICB9XG4gICAgb2JqID0gb2JqW25hbWVdO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICBvYmpbcHJvcF0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIG9iamVjdCB3aXRoIERPVCBhdHRyaWJ1dGVzIHRvIHRoZWlyIHZpcy5qcyBlcXVpdmFsZW50cy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXR0ciAgICAgT2JqZWN0IHdpdGggRE9UIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7b2JqZWN0fSBtYXBwaW5nXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAgICAgICAgIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdmlzLmpzIGF0dHJpYnV0ZXNcbiAqL1xuZnVuY3Rpb24gY29udmVydEF0dHIoYXR0ciwgbWFwcGluZykge1xuICB2YXIgY29udmVydGVkID0ge307XG4gIGZvciAodmFyIHByb3AgaW4gYXR0cikge1xuICAgIGlmIChhdHRyLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICB2YXIgdmlzUHJvcCA9IG1hcHBpbmdbcHJvcF07XG4gICAgICBpZiAoX0FycmF5JGlzQXJyYXkodmlzUHJvcCkpIHtcbiAgICAgICAgX2ZvckVhY2hJbnN0YW5jZVByb3BlcnR5KHZpc1Byb3ApLmNhbGwodmlzUHJvcCwgZnVuY3Rpb24gKHZpc1Byb3BJKSB7XG4gICAgICAgICAgc2V0UHJvcChjb252ZXJ0ZWQsIHZpc1Byb3BJLCBhdHRyW3Byb3BdKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2aXNQcm9wID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHNldFByb3AoY29udmVydGVkLCB2aXNQcm9wLCBhdHRyW3Byb3BdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFByb3AoY29udmVydGVkLCBwcm9wLCBhdHRyW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRlZDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgc3RyaW5nIGNvbnRhaW5pbmcgYSBncmFwaCBpbiBET1QgbGFuZ3VhZ2UgaW50byBhIG1hcCBjb250YWluaW5nXG4gKiB3aXRoIG5vZGVzIGFuZCBlZGdlcyBpbiB0aGUgZm9ybWF0IG9mIGdyYXBoLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhICAgICAgICAgVGV4dCBjb250YWluaW5nIGEgZ3JhcGggaW4gRE9ULW5vdGF0aW9uXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBncmFwaERhdGFcbiAqL1xuZnVuY3Rpb24gRE9UVG9HcmFwaChkYXRhKSB7XG4gIC8vIHBhcnNlIHRoZSBET1QgZmlsZVxuICB2YXIgZG90RGF0YSA9IHBhcnNlRE9UKGRhdGEpO1xuICB2YXIgZ3JhcGhEYXRhID0ge1xuICAgIG5vZGVzOiBbXSxcbiAgICBlZGdlczogW10sXG4gICAgb3B0aW9uczoge31cbiAgfTtcblxuICAvLyBjb3B5IHRoZSBub2Rlc1xuICBpZiAoZG90RGF0YS5ub2Rlcykge1xuICAgIHZhciBfY29udGV4dDI7XG4gICAgX2ZvckVhY2hJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0MiA9IGRvdERhdGEubm9kZXMpLmNhbGwoX2NvbnRleHQyLCBmdW5jdGlvbiAoZG90Tm9kZSkge1xuICAgICAgdmFyIGdyYXBoTm9kZSA9IHtcbiAgICAgICAgaWQ6IGRvdE5vZGUuaWQsXG4gICAgICAgIGxhYmVsOiBTdHJpbmcoZG90Tm9kZS5sYWJlbCB8fCBkb3ROb2RlLmlkKVxuICAgICAgfTtcbiAgICAgIG1lcmdlJDEoZ3JhcGhOb2RlLCBjb252ZXJ0QXR0cihkb3ROb2RlLmF0dHIsIE5PREVfQVRUUl9NQVBQSU5HKSk7XG4gICAgICBpZiAoZ3JhcGhOb2RlLmltYWdlKSB7XG4gICAgICAgIGdyYXBoTm9kZS5zaGFwZSA9IFwiaW1hZ2VcIjtcbiAgICAgIH1cbiAgICAgIGdyYXBoRGF0YS5ub2Rlcy5wdXNoKGdyYXBoTm9kZSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBjb3B5IHRoZSBlZGdlc1xuICBpZiAoZG90RGF0YS5lZGdlcykge1xuICAgIHZhciBfY29udGV4dDM7XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhbiBlZGdlIGluIERPVCBmb3JtYXQgdG8gYW4gZWRnZSB3aXRoIFZpc0dyYXBoIGZvcm1hdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRvdEVkZ2VcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBncmFwaEVkZ2VcbiAgICAgKi9cbiAgICB2YXIgY29udmVydEVkZ2UgPSBmdW5jdGlvbiBjb252ZXJ0RWRnZShkb3RFZGdlKSB7XG4gICAgICB2YXIgZ3JhcGhFZGdlID0ge1xuICAgICAgICBmcm9tOiBkb3RFZGdlLmZyb20sXG4gICAgICAgIHRvOiBkb3RFZGdlLnRvXG4gICAgICB9O1xuICAgICAgbWVyZ2UkMShncmFwaEVkZ2UsIGNvbnZlcnRBdHRyKGRvdEVkZ2UuYXR0ciwgRURHRV9BVFRSX01BUFBJTkcpKTtcblxuICAgICAgLy8gQWRkIGFycm93cyBhdHRyaWJ1dGUgdG8gZGVmYXVsdCBzdHlsZWQgYXJyb3cuXG4gICAgICAvLyBUaGUgcmVhc29uIHdoeSBkZWZhdWx0IHN0eWxlIGlzIG5vdCBhZGRlZCBpbiBwYXJzZUF0dHJpYnV0ZUxpc3QoKSBpc1xuICAgICAgLy8gYmVjYXVzZSBvbmx5IGRlZmF1bHQgaXMgY2xlYXJlZCBiZWZvcmUgaGVyZS5cbiAgICAgIGlmIChncmFwaEVkZ2UuYXJyb3dzID09IG51bGwgJiYgZG90RWRnZS50eXBlID09PSBcIi0+XCIpIHtcbiAgICAgICAgZ3JhcGhFZGdlLmFycm93cyA9IFwidG9cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncmFwaEVkZ2U7XG4gICAgfTtcbiAgICBfZm9yRWFjaEluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQzID0gZG90RGF0YS5lZGdlcykuY2FsbChfY29udGV4dDMsIGZ1bmN0aW9uIChkb3RFZGdlKSB7XG4gICAgICB2YXIgZnJvbSwgdG87XG4gICAgICBpZiAoZG90RWRnZS5mcm9tIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIGZyb20gPSBkb3RFZGdlLmZyb20ubm9kZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcm9tID0ge1xuICAgICAgICAgIGlkOiBkb3RFZGdlLmZyb21cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChkb3RFZGdlLnRvIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIHRvID0gZG90RWRnZS50by5ub2RlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvID0ge1xuICAgICAgICAgIGlkOiBkb3RFZGdlLnRvXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoZG90RWRnZS5mcm9tIGluc3RhbmNlb2YgT2JqZWN0ICYmIGRvdEVkZ2UuZnJvbS5lZGdlcykge1xuICAgICAgICB2YXIgX2NvbnRleHQ0O1xuICAgICAgICBfZm9yRWFjaEluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQ0ID0gZG90RWRnZS5mcm9tLmVkZ2VzKS5jYWxsKF9jb250ZXh0NCwgZnVuY3Rpb24gKHN1YkVkZ2UpIHtcbiAgICAgICAgICB2YXIgZ3JhcGhFZGdlID0gY29udmVydEVkZ2Uoc3ViRWRnZSk7XG4gICAgICAgICAgZ3JhcGhEYXRhLmVkZ2VzLnB1c2goZ3JhcGhFZGdlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmb3JFYWNoMihmcm9tLCB0bywgZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICAgIHZhciBzdWJFZGdlID0gY3JlYXRlRWRnZShncmFwaERhdGEsIGZyb20uaWQsIHRvLmlkLCBkb3RFZGdlLnR5cGUsIGRvdEVkZ2UuYXR0cik7XG4gICAgICAgIHZhciBncmFwaEVkZ2UgPSBjb252ZXJ0RWRnZShzdWJFZGdlKTtcbiAgICAgICAgZ3JhcGhEYXRhLmVkZ2VzLnB1c2goZ3JhcGhFZGdlKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGRvdEVkZ2UudG8gaW5zdGFuY2VvZiBPYmplY3QgJiYgZG90RWRnZS50by5lZGdlcykge1xuICAgICAgICB2YXIgX2NvbnRleHQ1O1xuICAgICAgICBfZm9yRWFjaEluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQ1ID0gZG90RWRnZS50by5lZGdlcykuY2FsbChfY29udGV4dDUsIGZ1bmN0aW9uIChzdWJFZGdlKSB7XG4gICAgICAgICAgdmFyIGdyYXBoRWRnZSA9IGNvbnZlcnRFZGdlKHN1YkVkZ2UpO1xuICAgICAgICAgIGdyYXBoRGF0YS5lZGdlcy5wdXNoKGdyYXBoRWRnZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gY29weSB0aGUgb3B0aW9uc1xuICBpZiAoZG90RGF0YS5hdHRyKSB7XG4gICAgZ3JhcGhEYXRhLm9wdGlvbnMgPSBkb3REYXRhLmF0dHI7XG4gIH1cbiAgcmV0dXJuIGdyYXBoRGF0YTtcbn1cblxuLyogZXNsaW50LWVuYWJsZSBuby12YXIgKi9cbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8qIGVzbGludC1lbmFibGUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zICovXG5cbnZhciBkb3RwYXJzZXIgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0RE9UVG9HcmFwaDogRE9UVG9HcmFwaCxcblx0cGFyc2VET1Q6IHBhcnNlRE9UXG59KTtcblxuLyoqXHJcbiAqIENvbnZlcnQgR2VwaGkgdG8gVmlzLlxyXG4gKlxyXG4gKiBAcGFyYW0gZ2VwaGlKU09OIC0gVGhlIHBhcnNlZCBKU09OIGRhdGEgaW4gR2VwaGkgZm9ybWF0LlxyXG4gKiBAcGFyYW0gb3B0aW9uc09iaiAtIEFkZGl0aW9uYWwgb3B0aW9ucy5cclxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBkYXRhIHJlYWR5IHRvIGJlIHVzZWQgaW4gVmlzLlxyXG4gKi9cbmZ1bmN0aW9uIHBhcnNlR2VwaGkoZ2VwaGlKU09OLCBvcHRpb25zT2JqKSB7XG4gIHZhciBfY29udGV4dDtcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgZWRnZXM6IHtcbiAgICAgIGluaGVyaXRDb2xvcjogZmFsc2VcbiAgICB9LFxuICAgIG5vZGVzOiB7XG4gICAgICBmaXhlZDogZmFsc2UsXG4gICAgICBwYXJzZUNvbG9yOiBmYWxzZVxuICAgIH1cbiAgfTtcbiAgaWYgKG9wdGlvbnNPYmogIT0gbnVsbCkge1xuICAgIGlmIChvcHRpb25zT2JqLmZpeGVkICE9IG51bGwpIHtcbiAgICAgIG9wdGlvbnMubm9kZXMuZml4ZWQgPSBvcHRpb25zT2JqLmZpeGVkO1xuICAgIH1cbiAgICBpZiAob3B0aW9uc09iai5wYXJzZUNvbG9yICE9IG51bGwpIHtcbiAgICAgIG9wdGlvbnMubm9kZXMucGFyc2VDb2xvciA9IG9wdGlvbnNPYmoucGFyc2VDb2xvcjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnNPYmouaW5oZXJpdENvbG9yICE9IG51bGwpIHtcbiAgICAgIG9wdGlvbnMuZWRnZXMuaW5oZXJpdENvbG9yID0gb3B0aW9uc09iai5pbmhlcml0Q29sb3I7XG4gICAgfVxuICB9XG4gIHZhciBnRWRnZXMgPSBnZXBoaUpTT04uZWRnZXM7XG4gIHZhciB2RWRnZXMgPSBfbWFwSW5zdGFuY2VQcm9wZXJ0eShnRWRnZXMpLmNhbGwoZ0VkZ2VzLCBmdW5jdGlvbiAoZ0VkZ2UpIHtcbiAgICB2YXIgdkVkZ2UgPSB7XG4gICAgICBmcm9tOiBnRWRnZS5zb3VyY2UsXG4gICAgICBpZDogZ0VkZ2UuaWQsXG4gICAgICB0bzogZ0VkZ2UudGFyZ2V0XG4gICAgfTtcbiAgICBpZiAoZ0VkZ2UuYXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICB2RWRnZS5hdHRyaWJ1dGVzID0gZ0VkZ2UuYXR0cmlidXRlcztcbiAgICB9XG4gICAgaWYgKGdFZGdlLmxhYmVsICE9IG51bGwpIHtcbiAgICAgIHZFZGdlLmxhYmVsID0gZ0VkZ2UubGFiZWw7XG4gICAgfVxuICAgIGlmIChnRWRnZS5hdHRyaWJ1dGVzICE9IG51bGwgJiYgZ0VkZ2UuYXR0cmlidXRlcy50aXRsZSAhPSBudWxsKSB7XG4gICAgICB2RWRnZS50aXRsZSA9IGdFZGdlLmF0dHJpYnV0ZXMudGl0bGU7XG4gICAgfVxuICAgIGlmIChnRWRnZS50eXBlID09PSBcIkRpcmVjdGVkXCIpIHtcbiAgICAgIHZFZGdlLmFycm93cyA9IFwidG9cIjtcbiAgICB9XG4gICAgLy8gZWRnZVsndmFsdWUnXSA9IGdFZGdlLmF0dHJpYnV0ZXMgIT0gbnVsbCA/IGdFZGdlLmF0dHJpYnV0ZXMuV2VpZ2h0IDogdW5kZWZpbmVkO1xuICAgIC8vIGVkZ2VbJ3dpZHRoJ10gPSBlZGdlWyd2YWx1ZSddICE9IG51bGwgPyB1bmRlZmluZWQgOiBlZGdlZ0VkZ2Uuc2l6ZTtcbiAgICBpZiAoZ0VkZ2UuY29sb3IgJiYgb3B0aW9ucy5lZGdlcy5pbmhlcml0Q29sb3IgPT09IGZhbHNlKSB7XG4gICAgICB2RWRnZS5jb2xvciA9IGdFZGdlLmNvbG9yO1xuICAgIH1cbiAgICByZXR1cm4gdkVkZ2U7XG4gIH0pO1xuICB2YXIgdk5vZGVzID0gX21hcEluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQgPSBnZXBoaUpTT04ubm9kZXMpLmNhbGwoX2NvbnRleHQsIGZ1bmN0aW9uIChnTm9kZSkge1xuICAgIHZhciB2Tm9kZSA9IHtcbiAgICAgIGlkOiBnTm9kZS5pZCxcbiAgICAgIGZpeGVkOiBvcHRpb25zLm5vZGVzLmZpeGVkICYmIGdOb2RlLnggIT0gbnVsbCAmJiBnTm9kZS55ICE9IG51bGxcbiAgICB9O1xuICAgIGlmIChnTm9kZS5hdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgIHZOb2RlLmF0dHJpYnV0ZXMgPSBnTm9kZS5hdHRyaWJ1dGVzO1xuICAgIH1cbiAgICBpZiAoZ05vZGUubGFiZWwgIT0gbnVsbCkge1xuICAgICAgdk5vZGUubGFiZWwgPSBnTm9kZS5sYWJlbDtcbiAgICB9XG4gICAgaWYgKGdOb2RlLnNpemUgIT0gbnVsbCkge1xuICAgICAgdk5vZGUuc2l6ZSA9IGdOb2RlLnNpemU7XG4gICAgfVxuICAgIGlmIChnTm9kZS5hdHRyaWJ1dGVzICE9IG51bGwgJiYgZ05vZGUuYXR0cmlidXRlcy50aXRsZSAhPSBudWxsKSB7XG4gICAgICB2Tm9kZS50aXRsZSA9IGdOb2RlLmF0dHJpYnV0ZXMudGl0bGU7XG4gICAgfVxuICAgIGlmIChnTm9kZS50aXRsZSAhPSBudWxsKSB7XG4gICAgICB2Tm9kZS50aXRsZSA9IGdOb2RlLnRpdGxlO1xuICAgIH1cbiAgICBpZiAoZ05vZGUueCAhPSBudWxsKSB7XG4gICAgICB2Tm9kZS54ID0gZ05vZGUueDtcbiAgICB9XG4gICAgaWYgKGdOb2RlLnkgIT0gbnVsbCkge1xuICAgICAgdk5vZGUueSA9IGdOb2RlLnk7XG4gICAgfVxuICAgIGlmIChnTm9kZS5jb2xvciAhPSBudWxsKSB7XG4gICAgICBpZiAob3B0aW9ucy5ub2Rlcy5wYXJzZUNvbG9yID09PSB0cnVlKSB7XG4gICAgICAgIHZOb2RlLmNvbG9yID0gZ05vZGUuY29sb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2Tm9kZS5jb2xvciA9IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBnTm9kZS5jb2xvcixcbiAgICAgICAgICBib3JkZXI6IGdOb2RlLmNvbG9yLFxuICAgICAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICAgICAgYmFja2dyb3VuZDogZ05vZGUuY29sb3IsXG4gICAgICAgICAgICBib3JkZXI6IGdOb2RlLmNvbG9yXG4gICAgICAgICAgfSxcbiAgICAgICAgICBob3Zlcjoge1xuICAgICAgICAgICAgYmFja2dyb3VuZDogZ05vZGUuY29sb3IsXG4gICAgICAgICAgICBib3JkZXI6IGdOb2RlLmNvbG9yXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdk5vZGU7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIG5vZGVzOiB2Tm9kZXMsXG4gICAgZWRnZXM6IHZFZGdlc1xuICB9O1xufVxuXG52YXIgZ2VwaGlQYXJzZXIgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0cGFyc2VHZXBoaTogcGFyc2VHZXBoaVxufSk7XG5cbi8vIEVuZ2xpc2hcbnZhciBlbiA9IHtcbiAgYWRkRGVzY3JpcHRpb246IFwiQ2xpY2sgaW4gYW4gZW1wdHkgc3BhY2UgdG8gcGxhY2UgYSBuZXcgbm9kZS5cIixcbiAgYWRkRWRnZTogXCJBZGQgRWRnZVwiLFxuICBhZGROb2RlOiBcIkFkZCBOb2RlXCIsXG4gIGJhY2s6IFwiQmFja1wiLFxuICBjbG9zZTogXCJDbG9zZVwiLFxuICBjcmVhdGVFZGdlRXJyb3I6IFwiQ2Fubm90IGxpbmsgZWRnZXMgdG8gYSBjbHVzdGVyLlwiLFxuICBkZWw6IFwiRGVsZXRlIHNlbGVjdGVkXCIsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogXCJDbHVzdGVycyBjYW5ub3QgYmUgZGVsZXRlZC5cIixcbiAgZWRnZURlc2NyaXB0aW9uOiBcIkNsaWNrIG9uIGEgbm9kZSBhbmQgZHJhZyB0aGUgZWRnZSB0byBhbm90aGVyIG5vZGUgdG8gY29ubmVjdCB0aGVtLlwiLFxuICBlZGl0OiBcIkVkaXRcIixcbiAgZWRpdENsdXN0ZXJFcnJvcjogXCJDbHVzdGVycyBjYW5ub3QgYmUgZWRpdGVkLlwiLFxuICBlZGl0RWRnZTogXCJFZGl0IEVkZ2VcIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCJDbGljayBvbiB0aGUgY29udHJvbCBwb2ludHMgYW5kIGRyYWcgdGhlbSB0byBhIG5vZGUgdG8gY29ubmVjdCB0byBpdC5cIixcbiAgZWRpdE5vZGU6IFwiRWRpdCBOb2RlXCJcbn07XG4vLyBHZXJtYW5cbnZhciBkZSA9IHtcbiAgYWRkRGVzY3JpcHRpb246IFwiS2xpY2tlIGF1ZiBlaW5lIGZyZWllIFN0ZWxsZSwgdW0gZWluZW4gbmV1ZW4gS25vdGVuIHp1IHBsYXppZXJlbi5cIixcbiAgYWRkRWRnZTogXCJLYW50ZSBoaW56dWZcXHhGQ2dlblwiLFxuICBhZGROb2RlOiBcIktub3RlbiBoaW56dWZcXHhGQ2dlblwiLFxuICBiYWNrOiBcIlp1clxceEZDY2tcIixcbiAgY2xvc2U6IFwiU2NobGllw59lblwiLFxuICBjcmVhdGVFZGdlRXJyb3I6IFwiRXMgaXN0IG5pY2h0IG1cXHhGNmdsaWNoLCBLYW50ZW4gbWl0IENsdXN0ZXJuIHp1IHZlcmJpbmRlbi5cIixcbiAgZGVsOiBcIkxcXHhGNnNjaGUgQXVzd2FobFwiLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6IFwiQ2x1c3RlciBrXFx4RjZubmVuIG5pY2h0IGdlbFxceEY2c2NodCB3ZXJkZW4uXCIsXG4gIGVkZ2VEZXNjcmlwdGlvbjogXCJLbGlja2UgYXVmIGVpbmVuIEtub3RlbiB1bmQgemllaGUgZGllIEthbnRlIHp1IGVpbmVtIGFuZGVyZW4gS25vdGVuLCB1bSBkaWVzZSB6dSB2ZXJiaW5kZW4uXCIsXG4gIGVkaXQ6IFwiRWRpdGllcmVuXCIsXG4gIGVkaXRDbHVzdGVyRXJyb3I6IFwiQ2x1c3RlciBrXFx4RjZubmVuIG5pY2h0IGVkaXRpZXJ0IHdlcmRlbi5cIixcbiAgZWRpdEVkZ2U6IFwiS2FudGUgZWRpdGllcmVuXCIsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246IFwiS2xpY2tlIGF1ZiBkaWUgVmVyYmluZHVuZ3NwdW5rdGUgdW5kIHppZWhlIGRpZXNlIGF1ZiBlaW5lbiBLbm90ZW4sIHVtIHNpZSB6dSB2ZXJiaW5kZW4uXCIsXG4gIGVkaXROb2RlOiBcIktub3RlbiBlZGl0aWVyZW5cIlxufTtcbi8vIFNwYW5pc2hcbnZhciBlcyA9IHtcbiAgYWRkRGVzY3JpcHRpb246IFwiSGFnYSBjbGljIGVuIHVuIGx1Z2FyIHZhY1xceEVEbyBwYXJhIGNvbG9jYXIgdW4gbnVldm8gbm9kby5cIixcbiAgYWRkRWRnZTogXCJBXFx4RjFhZGlyIGFyaXN0YVwiLFxuICBhZGROb2RlOiBcIkFcXHhGMWFkaXIgbm9kb1wiLFxuICBiYWNrOiBcIkF0clxceEUxc1wiLFxuICBjbG9zZTogXCJDZXJyYXJcIixcbiAgY3JlYXRlRWRnZUVycm9yOiBcIk5vIHNlIHB1ZWRlIGNvbmVjdGFyIHVuYSBhcmlzdGEgYSB1biBncnVwby5cIixcbiAgZGVsOiBcIkVsaW1pbmFyIHNlbGVjY2lcXHhGM25cIixcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiBcIk5vIGVzIHBvc2libGUgZWxpbWluYXIgZ3J1cG9zLlwiLFxuICBlZGdlRGVzY3JpcHRpb246IFwiSGFnYSBjbGljIGVuIHVuIG5vZG8geSBhcnJhc3RyZSBsYSBhcmlzdGEgaGFjaWEgb3RybyBub2RvIHBhcmEgY29uZWN0YXJsb3MuXCIsXG4gIGVkaXQ6IFwiRWRpdGFyXCIsXG4gIGVkaXRDbHVzdGVyRXJyb3I6IFwiTm8gZXMgcG9zaWJsZSBlZGl0YXIgZ3J1cG9zLlwiLFxuICBlZGl0RWRnZTogXCJFZGl0YXIgYXJpc3RhXCIsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246IFwiSGFnYSBjbGljIGVuIHVuIHB1bnRvIGRlIGNvbnRyb2wgeSBhcnJhc3RyZWxvIGEgdW4gbm9kbyBwYXJhIGNvbmVjdGFybG8uXCIsXG4gIGVkaXROb2RlOiBcIkVkaXRhciBub2RvXCJcbn07XG4vL0l0YWxpYW5vXG52YXIgaXQgPSB7XG4gIGFkZERlc2NyaXB0aW9uOiBcIkNsaWNjYSBwZXIgYWdnaXVuZ2VyZSB1biBudW92byBub2RvXCIsXG4gIGFkZEVkZ2U6IFwiQWdnaXVuZ2kgdW4gdmVydGljZVwiLFxuICBhZGROb2RlOiBcIkFnZ2l1bmdpIHVuIG5vZG9cIixcbiAgYmFjazogXCJJbmRpZXRyb1wiLFxuICBjbG9zZTogXCJDaGl1ZGVyZVwiLFxuICBjcmVhdGVFZGdlRXJyb3I6IFwiTm9uIHNpIHBvc3Nvbm8gY29sbGVnYXJlIHZlcnRpY2kgYWQgdW4gY2x1c3RlclwiLFxuICBkZWw6IFwiQ2FuY2VsbGEgbGEgc2VsZXppb25lXCIsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogXCJJIGNsdXN0ZXIgbm9uIHBvc3Nvbm8gZXNzZXJlIGNhbmNlbGxhdGlcIixcbiAgZWRnZURlc2NyaXB0aW9uOiBcIkNsaWNjYSBzdSB1biBub2RvIGUgdHJhc2NpbmFsbyBhZCB1biBhbHRybyBub2RvIHBlciBjb25uZXR0ZXJsaS5cIixcbiAgZWRpdDogXCJNb2RpZmljYVwiLFxuICBlZGl0Q2x1c3RlckVycm9yOiBcIkkgY2x1c3RlcnMgbm9uIHBvc3Nvbm8gZXNzZXJlIG1vZGlmaWNhdGkuXCIsXG4gIGVkaXRFZGdlOiBcIk1vZGlmaWNhIGlsIHZlcnRpY2VcIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCJDbGljY2Egc3VpIFB1bnRpIGRpIGNvbnRyb2xsbyBlIHRyYXNjaW5hbGkgYWQgdW4gbm9kbyBwZXIgY29ubmV0dGVybGkuXCIsXG4gIGVkaXROb2RlOiBcIk1vZGlmaWNhIGlsIG5vZG9cIlxufTtcbi8vIER1dGNoXG52YXIgbmwgPSB7XG4gIGFkZERlc2NyaXB0aW9uOiBcIktsaWsgb3AgZWVuIGxlZWcgZ2ViaWVkIG9tIGVlbiBuaWV1d2Ugbm9kZSB0ZSBtYWtlbi5cIixcbiAgYWRkRWRnZTogXCJMaW5rIHRvZXZvZWdlblwiLFxuICBhZGROb2RlOiBcIk5vZGUgdG9ldm9lZ2VuXCIsXG4gIGJhY2s6IFwiVGVydWdcIixcbiAgY2xvc2U6IFwiU2x1aXRlblwiLFxuICBjcmVhdGVFZGdlRXJyb3I6IFwiS2FuIGdlZW4gbGluayBtYWtlbiBuYWFyIGVlbiBjbHVzdGVyLlwiLFxuICBkZWw6IFwiU2VsZWN0aWUgdmVyd2lqZGVyZW5cIixcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiBcIkNsdXN0ZXJzIGt1bm5lbiBuaWV0IHdvcmRlbiB2ZXJ3aWpkZXJkLlwiLFxuICBlZGdlRGVzY3JpcHRpb246IFwiS2xpayBvcCBlZW4gbm9kZSBlbiBzbGVlcCBkZSBsaW5rIG5hYXIgZWVuIGFuZGVyZSBub2RlIG9tIHplIHRlIHZlcmJpbmRlbi5cIixcbiAgZWRpdDogXCJXaWp6aWdlblwiLFxuICBlZGl0Q2x1c3RlckVycm9yOiBcIkNsdXN0ZXJzIGt1bm5lbiBuaWV0IHdvcmRlbiBhYW5nZXBhc3QuXCIsXG4gIGVkaXRFZGdlOiBcIkxpbmsgd2lqemlnZW5cIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCJLbGlrIG9wIGRlIHZlcmJpbmRpbmdzcHVudGVuIGVuIHNsZWVwIHplIG5hYXIgZWVuIG5vZGUgb20gZGFhcm1lZSB0ZSB2ZXJiaW5kZW4uXCIsXG4gIGVkaXROb2RlOiBcIk5vZGUgd2lqemlnZW5cIlxufTtcbi8vIFBvcnR1Z3Vlc2UgQnJhemlsXG52YXIgcHQgPSB7XG4gIGFkZERlc2NyaXB0aW9uOiBcIkNsaXF1ZSBlbSB1bSBlc3Bhw6dvIGVtIGJyYW5jbyBwYXJhIGFkaWNpb25hciB1bSBub3ZvIG7Ds1wiLFxuICBhZGRFZGdlOiBcIkFkaWNpb25hciBhcmVzdGFcIixcbiAgYWRkTm9kZTogXCJBZGljaW9uYXIgbsOzXCIsXG4gIGJhY2s6IFwiVm9sdGFyXCIsXG4gIGNsb3NlOiBcIkZlY2hhclwiLFxuICBjcmVhdGVFZGdlRXJyb3I6IFwiTsOjbyBmb2kgcG9zc8OtdmVsIGxpbmthciBhcmVzdGFzIGEgdW0gY2x1c3Rlci5cIixcbiAgZGVsOiBcIlJlbW92ZXIgc2VsZWNpb25hZG9cIixcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiBcIkNsdXN0ZXJzIG7Do28gcHVkZXJhbSBzZXIgcmVtb3ZpZG9zLlwiLFxuICBlZGdlRGVzY3JpcHRpb246IFwiQ2xpcXVlIGVtIHVtIG7DsyBlIGFycmFzdGUgYSBhcmVzdGEgYXTDqSBvdXRybyBuw7MgcGFyYSBjb25lY3TDoS1sb3NcIixcbiAgZWRpdDogXCJFZGl0YXJcIixcbiAgZWRpdENsdXN0ZXJFcnJvcjogXCJDbHVzdGVycyBuw6NvIHB1ZGVyYW0gc2VyIGVkaXRhZG9zLlwiLFxuICBlZGl0RWRnZTogXCJFZGl0YXIgYXJlc3RhXCIsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246IFwiQ2xpcXVlIG5vcyBwb250b3MgZGUgY29udHJvbGUgZSBvcyBhcnJhc3RlIHBhcmEgdW0gbsOzIHBhcmEgY29uZWN0w6EtbG9zXCIsXG4gIGVkaXROb2RlOiBcIkVkaXRhciBuw7NcIlxufTtcbi8vIFJ1c3NpYW5cbnZhciBydSA9IHtcbiAgYWRkRGVzY3JpcHRpb246IFwi0JrQu9C40LrQvdC40YLQtSDQsiDRgdCy0L7QsdC+0LTQvdC+0LUg0LzQtdGB0YLQviwg0YfRgtC+0LHRiyDQtNC+0LHQsNCy0LjRgtGMINC90L7QstGL0Lkg0YPQt9C10LsuXCIsXG4gIGFkZEVkZ2U6IFwi0JTQvtCx0LDQstC40YLRjCDRgNC10LHRgNC+XCIsXG4gIGFkZE5vZGU6IFwi0JTQvtCx0LDQstC40YLRjCDRg9C30LXQu1wiLFxuICBiYWNrOiBcItCd0LDQt9Cw0LRcIixcbiAgY2xvc2U6IFwi0JfQsNC60YDRi9Cy0LDRgtGMXCIsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogXCLQndC10LLQvtC30LzQvtC20L3QviDRgdC+0LXQtNC40L3QuNGC0Ywg0YDQtdCx0YDQsCDQsiDQutC70LDRgdGC0LXRgC5cIixcbiAgZGVsOiBcItCj0LTQsNC70LjRgtGMINCy0YvQsdGA0LDQvdC90L7QtVwiLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6IFwi0JrQu9Cw0YHRgtC10YDRiyDQvdC1INC80L7Qs9GD0YIg0LHRi9GC0Ywg0YPQtNCw0LvQtdC90YtcIixcbiAgZWRnZURlc2NyaXB0aW9uOiBcItCa0LvQuNC60L3QuNGC0LUg0L3QsCDRg9C30LXQuyDQuCDQv9GA0L7RgtGP0L3QuNGC0LUg0YDQtdCx0YDQviDQuiDQtNGA0YPQs9C+0LzRgyDRg9C30LvRgywg0YfRgtC+0LHRiyDRgdC+0LXQtNC40L3QuNGC0Ywg0LjRhS5cIixcbiAgZWRpdDogXCLQoNC10LTQsNC60YLQuNGA0L7QstCw0YLRjFwiLFxuICBlZGl0Q2x1c3RlckVycm9yOiBcItCa0LvQsNGB0YLQtdGA0Ysg0L3QtdC00L7RgdGC0YPQv9C90Ysg0LTQu9GPINGA0LXQtNCw0LrRgtC40YDQvtCy0LDQvdC40Y8uXCIsXG4gIGVkaXRFZGdlOiBcItCg0LXQtNCw0LrRgtC40YDQvtCy0LDRgtGMINGA0LXQsdGA0L5cIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCLQmtC70LjQutC90LjRgtC1INC90LAg0LrQvtC90YLRgNC+0LvRjNC90YvQtSDRgtC+0YfQutC4INC4INC/0LXRgNC10YLQsNGJ0LjRgtC1INC40YUg0LIg0YPQt9C10LssINGH0YLQvtCx0Ysg0L/QvtC00LrQu9GO0YfQuNGC0YzRgdGPINC6INC90LXQvNGDLlwiLFxuICBlZGl0Tm9kZTogXCLQoNC10LTQsNC60YLQuNGA0L7QstCw0YLRjCDRg9C30LXQu1wiXG59O1xuLy8gQ2hpbmVzZVxudmFyIGNuID0ge1xuICBhZGREZXNjcmlwdGlvbjogXCLljZXlh7vnqbrnmb3lpITmlL7nva7mlrDoioLngrnjgIJcIixcbiAgYWRkRWRnZTogXCLmt7vliqDov57mjqXnur9cIixcbiAgYWRkTm9kZTogXCLmt7vliqDoioLngrlcIixcbiAgYmFjazogXCLov5Tlm55cIixcbiAgY2xvc2U6IFwi6Zec6ZaJXCIsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogXCLml6Dms5XlsIbov57mjqXnur/ov57mjqXliLDnvqTpm4bjgIJcIixcbiAgZGVsOiBcIuWIoOmZpOmAieWumlwiLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6IFwi5peg5rOV5Yig6Zmk576k6ZuG44CCXCIsXG4gIGVkZ2VEZXNjcmlwdGlvbjogXCLljZXlh7vmn5DkuKroioLngrnlubblsIbor6Xov57mjqXnur/mi5bliqjliLDlj6bkuIDkuKroioLngrnku6Xov57mjqXlroPku6zjgIJcIixcbiAgZWRpdDogXCLnvJbovpFcIixcbiAgZWRpdENsdXN0ZXJFcnJvcjogXCLml6Dms5XnvJbovpHnvqTpm4bjgIJcIixcbiAgZWRpdEVkZ2U6IFwi57yW6L6R6L+e5o6l57q/XCIsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246IFwi5Y2V5Ye75o6n5Yi26IqC54K55bm25bCG5a6D5Lus5ouW5Yiw6IqC54K55LiK6L+e5o6l44CCXCIsXG4gIGVkaXROb2RlOiBcIue8lui+keiKgueCuVwiXG59O1xuLy8gVWtyYWluaWFuXG52YXIgdWsgPSB7XG4gIGFkZERlc2NyaXB0aW9uOiBcIkvQu9GW0LrQvdGW0YLRjCDQvdCwINCy0ZbQu9GM0L3QtSDQvNGW0YHRhtC1LCDRidC+0LEg0LTQvtC00LDRgtC4INC90L7QstC40Lkg0LLRg9C30L7Quy5cIixcbiAgYWRkRWRnZTogXCLQlNC+0LTQsNGC0Lgg0LrRgNCw0LlcIixcbiAgYWRkTm9kZTogXCLQlNC+0LTQsNGC0Lgg0LLRg9C30L7Qu1wiLFxuICBiYWNrOiBcItCd0LDQt9Cw0LRcIixcbiAgY2xvc2U6IFwi0JfQsNC60YDQuNGC0LhcIixcbiAgY3JlYXRlRWRnZUVycm9yOiBcItCd0LUg0LzQvtC20LvQuNCy0L4g0L7QsSfRlNC00L3QsNGC0Lgg0LrRgNCw0Zcg0LIg0LPRgNGD0L/Rgy5cIixcbiAgZGVsOiBcItCS0LjQtNCw0LvQuNGC0Lgg0L7QsdGA0LDQvdC1XCIsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogXCLQk9GA0YPQv9C4INC90LUg0LzQvtC20YPRgtGMINCx0YPRgtC4INCy0LjQtNCw0LvQtdC90ZYuXCIsXG4gIGVkZ2VEZXNjcmlwdGlvbjogXCLQmtC70ZbQutC90ZbRgtGMINC90LAg0LLRg9C30L7QuyDRliDQv9C10YDQtdGC0Y/Qs9C90ZbRgtGMINC60YDQsNC5INC00L4g0ZbQvdGI0L7Qs9C+INCy0YPQt9C70LAsINGJ0L7QsSDRl9GFINC3J9GU0LTQvdCw0YLQuC5cIixcbiAgZWRpdDogXCLQoNC10LTQsNCz0YPQstCw0YLQuFwiLFxuICBlZGl0Q2x1c3RlckVycm9yOiBcItCT0YDRg9C/0Lgg0L3QtdC00L7RgdGC0YPQv9C90ZYg0LTQu9GPINGA0LXQtNCw0LPRg9Cy0LDQvdC90Y8uXCIsXG4gIGVkaXRFZGdlOiBcItCg0LXQtNCw0LPRg9Cy0LDRgtC4INC60YDQsNC5XCIsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246IFwi0JrQu9GW0LrQvdGW0YLRjCDQvdCwINC60L7QvdGC0YDQvtC70YzQvdGWINGC0L7Rh9C60Lgg0ZYg0L/QtdGA0LXRgtGP0LPQvdGW0YLRjCDRl9GFINGDINCy0YPQt9C+0LssINGJ0L7QsSDQv9GW0LTQutC70Y7Rh9C40YLQuNGB0Y8g0LTQviDQvdGM0L7Qs9C+LlwiLFxuICBlZGl0Tm9kZTogXCLQoNC10LTQsNCz0YPQstCw0YLQuCDQstGD0LfQvtC7XCJcbn07XG4vLyBGcmVuY2hcbnZhciBmciA9IHtcbiAgYWRkRGVzY3JpcHRpb246IFwiQ2xpcXVleiBkYW5zIHVuIGVuZHJvaXQgdmlkZSBwb3VyIHBsYWNlciB1biBuxZN1ZC5cIixcbiAgYWRkRWRnZTogXCJBam91dGVyIHVuIGxpZW5cIixcbiAgYWRkTm9kZTogXCJBam91dGVyIHVuIG7Fk3VkXCIsXG4gIGJhY2s6IFwiUmV0b3VyXCIsXG4gIGNsb3NlOiBcIkZlcm1lclwiLFxuICBjcmVhdGVFZGdlRXJyb3I6IFwiSW1wb3NzaWJsZSBkZSBjcsOpZXIgdW4gbGllbiB2ZXJzIHVuIGNsdXN0ZXIuXCIsXG4gIGRlbDogXCJFZmZhY2VyIGxhIHPDqWxlY3Rpb25cIixcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiBcIkxlcyBjbHVzdGVycyBuZSBwZXV2ZW50IHBhcyDDqnRyZSBlZmZhY8Opcy5cIixcbiAgZWRnZURlc2NyaXB0aW9uOiBcIkNsaXF1ZXogc3VyIHVuIG7Fk3VkIGV0IGdsaXNzZXogbGUgbGllbiB2ZXJzIHVuIGF1dHJlIG7Fk3VkIHBvdXIgbGVzIGNvbm5lY3Rlci5cIixcbiAgZWRpdDogXCLDiWRpdGVyXCIsXG4gIGVkaXRDbHVzdGVyRXJyb3I6IFwiTGVzIGNsdXN0ZXJzIG5lIHBldXZlbnQgcGFzIMOqdHJlIMOpZGl0w6lzLlwiLFxuICBlZGl0RWRnZTogXCLDiWRpdGVyIGxlIGxpZW5cIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCJDbGlxdWV6IHN1ciBsZXMgcG9pbnRzIGRlIGNvbnRyw7RsZSBldCBnbGlzc2V6LWxlcyBwb3VyIGNvbm5lY3RlciB1biBuxZN1ZC5cIixcbiAgZWRpdE5vZGU6IFwiw4lkaXRlciBsZSBuxZN1ZFwiXG59O1xuLy8gQ3plY2hcbnZhciBjcyA9IHtcbiAgYWRkRGVzY3JpcHRpb246IFwiS2x1a251dMOtbSBkbyBwcsOhemRuw6lobyBwcm9zdG9ydSBtxa/FvmV0ZSBwxZlpZGF0IG5vdsO9IHZyY2hvbC5cIixcbiAgYWRkRWRnZTogXCJQxZlpZGF0IGhyYW51XCIsXG4gIGFkZE5vZGU6IFwiUMWZaWRhdCB2cmNob2xcIixcbiAgYmFjazogXCJacMSbdFwiLFxuICBjbG9zZTogXCJaYXbFmcOtdFwiLFxuICBjcmVhdGVFZGdlRXJyb3I6IFwiTmVsemUgcMWZaXBvaml0IGhyYW51IGtlIHNobHVrdS5cIixcbiAgZGVsOiBcIlNtYXphdCB2w71ixJtyXCIsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogXCJOZWx6ZSBtYXphdCBzaGx1a3kuXCIsXG4gIGVkZ2VEZXNjcmlwdGlvbjogXCJQxZlldGHFvmVuw61tIHogamVkbm9obyB2cmNob2x1IGRvIGRydWjDqWhvIG3Fr8W+ZXRlIHNwb2ppdCB0eXRvIHZyY2hvbHkgbm92b3UgaHJhbm91LlwiLFxuICBlZGl0OiBcIlVwcmF2aXRcIixcbiAgZWRpdENsdXN0ZXJFcnJvcjogXCJOZWx6ZSB1cHJhdm92YXQgc2hsdWt5LlwiLFxuICBlZGl0RWRnZTogXCJVcHJhdml0IGhyYW51XCIsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246IFwiUMWZZXRhxb5lbsOtbSBrb250cm9sbsOtaG8gdnJjaG9sdSBocmFueSBqaSBtxa/FvmV0ZSBwxZlpcG9qaXQgayBqaW7DqW11IHZyY2hvbHUuXCIsXG4gIGVkaXROb2RlOiBcIlVwcmF2aXQgdnJjaG9sXCJcbn07XG5cbnZhciBsb2NhbGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdGNuOiBjbixcblx0Y3M6IGNzLFxuXHRkZTogZGUsXG5cdGVuOiBlbixcblx0ZXM6IGVzLFxuXHRmcjogZnIsXG5cdGl0OiBpdCxcblx0bmw6IG5sLFxuXHRwdDogcHQsXG5cdHJ1OiBydSxcblx0dWs6IHVrXG59KTtcblxuLyoqXHJcbiAqIE5vcm1hbGl6ZXMgbGFuZ3VhZ2UgY29kZSBpbnRvIHRoZSBmb3JtYXQgdXNlZCBpbnRlcm5hbGx5LlxyXG4gKlxyXG4gKiBAcGFyYW0gbG9jYWxlcyAtIEFsbCB0aGUgYXZhaWxhYmxlIGxvY2FsZXMuXHJcbiAqIEBwYXJhbSByYXdDb2RlIC0gVGhlIG9yaWdpbmFsIGNvZGUgYXMgc3VwcGxpZWQgYnkgdGhlIHVzZXIuXHJcbiAqIEByZXR1cm5zIExhbmd1YWdlIGNvZGUgaW4gdGhlIGZvcm1hdCBsYW5ndWFnZS1DT1VOVFJZIG9yIGxhbmd1YWdlLCBldmVudHVhbGx5XHJcbiAqIGZhbGxiYWNrcyB0byBlbi5cclxuICovXG5mdW5jdGlvbiBub3JtYWxpemVMYW5ndWFnZUNvZGUobG9jYWxlcywgcmF3Q29kZSkge1xuICB0cnkge1xuICAgIHZhciBfcmF3Q29kZSRzcGxpdCA9IHJhd0NvZGUuc3BsaXQoL1stXyAvXS8sIDIpLFxuICAgICAgX3Jhd0NvZGUkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX3Jhd0NvZGUkc3BsaXQsIDIpLFxuICAgICAgcmF3TGFuZ3VhZ2UgPSBfcmF3Q29kZSRzcGxpdDJbMF0sXG4gICAgICByYXdDb3VudHJ5ID0gX3Jhd0NvZGUkc3BsaXQyWzFdO1xuICAgIHZhciBsYW5ndWFnZSA9IHJhd0xhbmd1YWdlICE9IG51bGwgPyByYXdMYW5ndWFnZS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbiAgICB2YXIgY291bnRyeSA9IHJhd0NvdW50cnkgIT0gbnVsbCA/IHJhd0NvdW50cnkudG9VcHBlckNhc2UoKSA6IG51bGw7XG4gICAgaWYgKGxhbmd1YWdlICYmIGNvdW50cnkpIHtcbiAgICAgIHZhciBjb2RlID0gbGFuZ3VhZ2UgKyBcIi1cIiArIGNvdW50cnk7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGxvY2FsZXMsIGNvZGUpKSB7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9jb250ZXh0O1xuICAgICAgICBjb25zb2xlLndhcm4oX2NvbmNhdEluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQgPSBcIlVua25vd24gdmFyaWFudCBcIi5jb25jYXQoY291bnRyeSwgXCIgb2YgbGFuZ3VhZ2UgXCIpKS5jYWxsKF9jb250ZXh0LCBsYW5ndWFnZSwgXCIuXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhbmd1YWdlKSB7XG4gICAgICB2YXIgX2NvZGUgPSBsYW5ndWFnZTtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobG9jYWxlcywgX2NvZGUpKSB7XG4gICAgICAgIHJldHVybiBfY29kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVua25vd24gbGFuZ3VhZ2UgXCIuY29uY2F0KGxhbmd1YWdlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUud2FybihcIlVua25vd24gbG9jYWxlIFwiLmNvbmNhdChyYXdDb2RlLCBcIiwgZmFsbGluZyBiYWNrIHRvIEVuZ2xpc2guXCIpKTtcbiAgICByZXR1cm4gXCJlblwiO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIGNvbnNvbGUud2FybihcIlVuZXhwZWN0ZWQgZXJyb3Igd2hpbGUgbm9ybWFsaXppbmcgbG9jYWxlIFwiLmNvbmNhdChyYXdDb2RlLCBcIiwgZmFsbGluZyBiYWNrIHRvIEVuZ2xpc2guXCIpKTtcbiAgICByZXR1cm4gXCJlblwiO1xuICB9XG59XG5cbi8qKlxuICogQXNzb2NpYXRlcyBhIGNhbnZhcyB0byBhIGdpdmVuIGltYWdlLCBjb250YWluaW5nIGEgbnVtYmVyIG9mIHJlbmRlcmluZ3NcbiAqIG9mIHRoZSBpbWFnZSBhdCB2YXJpb3VzIHNpemVzLlxuICpcbiAqIFRoaXMgdGVjaG5pcXVlIGlzIGtub3duIGFzICdtaXBtYXBwaW5nJy5cbiAqXG4gKiBOT1RFOiBJbWFnZXMgY2FuIGFsc28gYmUgb2YgdHlwZSAnZGF0YTpzdmcreG1sYC4gVGhpcyBjb2RlIGFsc28gd29ya3NcbiAqICAgICAgIGZvciBzdmcsIGJ1dCB0aGUgbWlwbWFwcGluZyBtYXkgbm90IGJlIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVxuICovXG52YXIgQ2FjaGVkSW1hZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZnVuY3Rpb24gQ2FjaGVkSW1hZ2UoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhY2hlZEltYWdlKTtcbiAgICB0aGlzLk5VTV9JVEVSQVRJT05TID0gNDsgLy8gTnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBjb29yZGluYXRlcyBhcnJheVxuXG4gICAgdGhpcy5pbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgaW1hZ2UgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGxvYWRlZC5cbiAgICovXG4gIF9jcmVhdGVDbGFzcyhDYWNoZWRJbWFnZSwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQoKSkgcmV0dXJuO1xuICAgICAgdGhpcy5zcmMgPSB0aGlzLmltYWdlLnNyYzsgLy8gRm9yIHNhbWUgaW50ZXJmYWNlIHdpdGggSW1hZ2VcbiAgICAgIHZhciB3ID0gdGhpcy5pbWFnZS53aWR0aDtcbiAgICAgIHZhciBoID0gdGhpcy5pbWFnZS5oZWlnaHQ7XG5cbiAgICAgIC8vIEVhc2UgZXh0ZXJuYWwgYWNjZXNzXG4gICAgICB0aGlzLndpZHRoID0gdztcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaDtcbiAgICAgIHZhciBoMiA9IE1hdGguZmxvb3IoaCAvIDIpO1xuICAgICAgdmFyIGg0ID0gTWF0aC5mbG9vcihoIC8gNCk7XG4gICAgICB2YXIgaDggPSBNYXRoLmZsb29yKGggLyA4KTtcbiAgICAgIHZhciBoMTYgPSBNYXRoLmZsb29yKGggLyAxNik7XG4gICAgICB2YXIgdzIgPSBNYXRoLmZsb29yKHcgLyAyKTtcbiAgICAgIHZhciB3NCA9IE1hdGguZmxvb3IodyAvIDQpO1xuICAgICAgdmFyIHc4ID0gTWF0aC5mbG9vcih3IC8gOCk7XG4gICAgICB2YXIgdzE2ID0gTWF0aC5mbG9vcih3IC8gMTYpO1xuXG4gICAgICAvLyBNYWtlIGNhbnZhcyBhcyBzbWFsbCBhcyBwb3NzaWJsZVxuICAgICAgdGhpcy5jYW52YXMud2lkdGggPSAzICogdzQ7XG4gICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBoMjtcblxuICAgICAgLy8gQ29vcmRpbmF0ZXMgYW5kIHNpemVzIG9mIGltYWdlcyBjb250YWluZWQgaW4gdGhlIGNhbnZhc1xuICAgICAgLy8gVmFsdWVzIHBlciByb3c6ICBbdG9wIHgsIGxlZnQgeSwgd2lkdGgsIGhlaWdodF1cblxuICAgICAgdGhpcy5jb29yZGluYXRlcyA9IFtbMCwgMCwgdzIsIGgyXSwgW3cyLCAwLCB3NCwgaDRdLCBbdzIsIGg0LCB3OCwgaDhdLCBbNSAqIHc4LCBoNCwgdzE2LCBoMTZdXTtcbiAgICAgIHRoaXMuX2ZpbGxNaXBNYXAoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBpbml0KCkgaGFzIGJlZW4gY2FsbGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbGl6ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb29yZGluYXRlcyAhPT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZHJhdyBtYWluIGltYWdlIGluIHZhcmlvdXMgc2l6ZXMgdG8gdGhlIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBUaGUgcmF0aW9uYWxlIGJlaGluZCB0aGlzIGlzIHRvIHJlZHVjZSBhcnRlZmFjdHMgZHVlIHRvIGludGVycG9sYXRpb25cbiAgICAgKiBhdCBkaWZmZXJpbmcgem9vbSBsZXZlbHMuXG4gICAgICpcbiAgICAgKiBTb3VyY2U6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xLzE4NzYxNDA0LzEyMjM1MzFcbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kcyB0YWtlcyB0aGUgcmVzaXppbmcgb3V0IG9mIHRoZSBkcmF3aW5nIGxvb3AsIGluIG9yZGVyIHRvXG4gICAgICogcmVkdWNlIHBlcmZvcm1hbmNlIG92ZXJoZWFkLlxuICAgICAqXG4gICAgICogVE9ETzogVGhlIGNvZGUgYXNzdW1lcyB0aGF0IGEgMkQgY29udGV4dCBjYW4gYWx3YXlzIGJlIGdvdHRlbi4gVGhpcyBpc1xuICAgICAqICAgICAgIG5vdCBuZWNlc3NhcmlseSB0cnVlISBPVE9ILCBpZiBub3QgdHJ1ZSB0aGVuIHVzYWdlIG9mIHRoaXMgY2xhc3NcbiAgICAgKiAgICAgICBpcyBzZW5zZWxlc3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9maWxsTWlwTWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maWxsTWlwTWFwKCkge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgICAgLy8gRmlyc3Qgem9vbS1sZXZlbCBjb21lcyBmcm9tIHRoZSBpbWFnZVxuICAgICAgdmFyIHRvID0gdGhpcy5jb29yZGluYXRlc1swXTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5pbWFnZSwgdG9bMF0sIHRvWzFdLCB0b1syXSwgdG9bM10pO1xuXG4gICAgICAvLyBUaGUgcmVzdCBhcmUgY29weSBhY3Rpb25zIGludGVybmFsIHRvIHRoZSBjYW52YXMvY29udGV4dFxuICAgICAgZm9yICh2YXIgaXRlcmF0aW9ucyA9IDE7IGl0ZXJhdGlvbnMgPCB0aGlzLk5VTV9JVEVSQVRJT05TOyBpdGVyYXRpb25zKyspIHtcbiAgICAgICAgdmFyIGZyb20gPSB0aGlzLmNvb3JkaW5hdGVzW2l0ZXJhdGlvbnMgLSAxXTtcbiAgICAgICAgdmFyIF90byA9IHRoaXMuY29vcmRpbmF0ZXNbaXRlcmF0aW9uc107XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5jYW52YXMsIGZyb21bMF0sIGZyb21bMV0sIGZyb21bMl0sIGZyb21bM10sIF90b1swXSwgX3RvWzFdLCBfdG9bMl0sIF90b1szXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyB0aGUgaW1hZ2UsIHVzaW5nIHRoZSBtaXBtYXAgaWYgbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogTWlwTWFwIGlzIG9ubHkgdXNlZCBpZiBwYXJhbSBmYWN0b3IgPiAyOyBvdGhlcndpc2UsIG9yaWdpbmFsIGJpdG1hcFxuICAgICAqIGlzIHJlc2l6ZWQuIFRoaXMgaXMgYWxzbyB1c2VkIHRvIHNraXAgbWlwbWFwIHVzYWdlLCBlLmcuIGJ5IHNldHRpbmcgZmFjdG9yID0gMVxuICAgICAqXG4gICAgICogQ3JlZGl0cyB0byAnQWxleCBkZSBNdWxkZXInIGZvciBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggIGNvbnRleHQgb24gd2hpY2ggdG8gZHJhdyB6b29tZWQgaW1hZ2VcbiAgICAgKiBAcGFyYW0ge0Zsb2F0fSBmYWN0b3Igc2NhbGUgZmFjdG9yIGF0IHdoaWNoIHRvIGRyYXdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVmdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3BcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0ltYWdlQXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3SW1hZ2VBdFBvc2l0aW9uKGN0eCwgZmFjdG9yLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCgpKSByZXR1cm47IC8vY2FuJ3QgZHJhdyBpbWFnZSB5ZXQgbm90IGludGlhbGl6ZWRcblxuICAgICAgaWYgKGZhY3RvciA+IDIpIHtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIHpvb21lZCBpbWFnZSB0byB1c2VcbiAgICAgICAgZmFjdG9yICo9IDAuNTtcbiAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgICB3aGlsZSAoZmFjdG9yID4gMiAmJiBpdGVyYXRpb25zIDwgdGhpcy5OVU1fSVRFUkFUSU9OUykge1xuICAgICAgICAgIGZhY3RvciAqPSAwLjU7XG4gICAgICAgICAgaXRlcmF0aW9ucyArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVyYXRpb25zID49IHRoaXMuTlVNX0lURVJBVElPTlMpIHtcbiAgICAgICAgICBpdGVyYXRpb25zID0gdGhpcy5OVU1fSVRFUkFUSU9OUyAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIml0ZXJhdGlvbnM6IFwiICsgaXRlcmF0aW9ucyk7XG5cbiAgICAgICAgdmFyIGZyb20gPSB0aGlzLmNvb3JkaW5hdGVzW2l0ZXJhdGlvbnNdO1xuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuY2FudmFzLCBmcm9tWzBdLCBmcm9tWzFdLCBmcm9tWzJdLCBmcm9tWzNdLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRHJhdyBpbWFnZSBkaXJlY3RseVxuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuaW1hZ2UsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDYWNoZWRJbWFnZTtcbn0oKTtcblxuLyoqXG4gKiBUaGlzIGNhbGxiYWNrIGlzIGEgY2FsbGJhY2sgdGhhdCBhY2NlcHRzIGFuIEltYWdlLlxuICpcbiAqIEBjYWxsYmFjayBJbWFnZUNhbGxiYWNrXG4gKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVxuICovXG5cbi8qKlxuICogVGhpcyBjbGFzcyBsb2FkcyBpbWFnZXMgYW5kIGtlZXBzIHRoZW0gc3RvcmVkLlxuICpcbiAqIEBwYXJhbSB7SW1hZ2VDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xudmFyIEltYWdlcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0ltYWdlQ2FsbGJhY2t9IGNhbGxiYWNrXG4gICAqL1xuICBmdW5jdGlvbiBJbWFnZXMoY2FsbGJhY2spIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW1hZ2VzKTtcbiAgICB0aGlzLmltYWdlcyA9IHt9O1xuICAgIHRoaXMuaW1hZ2VCcm9rZW4gPSB7fTtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAgICAgICAgICAgICAgICAgICAgICBUaGUgb3JpZ2luYWwgVXJsIHRoYXQgZmFpbGVkIHRvIGxvYWQsIGlmIHRoZSBicm9rZW4gaW1hZ2UgaXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZCBpdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBjYWNoZSB1c2luZyB0aGlzIFVybCBhcyB0aGUga2V5IHNvIHRoYXQgc3Vic2VxdWVudCByZXF1ZXN0cyBmb3IgdGhpcyBVcmwgd2lsbCByZXR1cm4gdGhlIGJyb2tlbiBpbWFnZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYnJva2VuVXJsICAgICAgICAgICAgICAgIFVybCB0aGUgYnJva2VuIGltYWdlIHRvIHRyeSBhbmQgbG9hZFxuICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVRvTG9hZEJyb2tlblVybE9uICAgVGhlIGltYWdlIG9iamVjdFxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKEltYWdlcywgW3tcbiAgICBrZXk6IFwiX3RyeWxvYWRCcm9rZW5VcmxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RyeWxvYWRCcm9rZW5VcmwodXJsLCBicm9rZW5VcmwsIGltYWdlVG9Mb2FkQnJva2VuVXJsT24pIHtcbiAgICAgIC8vSWYgdGhlc2UgcGFyYW1ldGVycyBhcmVuJ3Qgc3BlY2lmaWVkIHRoZW4gZXhpdCB0aGUgZnVuY3Rpb24gYmVjYXVzZSBub3RoaW5nIGNvbnN0cnVjdGl2ZSBjYW4gYmUgZG9uZVxuICAgICAgaWYgKHVybCA9PT0gdW5kZWZpbmVkIHx8IGltYWdlVG9Mb2FkQnJva2VuVXJsT24gPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgaWYgKGJyb2tlblVybCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIk5vIGJyb2tlbiB1cmwgaW1hZ2UgZGVmaW5lZFwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvL0NsZWFyIHRoZSBvbGQgc3Vic2NyaXB0aW9uIHRvIHRoZSBlcnJvciBldmVudCBhbmQgcHV0IGEgbmV3IGluIHBsYWNlIHRoYXQgb25seSBoYW5kbGUgZXJyb3JzIGluIGxvYWRpbmcgdGhlIGJyb2tlbkltYWdlVXJsXG4gICAgICBpbWFnZVRvTG9hZEJyb2tlblVybE9uLmltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb3VsZCBub3QgbG9hZCBicm9rZW5JbWFnZTpcIiwgYnJva2VuVXJsKTtcbiAgICAgICAgLy8gY2FjaGUgaXRlbSB3aWxsIGNvbnRhaW4gZW1wdHkgaW1hZ2UsIHRoaXMgc2hvdWxkIGJlIE9LIGZvciBkZWZhdWx0XG4gICAgICB9O1xuXG4gICAgICAvL1NldCB0aGUgc291cmNlIG9mIHRoZSBpbWFnZSB0byB0aGUgYnJva2VuVXJsLCB0aGlzIGlzIGFjdHVhbGx5IHdoYXQga2lja3Mgb2ZmIHRoZSBsb2FkaW5nIG9mIHRoZSBicm9rZW4gaW1hZ2VcbiAgICAgIGltYWdlVG9Mb2FkQnJva2VuVXJsT24uaW1hZ2Uuc3JjID0gYnJva2VuVXJsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuSW1hZ2V9IGltYWdlVG9SZWRyYXdXaXRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfcmVkcmF3V2l0aEltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWRyYXdXaXRoSW1hZ2UoaW1hZ2VUb1JlZHJhd1dpdGgpIHtcbiAgICAgIGlmICh0aGlzLmNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soaW1hZ2VUb1JlZHJhd1dpdGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgICAgICAgICAgVXJsIG9mIHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBicm9rZW5VcmwgICAgVXJsIG9mIGFuIGltYWdlIHRvIHVzZSBpZiB0aGUgdXJsIGltYWdlIGlzIG5vdCBmb3VuZFxuICAgICAqIEByZXR1cm5zIHtJbWFnZX0gaW1nICAgICAgICAgIFRoZSBpbWFnZSBvYmplY3RcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQodXJsLCBicm9rZW5VcmwpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAvL1RyeSBhbmQgZ2V0IHRoZSBpbWFnZSBmcm9tIHRoZSBjYWNoZSwgaWYgc3VjY2Vzc2Z1bCB0aGVuIHJldHVybiB0aGUgY2FjaGVkIGltYWdlXG4gICAgICB2YXIgY2FjaGVkSW1hZ2UgPSB0aGlzLmltYWdlc1t1cmxdO1xuICAgICAgaWYgKGNhY2hlZEltYWdlKSByZXR1cm4gY2FjaGVkSW1hZ2U7XG5cbiAgICAgIC8vQ3JlYXRlIGEgbmV3IGltYWdlXG4gICAgICB2YXIgaW1nID0gbmV3IENhY2hlZEltYWdlKCk7XG5cbiAgICAgIC8vIE5lZWQgdG8gYWRkIHRvIGNhY2hlIGhlcmUsIG90aGVyd2lzZSBmaW5hbCByZXR1cm4gd2lsbCBzcGF3biBkaWZmZXJlbnQgY29waWVzIG9mIHRoZSBzYW1lIGltYWdlLFxuICAgICAgLy8gQWxzbywgdGhlcmUgd2lsbCBiZSBtdWx0aXBsZSBsb2FkcyBvZiB0aGUgc2FtZSBpbWFnZS5cbiAgICAgIHRoaXMuaW1hZ2VzW3VybF0gPSBpbWc7XG5cbiAgICAgIC8vU3Vic2NyaWJlIHRvIHRoZSBldmVudCB0aGF0IGlzIHJhaXNlZCBpZiB0aGUgaW1hZ2UgbG9hZHMgc3VjY2Vzc2Z1bGx5XG4gICAgICBpbWcuaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQcm9wZXJseSBpbml0IHRoZSBjYWNoZWQgaXRlbSBhbmQgdGhlbiByZXF1ZXN0IGEgcmVkcmF3XG4gICAgICAgIF90aGlzLl9maXhJbWFnZUNvb3JkaW5hdGVzKGltZy5pbWFnZSk7XG4gICAgICAgIGltZy5pbml0KCk7XG4gICAgICAgIF90aGlzLl9yZWRyYXdXaXRoSW1hZ2UoaW1nKTtcbiAgICAgIH07XG5cbiAgICAgIC8vU3Vic2NyaWJlIHRvIHRoZSBldmVudCB0aGF0IGlzIHJhaXNlZCBpZiB0aGUgaW1hZ2UgZmFpbHMgdG8gbG9hZFxuICAgICAgaW1nLmltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb3VsZCBub3QgbG9hZCBpbWFnZTpcIiwgdXJsKTtcbiAgICAgICAgLy9UcnkgYW5kIGxvYWQgdGhlIGltYWdlIHNwZWNpZmllZCBieSB0aGUgYnJva2VuVXJsIHVzaW5nXG4gICAgICAgIF90aGlzLl90cnlsb2FkQnJva2VuVXJsKHVybCwgYnJva2VuVXJsLCBpbWcpO1xuICAgICAgfTtcblxuICAgICAgLy9TZXQgdGhlIHNvdXJjZSBvZiB0aGUgaW1hZ2UgdG8gdGhlIHVybCwgdGhpcyBpcyB3aGF0IGFjdHVhbGx5IGtpY2tzIG9mZiB0aGUgbG9hZGluZyBvZiB0aGUgaW1hZ2VcbiAgICAgIGltZy5pbWFnZS5zcmMgPSB1cmw7XG5cbiAgICAgIC8vUmV0dXJuIHRoZSBuZXcgaW1hZ2VcbiAgICAgIHJldHVybiBpbWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSUUxMSBmaXggLS0gdGhhbmtzIGRwb25jaCFcbiAgICAgKlxuICAgICAqIExvY2FsIGhlbHBlciBmdW5jdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuSW1hZ2V9IGltYWdlVG9DYWNoZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpeEltYWdlQ29vcmRpbmF0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpeEltYWdlQ29vcmRpbmF0ZXMoaW1hZ2VUb0NhY2hlKSB7XG4gICAgICBpZiAoaW1hZ2VUb0NhY2hlLndpZHRoID09PSAwKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW1hZ2VUb0NhY2hlKTtcbiAgICAgICAgaW1hZ2VUb0NhY2hlLndpZHRoID0gaW1hZ2VUb0NhY2hlLm9mZnNldFdpZHRoO1xuICAgICAgICBpbWFnZVRvQ2FjaGUuaGVpZ2h0ID0gaW1hZ2VUb0NhY2hlLm9mZnNldEhlaWdodDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpbWFnZVRvQ2FjaGUpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSW1hZ2VzO1xufSgpO1xuXG52YXIgaW50ZXJuYWxNZXRhZGF0YSA9IHtleHBvcnRzOiB7fX07XG5cbi8vIEZGMjYtIGJ1ZzogQXJyYXlCdWZmZXJzIGFyZSBub24tZXh0ZW5zaWJsZSwgYnV0IE9iamVjdC5pc0V4dGVuc2libGUgZG9lcyBub3QgcmVwb3J0IGl0XG52YXIgZmFpbHMkOSA9IGZhaWxzJHc7XG5cbnZhciBhcnJheUJ1ZmZlck5vbkV4dGVuc2libGUgPSBmYWlscyQ5KGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig4KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWlzZXh0ZW5zaWJsZSwgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbiAgICBpZiAoT2JqZWN0LmlzRXh0ZW5zaWJsZShidWZmZXIpKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoYnVmZmVyLCAnYScsIHsgdmFsdWU6IDggfSk7XG4gIH1cbn0pO1xuXG52YXIgZmFpbHMkOCA9IGZhaWxzJHc7XG52YXIgaXNPYmplY3QkNiA9IGlzT2JqZWN0JGo7XG52YXIgY2xhc3NvZiQyID0gY2xhc3NvZlJhdyQyO1xudmFyIEFSUkFZX0JVRkZFUl9OT05fRVhURU5TSUJMRSA9IGFycmF5QnVmZmVyTm9uRXh0ZW5zaWJsZTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1pc2V4dGVuc2libGUgLS0gc2FmZVxudmFyICRpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xudmFyIEZBSUxTX09OX1BSSU1JVElWRVMkMSA9IGZhaWxzJDgoZnVuY3Rpb24gKCkgeyAkaXNFeHRlbnNpYmxlKDEpOyB9KTtcblxuLy8gYE9iamVjdC5pc0V4dGVuc2libGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuaXNleHRlbnNpYmxlXG52YXIgb2JqZWN0SXNFeHRlbnNpYmxlID0gKEZBSUxTX09OX1BSSU1JVElWRVMkMSB8fCBBUlJBWV9CVUZGRVJfTk9OX0VYVEVOU0lCTEUpID8gZnVuY3Rpb24gaXNFeHRlbnNpYmxlKGl0KSB7XG4gIGlmICghaXNPYmplY3QkNihpdCkpIHJldHVybiBmYWxzZTtcbiAgaWYgKEFSUkFZX0JVRkZFUl9OT05fRVhURU5TSUJMRSAmJiBjbGFzc29mJDIoaXQpID09PSAnQXJyYXlCdWZmZXInKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZShpdCkgOiB0cnVlO1xufSA6ICRpc0V4dGVuc2libGU7XG5cbnZhciBmYWlscyQ3ID0gZmFpbHMkdztcblxudmFyIGZyZWV6aW5nID0gIWZhaWxzJDcoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWlzZXh0ZW5zaWJsZSwgZXMvbm8tb2JqZWN0LXByZXZlbnRleHRlbnNpb25zIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG5cbnZhciAkJGcgPSBfZXhwb3J0O1xudmFyIHVuY3VycnlUaGlzJDQgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGhpZGRlbktleXMgPSBoaWRkZW5LZXlzJDY7XG52YXIgaXNPYmplY3QkNSA9IGlzT2JqZWN0JGo7XG52YXIgaGFzT3duJDMgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGRlZmluZVByb3BlcnR5JDIgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbE1vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbDtcbnZhciBpc0V4dGVuc2libGUkMSA9IG9iamVjdElzRXh0ZW5zaWJsZTtcbnZhciB1aWQgPSB1aWQkNDtcbnZhciBGUkVFWklORyQxID0gZnJlZXppbmc7XG5cbnZhciBSRVFVSVJFRCA9IGZhbHNlO1xudmFyIE1FVEFEQVRBID0gdWlkKCdtZXRhJyk7XG52YXIgaWQkMSA9IDA7XG5cbnZhciBzZXRNZXRhZGF0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBkZWZpbmVQcm9wZXJ0eSQyKGl0LCBNRVRBREFUQSwgeyB2YWx1ZToge1xuICAgIG9iamVjdElEOiAnTycgKyBpZCQxKyssIC8vIG9iamVjdCBJRFxuICAgIHdlYWtEYXRhOiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcblxudmFyIGZhc3RLZXkkMSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBhIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0JDUoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZiAoIWhhc093biQzKGl0LCBNRVRBREFUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlJDEoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhZGF0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQURBVEFdLm9iamVjdElEO1xufTtcblxudmFyIGdldFdlYWtEYXRhJDEgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhc093biQzKGl0LCBNRVRBREFUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlJDEoaXQpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhZGF0YShpdCk7XG4gIC8vIHJldHVybiB0aGUgc3RvcmUgb2Ygd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQURBVEFdLndlYWtEYXRhO1xufTtcblxuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaSU5HJDEgJiYgUkVRVUlSRUQgJiYgaXNFeHRlbnNpYmxlJDEoaXQpICYmICFoYXNPd24kMyhpdCwgTUVUQURBVEEpKSBzZXRNZXRhZGF0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cbnZhciBlbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gIG1ldGEuZW5hYmxlID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuICBSRVFVSVJFRCA9IHRydWU7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mO1xuICB2YXIgc3BsaWNlID0gdW5jdXJyeVRoaXMkNChbXS5zcGxpY2UpO1xuICB2YXIgdGVzdCA9IHt9O1xuICB0ZXN0W01FVEFEQVRBXSA9IDE7XG5cbiAgLy8gcHJldmVudCBleHBvc2luZyBvZiBtZXRhZGF0YSBrZXlcbiAgaWYgKGdldE93blByb3BlcnR5TmFtZXModGVzdCkubGVuZ3RoKSB7XG4gICAgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyZXN1bHRbaV0gPT09IE1FVEFEQVRBKSB7XG4gICAgICAgICAgc3BsaWNlKHJlc3VsdCwgaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgJCRnKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiB0cnVlIH0sIHtcbiAgICAgIGdldE93blByb3BlcnR5TmFtZXM6IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbE1vZHVsZS5mXG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBtZXRhID0gaW50ZXJuYWxNZXRhZGF0YS5leHBvcnRzID0ge1xuICBlbmFibGU6IGVuYWJsZSxcbiAgZmFzdEtleTogZmFzdEtleSQxLFxuICBnZXRXZWFrRGF0YTogZ2V0V2Vha0RhdGEkMSxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuXG5oaWRkZW5LZXlzW01FVEFEQVRBXSA9IHRydWU7XG5cbnZhciBpbnRlcm5hbE1ldGFkYXRhRXhwb3J0cyA9IGludGVybmFsTWV0YWRhdGEuZXhwb3J0cztcblxudmFyIGJpbmQkNSA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgY2FsbCQxID0gZnVuY3Rpb25DYWxsO1xudmFyIGFuT2JqZWN0JDMgPSBhbk9iamVjdCRkO1xudmFyIHRyeVRvU3RyaW5nJDEgPSB0cnlUb1N0cmluZyQ2O1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IGlzQXJyYXlJdGVyYXRvck1ldGhvZCQyO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDIgPSBsZW5ndGhPZkFycmF5TGlrZSRjO1xudmFyIGlzUHJvdG90eXBlT2YkNiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgZ2V0SXRlcmF0b3IgPSBnZXRJdGVyYXRvciQyO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QkOTtcbnZhciBpdGVyYXRvckNsb3NlID0gaXRlcmF0b3JDbG9zZSQyO1xuXG52YXIgJFR5cGVFcnJvciQzID0gVHlwZUVycm9yO1xuXG52YXIgUmVzdWx0ID0gZnVuY3Rpb24gKHN0b3BwZWQsIHJlc3VsdCkge1xuICB0aGlzLnN0b3BwZWQgPSBzdG9wcGVkO1xuICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbn07XG5cbnZhciBSZXN1bHRQcm90b3R5cGUgPSBSZXN1bHQucHJvdG90eXBlO1xuXG52YXIgaXRlcmF0ZSQzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCB1bmJvdW5kRnVuY3Rpb24sIG9wdGlvbnMpIHtcbiAgdmFyIHRoYXQgPSBvcHRpb25zICYmIG9wdGlvbnMudGhhdDtcbiAgdmFyIEFTX0VOVFJJRVMgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuQVNfRU5UUklFUyk7XG4gIHZhciBJU19SRUNPUkQgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSVNfUkVDT1JEKTtcbiAgdmFyIElTX0lURVJBVE9SID0gISEob3B0aW9ucyAmJiBvcHRpb25zLklTX0lURVJBVE9SKTtcbiAgdmFyIElOVEVSUlVQVEVEID0gISEob3B0aW9ucyAmJiBvcHRpb25zLklOVEVSUlVQVEVEKTtcbiAgdmFyIGZuID0gYmluZCQ1KHVuYm91bmRGdW5jdGlvbiwgdGhhdCk7XG4gIHZhciBpdGVyYXRvciwgaXRlckZuLCBpbmRleCwgbGVuZ3RoLCByZXN1bHQsIG5leHQsIHN0ZXA7XG5cbiAgdmFyIHN0b3AgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgaWYgKGl0ZXJhdG9yKSBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAnbm9ybWFsJywgY29uZGl0aW9uKTtcbiAgICByZXR1cm4gbmV3IFJlc3VsdCh0cnVlLCBjb25kaXRpb24pO1xuICB9O1xuXG4gIHZhciBjYWxsRm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoQVNfRU5UUklFUykge1xuICAgICAgYW5PYmplY3QkMyh2YWx1ZSk7XG4gICAgICByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZVswXSwgdmFsdWVbMV0sIHN0b3ApIDogZm4odmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICB9IHJldHVybiBJTlRFUlJVUFRFRCA/IGZuKHZhbHVlLCBzdG9wKSA6IGZuKHZhbHVlKTtcbiAgfTtcblxuICBpZiAoSVNfUkVDT1JEKSB7XG4gICAgaXRlcmF0b3IgPSBpdGVyYWJsZS5pdGVyYXRvcjtcbiAgfSBlbHNlIGlmIChJU19JVEVSQVRPUikge1xuICAgIGl0ZXJhdG9yID0gaXRlcmFibGU7XG4gIH0gZWxzZSB7XG4gICAgaXRlckZuID0gZ2V0SXRlcmF0b3JNZXRob2QoaXRlcmFibGUpO1xuICAgIGlmICghaXRlckZuKSB0aHJvdyBuZXcgJFR5cGVFcnJvciQzKHRyeVRvU3RyaW5nJDEoaXRlcmFibGUpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbiAgICAvLyBvcHRpbWlzYXRpb24gZm9yIGFycmF5IGl0ZXJhdG9yc1xuICAgIGlmIChpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlckZuKSkge1xuICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDIoaXRlcmFibGUpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICByZXN1bHQgPSBjYWxsRm4oaXRlcmFibGVbaW5kZXhdKTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiBpc1Byb3RvdHlwZU9mJDYoUmVzdWx0UHJvdG90eXBlLCByZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgICAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG4gICAgfVxuICAgIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoaXRlcmFibGUsIGl0ZXJGbik7XG4gIH1cblxuICBuZXh0ID0gSVNfUkVDT1JEID8gaXRlcmFibGUubmV4dCA6IGl0ZXJhdG9yLm5leHQ7XG4gIHdoaWxlICghKHN0ZXAgPSBjYWxsJDEobmV4dCwgaXRlcmF0b3IpKS5kb25lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGNhbGxGbihzdGVwLnZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgJ3Rocm93JywgZXJyb3IpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAnb2JqZWN0JyAmJiByZXN1bHQgJiYgaXNQcm90b3R5cGVPZiQ2KFJlc3VsdFByb3RvdHlwZSwgcmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG59O1xuXG52YXIgaXNQcm90b3R5cGVPZiQ1ID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcblxudmFyICRUeXBlRXJyb3IkMiA9IFR5cGVFcnJvcjtcblxudmFyIGFuSW5zdGFuY2UkMyA9IGZ1bmN0aW9uIChpdCwgUHJvdG90eXBlKSB7XG4gIGlmIChpc1Byb3RvdHlwZU9mJDUoUHJvdG90eXBlLCBpdCkpIHJldHVybiBpdDtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IkMignSW5jb3JyZWN0IGludm9jYXRpb24nKTtcbn07XG5cbnZhciAkJGYgPSBfZXhwb3J0O1xudmFyIGdsb2JhbCQ1ID0gZ2xvYmFsJG47XG52YXIgSW50ZXJuYWxNZXRhZGF0YU1vZHVsZSQxID0gaW50ZXJuYWxNZXRhZGF0YUV4cG9ydHM7XG52YXIgZmFpbHMkNiA9IGZhaWxzJHc7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDY7XG52YXIgaXRlcmF0ZSQyID0gaXRlcmF0ZSQzO1xudmFyIGFuSW5zdGFuY2UkMiA9IGFuSW5zdGFuY2UkMztcbnZhciBpc0NhbGxhYmxlID0gaXNDYWxsYWJsZSRpO1xudmFyIGlzT2JqZWN0JDQgPSBpc09iamVjdCRqO1xudmFyIGlzTnVsbE9yVW5kZWZpbmVkJDIgPSBpc051bGxPclVuZGVmaW5lZCQ2O1xudmFyIHNldFRvU3RyaW5nVGFnID0gc2V0VG9TdHJpbmdUYWckNjtcbnZhciBkZWZpbmVQcm9wZXJ0eSQxID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbnZhciBmb3JFYWNoID0gYXJyYXlJdGVyYXRpb24uZm9yRWFjaDtcbnZhciBERVNDUklQVE9SUyQ1ID0gZGVzY3JpcHRvcnM7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQyID0gaW50ZXJuYWxTdGF0ZTtcblxudmFyIHNldEludGVybmFsU3RhdGUkMiA9IEludGVybmFsU3RhdGVNb2R1bGUkMi5zZXQ7XG52YXIgaW50ZXJuYWxTdGF0ZUdldHRlckZvciQyID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQyLmdldHRlckZvcjtcblxudmFyIGNvbGxlY3Rpb24kMyA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FLCB3cmFwcGVyLCBjb21tb24pIHtcbiAgdmFyIElTX01BUCA9IENPTlNUUlVDVE9SX05BTUUuaW5kZXhPZignTWFwJykgIT09IC0xO1xuICB2YXIgSVNfV0VBSyA9IENPTlNUUlVDVE9SX05BTUUuaW5kZXhPZignV2VhaycpICE9PSAtMTtcbiAgdmFyIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJztcbiAgdmFyIE5hdGl2ZUNvbnN0cnVjdG9yID0gZ2xvYmFsJDVbQ09OU1RSVUNUT1JfTkFNRV07XG4gIHZhciBOYXRpdmVQcm90b3R5cGUgPSBOYXRpdmVDb25zdHJ1Y3RvciAmJiBOYXRpdmVDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIHZhciBleHBvcnRlZCA9IHt9O1xuICB2YXIgQ29uc3RydWN0b3I7XG5cbiAgaWYgKCFERVNDUklQVE9SUyQ1IHx8ICFpc0NhbGxhYmxlKE5hdGl2ZUNvbnN0cnVjdG9yKVxuICAgIHx8ICEoSVNfV0VBSyB8fCBOYXRpdmVQcm90b3R5cGUuZm9yRWFjaCAmJiAhZmFpbHMkNihmdW5jdGlvbiAoKSB7IG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpLmVudHJpZXMoKS5uZXh0KCk7IH0pKVxuICApIHtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIENvbnN0cnVjdG9yID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCwgQURERVIpO1xuICAgIEludGVybmFsTWV0YWRhdGFNb2R1bGUkMS5lbmFibGUoKTtcbiAgfSBlbHNlIHtcbiAgICBDb25zdHJ1Y3RvciA9IHdyYXBwZXIoZnVuY3Rpb24gKHRhcmdldCwgaXRlcmFibGUpIHtcbiAgICAgIHNldEludGVybmFsU3RhdGUkMihhbkluc3RhbmNlJDIodGFyZ2V0LCBQcm90b3R5cGUpLCB7XG4gICAgICAgIHR5cGU6IENPTlNUUlVDVE9SX05BTUUsXG4gICAgICAgIGNvbGxlY3Rpb246IG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpXG4gICAgICB9KTtcbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQkMihpdGVyYWJsZSkpIGl0ZXJhdGUkMihpdGVyYWJsZSwgdGFyZ2V0W0FEREVSXSwgeyB0aGF0OiB0YXJnZXQsIEFTX0VOVFJJRVM6IElTX01BUCB9KTtcbiAgICB9KTtcblxuICAgIHZhciBQcm90b3R5cGUgPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IkMihDT05TVFJVQ1RPUl9OQU1FKTtcblxuICAgIGZvckVhY2goWydhZGQnLCAnY2xlYXInLCAnZGVsZXRlJywgJ2ZvckVhY2gnLCAnZ2V0JywgJ2hhcycsICdzZXQnLCAna2V5cycsICd2YWx1ZXMnLCAnZW50cmllcyddLCBmdW5jdGlvbiAoS0VZKSB7XG4gICAgICB2YXIgSVNfQURERVIgPSBLRVkgPT09ICdhZGQnIHx8IEtFWSA9PT0gJ3NldCc7XG4gICAgICBpZiAoS0VZIGluIE5hdGl2ZVByb3RvdHlwZSAmJiAhKElTX1dFQUsgJiYgS0VZID09PSAnY2xlYXInKSkge1xuICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoUHJvdG90eXBlLCBLRVksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLmNvbGxlY3Rpb247XG4gICAgICAgICAgaWYgKCFJU19BRERFUiAmJiBJU19XRUFLICYmICFpc09iamVjdCQ0KGEpKSByZXR1cm4gS0VZID09PSAnZ2V0JyA/IHVuZGVmaW5lZCA6IGZhbHNlO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBjb2xsZWN0aW9uW0tFWV0oYSA9PT0gMCA/IDAgOiBhLCBiKTtcbiAgICAgICAgICByZXR1cm4gSVNfQURERVIgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIElTX1dFQUsgfHwgZGVmaW5lUHJvcGVydHkkMShQcm90b3R5cGUsICdzaXplJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLmNvbGxlY3Rpb24uc2l6ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgZXhwb3J0ZWRbQ09OU1RSVUNUT1JfTkFNRV0gPSBDb25zdHJ1Y3RvcjtcbiAgJCRmKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IHRydWUgfSwgZXhwb3J0ZWQpO1xuXG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQ29uc3RydWN0b3I7XG59O1xuXG52YXIgZGVmaW5lQnVpbHRJbiA9IGRlZmluZUJ1aWx0SW4kNTtcblxudmFyIGRlZmluZUJ1aWx0SW5zJDMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudW5zYWZlICYmIHRhcmdldFtrZXldKSB0YXJnZXRba2V5XSA9IHNyY1trZXldO1xuICAgIGVsc2UgZGVmaW5lQnVpbHRJbih0YXJnZXQsIGtleSwgc3JjW2tleV0sIG9wdGlvbnMpO1xuICB9IHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgZ2V0QnVpbHRJbiQxID0gZ2V0QnVpbHRJbiRjO1xudmFyIGRlZmluZUJ1aWx0SW5BY2Nlc3NvciQxID0gZGVmaW5lQnVpbHRJbkFjY2Vzc29yJDM7XG52YXIgd2VsbEtub3duU3ltYm9sID0gd2VsbEtub3duU3ltYm9sJG07XG52YXIgREVTQ1JJUFRPUlMkNCA9IGRlc2NyaXB0b3JzO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG52YXIgc2V0U3BlY2llcyQxID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SX05BTUUpIHtcbiAgdmFyIENvbnN0cnVjdG9yID0gZ2V0QnVpbHRJbiQxKENPTlNUUlVDVE9SX05BTUUpO1xuXG4gIGlmIChERVNDUklQVE9SUyQ0ICYmIENvbnN0cnVjdG9yICYmICFDb25zdHJ1Y3RvcltTUEVDSUVTXSkge1xuICAgIGRlZmluZUJ1aWx0SW5BY2Nlc3NvciQxKENvbnN0cnVjdG9yLCBTUEVDSUVTLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICB9KTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZSQ0ID0gb2JqZWN0Q3JlYXRlO1xudmFyIGRlZmluZUJ1aWx0SW5BY2Nlc3NvciA9IGRlZmluZUJ1aWx0SW5BY2Nlc3NvciQzO1xudmFyIGRlZmluZUJ1aWx0SW5zJDIgPSBkZWZpbmVCdWlsdElucyQzO1xudmFyIGJpbmQkNCA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgYW5JbnN0YW5jZSQxID0gYW5JbnN0YW5jZSQzO1xudmFyIGlzTnVsbE9yVW5kZWZpbmVkJDEgPSBpc051bGxPclVuZGVmaW5lZCQ2O1xudmFyIGl0ZXJhdGUkMSA9IGl0ZXJhdGUkMztcbnZhciBkZWZpbmVJdGVyYXRvciA9IGl0ZXJhdG9yRGVmaW5lO1xudmFyIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QgPSBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0JDM7XG52YXIgc2V0U3BlY2llcyA9IHNldFNwZWNpZXMkMTtcbnZhciBERVNDUklQVE9SUyQzID0gZGVzY3JpcHRvcnM7XG52YXIgZmFzdEtleSA9IGludGVybmFsTWV0YWRhdGFFeHBvcnRzLmZhc3RLZXk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQxID0gaW50ZXJuYWxTdGF0ZTtcblxudmFyIHNldEludGVybmFsU3RhdGUkMSA9IEludGVybmFsU3RhdGVNb2R1bGUkMS5zZXQ7XG52YXIgaW50ZXJuYWxTdGF0ZUdldHRlckZvciQxID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQxLmdldHRlckZvcjtcblxudmFyIGNvbGxlY3Rpb25TdHJvbmckMiA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UkMSh0aGF0LCBQcm90b3R5cGUpO1xuICAgICAgc2V0SW50ZXJuYWxTdGF0ZSQxKHRoYXQsIHtcbiAgICAgICAgdHlwZTogQ09OU1RSVUNUT1JfTkFNRSxcbiAgICAgICAgaW5kZXg6IGNyZWF0ZSQ0KG51bGwpLFxuICAgICAgICBmaXJzdDogdW5kZWZpbmVkLFxuICAgICAgICBsYXN0OiB1bmRlZmluZWQsXG4gICAgICAgIHNpemU6IDBcbiAgICAgIH0pO1xuICAgICAgaWYgKCFERVNDUklQVE9SUyQzKSB0aGF0LnNpemUgPSAwO1xuICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZCQxKGl0ZXJhYmxlKSkgaXRlcmF0ZSQxKGl0ZXJhYmxlLCB0aGF0W0FEREVSXSwgeyB0aGF0OiB0aGF0LCBBU19FTlRSSUVTOiBJU19NQVAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgUHJvdG90eXBlID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4gICAgdmFyIGdldEludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yJDEoQ09OU1RSVUNUT1JfTkFNRSk7XG5cbiAgICB2YXIgZGVmaW5lID0gZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgdmFyIHByZXZpb3VzLCBpbmRleDtcbiAgICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgIGVudHJ5LnZhbHVlID0gdmFsdWU7XG4gICAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5sYXN0ID0gZW50cnkgPSB7XG4gICAgICAgICAgaW5kZXg6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLFxuICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBwcmV2aW91czogcHJldmlvdXMgPSBzdGF0ZS5sYXN0LFxuICAgICAgICAgIG5leHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICByZW1vdmVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXN0YXRlLmZpcnN0KSBzdGF0ZS5maXJzdCA9IGVudHJ5O1xuICAgICAgICBpZiAocHJldmlvdXMpIHByZXZpb3VzLm5leHQgPSBlbnRyeTtcbiAgICAgICAgaWYgKERFU0NSSVBUT1JTJDMpIHN0YXRlLnNpemUrKztcbiAgICAgICAgZWxzZSB0aGF0LnNpemUrKztcbiAgICAgICAgLy8gYWRkIHRvIGluZGV4XG4gICAgICAgIGlmIChpbmRleCAhPT0gJ0YnKSBzdGF0ZS5pbmRleFtpbmRleF0gPSBlbnRyeTtcbiAgICAgIH0gcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIHZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uICh0aGF0LCBrZXkpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICAvLyBmYXN0IGNhc2VcbiAgICAgIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KTtcbiAgICAgIHZhciBlbnRyeTtcbiAgICAgIGlmIChpbmRleCAhPT0gJ0YnKSByZXR1cm4gc3RhdGUuaW5kZXhbaW5kZXhdO1xuICAgICAgLy8gZnJvemVuIG9iamVjdCBjYXNlXG4gICAgICBmb3IgKGVudHJ5ID0gc3RhdGUuZmlyc3Q7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm5leHQpIHtcbiAgICAgICAgaWYgKGVudHJ5LmtleSA9PT0ga2V5KSByZXR1cm4gZW50cnk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRlZmluZUJ1aWx0SW5zJDIoUHJvdG90eXBlLCB7XG4gICAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZS5jbGVhcigpYCBtZXRob2RzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuY2xlYXJcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5jbGVhclxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICAgIHZhciBkYXRhID0gc3RhdGUuaW5kZXg7XG4gICAgICAgIHZhciBlbnRyeSA9IHN0YXRlLmZpcnN0O1xuICAgICAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgICAgICBlbnRyeS5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZW50cnkucHJldmlvdXMpIGVudHJ5LnByZXZpb3VzID0gZW50cnkucHJldmlvdXMubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pbmRleF07XG4gICAgICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmZpcnN0ID0gc3RhdGUubGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKERFU0NSSVBUT1JTJDMpIHN0YXRlLnNpemUgPSAwO1xuICAgICAgICBlbHNlIHRoYXQuc2l6ZSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gYHsgTWFwLCBTZXQgfS5wcm90b3R5cGUuZGVsZXRlKGtleSlgIG1ldGhvZHNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5kZWxldGVcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5kZWxldGVcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uZXh0O1xuICAgICAgICAgIHZhciBwcmV2ID0gZW50cnkucHJldmlvdXM7XG4gICAgICAgICAgZGVsZXRlIHN0YXRlLmluZGV4W2VudHJ5LmluZGV4XTtcbiAgICAgICAgICBlbnRyeS5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocHJldikgcHJldi5uZXh0ID0gbmV4dDtcbiAgICAgICAgICBpZiAobmV4dCkgbmV4dC5wcmV2aW91cyA9IHByZXY7XG4gICAgICAgICAgaWYgKHN0YXRlLmZpcnN0ID09PSBlbnRyeSkgc3RhdGUuZmlyc3QgPSBuZXh0O1xuICAgICAgICAgIGlmIChzdGF0ZS5sYXN0ID09PSBlbnRyeSkgc3RhdGUubGFzdCA9IHByZXY7XG4gICAgICAgICAgaWYgKERFU0NSSVBUT1JTJDMpIHN0YXRlLnNpemUtLTtcbiAgICAgICAgICBlbHNlIHRoYXQuc2l6ZS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIGB7IE1hcCwgU2V0IH0ucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClgIG1ldGhvZHNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5mb3JlYWNoXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuZm9yZWFjaFxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgICAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQkNChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgd2hpbGUgKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uZXh0IDogc3RhdGUuZmlyc3QpIHtcbiAgICAgICAgICBib3VuZEZ1bmN0aW9uKGVudHJ5LnZhbHVlLCBlbnRyeS5rZXksIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yZW1vdmVkKSBlbnRyeSA9IGVudHJ5LnByZXZpb3VzO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gYHsgTWFwLCBTZXR9LnByb3RvdHlwZS5oYXMoa2V5KWAgbWV0aG9kc1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmhhc1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmhhc1xuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBkZWZpbmVCdWlsdElucyQyKFByb3RvdHlwZSwgSVNfTUFQID8ge1xuICAgICAgLy8gYE1hcC5wcm90b3R5cGUuZ2V0KGtleSlgIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmdldFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52YWx1ZTtcbiAgICAgIH0sXG4gICAgICAvLyBgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlgIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLnNldFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IDoge1xuICAgICAgLy8gYFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKWAgbWV0aG9kXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuYWRkXG4gICAgICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoREVTQ1JJUFRPUlMkMykgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKFByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykuc2l6ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH0sXG4gIHNldFN0cm9uZzogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVApIHtcbiAgICB2YXIgSVRFUkFUT1JfTkFNRSA9IENPTlNUUlVDVE9SX05BTUUgKyAnIEl0ZXJhdG9yJztcbiAgICB2YXIgZ2V0SW50ZXJuYWxDb2xsZWN0aW9uU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yJDEoQ09OU1RSVUNUT1JfTkFNRSk7XG4gICAgdmFyIGdldEludGVybmFsSXRlcmF0b3JTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IkMShJVEVSQVRPUl9OQU1FKTtcbiAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZS57IGtleXMsIHZhbHVlcywgZW50cmllcywgQEBpdGVyYXRvciB9KClgIG1ldGhvZHNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuZW50cmllc1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5rZXlzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLnZhbHVlc1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmVudHJpZXNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUua2V5c1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS52YWx1ZXNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUtQEBpdGVyYXRvclxuICAgIGRlZmluZUl0ZXJhdG9yKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgICAgIHNldEludGVybmFsU3RhdGUkMSh0aGlzLCB7XG4gICAgICAgIHR5cGU6IElURVJBVE9SX05BTUUsXG4gICAgICAgIHRhcmdldDogaXRlcmF0ZWQsXG4gICAgICAgIHN0YXRlOiBnZXRJbnRlcm5hbENvbGxlY3Rpb25TdGF0ZShpdGVyYXRlZCksXG4gICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgIGxhc3Q6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxJdGVyYXRvclN0YXRlKHRoaXMpO1xuICAgICAgdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xuICAgICAgdmFyIGVudHJ5ID0gc3RhdGUubGFzdDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnJlbW92ZWQpIGVudHJ5ID0gZW50cnkucHJldmlvdXM7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYgKCFzdGF0ZS50YXJnZXQgfHwgIShzdGF0ZS5sYXN0ID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm5leHQgOiBzdGF0ZS5zdGF0ZS5maXJzdCkpIHtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdCh1bmRlZmluZWQsIHRydWUpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYgKGtpbmQgPT09ICdrZXlzJykgcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QoZW50cnkua2V5LCBmYWxzZSk7XG4gICAgICBpZiAoa2luZCA9PT0gJ3ZhbHVlcycpIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KGVudHJ5LnZhbHVlLCBmYWxzZSk7XG4gICAgICByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdChbZW50cnkua2V5LCBlbnRyeS52YWx1ZV0sIGZhbHNlKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJywgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZVtAQHNwZWNpZXNdYCBhY2Nlc3NvcnNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1tYXAtQEBzcGVjaWVzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXQtc2V0LUBAc3BlY2llc1xuICAgIHNldFNwZWNpZXMoQ09OU1RSVUNUT1JfTkFNRSk7XG4gIH1cbn07XG5cbnZhciBjb2xsZWN0aW9uJDIgPSBjb2xsZWN0aW9uJDM7XG52YXIgY29sbGVjdGlvblN0cm9uZyQxID0gY29sbGVjdGlvblN0cm9uZyQyO1xuXG4vLyBgTWFwYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAtb2JqZWN0c1xuY29sbGVjdGlvbiQyKCdNYXAnLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gTWFwKCkgeyByZXR1cm4gaW5pdCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIGNvbGxlY3Rpb25TdHJvbmckMSk7XG5cbnZhciBwYXRoJGYgPSBwYXRoJHc7XG5cbnZhciBtYXAkMiA9IHBhdGgkZi5NYXA7XG5cbnZhciBwYXJlbnQkdiA9IG1hcCQyO1xuXG5cbnZhciBtYXAkMSA9IHBhcmVudCR2O1xuXG52YXIgbWFwID0gbWFwJDE7XG5cbnZhciBfTWFwID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKG1hcCk7XG5cbi8qKlxuICogVGhpcyBjbGFzcyBjYW4gc3RvcmUgZ3JvdXBzIGFuZCBvcHRpb25zIHNwZWNpZmljIGZvciBncm91cHMuXG4gKi9cbnZhciBHcm91cHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZnVuY3Rpb24gR3JvdXBzKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHcm91cHMpO1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB0aGlzLl9kZWZhdWx0SW5kZXggPSAwO1xuICAgIHRoaXMuX2dyb3VwSW5kZXggPSAwO1xuICAgIHRoaXMuX2RlZmF1bHRHcm91cHMgPSBbe1xuICAgICAgYm9yZGVyOiBcIiMyQjdDRTlcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiIzk3QzJGQ1wiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjMkI3Q0U5XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0QyRTVGRlwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiMyQjdDRTlcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRDJFNUZGXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIDA6IGJsdWVcbiAgICB7XG4gICAgICBib3JkZXI6IFwiI0ZGQTUwMFwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjRkZGRjAwXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNGRkE1MDBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkZGRkEzXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0ZGQTUwMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRkZGQTNcIlxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gMTogeWVsbG93XG4gICAge1xuICAgICAgYm9yZGVyOiBcIiNGQTBBMTBcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiI0ZCN0U4MVwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjRkEwQTEwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGQUZCMVwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNGQTBBMTBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkZBRkIxXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIDI6IHJlZFxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjNDFBOTA2XCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiM3QkUxNDFcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiIzQxQTkwNlwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNBMUVDNzZcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjNDFBOTA2XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ExRUM3NlwiXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyAzOiBncmVlblxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjRTEyOUYwXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiNFQjdERjRcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0UxMjlGMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGMEIzRjVcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjRTEyOUYwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0YwQjNGNVwiXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyA0OiBtYWdlbnRhXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiM3QzI5RjBcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiI0FEODVFNFwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjN0MyOUYwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0QzQkRGMFwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiM3QzI5RjBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRDNCREYwXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIDU6IHB1cnBsZVxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjQzM3RjAwXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiNGRkE4MDdcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0MzN0YwMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRkNBNjZcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjQzM3RjAwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGQ0E2NlwiXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyA2OiBvcmFuZ2VcbiAgICB7XG4gICAgICBib3JkZXI6IFwiIzQyMjBGQlwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjNkU2RUZEXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiM0MjIwRkJcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjOUI5QkZEXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiIzQyMjBGQlwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiM5QjlCRkRcIlxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gNzogZGFya2JsdWVcbiAgICB7XG4gICAgICBib3JkZXI6IFwiI0ZENUE3N1wiLFxuICAgICAgYmFja2dyb3VuZDogXCIjRkZDMENCXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNGRDVBNzdcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkZEMUQ5XCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0ZENUE3N1wiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRkQxRDlcIlxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gODogcGlua1xuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjNEFENjNBXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiNDMkZBQkNcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiIzRBRDYzQVwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNFNkZGRTNcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjNEFENjNBXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0U2RkZFM1wiXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyA5OiBtaW50XG5cbiAgICB7XG4gICAgICBib3JkZXI6IFwiIzk5MDAwMFwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjRUUwMDAwXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNCQjAwMDBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkYzMzMzXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0JCMDAwMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRjMzMzNcIlxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gMTA6YnJpZ2h0IHJlZFxuXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiNGRjYwMDBcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiI0ZGNjAwMFwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjRkY2MDAwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGNjAwMFwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNGRjYwMDBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkY2MDAwXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIDEyOiByZWFsIG9yYW5nZVxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjOTdDMkZDXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiMyQjdDRTlcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0QyRTVGRlwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMyQjdDRTlcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjRDJFNUZGXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzJCN0NFOVwiXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyAxMzogYmx1ZVxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjMzk5NjA1XCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiMyNTVDMDNcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiIzM5OTYwNVwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMyNTVDMDNcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjMzk5NjA1XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzI1NUMwM1wiXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyAxNDogZ3JlZW5cbiAgICB7XG4gICAgICBib3JkZXI6IFwiI0I3MDA1NFwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjRkYwMDdFXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNCNzAwNTRcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkYwMDdFXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0I3MDA1NFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRjAwN0VcIlxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gMTU6IG1hZ2VudGFcbiAgICB7XG4gICAgICBib3JkZXI6IFwiI0FEODVFNFwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjN0MyOUYwXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNEM0JERjBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjN0MyOUYwXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0QzQkRGMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiM3QzI5RjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gMTY6IHB1cnBsZVxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjNDU1N0ZBXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiMwMDBFQTFcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiIzZFNkVGRFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMwMDBFQTFcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjNkU2RUZEXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzAwMEVBMVwiXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyAxNzogZGFya2JsdWVcbiAgICB7XG4gICAgICBib3JkZXI6IFwiI0ZGQzBDQlwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjRkQ1QTc3XCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNGRkQxRDlcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkQ1QTc3XCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0ZGRDFEOVwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRDVBNzdcIlxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gMTg6IHBpbmtcbiAgICB7XG4gICAgICBib3JkZXI6IFwiI0MyRkFCQ1wiLFxuICAgICAgYmFja2dyb3VuZDogXCIjNzRENjZBXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNFNkZGRTNcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjNzRENjZBXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0U2RkZFM1wiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiM3NEQ2NkFcIlxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gMTk6IG1pbnRcblxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjRUUwMDAwXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiM5OTAwMDBcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0ZGMzMzM1wiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNCQjAwMDBcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjRkYzMzMzXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0JCMDAwMFwiXG4gICAgICB9XG4gICAgfSAvLyAyMDpicmlnaHQgcmVkXG4gICAgXTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICB1c2VEZWZhdWx0R3JvdXBzOiB0cnVlXG4gICAgfTtcbiAgICBfT2JqZWN0JGFzc2lnbih0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoR3JvdXBzLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdmFyIG9wdGlvbkZpZWxkcyA9IFtcInVzZURlZmF1bHRHcm91cHNcIl07XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvciAodmFyIGdyb3VwTmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBncm91cE5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoX2luZGV4T2ZJbnN0YW5jZVByb3BlcnR5KG9wdGlvbkZpZWxkcykuY2FsbChvcHRpb25GaWVsZHMsIGdyb3VwTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHZhciBncm91cCA9IG9wdGlvbnNbZ3JvdXBOYW1lXTtcbiAgICAgICAgICAgICAgdGhpcy5hZGQoZ3JvdXBOYW1lLCBncm91cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIGdyb3Vwc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5fZ3JvdXBzID0gbmV3IF9NYXAoKTtcbiAgICAgIHRoaXMuX2dyb3VwTmFtZXMgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZ3JvdXAgb3B0aW9ucyBvZiBhIGdyb3VwbmFtZS5cbiAgICAgKiBJZiBncm91cG5hbWUgaXMgbm90IGZvdW5kLCBhIG5ldyBncm91cCBtYXkgYmUgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gICAgICAgZ3JvdXBuYW1lICAgICBDYW4gYmUgYSBudW1iZXIsIHN0cmluZywgRGF0ZSwgZXRjLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Nob3VsZENyZWF0ZT10cnVlXSBJZiB0cnVlLCBjcmVhdGUgYSBuZXcgZ3JvdXBcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgZm91bmQgb3IgY3JlYXRlZCBncm91cFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoZ3JvdXBuYW1lKSB7XG4gICAgICB2YXIgc2hvdWxkQ3JlYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgdmFyIGdyb3VwID0gdGhpcy5fZ3JvdXBzLmdldChncm91cG5hbWUpO1xuICAgICAgaWYgKGdyb3VwID09PSB1bmRlZmluZWQgJiYgc2hvdWxkQ3JlYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXNlRGVmYXVsdEdyb3VwcyA9PT0gZmFsc2UgJiYgdGhpcy5fZ3JvdXBOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gY3JlYXRlIG5ldyBncm91cFxuICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2dyb3VwSW5kZXggJSB0aGlzLl9ncm91cE5hbWVzLmxlbmd0aDtcbiAgICAgICAgICArK3RoaXMuX2dyb3VwSW5kZXg7XG4gICAgICAgICAgZ3JvdXAgPSB7fTtcbiAgICAgICAgICBncm91cC5jb2xvciA9IHRoaXMuX2dyb3Vwcy5nZXQodGhpcy5fZ3JvdXBOYW1lc1tpbmRleF0pO1xuICAgICAgICAgIHRoaXMuX2dyb3Vwcy5zZXQoZ3JvdXBuYW1lLCBncm91cCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY3JlYXRlIG5ldyBncm91cFxuICAgICAgICAgIHZhciBfaW5kZXggPSB0aGlzLl9kZWZhdWx0SW5kZXggJSB0aGlzLl9kZWZhdWx0R3JvdXBzLmxlbmd0aDtcbiAgICAgICAgICB0aGlzLl9kZWZhdWx0SW5kZXgrKztcbiAgICAgICAgICBncm91cCA9IHt9O1xuICAgICAgICAgIGdyb3VwLmNvbG9yID0gdGhpcy5fZGVmYXVsdEdyb3Vwc1tfaW5kZXhdO1xuICAgICAgICAgIHRoaXMuX2dyb3Vwcy5zZXQoZ3JvdXBuYW1lLCBncm91cCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgY3VzdG9tIGdyb3VwIHN0eWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGdyb3VwTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBncm91cCwgYSBuZXcgZ3JvdXAgd2lsbCBiZVxuICAgICAqIGNyZWF0ZWQgaWYgYSBncm91cCB3aXRoIHRoZSBzYW1lIG5hbWUgZG9lc24ndCBleGlzdCwgb3RoZXJ3aXNlIHRoZSBvbGRcbiAgICAgKiBncm91cHMgc3R5bGUgd2lsbCBiZSBvdmVyd3JpdHRlbi5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGUgLSBBbiBvYmplY3QgY29udGFpbmluZyBib3JkZXJDb2xvciwgYmFja2dyb3VuZENvbG9yLFxuICAgICAqIGV0Yy5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgY3JlYXRlZCBncm91cCBvYmplY3QuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChncm91cE5hbWUsIHN0eWxlKSB7XG4gICAgICAvLyBPbmx5IHB1c2ggZ3JvdXAgbmFtZSBvbmNlIHRvIHByZXZlbnQgZHVwbGljYXRlcyB3aGljaCB3b3VsZCBjb25zdW1lIG1vcmVcbiAgICAgIC8vIFJBTSBhbmQgYWxzbyBza2V3IHRoZSBkaXN0cmlidXRpb24gdG93YXJkcyBtb3JlIG9mdGVuIHVwZGF0ZWQgZ3JvdXBzLFxuICAgICAgLy8gbmVpdGhlciBvZiB3aGljaCBpcyBkZXNpcmFibGUuXG4gICAgICBpZiAoIXRoaXMuX2dyb3Vwcy5oYXMoZ3JvdXBOYW1lKSkge1xuICAgICAgICB0aGlzLl9ncm91cE5hbWVzLnB1c2goZ3JvdXBOYW1lKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2dyb3Vwcy5zZXQoZ3JvdXBOYW1lLCBzdHlsZSk7XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBHcm91cHM7XG59KCk7XG5cbnZhciAkJGUgPSBfZXhwb3J0O1xuXG4vLyBgTnVtYmVyLmlzTmFOYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbnVtYmVyLmlzbmFuXG4kJGUoeyB0YXJnZXQ6ICdOdW1iZXInLCBzdGF0OiB0cnVlIH0sIHtcbiAgaXNOYU46IGZ1bmN0aW9uIGlzTmFOKG51bWJlcikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgcmV0dXJuIG51bWJlciAhPT0gbnVtYmVyO1xuICB9XG59KTtcblxudmFyIHBhdGgkZSA9IHBhdGgkdztcblxudmFyIGlzTmFuJDIgPSBwYXRoJGUuTnVtYmVyLmlzTmFOO1xuXG52YXIgcGFyZW50JHUgPSBpc05hbiQyO1xuXG52YXIgaXNOYW4kMSA9IHBhcmVudCR1O1xuXG52YXIgaXNOYW4gPSBpc05hbiQxO1xuXG52YXIgX051bWJlciRpc05hTiA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhpc05hbik7XG5cbnZhciBnbG9iYWwkNCA9IGdsb2JhbCRuO1xuXG52YXIgZ2xvYmFsSXNGaW5pdGUgPSBnbG9iYWwkNC5pc0Zpbml0ZTtcblxuLy8gYE51bWJlci5pc0Zpbml0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW51bWJlci5pc2Zpbml0ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW51bWJlci1pc2Zpbml0ZSAtLSBzYWZlXG52YXIgbnVtYmVySXNGaW5pdGUkMSA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiBpc0Zpbml0ZShpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdudW1iZXInICYmIGdsb2JhbElzRmluaXRlKGl0KTtcbn07XG5cbnZhciAkJGQgPSBfZXhwb3J0O1xudmFyIG51bWJlcklzRmluaXRlID0gbnVtYmVySXNGaW5pdGUkMTtcblxuLy8gYE51bWJlci5pc0Zpbml0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW51bWJlci5pc2Zpbml0ZVxuJCRkKHsgdGFyZ2V0OiAnTnVtYmVyJywgc3RhdDogdHJ1ZSB9LCB7IGlzRmluaXRlOiBudW1iZXJJc0Zpbml0ZSB9KTtcblxudmFyIHBhdGgkZCA9IHBhdGgkdztcblxudmFyIF9pc0Zpbml0ZSQyID0gcGF0aCRkLk51bWJlci5pc0Zpbml0ZTtcblxudmFyIHBhcmVudCR0ID0gX2lzRmluaXRlJDI7XG5cbnZhciBfaXNGaW5pdGUkMSA9IHBhcmVudCR0O1xuXG52YXIgX2lzRmluaXRlID0gX2lzRmluaXRlJDE7XG5cbnZhciBfTnVtYmVyJGlzRmluaXRlID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKF9pc0Zpbml0ZSk7XG5cbnZhciAkJGMgPSBfZXhwb3J0O1xudmFyICRzb21lID0gYXJyYXlJdGVyYXRpb24uc29tZTtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0JDMgPSBhcnJheU1ldGhvZElzU3RyaWN0JDY7XG5cbnZhciBTVFJJQ1RfTUVUSE9EJDIgPSBhcnJheU1ldGhvZElzU3RyaWN0JDMoJ3NvbWUnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5zb21lYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvbWVcbiQkYyh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIVNUUklDVF9NRVRIT0QkMiB9LCB7XG4gIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJHNvbWUodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCQ0ID0gZW50cnlWaXJ0dWFsJGk7XG5cbnZhciBzb21lJDMgPSBlbnRyeVZpcnR1YWwkNCgnQXJyYXknKS5zb21lO1xuXG52YXIgaXNQcm90b3R5cGVPZiQ0ID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkNCA9IHNvbWUkMztcblxudmFyIEFycmF5UHJvdG90eXBlJDQgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBzb21lJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LnNvbWU7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkNCB8fCAoaXNQcm90b3R5cGVPZiQ0KEFycmF5UHJvdG90eXBlJDQsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJDQuc29tZSkgPyBtZXRob2QkNCA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQkcyA9IHNvbWUkMjtcblxudmFyIHNvbWUkMSA9IHBhcmVudCRzO1xuXG52YXIgc29tZSA9IHNvbWUkMTtcblxudmFyIF9zb21lSW5zdGFuY2VQcm9wZXJ0eSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhzb21lKTtcblxudmFyIHBhdGgkYyA9IHBhdGgkdztcblxudmFyIGdldE93blByb3BlcnR5U3ltYm9scyQyID0gcGF0aCRjLk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbnZhciBwYXJlbnQkciA9IGdldE93blByb3BlcnR5U3ltYm9scyQyO1xuXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzJDEgPSBwYXJlbnQkcjtcblxudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyQxO1xuXG52YXIgX09iamVjdCRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZ2V0T3duUHJvcGVydHlTeW1ib2xzKTtcblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ2ID0ge2V4cG9ydHM6IHt9fTtcblxudmFyICQkYiA9IF9leHBvcnQ7XG52YXIgZmFpbHMkNSA9IGZhaWxzJHc7XG52YXIgdG9JbmRleGVkT2JqZWN0JDEgPSB0b0luZGV4ZWRPYmplY3QkYTtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcbnZhciBERVNDUklQVE9SUyQyID0gZGVzY3JpcHRvcnM7XG5cbnZhciBGT1JDRUQkNSA9ICFERVNDUklQVE9SUyQyIHx8IGZhaWxzJDUoZnVuY3Rpb24gKCkgeyBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoMSk7IH0pO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcbiQkYih7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRk9SQ0VEJDUsIHNoYW06ICFERVNDUklQVE9SUyQyIH0sIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICAgIHJldHVybiBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JbmRleGVkT2JqZWN0JDEoaXQpLCBrZXkpO1xuICB9XG59KTtcblxudmFyIHBhdGgkYiA9IHBhdGgkdztcblxudmFyIE9iamVjdCQzID0gcGF0aCRiLk9iamVjdDtcblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ1ID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDYuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIHJldHVybiBPYmplY3QkMy5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSk7XG59O1xuXG5pZiAoT2JqZWN0JDMuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLnNoYW0pIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ1LnNoYW0gPSB0cnVlO1xuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yRXhwb3J0cyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ2LmV4cG9ydHM7XG5cbnZhciBwYXJlbnQkcSA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvckV4cG9ydHM7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkNCA9IHBhcmVudCRxO1xuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDMgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkNDtcblxudmFyIF9PYmplY3QkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDMpO1xuXG52YXIgJCRhID0gX2V4cG9ydDtcbnZhciBERVNDUklQVE9SUyQxID0gZGVzY3JpcHRvcnM7XG52YXIgb3duS2V5cyQ0ID0gb3duS2V5cyQ1O1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHRvSW5kZXhlZE9iamVjdCRhO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gY3JlYXRlUHJvcGVydHkkNjtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbiQkYSh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIHNoYW06ICFERVNDUklQVE9SUyQxIH0sIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3QpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUkMS5mO1xuICAgIHZhciBrZXlzID0gb3duS2V5cyQ0KE8pO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBrZXksIGRlc2NyaXB0b3I7XG4gICAgd2hpbGUgKGtleXMubGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywga2V5ID0ga2V5c1tpbmRleCsrXSk7XG4gICAgICBpZiAoZGVzY3JpcHRvciAhPT0gdW5kZWZpbmVkKSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG52YXIgcGF0aCRhID0gcGF0aCR3O1xuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyQyID0gcGF0aCRhLk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xuXG52YXIgcGFyZW50JHAgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzJDI7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzJDEgPSBwYXJlbnQkcDtcblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzJDE7XG5cbnZhciBfT2JqZWN0JGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0aWVzJDQgPSB7ZXhwb3J0czoge319O1xuXG52YXIgJCQ5ID0gX2V4cG9ydDtcbnZhciBERVNDUklQVE9SUyA9IGRlc2NyaXB0b3JzO1xudmFyIGRlZmluZVByb3BlcnRpZXMkMyA9IG9iamVjdERlZmluZVByb3BlcnRpZXMuZjtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydGllcyAtLSBzYWZlXG4kJDkoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzICE9PSBkZWZpbmVQcm9wZXJ0aWVzJDMsIHNoYW06ICFERVNDUklQVE9SUyB9LCB7XG4gIGRlZmluZVByb3BlcnRpZXM6IGRlZmluZVByb3BlcnRpZXMkM1xufSk7XG5cbnZhciBwYXRoJDkgPSBwYXRoJHc7XG5cbnZhciBPYmplY3QkMiA9IHBhdGgkOS5PYmplY3Q7XG5cbnZhciBkZWZpbmVQcm9wZXJ0aWVzJDIgPSBkZWZpbmVQcm9wZXJ0aWVzJDQuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoVCwgRCkge1xuICByZXR1cm4gT2JqZWN0JDIuZGVmaW5lUHJvcGVydGllcyhULCBEKTtcbn07XG5cbmlmIChPYmplY3QkMi5kZWZpbmVQcm9wZXJ0aWVzLnNoYW0pIGRlZmluZVByb3BlcnRpZXMkMi5zaGFtID0gdHJ1ZTtcblxudmFyIGRlZmluZVByb3BlcnRpZXNFeHBvcnRzID0gZGVmaW5lUHJvcGVydGllcyQ0LmV4cG9ydHM7XG5cbnZhciBwYXJlbnQkbyA9IGRlZmluZVByb3BlcnRpZXNFeHBvcnRzO1xuXG52YXIgZGVmaW5lUHJvcGVydGllcyQxID0gcGFyZW50JG87XG5cbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZGVmaW5lUHJvcGVydGllcyQxO1xuXG52YXIgX09iamVjdCRkZWZpbmVQcm9wZXJ0aWVzID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGRlZmluZVByb3BlcnRpZXMpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eSQ5O1xuXG52YXIgX09iamVjdCRkZWZpbmVQcm9wZXJ0eSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhkZWZpbmVQcm9wZXJ0eSk7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBfT2JqZWN0JGRlZmluZVByb3BlcnR5JDEob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxudmFyIGdsb2JhbCQzID0gZ2xvYmFsJG47XG52YXIgZmFpbHMkNCA9IGZhaWxzJHc7XG52YXIgdW5jdXJyeVRoaXMkMyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9TdHJpbmckMSA9IHRvU3RyaW5nJGE7XG52YXIgdHJpbSA9IHN0cmluZ1RyaW0udHJpbTtcbnZhciB3aGl0ZXNwYWNlcyA9IHdoaXRlc3BhY2VzJDM7XG5cbnZhciBjaGFyQXQgPSB1bmN1cnJ5VGhpcyQzKCcnLmNoYXJBdCk7XG52YXIgJHBhcnNlRmxvYXQkMSA9IGdsb2JhbCQzLnBhcnNlRmxvYXQ7XG52YXIgU3ltYm9sJDEgPSBnbG9iYWwkMy5TeW1ib2w7XG52YXIgSVRFUkFUT1IgPSBTeW1ib2wkMSAmJiBTeW1ib2wkMS5pdGVyYXRvcjtcbnZhciBGT1JDRUQkNCA9IDEgLyAkcGFyc2VGbG9hdCQxKHdoaXRlc3BhY2VzICsgJy0wJykgIT09IC1JbmZpbml0eVxuICAvLyBNUyBFZGdlIDE4LSBicm9rZW4gd2l0aCBib3hlZCBzeW1ib2xzXG4gIHx8IChJVEVSQVRPUiAmJiAhZmFpbHMkNChmdW5jdGlvbiAoKSB7ICRwYXJzZUZsb2F0JDEoT2JqZWN0KElURVJBVE9SKSk7IH0pKTtcblxuLy8gYHBhcnNlRmxvYXRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wYXJzZWZsb2F0LXN0cmluZ1xudmFyIG51bWJlclBhcnNlRmxvYXQgPSBGT1JDRUQkNCA/IGZ1bmN0aW9uIHBhcnNlRmxvYXQoc3RyaW5nKSB7XG4gIHZhciB0cmltbWVkU3RyaW5nID0gdHJpbSh0b1N0cmluZyQxKHN0cmluZykpO1xuICB2YXIgcmVzdWx0ID0gJHBhcnNlRmxvYXQkMSh0cmltbWVkU3RyaW5nKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gMCAmJiBjaGFyQXQodHJpbW1lZFN0cmluZywgMCkgPT09ICctJyA/IC0wIDogcmVzdWx0O1xufSA6ICRwYXJzZUZsb2F0JDE7XG5cbnZhciAkJDggPSBfZXhwb3J0O1xudmFyICRwYXJzZUZsb2F0ID0gbnVtYmVyUGFyc2VGbG9hdDtcblxuLy8gYHBhcnNlRmxvYXRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wYXJzZWZsb2F0LXN0cmluZ1xuJCQ4KHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IHBhcnNlRmxvYXQgIT09ICRwYXJzZUZsb2F0IH0sIHtcbiAgcGFyc2VGbG9hdDogJHBhcnNlRmxvYXRcbn0pO1xuXG52YXIgcGF0aCQ4ID0gcGF0aCR3O1xuXG52YXIgX3BhcnNlRmxvYXQkMyA9IHBhdGgkOC5wYXJzZUZsb2F0O1xuXG52YXIgcGFyZW50JG4gPSBfcGFyc2VGbG9hdCQzO1xuXG52YXIgX3BhcnNlRmxvYXQkMiA9IHBhcmVudCRuO1xuXG52YXIgX3BhcnNlRmxvYXQgPSBfcGFyc2VGbG9hdCQyO1xuXG52YXIgX3BhcnNlRmxvYXQkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhfcGFyc2VGbG9hdCk7XG5cbnZhciAkJDcgPSBfZXhwb3J0O1xudmFyIGZhaWxzJDMgPSBmYWlscyR3O1xudmFyIGdldE93blByb3BlcnR5TmFtZXMkMyA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gZmFpbHMkMyhmdW5jdGlvbiAoKSB7IHJldHVybiAhT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoMSk7IH0pO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuJCQ3KHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGQUlMU19PTl9QUklNSVRJVkVTIH0sIHtcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogZ2V0T3duUHJvcGVydHlOYW1lcyQzXG59KTtcblxudmFyIHBhdGgkNyA9IHBhdGgkdztcblxudmFyIE9iamVjdCQxID0gcGF0aCQ3Lk9iamVjdDtcblxudmFyIGdldE93blByb3BlcnR5TmFtZXMkMiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIE9iamVjdCQxLmdldE93blByb3BlcnR5TmFtZXMoaXQpO1xufTtcblxudmFyIHBhcmVudCRtID0gZ2V0T3duUHJvcGVydHlOYW1lcyQyO1xuXG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyQxID0gcGFyZW50JG07XG5cbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZ2V0T3duUHJvcGVydHlOYW1lcyQxO1xuXG52YXIgX09iamVjdCRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGdldE93blByb3BlcnR5TmFtZXMpO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIGNvbXBvbmVudHNcbiAqL1xuXG4vKipcbiAqIERldGVybWluZSB2YWx1ZXMgdG8gdXNlIGZvciAoc3ViKW9wdGlvbnMgb2YgJ2Nob3NlbicuXG4gKlxuICogVGhpcyBvcHRpb24gaXMgZWl0aGVyIGEgYm9vbGVhbiBvciBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIHNob3VsZCBiZSBleGFtaW5lZCBmdXJ0aGVyLlxuICogVGhlIHJlbGV2YW50IHN0cnVjdHVyZXMgYXJlOlxuICpcbiAqIC0gY2hvc2VuOiA8Ym9vbGVhbiB2YWx1ZT5cbiAqIC0gY2hvc2VuOiB7IHN1Yk9wdGlvbjogPGJvb2xlYW4gb3IgZnVuY3Rpb24+IH1cbiAqXG4gKiBXaGVyZSBzdWJPcHRpb24gaXMgJ25vZGUnLCAnZWRnZScgb3IgJ2xhYmVsJy5cbiAqXG4gKiBUaGUgaW50ZW50aW9uIG9mIHRoaXMgbWV0aG9kIGFwcGVhcnMgdG8gYmUgdG8gc2V0IGEgc3BlY2lmaWMgcHJpb3JpdHkgdG8gdGhlIG9wdGlvbnM7XG4gKiBTaW5jZSBtb3N0IHByb3BlcnRpZXMgYXJlIGVpdGhlciBicmlkZ2VkIG9yIG1lcmdlZCBpbnRvIHRoZSBsb2NhbCBvcHRpb25zIG9iamVjdHMsIHRoZXJlXG4gKiBpcyBub3QgbXVjaCBwb2ludCBpbiBoYW5kbGluZyB0aGVtIHNlcGFyYXRlbHkuXG4gKiBUT0RPOiBleGFtaW5lIGlmICdtb3N0JyBpbiBwcmV2aW91cyBzZW50ZW5jZSBjYW4gYmUgcmVwbGFjZWQgd2l0aCAnYWxsJy4gSW4gdGhhdCBjYXNlLCB3ZVxuICogICAgICAgc2hvdWxkIGJlIGFibGUgdG8gZ2V0IHJpZCBvZiB0aGlzIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gIHN1Yk9wdGlvbiAgb3B0aW9uIHdpdGhpbiBvYmplY3QgJ2Nob3NlbicgdG8gY29uc2lkZXI7IGVpdGhlciAnbm9kZScsICdlZGdlJyBvciAnbGFiZWwnXG4gKiBAcGFyYW0ge29iamVjdH0gIHBpbGUgICAgICAgYXJyYXkgb2Ygb3B0aW9ucyBvYmplY3RzIHRvIGNvbnNpZGVyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbiB8IEZ1bmN0aW9ufSAgdmFsdWUgZm9yIHBhc3NlZCBzdWJPcHRpb24gb2YgJ2Nob3NlbicgdG8gdXNlXG4gKi9cbmZ1bmN0aW9uIGNob29zaWZ5KHN1Yk9wdGlvbiwgcGlsZSkge1xuICAvLyBhbGxvd2VkIHZhbHVlcyBmb3Igc3ViT3B0aW9uXG4gIHZhciBhbGxvd2VkID0gW1wibm9kZVwiLCBcImVkZ2VcIiwgXCJsYWJlbFwiXTtcbiAgdmFyIHZhbHVlID0gdHJ1ZTtcbiAgdmFyIGNob3NlbiA9IHRvcE1vc3QocGlsZSwgXCJjaG9zZW5cIik7XG4gIGlmICh0eXBlb2YgY2hvc2VuID09PSBcImJvb2xlYW5cIikge1xuICAgIHZhbHVlID0gY2hvc2VuO1xuICB9IGVsc2UgaWYgKF90eXBlb2YoY2hvc2VuKSA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmIChfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkoYWxsb3dlZCkuY2FsbChhbGxvd2VkLCBzdWJPcHRpb24pID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hvb3NpZnk6IHN1Yk9wdGlvbiAnXCIgKyBzdWJPcHRpb24gKyBcIicgc2hvdWxkIGJlIG9uZSBvZiBcIiArIFwiJ1wiICsgYWxsb3dlZC5qb2luKFwiJywgJ1wiKSArIFwiJ1wiKTtcbiAgICB9XG4gICAgdmFyIGNob3NlbkVkZ2UgPSB0b3BNb3N0KHBpbGUsIFtcImNob3NlblwiLCBzdWJPcHRpb25dKTtcbiAgICBpZiAodHlwZW9mIGNob3NlbkVkZ2UgPT09IFwiYm9vbGVhblwiIHx8IHR5cGVvZiBjaG9zZW5FZGdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHZhbHVlID0gY2hvc2VuRWRnZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBwb2ludCBmYWxscyB3aXRoaW4gdGhlIGdpdmVuIHJlY3RhbmdsZS5cbiAqXG4gKiBAcGFyYW0ge3JlY3R9IHJlY3RcbiAqIEBwYXJhbSB7cG9pbnR9IHBvaW50XG4gKiBAcGFyYW0ge3JvdGF0aW9uUG9pbnR9IFtyb3RhdGlvblBvaW50XSBpZiBzcGVjaWZpZWQsIHRoZSByb3RhdGlvbiB0aGF0IGFwcGxpZXMgdG8gdGhlIHJlY3RhbmdsZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSAgdHJ1ZSBpZiBwb2ludCB3aXRoaW4gcmVjdGFuZ2xlLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gcG9pbnRJblJlY3QocmVjdCwgcG9pbnQsIHJvdGF0aW9uUG9pbnQpIHtcbiAgaWYgKHJlY3Qud2lkdGggPD0gMCB8fCByZWN0LmhlaWdodCA8PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBlYXJseSBvdXRcbiAgfVxuXG4gIGlmIChyb3RhdGlvblBvaW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBSb3RhdGUgdGhlIHBvaW50IHRoZSBzYW1lIGFtb3VudCBhcyB0aGUgcmVjdGFuZ2xlXG4gICAgdmFyIHRtcCA9IHtcbiAgICAgIHg6IHBvaW50LnggLSByb3RhdGlvblBvaW50LngsXG4gICAgICB5OiBwb2ludC55IC0gcm90YXRpb25Qb2ludC55XG4gICAgfTtcbiAgICBpZiAocm90YXRpb25Qb2ludC5hbmdsZSAhPT0gMCkge1xuICAgICAgLy8gSW4gb3JkZXIgdG8gZ2V0IHRoZSBjb29yZGluYXRlcyB0aGUgc2FtZSwgeW91IG5lZWQgdG9cbiAgICAgIC8vIHJvdGF0ZSBpbiB0aGUgcmV2ZXJzZSBkaXJlY3Rpb25cbiAgICAgIHZhciBhbmdsZSA9IC1yb3RhdGlvblBvaW50LmFuZ2xlO1xuICAgICAgdmFyIHRtcDIgPSB7XG4gICAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSAqIHRtcC54IC0gTWF0aC5zaW4oYW5nbGUpICogdG1wLnksXG4gICAgICAgIHk6IE1hdGguc2luKGFuZ2xlKSAqIHRtcC54ICsgTWF0aC5jb3MoYW5nbGUpICogdG1wLnlcbiAgICAgIH07XG4gICAgICBwb2ludCA9IHRtcDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ID0gdG1wO1xuICAgIH1cblxuICAgIC8vIE5vdGUgdGhhdCBpZiBhIHJvdGF0aW9uIGlzIHNwZWNpZmllZCwgdGhlIHJlY3RhbmdsZSBjb29yZGluYXRlc1xuICAgIC8vIGFyZSAqKm5vdCogdGhlIGZ1bGwgY2FudmFzIGNvb3JkaW5hdGVzLiBUaGV5IGFyZSByZWxhdGl2ZSB0byB0aGVcbiAgICAvLyByb3RhdGlvblBvaW50LiBIZW5jZSwgdGhlIHBvaW50IGNvb3JkaW5hdGVzIG5lZWQgbm90IGJlIHRyYW5zbGF0ZWRcbiAgICAvLyBiYWNrIGluIHRoaXMgY2FzZS5cbiAgfVxuXG4gIHZhciByaWdodCA9IHJlY3QueCArIHJlY3Qud2lkdGg7XG4gIHZhciBib3R0b20gPSByZWN0LnkgKyByZWN0LndpZHRoO1xuICByZXR1cm4gcmVjdC5sZWZ0IDwgcG9pbnQueCAmJiByaWdodCA+IHBvaW50LnggJiYgcmVjdC50b3AgPCBwb2ludC55ICYmIGJvdHRvbSA+IHBvaW50Lnk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgZ2l2ZW4gdmFsdWUgaXMgYWNjZXB0YWJsZSBhcyBhIGxhYmVsIHRleHQuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IHZhbHVlIHRvIGNoZWNrOyBjYW4gYmUgYW55dGhpbmcgYXQgdGhpcyBwb2ludFxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdmFsaWQgbGFiZWwgdmFsdWUsIGZhbHNlIG90aGVyd2lzZVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkTGFiZWwodGV4dCkge1xuICAvLyBOb3RlIHRoYXQgdGhpcyBpcyBxdWl0ZSBzdHJpY3Q6IHR5cGVzIHRoYXQgKm1pZ2h0KiBiZSBjb252ZXJ0ZWQgdG8gc3RyaW5nIGFyZSBkaXNhbGxvd2VkXG4gIHJldHVybiB0eXBlb2YgdGV4dCA9PT0gXCJzdHJpbmdcIiAmJiB0ZXh0ICE9PSBcIlwiO1xufVxuXG4vKipcbiAqIFJldHVybnMgeCwgeSBvZiBzZWxmIHJlZmVyZW5jZSBjaXJjbGUgYmFzZWQgb24gcHJvdmlkZWQgYW5nbGVcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY3R4XG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXNcbiAqIEBwYXJhbSB7VmlzTm9kZX0gbm9kZVxuICogQHJldHVybnMge29iamVjdH0geCBhbmQgeSBjb29yZGluYXRlc1xuICovXG5mdW5jdGlvbiBnZXRTZWxmUmVmQ29vcmRpbmF0ZXMoY3R4LCBhbmdsZSwgcmFkaXVzLCBub2RlKSB7XG4gIHZhciB4ID0gbm9kZS54O1xuICB2YXIgeSA9IG5vZGUueTtcbiAgaWYgKHR5cGVvZiBub2RlLmRpc3RhbmNlVG9Cb3JkZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIC8vY2FsY3VsYXRpbmcgb3Bwb3NpdGUgYW5kIGFkamFjZW50XG4gICAgLy9kaXN0YW5lVG9Cb3JkZXIgYmVjb21lcyBIeXBvdGVudXNlLlxuICAgIC8vRm9ybXVsYXMgc2luKGEpID0gT3Bwb3NpdGUgLyBIeXBvdGVudXNlIGFuZCBjb3MoYSkgPSBBZGphY2VudCAvIEh5cG90ZW51c2VcbiAgICB2YXIgdG9Cb3JkZXJEaXN0ID0gbm9kZS5kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIHZhciB5RnJvbU5vZGVDZW50ZXIgPSBNYXRoLnNpbihhbmdsZSkgKiB0b0JvcmRlckRpc3Q7XG4gICAgdmFyIHhGcm9tTm9kZUNlbnRlciA9IE1hdGguY29zKGFuZ2xlKSAqIHRvQm9yZGVyRGlzdDtcbiAgICAvL3hGcm9tTm9kZUNlbnRlciBpcyBiYXNpY2FsbHkgeCBhbmQgaWYgeEZyb21Ob2RlQ2VudGVyIGVxdWFscyB0byB0aGUgZGlzdGFuY2UgdG8gYm9yZGVyIHRoZW4gaXQgbWVhbnNcbiAgICAvL3RoYXQgeSBkb2VzIG5vdCBuZWVkIGNhbGN1bGF0aW9uIGJlY2F1c2UgaXQgaXMgZXF1YWwgbm9kZS5oZWlnaHQgLyAyIG9yIG5vZGUueVxuICAgIC8vc2FtZSB0aGluZyB3aXRoIHlGcm9tTm9kZUNlbnRlciBhbmQgaWYgeUZyb21Ob2RlQ2VudGVyIGVxdWFscyB0byB0aGUgZGlzdGFuY2UgdG8gYm9yZGVyIHRoZW4gaXQgbWVhbnNcbiAgICAvL3RoYXQgeCBpcyBlcXVhbCBub2RlLndpZHRoIC8gMiBvciBub2RlLnhcbiAgICBpZiAoeEZyb21Ob2RlQ2VudGVyID09PSB0b0JvcmRlckRpc3QpIHtcbiAgICAgIHggKz0gdG9Cb3JkZXJEaXN0O1xuICAgICAgeSA9IG5vZGUueTtcbiAgICB9IGVsc2UgaWYgKHlGcm9tTm9kZUNlbnRlciA9PT0gdG9Cb3JkZXJEaXN0KSB7XG4gICAgICB4ID0gbm9kZS54O1xuICAgICAgeSAtPSB0b0JvcmRlckRpc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggKz0geEZyb21Ob2RlQ2VudGVyO1xuICAgICAgeSAtPSB5RnJvbU5vZGVDZW50ZXI7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUuc2hhcGUud2lkdGggPiBub2RlLnNoYXBlLmhlaWdodCkge1xuICAgIHggPSBub2RlLnggKyBub2RlLnNoYXBlLndpZHRoICogMC41O1xuICAgIHkgPSBub2RlLnkgLSByYWRpdXM7XG4gIH0gZWxzZSB7XG4gICAgeCA9IG5vZGUueCArIHJhZGl1cztcbiAgICB5ID0gbm9kZS55IC0gbm9kZS5zaGFwZS5oZWlnaHQgKiAwLjU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbn1cblxudmFyIGVudHJ5VmlydHVhbCQzID0gZW50cnlWaXJ0dWFsJGk7XG5cbnZhciB2YWx1ZXMkMyA9IGVudHJ5VmlydHVhbCQzKCdBcnJheScpLnZhbHVlcztcblxudmFyIHBhcmVudCRsID0gdmFsdWVzJDM7XG5cbnZhciB2YWx1ZXMkMiA9IHBhcmVudCRsO1xuXG52YXIgY2xhc3NvZiQxID0gY2xhc3NvZiRkO1xudmFyIGhhc093biQyID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc1Byb3RvdHlwZU9mJDMgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCQzID0gdmFsdWVzJDI7XG5cbnZhciBBcnJheVByb3RvdHlwZSQzID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgRE9NSXRlcmFibGVzID0ge1xuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIE5vZGVMaXN0OiB0cnVlXG59O1xuXG52YXIgdmFsdWVzJDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LnZhbHVlcztcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSQzIHx8IChpc1Byb3RvdHlwZU9mJDMoQXJyYXlQcm90b3R5cGUkMywgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkMy52YWx1ZXMpXG4gICAgfHwgaGFzT3duJDIoRE9NSXRlcmFibGVzLCBjbGFzc29mJDEoaXQpKSA/IG1ldGhvZCQzIDogb3duO1xufTtcblxudmFyIHZhbHVlcyA9IHZhbHVlcyQxO1xuXG52YXIgX3ZhbHVlc0luc3RhbmNlUHJvcGVydHkgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanModmFsdWVzKTtcblxuLyoqXG4gKiBDYWxsYmFjayB0byBkZXRlcm1pbmUgdGV4dCBkaW1lbnNpb25zLCB1c2luZyB0aGUgcGFyZW50IGxhYmVsIHNldHRpbmdzLlxuICpcbiAqIEBjYWxsYmFjayBNZWFzdXJlVGV4dFxuICogQHBhcmFtIHt0ZXh0fSB0ZXh0XG4gKiBAcGFyYW0ge3RleHR9IG1vZFxuICogQHJldHVybnMge29iamVjdH0geyB3aWR0aCwgdmFsdWVzfSB3aWR0aCBpbiBwaXhlbHMgYW5kIGZvbnQgYXR0cmlidXRlc1xuICovXG4vKipcbiAqIEhlbHBlciBjbGFzcyBmb3IgTGFiZWwgd2hpY2ggY29sbGVjdHMgcmVzdWx0cyBvZiBzcGxpdHRpbmcgbGFiZWxzIGludG8gbGluZXMgYW5kIGJsb2Nrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgTGFiZWxBY2N1bXVsYXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge01lYXN1cmVUZXh0fSBtZWFzdXJlVGV4dFxuICAgKi9cbiAgZnVuY3Rpb24gTGFiZWxBY2N1bXVsYXRvcihtZWFzdXJlVGV4dCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYWJlbEFjY3VtdWxhdG9yKTtcbiAgICB0aGlzLm1lYXN1cmVUZXh0ID0gbWVhc3VyZVRleHQ7XG4gICAgdGhpcy5jdXJyZW50ID0gMDtcbiAgICB0aGlzLndpZHRoID0gMDtcbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5saW5lcyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBnaXZlbiB0ZXh0IHRvIHRoZSBnaXZlbiBsaW5lLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gIGwgICAgaW5kZXggb2YgbGluZSB0byBhZGQgdG9cbiAgICogQHBhcmFtIHtzdHJpbmd9ICB0ZXh0IHN0cmluZyB0byBhcHBlbmQgdG8gbGluZVxuICAgKiBAcGFyYW0geydib2xkJ3wnaXRhbCd8J2JvbGRpdGFsJ3wnbW9ubyd8J25vcm1hbCd9IFttb2Q9J25vcm1hbCddXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoTGFiZWxBY2N1bXVsYXRvciwgW3tcbiAgICBrZXk6IFwiX2FkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkKGwsIHRleHQpIHtcbiAgICAgIHZhciBtb2QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFwibm9ybWFsXCI7XG4gICAgICBpZiAodGhpcy5saW5lc1tsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubGluZXNbbF0gPSB7XG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgIGJsb2NrczogW11cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gV2Ugc3RpbGwgbmVlZCB0byBzZXQgYSBibG9jayBmb3IgdW5kZWZpbmVkIGFuZCBlbXB0eSB0ZXh0cywgaGVuY2UgcmV0dXJuIGF0IHRoaXMgcG9pbnRcbiAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugd2UgZG9uJ3Qga25vdyBhdCB0aGlzIHBvaW50IGlmIHdlJ3JlIGF0IHRoZVxuICAgICAgLy8gc3RhcnQgb2YgYW4gZW1wdHkgbGluZSBvciBub3QuXG4gICAgICAvLyBUbyBjb21wZW5zYXRlLCBlbXB0eSBibG9ja3MgYXJlIHJlbW92ZWQgaW4gYGZpbmFsaXplKClgLlxuICAgICAgLy9cbiAgICAgIC8vIEVtcHR5IHN0cmluZ3Mgc2hvdWxkIHN0aWxsIGhhdmUgYSBoZWlnaHRcbiAgICAgIHZhciB0bXBUZXh0ID0gdGV4dDtcbiAgICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQgfHwgdGV4dCA9PT0gXCJcIikgdG1wVGV4dCA9IFwiIFwiO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgd2lkdGggYW5kIGdldCB0aGUgZm9udCBwcm9wZXJ0aWVzXG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5tZWFzdXJlVGV4dCh0bXBUZXh0LCBtb2QpO1xuICAgICAgdmFyIGJsb2NrID0gX09iamVjdCRhc3NpZ24oe30sIF92YWx1ZXNJbnN0YW5jZVByb3BlcnR5KHJlc3VsdCkpO1xuICAgICAgYmxvY2sudGV4dCA9IHRleHQ7XG4gICAgICBibG9jay53aWR0aCA9IHJlc3VsdC53aWR0aDtcbiAgICAgIGJsb2NrLm1vZCA9IG1vZDtcbiAgICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQgfHwgdGV4dCA9PT0gXCJcIikge1xuICAgICAgICBibG9jay53aWR0aCA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLmxpbmVzW2xdLmJsb2Nrcy5wdXNoKGJsb2NrKTtcblxuICAgICAgLy8gVXBkYXRlIHRoZSBsaW5lIHdpZHRoLiBXZSBuZWVkIHRoaXMgZm9yIGRldGVybWluaW5nIGlmIGEgc3RyaW5nIGdvZXMgb3ZlciBtYXggd2lkdGhcbiAgICAgIHRoaXMubGluZXNbbF0ud2lkdGggKz0gYmxvY2sud2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggaW4gcGl4ZWxzIG9mIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImN1cldpZHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1cldpZHRoKCkge1xuICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW3RoaXMuY3VycmVudF07XG4gICAgICBpZiAobGluZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDtcbiAgICAgIHJldHVybiBsaW5lLndpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCB0ZXh0IGluIGJsb2NrIHRvIGN1cnJlbnQgbGluZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcGFyYW0geydib2xkJ3wnaXRhbCd8J2JvbGRpdGFsJ3wnbW9ubyd8J25vcm1hbCd9IFttb2Q9J25vcm1hbCddXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZCh0ZXh0KSB7XG4gICAgICB2YXIgbW9kID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIm5vcm1hbFwiO1xuICAgICAgdGhpcy5fYWRkKHRoaXMuY3VycmVudCwgdGV4dCwgbW9kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgdGV4dCBpbiBibG9jayB0byBjdXJyZW50IGxpbmUgYW5kIHN0YXJ0IGEgbmV3IGxpbmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHBhcmFtIHsnYm9sZCd8J2l0YWwnfCdib2xkaXRhbCd8J21vbm8nfCdub3JtYWwnfSBbbW9kPSdub3JtYWwnXVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm5ld0xpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV3TGluZSh0ZXh0KSB7XG4gICAgICB2YXIgbW9kID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIm5vcm1hbFwiO1xuICAgICAgdGhpcy5fYWRkKHRoaXMuY3VycmVudCwgdGV4dCwgbW9kKTtcbiAgICAgIHRoaXMuY3VycmVudCsrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBhbmQgc2V0IHRoZSBoZWlnaHRzIG9mIGFsbCB0aGUgbGluZXMgY3VycmVudGx5IGNvbnRhaW5lZCBpbiB0aGlzIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgd2lkdGggaGFzIGFscmVhZHkgYmVlbiBzZXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRldGVybWluZUxpbmVIZWlnaHRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldGVybWluZUxpbmVIZWlnaHRzKCkge1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmxpbmVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5saW5lc1trXTtcblxuICAgICAgICAvLyBMb29raW5nIGZvciBtYXggaGVpZ2h0IG9mIGJsb2NrcyBpbiBsaW5lXG4gICAgICAgIHZhciBoZWlnaHQgPSAwO1xuICAgICAgICBpZiAobGluZS5ibG9ja3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIENhbiBoYXBwZW4gaWYgdGV4dCBjb250YWlucyBlLmcuICdcXG4gJ1xuICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGluZS5ibG9ja3MubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgIHZhciBibG9jayA9IGxpbmUuYmxvY2tzW2xdO1xuICAgICAgICAgICAgaWYgKGhlaWdodCA8IGJsb2NrLmhlaWdodCkge1xuICAgICAgICAgICAgICBoZWlnaHQgPSBibG9jay5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxpbmUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgZnVsbCBzaXplIG9mIHRoZSBsYWJlbCB0ZXh0LCBhcyBkZXRlcm1pbmVkIGJ5IGN1cnJlbnQgbGluZXMgYW5kIGJsb2Nrc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkZXRlcm1pbmVMYWJlbFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZXJtaW5lTGFiZWxTaXplKCkge1xuICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgIHZhciBoZWlnaHQgPSAwO1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmxpbmVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5saW5lc1trXTtcbiAgICAgICAgaWYgKGxpbmUud2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgIHdpZHRoID0gbGluZS53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBoZWlnaHQgKz0gbGluZS5oZWlnaHQ7XG4gICAgICB9XG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGVtcHR5IGJsb2NrcyBhbmQgZW1wdHkgbGluZXMgd2UgZG9uJ3QgbmVlZFxuICAgICAqXG4gICAgICogVGhpcyBtdXN0IGJlIGRvbmUgYWZ0ZXIgdGhlIHdpZHRoL2hlaWdodCBkZXRlcm1pbmF0aW9uLFxuICAgICAqIHNvIHRoYXQgdGhlc2UgYXJlIHNldCBwcm9wZXJseSBmb3IgcHJvY2Vzc2luZyBoZXJlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5PExpbmU+fSBMaW5lcyB3aXRoIGVtcHR5IGJsb2NrcyAoYW5kIHNvbWUgZW1wdHkgbGluZXMpIHJlbW92ZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUVtcHR5QmxvY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUVtcHR5QmxvY2tzKCkge1xuICAgICAgdmFyIHRtcExpbmVzID0gW107XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGluZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2tdO1xuXG4gICAgICAgIC8vIE5vdGU6IGFuIGVtcHR5IGxpbmUgaW4gYmV0d2VlbiB0ZXh0IGhhcyB3aWR0aCB6ZXJvIGJ1dCBpcyBzdGlsbCByZWxldmFudCB0byBsYXlvdXQuXG4gICAgICAgIC8vIFNvIHdlIGNhbid0IHVzZSB3aWR0aCBmb3IgdGVzdGluZyBlbXB0eSBsaW5lIGhlcmVcbiAgICAgICAgaWYgKGxpbmUuYmxvY2tzLmxlbmd0aCA9PT0gMCkgY29udGludWU7XG5cbiAgICAgICAgLy8gRGlzY2FyZCBmaW5hbCBlbXB0eSBsaW5lIGFsd2F5c1xuICAgICAgICBpZiAoayA9PT0gdGhpcy5saW5lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgaWYgKGxpbmUud2lkdGggPT09IDApIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0bXBMaW5lID0ge307XG4gICAgICAgIF9PYmplY3QkYXNzaWduKHRtcExpbmUsIGxpbmUpO1xuICAgICAgICB0bXBMaW5lLmJsb2NrcyA9IFtdO1xuICAgICAgICB2YXIgZmlyc3RFbXB0eUJsb2NrID0gdm9pZCAwO1xuICAgICAgICB2YXIgdG1wQmxvY2tzID0gW107XG4gICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGluZS5ibG9ja3MubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICB2YXIgYmxvY2sgPSBsaW5lLmJsb2Nrc1tsXTtcbiAgICAgICAgICBpZiAoYmxvY2sud2lkdGggIT09IDApIHtcbiAgICAgICAgICAgIHRtcEJsb2Nrcy5wdXNoKGJsb2NrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZpcnN0RW1wdHlCbG9jayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGZpcnN0RW1wdHlCbG9jayA9IGJsb2NrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZXJlIGlzICpzb21lKiB0ZXh0IHByZXNlbnRcbiAgICAgICAgaWYgKHRtcEJsb2Nrcy5sZW5ndGggPT09IDAgJiYgZmlyc3RFbXB0eUJsb2NrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0bXBCbG9ja3MucHVzaChmaXJzdEVtcHR5QmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIHRtcExpbmUuYmxvY2tzID0gdG1wQmxvY2tzO1xuICAgICAgICB0bXBMaW5lcy5wdXNoKHRtcExpbmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRtcExpbmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc2l6ZXMgZm9yIGFsbCBsaW5lcyBhbmQgdGhlIHdob2xlIHRoaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3t3aWR0aDogKG51bWJlcnwqKSwgaGVpZ2h0OiAobnVtYmVyfCopLCBsaW5lczogQXJyYXl9fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImZpbmFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmFsaXplKCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeSh0aGlzLmxpbmVzLCBudWxsLCAyKSk7XG5cbiAgICAgIHRoaXMuZGV0ZXJtaW5lTGluZUhlaWdodHMoKTtcbiAgICAgIHRoaXMuZGV0ZXJtaW5lTGFiZWxTaXplKCk7XG4gICAgICB2YXIgdG1wTGluZXMgPSB0aGlzLnJlbW92ZUVtcHR5QmxvY2tzKCk7XG5cbiAgICAgIC8vIFJldHVybiBhIHNpbXBsZSBoYXNoIG9iamVjdCBmb3IgZnVydGhlciBwcm9jZXNzaW5nLlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgIGxpbmVzOiB0bXBMaW5lc1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIExhYmVsQWNjdW11bGF0b3I7XG59KCk7XG5cbi8vIEhhc2ggb2YgcHJlcGFyZWQgcmVnZXhwJ3MgZm9yIHRhZ3NcbnZhciB0YWdQYXR0ZXJuID0ge1xuICAvLyBIVE1MXG4gIFwiPGI+XCI6IC88Yj4vLFxuICBcIjxpPlwiOiAvPGk+LyxcbiAgXCI8Y29kZT5cIjogLzxjb2RlPi8sXG4gIFwiPC9iPlwiOiAvPFxcL2I+LyxcbiAgXCI8L2k+XCI6IC88XFwvaT4vLFxuICBcIjwvY29kZT5cIjogLzxcXC9jb2RlPi8sXG4gIC8vIE1hcmtkb3duXG4gIFwiKlwiOiAvXFwqLyxcbiAgLy8gYm9sZFxuICBfOiAvXy8sXG4gIC8vIGl0YWxcbiAgXCJgXCI6IC9gLyxcbiAgLy8gbW9ub1xuICBhZnRlckJvbGQ6IC9bXipdLyxcbiAgYWZ0ZXJJdGFsOiAvW15fXS8sXG4gIGFmdGVyTW9ubzogL1teYF0vXG59O1xuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciBjbGFzcyBmb3IgcGFyc2luZyB0aGUgbWFya3VwIHRhZ3MgZm9yIEhUTUwgYW5kIE1hcmtkb3duLlxuICpcbiAqIE5PVEU6IFNlcXVlbmNlcyBvZiB0YWJzIGFuZCBzcGFjZXMgYXJlIHJlZHVjZWQgdG8gc2luZ2xlIHNwYWNlLlxuICogICAgICAgU2NhbiB1c2FnZSBvZiBgdGhpcy5zcGFjaW5nYCB3aXRoaW4gbWV0aG9kXG4gKi9cbnZhciBNYXJrdXBBY2N1bXVsYXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgIHRleHQgdG8gcGFyc2UgZm9yIG1hcmt1cFxuICAgKi9cbiAgZnVuY3Rpb24gTWFya3VwQWNjdW11bGF0b3IodGV4dCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXJrdXBBY2N1bXVsYXRvcik7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB0aGlzLmJvbGQgPSBmYWxzZTtcbiAgICB0aGlzLml0YWwgPSBmYWxzZTtcbiAgICB0aGlzLm1vbm8gPSBmYWxzZTtcbiAgICB0aGlzLnNwYWNpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XG4gICAgdGhpcy5tb2RTdGFjayA9IFtdO1xuICAgIHRoaXMuYmxvY2tzID0gW107XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBtb2QgbGFiZWwgY3VycmVudGx5IG9uIHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9ICBsYWJlbCBvZiB0b3Btb3N0IG1vZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKE1hcmt1cEFjY3VtdWxhdG9yLCBbe1xuICAgIGtleTogXCJtb2RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9kKCkge1xuICAgICAgcmV0dXJuIHRoaXMubW9kU3RhY2subGVuZ3RoID09PSAwID8gXCJub3JtYWxcIiA6IHRoaXMubW9kU3RhY2tbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBtb2QgbGFiZWwgY3VycmVudGx5IGFjdGl2ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gIGxhYmVsIG9mIGFjdGl2ZSBtb2RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm1vZE5hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9kTmFtZSgpIHtcbiAgICAgIGlmICh0aGlzLm1vZFN0YWNrLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFwibm9ybWFsXCI7ZWxzZSBpZiAodGhpcy5tb2RTdGFja1swXSA9PT0gXCJtb25vXCIpIHJldHVybiBcIm1vbm9cIjtlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuYm9sZCAmJiB0aGlzLml0YWwpIHtcbiAgICAgICAgICByZXR1cm4gXCJib2xkaXRhbFwiO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYm9sZCkge1xuICAgICAgICAgIHJldHVybiBcImJvbGRcIjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLml0YWwpIHtcbiAgICAgICAgICByZXR1cm4gXCJpdGFsXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImVtaXRCbG9ja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0QmxvY2soKSB7XG4gICAgICBpZiAodGhpcy5zcGFjaW5nKSB7XG4gICAgICAgIHRoaXMuYWRkKFwiIFwiKTtcbiAgICAgICAgdGhpcy5zcGFjaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmJsb2Nrcy5wdXNoKHtcbiAgICAgICAgICB0ZXh0OiB0aGlzLmJ1ZmZlcixcbiAgICAgICAgICBtb2Q6IHRoaXMubW9kTmFtZSgpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3V0cHV0IHRleHQgdG8gYnVmZmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAgdGV4dCB0byBhZGRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQodGV4dCkge1xuICAgICAgaWYgKHRleHQgPT09IFwiIFwiKSB7XG4gICAgICAgIHRoaXMuc3BhY2luZyA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zcGFjaW5nKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyICs9IFwiIFwiO1xuICAgICAgICB0aGlzLnNwYWNpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0ICE9IFwiIFwiKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyICs9IHRleHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIHBhcnNpbmcgb2Ygd2hpdGVzcGFjZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoICB0aGUgY2hhcmFjdGVyIHRvIGNoZWNrXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGNoYXJhY3RlciB3YXMgcHJvY2Vzc2VkIGFzIHdoaXRlc3BhY2UsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInBhcnNlV1NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VXUyhjaCkge1xuICAgICAgaWYgKC9bIFxcdF0vLnRlc3QoY2gpKSB7XG4gICAgICAgIGlmICghdGhpcy5tb25vKSB7XG4gICAgICAgICAgdGhpcy5zcGFjaW5nID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFkZChjaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgIGxhYmVsIGZvciBibG9jayB0eXBlIHRvIHNldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRhZyh0YWdOYW1lKSB7XG4gICAgICB0aGlzLmVtaXRCbG9jaygpO1xuICAgICAgdGhpc1t0YWdOYW1lXSA9IHRydWU7XG4gICAgICB0aGlzLm1vZFN0YWNrLnVuc2hpZnQodGFnTmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgIGxhYmVsIGZvciBibG9jayB0eXBlIHRvIHVuc2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1bnNldFRhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNldFRhZyh0YWdOYW1lKSB7XG4gICAgICB0aGlzLmVtaXRCbG9jaygpO1xuICAgICAgdGhpc1t0YWdOYW1lXSA9IGZhbHNlO1xuICAgICAgdGhpcy5tb2RTdGFjay5zaGlmdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lIGxhYmVsIGZvciBibG9jayB0eXBlIHdlIGFyZSBjdXJyZW50bHkgcHJvY2Vzc2luZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gdGFnIHN0cmluZyB0byBtYXRjaCBpbiB0ZXh0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHRhZyB3YXMgcHJvY2Vzc2VkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVN0YXJ0VGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcodGFnTmFtZSwgdGFnKSB7XG4gICAgICAvLyBOb3RlOiBpZiAnbW9ubycgcGFzc2VkIGFzIHRhZ05hbWUsIHRoZXJlIGlzIGEgZG91YmxlIGNoZWNrIGhlcmUuIFRoaXMgaXMgT0tcbiAgICAgIGlmICghdGhpcy5tb25vICYmICF0aGlzW3RhZ05hbWVdICYmIHRoaXMubWF0Y2godGFnKSkge1xuICAgICAgICB0aGlzLnNldFRhZyh0YWdOYW1lKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfSB0YWdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FkdmFuY2U9dHJ1ZV0gaWYgc2V0LCBhZHZhbmNlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGV4dFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIG1hdGNoIGF0IGdpdmVuIHBvc2l0aW9uLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm1hdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoKHRhZykge1xuICAgICAgdmFyIGFkdmFuY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICB2YXIgX3RoaXMkcHJlcGFyZVJlZ0V4cCA9IHRoaXMucHJlcGFyZVJlZ0V4cCh0YWcpLFxuICAgICAgICBfdGhpcyRwcmVwYXJlUmVnRXhwMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJHByZXBhcmVSZWdFeHAsIDIpLFxuICAgICAgICByZWdFeHAgPSBfdGhpcyRwcmVwYXJlUmVnRXhwMlswXSxcbiAgICAgICAgbGVuZ3RoID0gX3RoaXMkcHJlcGFyZVJlZ0V4cDJbMV07XG4gICAgICB2YXIgbWF0Y2hlZCA9IHJlZ0V4cC50ZXN0KHRoaXMudGV4dC5zdWJzdHIodGhpcy5wb3NpdGlvbiwgbGVuZ3RoKSk7XG4gICAgICBpZiAobWF0Y2hlZCAmJiBhZHZhbmNlKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gbGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lIGxhYmVsIGZvciBibG9jayB0eXBlIHdlIGFyZSBjdXJyZW50bHkgcHJvY2Vzc2luZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gdGFnIHN0cmluZyB0byBtYXRjaCBpbiB0ZXh0XG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtuZXh0VGFnXSByZWd1bGFyIGV4cHJlc3Npb24gdG8gbWF0Y2ggZm9yIGNoYXJhY3RlcnMgKmZvbGxvd2luZyogdGhlIGN1cnJlbnQgdGFnXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHRhZyB3YXMgcHJvY2Vzc2VkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZUVuZFRhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUVuZFRhZyh0YWdOYW1lLCB0YWcsIG5leHRUYWcpIHtcbiAgICAgIHZhciBjaGVja1RhZyA9IHRoaXMubW9kKCkgPT09IHRhZ05hbWU7XG4gICAgICBpZiAodGFnTmFtZSA9PT0gXCJtb25vXCIpIHtcbiAgICAgICAgLy8gc3BlY2lhbCBoYW5kbGluZyBmb3IgJ21vbm8nXG4gICAgICAgIGNoZWNrVGFnID0gY2hlY2tUYWcgJiYgdGhpcy5tb25vO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2tUYWcgPSBjaGVja1RhZyAmJiAhdGhpcy5tb25vO1xuICAgICAgfVxuICAgICAgaWYgKGNoZWNrVGFnICYmIHRoaXMubWF0Y2godGFnKSkge1xuICAgICAgICBpZiAobmV4dFRhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUHVycG9zZSBvZiB0aGUgZm9sbG93aW5nIG1hdGNoIGlzIHRvIHByZXZlbnQgYSBkaXJlY3QgdW5zZXQvc2V0IG9mIGEgZ2l2ZW4gdGFnXG4gICAgICAgICAgLy8gRS5nLiAnKmJvbGQgKipzdGlsbCBib2xkKicgPT4gJypib2xkIHN0aWxsIGJvbGQqJ1xuICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09PSB0aGlzLnRleHQubGVuZ3RoIC0gMSB8fCB0aGlzLm1hdGNoKG5leHRUYWcsIGZhbHNlKSkge1xuICAgICAgICAgICAgdGhpcy51bnNldFRhZyh0YWdOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy51bnNldFRhZyh0YWdOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xSZWdFeHB9IHRhZyAgc3RyaW5nIHRvIG1hdGNoIGluIHRleHRcbiAgICAgKiBAcGFyYW0ge3ZhbHVlfSB2YWx1ZSAgc3RyaW5nIHRvIHJlcGxhY2UgdGFnIHdpdGgsIGlmIGZvdW5kIGF0IGN1cnJlbnQgcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdGFnIHdhcyBwcm9jZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlcGxhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZSh0YWcsIHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCh0YWcpKSB7XG4gICAgICAgIHRoaXMuYWRkKHZhbHVlKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBsZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIHRoZSB0YWcgaWYgaXQgaXNuJ3QgYWxyZWFkeSBvbmUuXG4gICAgICpcbiAgICAgKiBUaGUgcmV0dXJuIHZhbHVlIGlzIGFuIGFycmF5IGBbUmVnRXhwLCBudW1iZXJdYCwgd2l0aCBleGFjdGx5IHR3byB2YWx1ZSwgd2hlcmU6XG4gICAgICogIC0gUmVnRXhwIGlzIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gdG8gdXNlXG4gICAgICogIC0gbnVtYmVyIGlzIHRoZSBsZW50aCBvZiB0aGUgaW5wdXQgc3RyaW5nIHRvIG1hdGNoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xSZWdFeHB9IHRhZyAgc3RyaW5nIHRvIG1hdGNoIGluIHRleHRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9ICByZWd1bGFyIGV4cHJlc3Npb24gdG8gdXNlIGFuZCBsZW5ndGggb2YgaW5wdXQgc3RyaW5nIHRvIG1hdGNoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwcmVwYXJlUmVnRXhwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZXBhcmVSZWdFeHAodGFnKSB7XG4gICAgICB2YXIgbGVuZ3RoO1xuICAgICAgdmFyIHJlZ0V4cDtcbiAgICAgIGlmICh0YWcgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmVnRXhwID0gdGFnO1xuICAgICAgICBsZW5ndGggPSAxOyAvLyBBU1NVTVBUSU9OOiByZWdleHAgb25seSB0ZXN0cyBvbmUgY2hhcmFjdGVyXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1c2UgcHJlcGFyZWQgcmVnZXhwIGlmIHByZXNlbnRcbiAgICAgICAgdmFyIHByZXBhcmVkID0gdGFnUGF0dGVyblt0YWddO1xuICAgICAgICBpZiAocHJlcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlZ0V4cCA9IHByZXBhcmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZ0V4cCA9IG5ldyBSZWdFeHAodGFnKTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggPSB0YWcubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtyZWdFeHAsIGxlbmd0aF07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBNYXJrdXBBY2N1bXVsYXRvcjtcbn0oKTtcbi8qKlxuICogSGVscGVyIGNsYXNzIGZvciBMYWJlbCB3aGljaCBleHBsb2RlcyB0aGUgbGFiZWwgdGV4dCBpbnRvIGxpbmVzIGFuZCBibG9ja3Mgd2l0aGluIGxpbmVzXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIExhYmVsU3BsaXR0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcbiAgICogQHBhcmFtIHtMYWJlbH0gcGFyZW50IHJlZmVyZW5jZSB0byB0aGUgTGFiZWwgaW5zdGFuY2UgdXNpbmcgY3VycmVudCBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICovXG4gIGZ1bmN0aW9uIExhYmVsU3BsaXR0ZXIoY3R4LCBwYXJlbnQsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExhYmVsU3BsaXR0ZXIpO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICB0aGlzLmhvdmVyID0gaG92ZXI7XG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB0byBkZXRlcm1pbmUgdGV4dCB3aWR0aDsgcGFzc2VkIHRvIExhYmVsQWNjdW11bGF0b3IgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdGV4dCBzdHJpbmcgdG8gZGV0ZXJtaW5lIHdpZHRoIG9mXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBtb2QgIGZvbnQgdHlwZSB0byB1c2UgZm9yIHRoaXMgdGV4dFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHsgd2lkdGgsIHZhbHVlc30gd2lkdGggaW4gcGl4ZWxzIGFuZCBmb250IGF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICB2YXIgdGV4dFdpZHRoID0gZnVuY3Rpb24gdGV4dFdpZHRoKHRleHQsIG1vZCkge1xuICAgICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG5cbiAgICAgIC8vIFRPRE86IFRoaXMgY2FuIGJlIGRvbmUgbW9yZSBlZmZpY2llbnRseSB3aXRoIGNhY2hpbmdcbiAgICAgIC8vIFRoaXMgd2lsbCBzZXQgdGhlIGN0eC5mb250IGNvcnJlY3RseSwgZGVwZW5kaW5nIG9uIHNlbGVjdGVkL2hvdmVyIGFuZCBtb2QgLSBzbyB0aGF0IGN0eC5tZWFzdXJlVGV4dCgpIHdpbGwgYmUgYWNjdXJhdGUuXG4gICAgICB2YXIgdmFsdWVzID0gX3RoaXMucGFyZW50LmdldEZvcm1hdHRpbmdWYWx1ZXMoY3R4LCBzZWxlY3RlZCwgaG92ZXIsIG1vZCk7XG4gICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgaWYgKHRleHQgIT09IFwiXCIpIHtcbiAgICAgICAgdmFyIG1lYXN1cmUgPSBfdGhpcy5jdHgubWVhc3VyZVRleHQodGV4dCk7XG4gICAgICAgIHdpZHRoID0gbWVhc3VyZS53aWR0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXNcbiAgICAgIH07XG4gICAgfTtcbiAgICB0aGlzLmxpbmVzID0gbmV3IExhYmVsQWNjdW11bGF0b3IodGV4dFdpZHRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCBwYXNzZWQgdGV4dCBvZiBhIGxhYmVsIGludG8gbGluZXMgYW5kIGJsb2Nrcy5cbiAgICpcbiAgICogIyBOT1RFXG4gICAqXG4gICAqIFRoZSBoYW5kbGluZyBvZiBzcGFjaW5nIGlzIG9wdGlvbiBkZXBlbmRlbnQ6XG4gICAqXG4gICAqIC0gaWYgYGZvbnQubXVsdGkgOiBmYWxzZWAsIGFsbCBzcGFjZXMgYXJlIHJldGFpbmVkXG4gICAqIC0gaWYgYGZvbnQubXVsdGkgOiB0cnVlYCwgZXZlcnkgc2VxdWVuY2Ugb2Ygc3BhY2VzIGlzIGNvbXByZXNzZWQgdG8gYSBzaW5nbGUgc3BhY2VcbiAgICpcbiAgICogVGhpcyBtaWdodCBub3QgYmUgdGhlIGJlc3Qgd2F5IHRvIGRvIGl0LCBidXQgdGhpcyBpcyBhcyBpdCBoYXMgYmVlbiB3b3JraW5nIHRpbGwgbm93LlxuICAgKiBJbiBvcmRlciBub3QgdG8gYnJlYWsgZXhpc3RpbmcgZnVuY3Rpb25hbGl0eSwgZm9yIHRoZSB0aW1lIGJlaW5nIHRoaXMgYmVoYXZpb3VyIHdpbGxcbiAgICogYmUgcmV0YWluZWQgaW4gYW55IGNvZGUgY2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgIHRleHQgdG8gc3BsaXRcbiAgICogQHJldHVybnMge0FycmF5PGxpbmU+fVxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKExhYmVsU3BsaXR0ZXIsIFt7XG4gICAga2V5OiBcInByb2Nlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzcyh0ZXh0KSB7XG4gICAgICBpZiAoIWlzVmFsaWRMYWJlbCh0ZXh0KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lcy5maW5hbGl6ZSgpO1xuICAgICAgfVxuICAgICAgdmFyIGZvbnQgPSB0aGlzLnBhcmVudC5mb250T3B0aW9ucztcblxuICAgICAgLy8gTm9ybWFsaXplIHRoZSBlbmQtb2YtbGluZSdzIHRvIGEgc2luZ2xlIHJlcHJlc2VudGF0aW9uIC0gb3JkZXIgaW1wb3J0YW50XG4gICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHJcXG4vZywgXCJcXG5cIik7IC8vIERvcyBFT0wnc1xuICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxyL2csIFwiXFxuXCIpOyAvLyBNYWMgRU9MJ3NcblxuICAgICAgLy8gTm90ZSB0aGF0IGF0IHRoaXMgcG9pbnQsIHRoZXJlIGNhbiBiZSBubyBcXHIncyBpbiB0aGUgdGV4dC5cbiAgICAgIC8vIFRoaXMgaXMgdXNlZCBsYXRlciBvbiBzcGxpdFN0cmluZ0ludG9MaW5lcygpIHRvIHNwbGl0IG11bHRpZm9udCB0ZXh0cy5cblxuICAgICAgdmFyIG5sTGluZXMgPSBTdHJpbmcodGV4dCkuc3BsaXQoXCJcXG5cIik7XG4gICAgICB2YXIgbGluZUNvdW50ID0gbmxMaW5lcy5sZW5ndGg7XG4gICAgICBpZiAoZm9udC5tdWx0aSkge1xuICAgICAgICAvLyBNdWx0aS1mb250IGNhc2U6IHN0eWxpbmcgdGFncyBhY3RpdmVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lQ291bnQ7IGkrKykge1xuICAgICAgICAgIHZhciBibG9ja3MgPSB0aGlzLnNwbGl0QmxvY2tzKG5sTGluZXNbaV0sIGZvbnQubXVsdGkpO1xuICAgICAgICAgIC8vIFBvc3Q6IFNlcXVlbmNlcyBvZiB0YWJzIGFuZCBzcGFjZXMgYXJlIHJlZHVjZWQgdG8gc2luZ2xlIHNwYWNlXG5cbiAgICAgICAgICBpZiAoYmxvY2tzID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmIChibG9ja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVzLm5ld0xpbmUoXCJcIik7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZvbnQubWF4V2R0ID4gMCkge1xuICAgICAgICAgICAgLy8gd2lkdGhDb25zdHJhaW50Lm1heGltdW0gZGVmaW5lZFxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnUnVubmluZyB3aWR0aENvbnN0cmFpbnQgbXVsdGksIG1heDogJyArIHRoaXMuZm9udE9wdGlvbnMubWF4V2R0KTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYmxvY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBtb2QgPSBibG9ja3Nbal0ubW9kO1xuICAgICAgICAgICAgICB2YXIgX3RleHQgPSBibG9ja3Nbal0udGV4dDtcbiAgICAgICAgICAgICAgdGhpcy5zcGxpdFN0cmluZ0ludG9MaW5lcyhfdGV4dCwgbW9kLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd2lkdGhDb25zdHJhaW50Lm1heGltdW0gTk9UIGRlZmluZWRcbiAgICAgICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBibG9ja3MubGVuZ3RoOyBfaisrKSB7XG4gICAgICAgICAgICAgIHZhciBfbW9kID0gYmxvY2tzW19qXS5tb2Q7XG4gICAgICAgICAgICAgIHZhciBfdGV4dDIgPSBibG9ja3NbX2pdLnRleHQ7XG4gICAgICAgICAgICAgIHRoaXMubGluZXMuYXBwZW5kKF90ZXh0MiwgX21vZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubGluZXMubmV3TGluZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTaW5nbGUtZm9udCBjYXNlXG4gICAgICAgIGlmIChmb250Lm1heFdkdCA+IDApIHtcbiAgICAgICAgICAvLyB3aWR0aENvbnN0cmFpbnQubWF4aW11bSBkZWZpbmVkXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ1J1bm5pbmcgd2lkdGhDb25zdHJhaW50IG5vcm1hbCwgbWF4OiAnICsgdGhpcy5mb250T3B0aW9ucy5tYXhXZHQpO1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsaW5lQ291bnQ7IF9pKyspIHtcbiAgICAgICAgICAgIHRoaXMuc3BsaXRTdHJpbmdJbnRvTGluZXMobmxMaW5lc1tfaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB3aWR0aENvbnN0cmFpbnQubWF4aW11bSBOT1QgZGVmaW5lZFxuICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGxpbmVDb3VudDsgX2kyKyspIHtcbiAgICAgICAgICAgIHRoaXMubGluZXMubmV3TGluZShubExpbmVzW19pMl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubGluZXMuZmluYWxpemUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBub3JtYWxpemUgdGhlIG1hcmt1cCBzeXN0ZW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnwnbWQnfCdtYXJrZG93bid8J2h0bWwnfSBtYXJrdXBTeXN0ZW1cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRlY29kZU1hcmt1cFN5c3RlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVNYXJrdXBTeXN0ZW0obWFya3VwU3lzdGVtKSB7XG4gICAgICB2YXIgc3lzdGVtID0gXCJub25lXCI7XG4gICAgICBpZiAobWFya3VwU3lzdGVtID09PSBcIm1hcmtkb3duXCIgfHwgbWFya3VwU3lzdGVtID09PSBcIm1kXCIpIHtcbiAgICAgICAgc3lzdGVtID0gXCJtYXJrZG93blwiO1xuICAgICAgfSBlbHNlIGlmIChtYXJrdXBTeXN0ZW0gPT09IHRydWUgfHwgbWFya3VwU3lzdGVtID09PSBcImh0bWxcIikge1xuICAgICAgICBzeXN0ZW0gPSBcImh0bWxcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzeXN0ZW07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzcGxpdEh0bWxCbG9ja3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3BsaXRIdG1sQmxvY2tzKHRleHQpIHtcbiAgICAgIHZhciBzID0gbmV3IE1hcmt1cEFjY3VtdWxhdG9yKHRleHQpO1xuICAgICAgdmFyIHBhcnNlRW50aXRpZXMgPSBmdW5jdGlvbiBwYXJzZUVudGl0aWVzKGNoKSB7XG4gICAgICAgIGlmICgvJi8udGVzdChjaCkpIHtcbiAgICAgICAgICB2YXIgcGFyc2VkID0gcy5yZXBsYWNlKHMudGV4dCwgXCImbHQ7XCIsIFwiPFwiKSB8fCBzLnJlcGxhY2Uocy50ZXh0LCBcIiZhbXA7XCIsIFwiJlwiKTtcbiAgICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgICAgcy5hZGQoXCImXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgd2hpbGUgKHMucG9zaXRpb24gPCBzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaCA9IHMudGV4dC5jaGFyQXQocy5wb3NpdGlvbik7XG4gICAgICAgIHZhciBwYXJzZWQgPSBzLnBhcnNlV1MoY2gpIHx8IC88Ly50ZXN0KGNoKSAmJiAocy5wYXJzZVN0YXJ0VGFnKFwiYm9sZFwiLCBcIjxiPlwiKSB8fCBzLnBhcnNlU3RhcnRUYWcoXCJpdGFsXCIsIFwiPGk+XCIpIHx8IHMucGFyc2VTdGFydFRhZyhcIm1vbm9cIiwgXCI8Y29kZT5cIikgfHwgcy5wYXJzZUVuZFRhZyhcImJvbGRcIiwgXCI8L2I+XCIpIHx8IHMucGFyc2VFbmRUYWcoXCJpdGFsXCIsIFwiPC9pPlwiKSB8fCBzLnBhcnNlRW5kVGFnKFwibW9ub1wiLCBcIjwvY29kZT5cIikpIHx8IHBhcnNlRW50aXRpZXMoY2gpO1xuICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgIHMuYWRkKGNoKTtcbiAgICAgICAgfVxuICAgICAgICBzLnBvc2l0aW9uKys7XG4gICAgICB9XG4gICAgICBzLmVtaXRCbG9jaygpO1xuICAgICAgcmV0dXJuIHMuYmxvY2tzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic3BsaXRNYXJrZG93bkJsb2Nrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzcGxpdE1hcmtkb3duQmxvY2tzKHRleHQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIHMgPSBuZXcgTWFya3VwQWNjdW11bGF0b3IodGV4dCk7XG4gICAgICB2YXIgYmVnaW5hYmxlID0gdHJ1ZTtcbiAgICAgIHZhciBwYXJzZU92ZXJyaWRlID0gZnVuY3Rpb24gcGFyc2VPdmVycmlkZShjaCkge1xuICAgICAgICBpZiAoL1xcXFwvLnRlc3QoY2gpKSB7XG4gICAgICAgICAgaWYgKHMucG9zaXRpb24gPCBfdGhpczIudGV4dC5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgICBzLnBvc2l0aW9uKys7XG4gICAgICAgICAgICBjaCA9IF90aGlzMi50ZXh0LmNoYXJBdChzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmICgvIFxcdC8udGVzdChjaCkpIHtcbiAgICAgICAgICAgICAgcy5zcGFjaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMuYWRkKGNoKTtcbiAgICAgICAgICAgICAgYmVnaW5hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICB3aGlsZSAocy5wb3NpdGlvbiA8IHMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoID0gcy50ZXh0LmNoYXJBdChzLnBvc2l0aW9uKTtcbiAgICAgICAgdmFyIHBhcnNlZCA9IHMucGFyc2VXUyhjaCkgfHwgcGFyc2VPdmVycmlkZShjaCkgfHwgKGJlZ2luYWJsZSB8fCBzLnNwYWNpbmcpICYmIChzLnBhcnNlU3RhcnRUYWcoXCJib2xkXCIsIFwiKlwiKSB8fCBzLnBhcnNlU3RhcnRUYWcoXCJpdGFsXCIsIFwiX1wiKSB8fCBzLnBhcnNlU3RhcnRUYWcoXCJtb25vXCIsIFwiYFwiKSkgfHwgcy5wYXJzZUVuZFRhZyhcImJvbGRcIiwgXCIqXCIsIFwiYWZ0ZXJCb2xkXCIpIHx8IHMucGFyc2VFbmRUYWcoXCJpdGFsXCIsIFwiX1wiLCBcImFmdGVySXRhbFwiKSB8fCBzLnBhcnNlRW5kVGFnKFwibW9ub1wiLCBcImBcIiwgXCJhZnRlck1vbm9cIik7XG4gICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgcy5hZGQoY2gpO1xuICAgICAgICAgIGJlZ2luYWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHMucG9zaXRpb24rKztcbiAgICAgIH1cbiAgICAgIHMuZW1pdEJsb2NrKCk7XG4gICAgICByZXR1cm4gcy5ibG9ja3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwbG9kZXMgYSBwaWVjZSBvZiB0ZXh0IGludG8gc2luZ2xlLWZvbnQgYmxvY2tzIHVzaW5nIGEgZ2l2ZW4gbWFya3VwXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnwnbWQnfCdtYXJrZG93bid8J2h0bWwnfSBtYXJrdXBTeXN0ZW1cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHt0ZXh0OiBzdHJpbmcsIG1vZDogc3RyaW5nfT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzcGxpdEJsb2Nrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzcGxpdEJsb2Nrcyh0ZXh0LCBtYXJrdXBTeXN0ZW0pIHtcbiAgICAgIHZhciBzeXN0ZW0gPSB0aGlzLmRlY29kZU1hcmt1cFN5c3RlbShtYXJrdXBTeXN0ZW0pO1xuICAgICAgaWYgKHN5c3RlbSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBtb2Q6IFwibm9ybWFsXCJcbiAgICAgICAgfV07XG4gICAgICB9IGVsc2UgaWYgKHN5c3RlbSA9PT0gXCJtYXJrZG93blwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwbGl0TWFya2Rvd25CbG9ja3ModGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKHN5c3RlbSA9PT0gXCJodG1sXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXRIdG1sQmxvY2tzKHRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGV4dCBsZW5ndGggb3ZlciB0aGUgY3VycmVudCBtYXggd2l0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwib3Zlck1heFdpZHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG92ZXJNYXhXaWR0aCh0ZXh0KSB7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLmN0eC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcbiAgICAgIHJldHVybiB0aGlzLmxpbmVzLmN1cldpZHRoKCkgKyB3aWR0aCA+IHRoaXMucGFyZW50LmZvbnRPcHRpb25zLm1heFdkdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGxvbmdlc3QgcGFydCBvZiB0aGUgc2VudGVuY2Ugd2hpY2ggc3RpbGwgZml0cyBpbiB0aGVcbiAgICAgKiBjdXJyZW50IG1heCB3aWR0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzICBBcnJheSBvZiBzdHJpbmdzIHNpZ25pZnlpbmcgYSB0ZXh0IGxpbmVzXG4gICAgICogQHJldHVybnMge251bWJlcn0gICAgICBpbmRleCBvZiBmaXJzdCBpdGVtIGluIHN0cmluZyBtYWtpbmcgc3RyaW5nIGdvIG92ZXIgbWF4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRMb25nZXN0Rml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExvbmdlc3RGaXQod29yZHMpIHtcbiAgICAgIHZhciB0ZXh0ID0gXCJcIjtcbiAgICAgIHZhciB3ID0gMDtcbiAgICAgIHdoaWxlICh3IDwgd29yZHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBwcmUgPSB0ZXh0ID09PSBcIlwiID8gXCJcIiA6IFwiIFwiO1xuICAgICAgICB2YXIgbmV3VGV4dCA9IHRleHQgKyBwcmUgKyB3b3Jkc1t3XTtcbiAgICAgICAgaWYgKHRoaXMub3Zlck1heFdpZHRoKG5ld1RleHQpKSBicmVhaztcbiAgICAgICAgdGV4dCA9IG5ld1RleHQ7XG4gICAgICAgIHcrKztcbiAgICAgIH1cbiAgICAgIHJldHVybiB3O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgbG9uZ2VzdCBwYXJ0IG9mIHRoZSBzdHJpbmcgd2hpY2ggc3RpbGwgZml0cyBpbiB0aGVcbiAgICAgKiBjdXJyZW50IG1heCB3aWR0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIEFycmF5IG9mIHN0cmluZ3Mgc2lnbmlmeWluZyBhIHRleHQgbGluZXNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBpbmRleCBvZiBmaXJzdCBpdGVtIGluIHN0cmluZyBtYWtpbmcgc3RyaW5nIGdvIG92ZXIgbWF4XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TG9uZ2VzdEZpdFdvcmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TG9uZ2VzdEZpdFdvcmQod29yZHMpIHtcbiAgICAgIHZhciB3ID0gMDtcbiAgICAgIHdoaWxlICh3IDwgd29yZHMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLm92ZXJNYXhXaWR0aChfc2xpY2VJbnN0YW5jZVByb3BlcnR5KHdvcmRzKS5jYWxsKHdvcmRzLCAwLCB3KSkpIGJyZWFrO1xuICAgICAgICB3Kys7XG4gICAgICB9XG4gICAgICByZXR1cm4gdztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdCB0aGUgcGFzc2VkIHRleHQgaW50byBsaW5lcywgYWNjb3JkaW5nIHRvIHdpZHRoIGNvbnN0cmFpbnQgKGlmIGFueSkuXG4gICAgICpcbiAgICAgKiBUaGUgbWV0aG9kIGFzc3VtZXMgdGhhdCB0aGUgaW5wdXQgc3RyaW5nIGlzIGEgc2luZ2xlIGxpbmUsIGkuZS4gd2l0aG91dCBsaW5lcyBicmVhay5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldGFpbnMgc3BhY2VzLCBpZiBzdGlsbCBwcmVzZW50IChjYXNlIGBmb250Lm11bHRpOiBmYWxzZWApLlxuICAgICAqIEEgc3BhY2Ugd2hpY2ggZmFsbHMgb24gYW4gaW50ZXJuYWwgbGluZSBicmVhaywgd2lsbCBiZSByZXBsYWNlZCBieSBhIG5ld2xpbmUuXG4gICAgICogVGhlcmUgaXMgbm8gc3BlY2lhbCBoYW5kbGluZyBvZiB0YWJzOyB0aGVzZSBnbyBhbG9uZyB3aXRoIHRoZSBmbG93LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbW9kPSdub3JtYWwnXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FwcGVuZExhc3Q9ZmFsc2VdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzcGxpdFN0cmluZ0ludG9MaW5lc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzcGxpdFN0cmluZ0ludG9MaW5lcyhzdHIpIHtcbiAgICAgIHZhciBtb2QgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwibm9ybWFsXCI7XG4gICAgICB2YXIgYXBwZW5kTGFzdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICAvLyBTZXQgdGhlIGNhbnZhcyBjb250ZXh0IGZvbnQsIGJhc2VkIHVwb24gdGhlIGN1cnJlbnQgc2VsZWN0ZWQvaG92ZXIgc3RhdGVcbiAgICAgIC8vIGFuZCB0aGUgcHJvdmlkZWQgbW9kLCBzbyB0aGUgdGV4dCBtZWFzdXJlbWVudCBwZXJmb3JtZWQgYnkgZ2V0TG9uZ2VzdEZpdFxuICAgICAgLy8gd2lsbCBiZSBhY2N1cmF0ZSAtIGFuZCBub3QganVzdCB1c2UgdGhlIGZvbnQgb2Ygd2hvZXZlciBsYXN0IHVzZWQgdGhlIGNhbnZhcy5cbiAgICAgIHRoaXMucGFyZW50LmdldEZvcm1hdHRpbmdWYWx1ZXModGhpcy5jdHgsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIG1vZCk7XG5cbiAgICAgIC8vIFN0aWxsLXByZXNlbnQgc3BhY2VzIGFyZSByZWxldmFudCwgcmV0YWluIHRoZW1cbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9eKCArKS9nLCBcIiQxXFxyXCIpO1xuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLyhbXlxccl1bXiBdKikoICspL2csIFwiJDFcXHIkMlxcclwiKTtcbiAgICAgIHZhciB3b3JkcyA9IHN0ci5zcGxpdChcIlxcclwiKTtcbiAgICAgIHdoaWxlICh3b3Jkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy5nZXRMb25nZXN0Rml0KHdvcmRzKTtcbiAgICAgICAgaWYgKHcgPT09IDApIHtcbiAgICAgICAgICAvLyBTcGVjaWFsIGNhc2U6IHRoZSBmaXJzdCB3b3JkIGlzIGFscmVhZHkgbGFyZ2VyIHRoYW4gdGhlIG1heCB3aWR0aC5cbiAgICAgICAgICB2YXIgd29yZCA9IHdvcmRzWzBdO1xuXG4gICAgICAgICAgLy8gQnJlYWsgdGhlIHdvcmQgdG8gdGhlIGxhcmdlc3QgcGFydCB0aGF0IGZpdHMgdGhlIGxpbmVcbiAgICAgICAgICB2YXIgeCA9IHRoaXMuZ2V0TG9uZ2VzdEZpdFdvcmQod29yZCk7XG4gICAgICAgICAgdGhpcy5saW5lcy5uZXdMaW5lKF9zbGljZUluc3RhbmNlUHJvcGVydHkod29yZCkuY2FsbCh3b3JkLCAwLCB4KSwgbW9kKTtcblxuICAgICAgICAgIC8vIEFkanVzdCB0aGUgd29yZCwgc28gdGhhdCB0aGUgcmVzdCB3aWxsIGJlIGRvbmUgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICB3b3Jkc1swXSA9IF9zbGljZUluc3RhbmNlUHJvcGVydHkod29yZCkuY2FsbCh3b3JkLCB4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBza2lwIGFueSBzcGFjZSB0aGF0IGlzIHJlcGxhY2VkIGJ5IGEgbmV3bGluZVxuICAgICAgICAgIHZhciBuZXdXID0gdztcbiAgICAgICAgICBpZiAod29yZHNbdyAtIDFdID09PSBcIiBcIikge1xuICAgICAgICAgICAgdy0tO1xuICAgICAgICAgIH0gZWxzZSBpZiAod29yZHNbbmV3V10gPT09IFwiIFwiKSB7XG4gICAgICAgICAgICBuZXdXKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0ZXh0ID0gX3NsaWNlSW5zdGFuY2VQcm9wZXJ0eSh3b3JkcykuY2FsbCh3b3JkcywgMCwgdykuam9pbihcIlwiKTtcbiAgICAgICAgICBpZiAodyA9PSB3b3Jkcy5sZW5ndGggJiYgYXBwZW5kTGFzdCkge1xuICAgICAgICAgICAgdGhpcy5saW5lcy5hcHBlbmQodGV4dCwgbW9kKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5saW5lcy5uZXdMaW5lKHRleHQsIG1vZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQWRqdXN0IHRoZSB3b3JkLCBzbyB0aGF0IHRoZSByZXN0IHdpbGwgYmUgZG9uZSBuZXh0IGl0ZXJhdGlvblxuICAgICAgICAgIHdvcmRzID0gX3NsaWNlSW5zdGFuY2VQcm9wZXJ0eSh3b3JkcykuY2FsbCh3b3JkcywgbmV3Vyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIExhYmVsU3BsaXR0ZXI7XG59KCk7XG5cbi8qKlxuICogTGlzdCBvZiBzcGVjaWFsIHN0eWxlcyBmb3IgbXVsdGktZm9udHNcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgbXVsdGlGb250U3R5bGUgPSBbXCJib2xkXCIsIFwiaXRhbFwiLCBcImJvbGRpdGFsXCIsIFwibW9ub1wiXTtcblxuLyoqXG4gKiBBIExhYmVsIHRvIGJlIHVzZWQgZm9yIE5vZGVzIG9yIEVkZ2VzLlxuICovXG52YXIgTGFiZWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbZWRnZWxhYmVsPWZhbHNlXVxuICAgKi9cbiAgZnVuY3Rpb24gTGFiZWwoYm9keSwgb3B0aW9ucykge1xuICAgIHZhciBlZGdlbGFiZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYWJlbCk7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnBvaW50VG9TZWxmID0gZmFsc2U7XG4gICAgdGhpcy5iYXNlU2l6ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZvbnRPcHRpb25zID0ge307IC8vIGluc3RhbmNlIHZhcmlhYmxlIGNvbnRhaW5pbmcgdGhlICppbnN0YW5jZS1sb2NhbCogZm9udCBvcHRpb25zXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuc2l6ZSA9IHtcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIHlMaW5lOiAwXG4gICAgfTtcbiAgICB0aGlzLmlzRWRnZUxhYmVsID0gZWRnZWxhYmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIG9mIHRoZSBwYXJlbnQgTm9kZS1pbnN0YW5jZVxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKExhYmVsLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5lbGVtZW50T3B0aW9ucyA9IG9wdGlvbnM7IC8vIFJlZmVyZW5jZSB0byB0aGUgb3B0aW9ucyBvZiB0aGUgcGFyZW50IE5vZGUtaW5zdGFuY2VcblxuICAgICAgdGhpcy5pbml0Rm9udE9wdGlvbnMob3B0aW9ucy5mb250KTtcbiAgICAgIGlmIChpc1ZhbGlkTGFiZWwob3B0aW9ucy5sYWJlbCkpIHtcbiAgICAgICAgdGhpcy5sYWJlbERpcnR5ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJhZCBsYWJlbCEgQ2hhbmdlIHRoZSBvcHRpb24gdmFsdWUgdG8gcHJldmVudCBiYWQgc3R1ZmYgaGFwcGVuaW5nXG4gICAgICAgIG9wdGlvbnMubGFiZWwgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5mb250ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5mb250ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIGZvbnQgb3B0aW9ucyBjYW4gYmUgZGVsZXRlZCBhdCB2YXJpb3VzIGxldmVsc1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZm9udCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRoaXMuYmFzZVNpemUgPSB0aGlzLmZvbnRPcHRpb25zLnNpemU7XG4gICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihvcHRpb25zLmZvbnQpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdmFyIHNpemUgPSBvcHRpb25zLmZvbnQuc2l6ZTtcbiAgICAgICAgICBpZiAoc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2VTaXplID0gc2l6ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0IHRoZSBmb250IE9wdGlvbnMgc3RydWN0dXJlLlxuICAgICAqXG4gICAgICogTWVtYmVyIGZvbnRPcHRpb25zIHNlcnZlcyBhcyBhbiBhY2N1bXVsYXRvciBmb3IgdGhlIGN1cnJlbnQgZm9udCBvcHRpb25zLlxuICAgICAqIEFzIHN1Y2gsIGl0IG5lZWRzIHRvIGJlIGNvbXBsZXRlbHkgc2VwYXJhdGVkIGZyb20gdGhlIG5vZGUgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdGb250T3B0aW9ucyB0aGUgbmV3IGZvbnQgb3B0aW9ucyB0byBwcm9jZXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpbml0Rm9udE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdEZvbnRPcHRpb25zKG5ld0ZvbnRPcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgLy8gUHJlcGFyZSB0aGUgbXVsdGktZm9udCBvcHRpb24gb2JqZWN0cy5cbiAgICAgIC8vIFRoZXNlIHdpbGwgYmUgZmlsbGVkIGluIHByb3BhZ2F0ZUZvbnRzKCksIGlmIHJlcXVpcmVkXG4gICAgICBmb3JFYWNoJDEobXVsdGlGb250U3R5bGUsIGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICBfdGhpcy5mb250T3B0aW9uc1tzdHlsZV0gPSB7fTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBIYW5kbGUgc2hvcnRoYW5kIG9wdGlvbiwgaWYgcHJlc2VudFxuICAgICAgaWYgKExhYmVsLnBhcnNlRm9udFN0cmluZyh0aGlzLmZvbnRPcHRpb25zLCBuZXdGb250T3B0aW9ucykpIHtcbiAgICAgICAgdGhpcy5mb250T3B0aW9ucy52YWRqdXN0ID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDb3B5IG92ZXIgdGhlIG5vbi1tdWx0aWZvbnQgb3B0aW9ucywgaWYgc3BlY2lmaWVkXG4gICAgICBmb3JFYWNoJDEobmV3Rm9udE9wdGlvbnMsIGZ1bmN0aW9uIChwcm9wLCBuKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSB1bmRlZmluZWQgJiYgcHJvcCAhPT0gbnVsbCAmJiBfdHlwZW9mKHByb3ApICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgX3RoaXMuZm9udE9wdGlvbnNbbl0gPSBwcm9wO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiBpbi12YXJpYWJsZSBpcyBhIHN0cmluZywgcGFyc2UgaXQgYXMgYSBmb250IHNwZWNpZmllci5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBmb2xsb3dpbmcgaXMgbm90IGRvbmUgaGVyZSBhbmQgaGF2ZSB0byBiZSBkb25lIGFmdGVyIHRoZSBjYWxsOlxuICAgICAqIC0gTm90IGFsbCBmb250IG9wdGlvbnMgYXJlIHNldCAodmFkanVzdCwgbW9kKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG91dE9wdGlvbnMgIG91dC1wYXJhbWV0ZXIsIG9iamVjdCBpbiB3aGljaCB0byBzdG9yZSB0aGUgcGFyc2UgcmVzdWx0cyAoaWYgYW55KVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpbk9wdGlvbnMgIGZvbnQgb3B0aW9ucyB0byBwYXJzZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGZvbnQgcGFyc2VkIGFzIHN0cmluZywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNvbnN0cmFpblwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgd2lkdGggYW5kIGhlaWdodCBjb25zdHJhaW50cyBiYXNlZCBvbiAnbmVhcmVzdCcgdmFsdWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBpbGUgYXJyYXkgb2Ygb3B0aW9uIG9iamVjdHMgdG8gY29uc2lkZXJcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSB0aGUgYWN0dWFsIGNvbnN0cmFpbnQgdmFsdWVzIHRvIHVzZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uc3RyYWluKHBpbGUpIHtcbiAgICAgIC8vIE5PVEU6IGNvbnN0cmFpbldpZHRoIGFuZCAgY29uc3RyYWluSGVpZ2h0IG5ldmVyIHNldCFcbiAgICAgIC8vIE5PVEU6IGZvciBlZGdlIGxhYmVscywgb25seSAnbWF4V2R0JyBzZXRcbiAgICAgIC8vIE5vZGUgbGFiZWxzIGNhbiBzZXQgYWxsIHRoZSBmaWVsZHNcbiAgICAgIHZhciBmb250T3B0aW9ucyA9IHtcbiAgICAgICAgY29uc3RyYWluV2lkdGg6IGZhbHNlLFxuICAgICAgICBtYXhXZHQ6IC0xLFxuICAgICAgICBtaW5XZHQ6IC0xLFxuICAgICAgICBjb25zdHJhaW5IZWlnaHQ6IGZhbHNlLFxuICAgICAgICBtaW5IZ3Q6IC0xLFxuICAgICAgICB2YWxpZ246IFwibWlkZGxlXCJcbiAgICAgIH07XG4gICAgICB2YXIgd2lkdGhDb25zdHJhaW50ID0gdG9wTW9zdChwaWxlLCBcIndpZHRoQ29uc3RyYWludFwiKTtcbiAgICAgIGlmICh0eXBlb2Ygd2lkdGhDb25zdHJhaW50ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGZvbnRPcHRpb25zLm1heFdkdCA9IE51bWJlcih3aWR0aENvbnN0cmFpbnQpO1xuICAgICAgICBmb250T3B0aW9ucy5taW5XZHQgPSBOdW1iZXIod2lkdGhDb25zdHJhaW50KTtcbiAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZih3aWR0aENvbnN0cmFpbnQpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciB3aWR0aENvbnN0cmFpbnRNYXhpbXVtID0gdG9wTW9zdChwaWxlLCBbXCJ3aWR0aENvbnN0cmFpbnRcIiwgXCJtYXhpbXVtXCJdKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aENvbnN0cmFpbnRNYXhpbXVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgZm9udE9wdGlvbnMubWF4V2R0ID0gTnVtYmVyKHdpZHRoQ29uc3RyYWludE1heGltdW0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWR0aENvbnN0cmFpbnRNaW5pbXVtID0gdG9wTW9zdChwaWxlLCBbXCJ3aWR0aENvbnN0cmFpbnRcIiwgXCJtaW5pbXVtXCJdKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aENvbnN0cmFpbnRNaW5pbXVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgZm9udE9wdGlvbnMubWluV2R0ID0gTnVtYmVyKHdpZHRoQ29uc3RyYWludE1pbmltdW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgaGVpZ2h0Q29uc3RyYWludCA9IHRvcE1vc3QocGlsZSwgXCJoZWlnaHRDb25zdHJhaW50XCIpO1xuICAgICAgaWYgKHR5cGVvZiBoZWlnaHRDb25zdHJhaW50ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGZvbnRPcHRpb25zLm1pbkhndCA9IE51bWJlcihoZWlnaHRDb25zdHJhaW50KTtcbiAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihoZWlnaHRDb25zdHJhaW50KSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgaGVpZ2h0Q29uc3RyYWludE1pbmltdW0gPSB0b3BNb3N0KHBpbGUsIFtcImhlaWdodENvbnN0cmFpbnRcIiwgXCJtaW5pbXVtXCJdKTtcbiAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHRDb25zdHJhaW50TWluaW11bSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGZvbnRPcHRpb25zLm1pbkhndCA9IE51bWJlcihoZWlnaHRDb25zdHJhaW50TWluaW11bSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlaWdodENvbnN0cmFpbnRWYWxpZ24gPSB0b3BNb3N0KHBpbGUsIFtcImhlaWdodENvbnN0cmFpbnRcIiwgXCJ2YWxpZ25cIl0pO1xuICAgICAgICBpZiAodHlwZW9mIGhlaWdodENvbnN0cmFpbnRWYWxpZ24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAoaGVpZ2h0Q29uc3RyYWludFZhbGlnbiA9PT0gXCJ0b3BcIiB8fCBoZWlnaHRDb25zdHJhaW50VmFsaWduID09PSBcImJvdHRvbVwiKSB7XG4gICAgICAgICAgICBmb250T3B0aW9ucy52YWxpZ24gPSBoZWlnaHRDb25zdHJhaW50VmFsaWduO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZvbnRPcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBvcHRpb25zIGFuZCB1cGRhdGUgaW50ZXJuYWwgc3RhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICBvcHRpb25zIHRvIHNldFxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBwaWxlICAgICBhcnJheSBvZiBvcHRpb24gb2JqZWN0cyB0byBjb25zaWRlciBmb3Igb3B0aW9uICdjaG9zZW4nXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShvcHRpb25zLCBwaWxlKSB7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucywgdHJ1ZSk7XG4gICAgICB0aGlzLnByb3BhZ2F0ZUZvbnRzKHBpbGUpO1xuICAgICAgZGVlcEV4dGVuZCh0aGlzLmZvbnRPcHRpb25zLCB0aGlzLmNvbnN0cmFpbihwaWxlKSk7XG4gICAgICB0aGlzLmZvbnRPcHRpb25zLmNob29zZXIgPSBjaG9vc2lmeShcImxhYmVsXCIsIHBpbGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gbWFyZ2lucyBhcmUgc2V0IGluIGFuIGVsZW1lbnQsIGFkanVzdCBzaXplcyBpcyBjYWxsZWQgdG8gcmVtb3ZlIHRoZW1cbiAgICAgKiBmcm9tIHRoZSB3aWR0aC9oZWlnaHQgY29uc3RyYWludHMuIFRoaXMgbXVzdCBiZSBkb25lIHByaW9yIHRvIGxhYmVsIHNpemluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3RvcDogbnVtYmVyLCByaWdodDogbnVtYmVyLCBib3R0b206IG51bWJlciwgbGVmdDogbnVtYmVyfX0gbWFyZ2luc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFkanVzdFNpemVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkanVzdFNpemVzKG1hcmdpbnMpIHtcbiAgICAgIHZhciB3aWR0aEJpYXMgPSBtYXJnaW5zID8gbWFyZ2lucy5yaWdodCArIG1hcmdpbnMubGVmdCA6IDA7XG4gICAgICBpZiAodGhpcy5mb250T3B0aW9ucy5jb25zdHJhaW5XaWR0aCkge1xuICAgICAgICB0aGlzLmZvbnRPcHRpb25zLm1heFdkdCAtPSB3aWR0aEJpYXM7XG4gICAgICAgIHRoaXMuZm9udE9wdGlvbnMubWluV2R0IC09IHdpZHRoQmlhcztcbiAgICAgIH1cbiAgICAgIHZhciBoZWlnaHRCaWFzID0gbWFyZ2lucyA/IG1hcmdpbnMudG9wICsgbWFyZ2lucy5ib3R0b20gOiAwO1xuICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMuY29uc3RyYWluSGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuZm9udE9wdGlvbnMubWluSGd0IC09IGhlaWdodEJpYXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gTWV0aG9kcyBmb3IgaGFuZGxpbmcgb3B0aW9ucyBwaWxlc1xuICAgIC8vIEV2ZW50dWFsbHksIHRoZXNlIHdpbGwgYmUgbW92ZWQgdG8gYSBzZXBhcmF0ZSBjbGFzc1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBmb250IG1lbWJlcnMgb2YgdGhlIHBhc3NlZCBsaXN0IG9mIG9wdGlvbiBvYmplY3RzIHRvIHRoZSBwaWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQaWxlfSBkc3RQaWxlICBwaWxlIG9mIG9wdGlvbiBvYmplY3RzIGFkZCB0b1xuICAgICAqIEBwYXJhbSB7UGlsZX0gc3JjUGlsZSAgcGlsZSBvZiBvcHRpb24gb2JqZWN0cyB0byB0YWtlIGZvbnQgb3B0aW9ucyBmcm9tXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhZGRGb250T3B0aW9uc1RvUGlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRGb250T3B0aW9uc1RvUGlsZShkc3RQaWxlLCBzcmNQaWxlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNyY1BpbGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdGhpcy5hZGRGb250VG9QaWxlKGRzdFBpbGUsIHNyY1BpbGVbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBnaXZlbiBmb250IG9wdGlvbiBvYmplY3QgdG8gdGhlIGxpc3Qgb2Ygb2JqZWN0cyAodGhlICdwaWxlJykgdG8gY29uc2lkZXIgZm9yIGRldGVybWluaW5nXG4gICAgICogbXVsdGktZm9udCBvcHRpb24gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQaWxlfSBwaWxlICBwaWxlIG9mIG9wdGlvbiBvYmplY3RzIHRvIHVzZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICBpbnN0YW5jZSB0byBhZGQgdG8gcGlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRm9udFRvUGlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRGb250VG9QaWxlKHBpbGUsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgIGlmIChvcHRpb25zLmZvbnQgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmZvbnQgPT09IG51bGwpIHJldHVybjtcbiAgICAgIHZhciBpdGVtID0gb3B0aW9ucy5mb250O1xuICAgICAgcGlsZS5wdXNoKGl0ZW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbGxlY3QgYWxsIG93bi1wcm9wZXJ0eSB2YWx1ZXMgZnJvbSB0aGUgZm9udCBwaWxlIHRoYXQgYXJlbid0IG11bHRpLWZvbnQgb3B0aW9uIG9iamVjdHNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQaWxlfSBwaWxlICBwaWxlIG9mIG9wdGlvbiBvYmplY3RzIHRvIHVzZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IG9iamVjdCB3aXRoIGFsbCBjdXJyZW50IG93biBiYXNpYyBmb250IHByb3BlcnRpZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEJhc2ljT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCYXNpY09wdGlvbnMocGlsZSkge1xuICAgICAgdmFyIHJldCA9IHt9O1xuXG4gICAgICAvLyBTY2FucyB0aGUgd2hvbGUgcGlsZSB0byBnZXQgYWxsIG9wdGlvbnMgcHJlc2VudFxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBwaWxlLmxlbmd0aDsgKytuKSB7XG4gICAgICAgIHZhciBmb250T3B0aW9ucyA9IHBpbGVbbl07XG5cbiAgICAgICAgLy8gQ29udmVydCBzaG9ydGhhbmQgaWYgbmVjZXNzYXJ5XG4gICAgICAgIHZhciB0bXBTaG9ydGhhbmQgPSB7fTtcbiAgICAgICAgaWYgKExhYmVsLnBhcnNlRm9udFN0cmluZyh0bXBTaG9ydGhhbmQsIGZvbnRPcHRpb25zKSkge1xuICAgICAgICAgIGZvbnRPcHRpb25zID0gdG1wU2hvcnRoYW5kO1xuICAgICAgICB9XG4gICAgICAgIGZvckVhY2gkMShmb250T3B0aW9ucywgZnVuY3Rpb24gKG9wdCwgbmFtZSkge1xuICAgICAgICAgIGlmIChvcHQgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAvLyBtdWx0aS1mb250IG9wdGlvbiBuZWVkIG5vdCBiZSBwcmVzZW50XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXQsIG5hbWUpKSByZXR1cm47IC8vIEtlZXAgZmlyc3QgdmFsdWUgd2UgZW5jb3VudGVyXG5cbiAgICAgICAgICBpZiAoX2luZGV4T2ZJbnN0YW5jZVByb3BlcnR5KG11bHRpRm9udFN0eWxlKS5jYWxsKG11bHRpRm9udFN0eWxlLCBuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFNraXAgbXVsdGktZm9udCBwcm9wZXJ0aWVzIGJ1dCB3ZSBkbyBuZWVkIHRoZSBzdHJ1Y3R1cmVcbiAgICAgICAgICAgIHJldFtuYW1lXSA9IHt9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXRbbmFtZV0gPSBvcHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSBmb3IgZ2l2ZW4gb3B0aW9uIGZvciB0aGUgZ2l2ZW4gbXVsdGktZm9udC5cbiAgICAgKlxuICAgICAqIEFsbCBhdmFpbGFibGUgb3B0aW9uIG9iamVjdHMgYXJlIHRyYXdsZWQgaW4gdGhlIHNldCBvcmRlciB0byBjb25zdHJ1Y3QgdGhlIG9wdGlvbiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiAjIyBUcmF2ZXJzYWwgb2YgcGlsZSBmb3IgbXVsdGktZm9udHNcbiAgICAgKlxuICAgICAqIFRoZSBkZXRlcm1pbmF0aW9uIG9mIG11bHRpLWZvbnQgb3B0aW9uIHZhbHVlcyBpcyBhIHNwZWNpYWwgY2FzZSwgYmVjYXVzZSBhbnkgdmFsdWVzIG5vdFxuICAgICAqIHByZXNlbnQgaW4gdGhlIG11bHRpLWZvbnQgb3B0aW9ucyBzaG91bGQgYnkgZGVmaW5pdGlvbiBiZSB0YWtlbiBmcm9tIHRoZSBtYWluIGZvbnQgb3B0aW9ucyxcbiAgICAgKiBpLmUuIGZyb20gdGhlIGN1cnJlbnQgJ3BhcmVudCcgb2JqZWN0IG9mIHRoZSBtdWx0aS1mb250IG9wdGlvbi5cbiAgICAgKlxuICAgICAqICMjIyBTZWFyY2ggb3JkZXIgZm9yIG11bHRpLWZvbnRzXG4gICAgICpcbiAgICAgKiAnYm9sZCcgdXNlZCBhcyBleGFtcGxlOlxuICAgICAqXG4gICAgICogICAtIHNlYXJjaCBpbiBvcHRpb24gZ3JvdXAgJ2JvbGQnIGluIGxvY2FsIHByb3BlcnRpZXNcbiAgICAgKiAgIC0gc2VhcmNoIGluIG1haW4gZm9udCBvcHRpb24gZ3JvdXAgaW4gbG9jYWwgcHJvcGVydGllc1xuICAgICAqXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BpbGV9IHBpbGUgIHBpbGUgb2Ygb3B0aW9uIG9iamVjdHMgdG8gdXNlXG4gICAgICogQHBhcmFtIHtNdWx0aUZvbnRTdHlsZX0gbXVsdGlOYW1lIHN1YiBwYXRoIGZvciB0aGUgbXVsdGktZm9udFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb24gIHRoZSBvcHRpb24gdG8gc2VhcmNoIGZvciwgZm9yIHRoZSBnaXZlbiBtdWx0aS1mb250XG4gICAgICogQHJldHVybnMge3N0cmluZ3xudW1iZXJ9IHRoZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Rm9udE9wdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGb250T3B0aW9uKHBpbGUsIG11bHRpTmFtZSwgb3B0aW9uKSB7XG4gICAgICB2YXIgbXVsdGlGb250O1xuXG4gICAgICAvLyBTZWFyY2ggbXVsdGkgZm9udCBpbiBsb2NhbCBwcm9wZXJ0aWVzXG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHBpbGUubGVuZ3RoOyArK24pIHtcbiAgICAgICAgdmFyIGZvbnRPcHRpb25zID0gcGlsZVtuXTtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmb250T3B0aW9ucywgbXVsdGlOYW1lKSkge1xuICAgICAgICAgIG11bHRpRm9udCA9IGZvbnRPcHRpb25zW211bHRpTmFtZV07XG4gICAgICAgICAgaWYgKG11bHRpRm9udCA9PT0gdW5kZWZpbmVkIHx8IG11bHRpRm9udCA9PT0gbnVsbCkgY29udGludWU7XG5cbiAgICAgICAgICAvLyBDb252ZXJ0IHNob3J0aGFuZCBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAvLyBUT0RPOiBpbmVmZmljaWVudCB0byBkbyB0aGlzIGNvbnZlcnNpb24gZXZlcnkgdGltZTsgZmluZCBhIGJldHRlciB3YXkuXG4gICAgICAgICAgdmFyIHRtcFNob3J0aGFuZCA9IHt9O1xuICAgICAgICAgIGlmIChMYWJlbC5wYXJzZUZvbnRTdHJpbmcodG1wU2hvcnRoYW5kLCBtdWx0aUZvbnQpKSB7XG4gICAgICAgICAgICBtdWx0aUZvbnQgPSB0bXBTaG9ydGhhbmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobXVsdGlGb250LCBvcHRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gbXVsdGlGb250W29wdGlvbl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE9wdGlvbiBpcyBub3QgbWVudGlvbmVkIGluIHRoZSBtdWx0aSBmb250IG9wdGlvbnM7IHRha2UgaXQgZnJvbSB0aGUgcGFyZW50IGZvbnQgb3B0aW9ucy5cbiAgICAgIC8vIFRoZXNlIGhhdmUgYWxyZWFkeSBiZWVuIGNvbnZlcnRlZCB3aXRoIGdldEJhc2ljT3B0aW9ucygpLCBzbyB1c2UgdGhlIGNvbnZlcnRlZCB2YWx1ZXMuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuZm9udE9wdGlvbnMsIG9wdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9udE9wdGlvbnNbb3B0aW9uXTtcbiAgICAgIH1cblxuICAgICAgLy8gQSB2YWx1ZSAqKm11c3QqKiBiZSBmb3VuZDsgeW91IHNob3VsZCBuZXZlciBnZXQgaGVyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpZCBub3QgZmluZCB2YWx1ZSBmb3IgbXVsdGktZm9udCBmb3IgcHJvcGVydHk6ICdcIiArIG9wdGlvbiArIFwiJ1wiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYWxsIG9wdGlvbnMgdmFsdWVzIGZvciB0aGUgZ2l2ZW4gbXVsdGktZm9udC5cbiAgICAgKlxuICAgICAqIEFsbCBhdmFpbGFibGUgb3B0aW9uIG9iamVjdHMgYXJlIHRyYXdsZWQgaW4gdGhlIHNldCBvcmRlciB0byBjb25zdHJ1Y3QgdGhlIG9wdGlvbiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BpbGV9IHBpbGUgIHBpbGUgb2Ygb3B0aW9uIG9iamVjdHMgdG8gdXNlXG4gICAgICogQHBhcmFtIHtNdWx0aUZvbnRTdHlsZX0gbXVsdGlOYW1lIHN1YiBwYXRoIGZvciB0aGUgbW9kLWZvbnRcbiAgICAgKiBAcmV0dXJucyB7TXVsdGlGb250T3B0aW9uc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEZvbnRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZvbnRPcHRpb25zKHBpbGUsIG11bHRpTmFtZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgdmFyIG9wdGlvbk5hbWVzID0gW1wiY29sb3JcIiwgXCJzaXplXCIsIFwiZmFjZVwiLCBcIm1vZFwiLCBcInZhZGp1c3RcIl07IC8vIExpc3Qgb2YgYWxsb3dlZCBvcHRpb25zIHBlciBtdWx0aS1mb250XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9uTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIG1vZCA9IG9wdGlvbk5hbWVzW2ldO1xuICAgICAgICByZXN1bHRbbW9kXSA9IHRoaXMuZ2V0Rm9udE9wdGlvbihwaWxlLCBtdWx0aU5hbWUsIG1vZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEVuZCBtZXRob2RzIGZvciBoYW5kbGluZyBvcHRpb25zIHBpbGVzXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZSB0aGUgZm9udCBvcHRpb25zIGZvciB0aGUgbXVsdGktZm9udCB0byBzaW5nbGUgb2JqZWN0cywgZnJvbVxuICAgICAqIHRoZSBjaGFpbiBvZiBvcHRpb24gb2JqZWN0cyBwYXNzZWQgKHRoZSAncGlsZScpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQaWxlfSBwaWxlICBzZXF1ZW5jZSBvZiBvcHRpb24gb2JqZWN0cyB0byBjb25zaWRlci5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIEZpcnN0IGl0ZW0gaW4gbGlzdCBhc3N1bWVkIHRvIGJlIHRoZSBuZXdseSBzZXQgb3B0aW9ucy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwcm9wYWdhdGVGb250c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9wYWdhdGVGb250cyhwaWxlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBmb250UGlsZSA9IFtdOyAvLyBzZXF1ZW5jZSBvZiBmb250IG9iamVjdHMgdG8gY29uc2lkZXIsIG9yZGVyIGltcG9ydGFudFxuXG4gICAgICAvLyBOb3RlIHRoYXQgdGhpcy5lbGVtZW50T3B0aW9ucyBpcyBub3QgdXNlZCBoZXJlLlxuICAgICAgdGhpcy5hZGRGb250T3B0aW9uc1RvUGlsZShmb250UGlsZSwgcGlsZSk7XG4gICAgICB0aGlzLmZvbnRPcHRpb25zID0gdGhpcy5nZXRCYXNpY09wdGlvbnMoZm9udFBpbGUpO1xuXG4gICAgICAvLyBXZSBzZXQgbXVsdGlmb250IHZhbHVlcyBldmVuIGlmIG11bHRpID09PSBmYWxzZSwgZm9yIGNvbnNpc3RlbmN5ICh0aGluZ3MgYnJlYWsgb3RoZXJ3aXNlKVxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgIHZhciBtb2QgPSBtdWx0aUZvbnRTdHlsZVtpXTtcbiAgICAgICAgdmFyIG1vZE9wdGlvbnMgPSBfdGhpczIuZm9udE9wdGlvbnNbbW9kXTtcbiAgICAgICAgdmFyIHRtcE11bHRpRm9udE9wdGlvbnMgPSBfdGhpczIuZ2V0Rm9udE9wdGlvbnMoZm9udFBpbGUsIG1vZCk7XG5cbiAgICAgICAgLy8gQ29weSBvdmVyIGZvdW5kIHZhbHVlc1xuICAgICAgICBmb3JFYWNoJDEodG1wTXVsdGlGb250T3B0aW9ucywgZnVuY3Rpb24gKG9wdGlvbiwgbikge1xuICAgICAgICAgIG1vZE9wdGlvbnNbbl0gPSBvcHRpb247XG4gICAgICAgIH0pO1xuICAgICAgICBtb2RPcHRpb25zLnNpemUgPSBOdW1iZXIobW9kT3B0aW9ucy5zaXplKTtcbiAgICAgICAgbW9kT3B0aW9ucy52YWRqdXN0ID0gTnVtYmVyKG1vZE9wdGlvbnMudmFkanVzdCk7XG4gICAgICB9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdWx0aUZvbnRTdHlsZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBfbG9vcCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1haW4gZnVuY3Rpb24uIFRoaXMgaXMgY2FsbGVkIGZyb20gYW55dGhpbmcgdGhhdCB3YW50cyB0byBkcmF3IGEgbGFiZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtiYXNlbGluZT0nbWlkZGxlJ11cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIHZhciBiYXNlbGluZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogXCJtaWRkbGVcIjtcbiAgICAgIC8vIGlmIG5vIGxhYmVsLCByZXR1cm5cbiAgICAgIGlmICh0aGlzLmVsZW1lbnRPcHRpb25zLmxhYmVsID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSB0byByZW5kZXIgdGhlIGxhYmVsXG4gICAgICB2YXIgdmlld0ZvbnRTaXplID0gdGhpcy5mb250T3B0aW9ucy5zaXplICogdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICBpZiAodGhpcy5lbGVtZW50T3B0aW9ucy5sYWJlbCAmJiB2aWV3Rm9udFNpemUgPCB0aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwuZHJhd1RocmVzaG9sZCAtIDEpIHJldHVybjtcblxuICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgdGhlcmUgd2lsbCBub3QgYmUgSFVHRSBsZXR0ZXJzIG9uIHNjcmVlblxuICAgICAgLy8gYnkgc2V0dGluZyBhbiB1cHBlciBsaW1pdCBvbiB0aGUgdmlzaWJsZSB0ZXh0IHNpemUgKHJlZ2FyZGxlc3Mgb2Ygem9vbUxldmVsKVxuICAgICAgaWYgKHZpZXdGb250U2l6ZSA+PSB0aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwubWF4VmlzaWJsZSkge1xuICAgICAgICB2aWV3Rm9udFNpemUgPSBOdW1iZXIodGhpcy5lbGVtZW50T3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1heFZpc2libGUpIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICB9XG5cbiAgICAgIC8vIHVwZGF0ZSB0aGUgc2l6ZSBjYWNoZSBpZiByZXF1aXJlZFxuICAgICAgdGhpcy5jYWxjdWxhdGVMYWJlbFNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIsIHgsIHksIGJhc2VsaW5lKTtcbiAgICAgIHRoaXMuX2RyYXdCYWNrZ3JvdW5kKGN0eCk7XG4gICAgICB0aGlzLl9kcmF3VGV4dChjdHgsIHgsIHRoaXMuc2l6ZS55TGluZSwgYmFzZWxpbmUsIHZpZXdGb250U2l6ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGxhYmVsIGJhY2tncm91bmRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3QmFja2dyb3VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0JhY2tncm91bmQoY3R4KSB7XG4gICAgICBpZiAodGhpcy5mb250T3B0aW9ucy5iYWNrZ3JvdW5kICE9PSB1bmRlZmluZWQgJiYgdGhpcy5mb250T3B0aW9ucy5iYWNrZ3JvdW5kICE9PSBcIm5vbmVcIikge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5mb250T3B0aW9ucy5iYWNrZ3JvdW5kO1xuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgICAgICBjdHguZmlsbFJlY3Qoc2l6ZS5sZWZ0LCBzaXplLnRvcCwgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Jhc2VsaW5lPSdtaWRkbGUnXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2aWV3Rm9udFNpemVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3VGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd1RleHQoY3R4LCB4LCB5KSB7XG4gICAgICB2YXIgYmFzZWxpbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFwibWlkZGxlXCI7XG4gICAgICB2YXIgdmlld0ZvbnRTaXplID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgX3RoaXMkX3NldEFsaWdubWVudCA9IHRoaXMuX3NldEFsaWdubWVudChjdHgsIHgsIHksIGJhc2VsaW5lKTtcbiAgICAgIHZhciBfdGhpcyRfc2V0QWxpZ25tZW50MiA9IF9zbGljZWRUb0FycmF5KF90aGlzJF9zZXRBbGlnbm1lbnQsIDIpO1xuICAgICAgeCA9IF90aGlzJF9zZXRBbGlnbm1lbnQyWzBdO1xuICAgICAgeSA9IF90aGlzJF9zZXRBbGlnbm1lbnQyWzFdO1xuICAgICAgY3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgeCA9IHggLSB0aGlzLnNpemUud2lkdGggLyAyOyAvLyBTaGlmdCBsYWJlbCAxLzItZGlzdGFuY2UgdG8gdGhlIGxlZnRcbiAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLnZhbGlnbiAmJiB0aGlzLnNpemUuaGVpZ2h0ID4gdGhpcy5zaXplLmxhYmVsSGVpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLnZhbGlnbiA9PT0gXCJ0b3BcIikge1xuICAgICAgICAgIHkgLT0gKHRoaXMuc2l6ZS5oZWlnaHQgLSB0aGlzLnNpemUubGFiZWxIZWlnaHQpIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mb250T3B0aW9ucy52YWxpZ24gPT09IFwiYm90dG9tXCIpIHtcbiAgICAgICAgICB5ICs9ICh0aGlzLnNpemUuaGVpZ2h0IC0gdGhpcy5zaXplLmxhYmVsSGVpZ2h0KSAvIDI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZHJhdyB0aGUgdGV4dFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVDb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5saW5lc1tpXTtcbiAgICAgICAgaWYgKGxpbmUgJiYgbGluZS5ibG9ja3MpIHtcbiAgICAgICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgICAgIGlmICh0aGlzLmlzRWRnZUxhYmVsIHx8IHRoaXMuZm9udE9wdGlvbnMuYWxpZ24gPT09IFwiY2VudGVyXCIpIHtcbiAgICAgICAgICAgIHdpZHRoICs9ICh0aGlzLnNpemUud2lkdGggLSBsaW5lLndpZHRoKSAvIDI7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZvbnRPcHRpb25zLmFsaWduID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICAgIHdpZHRoICs9IHRoaXMuc2l6ZS53aWR0aCAtIGxpbmUud2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZS5ibG9ja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBibG9jayA9IGxpbmUuYmxvY2tzW2pdO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBibG9jay5mb250O1xuICAgICAgICAgICAgdmFyIF90aGlzJF9nZXRDb2xvciA9IHRoaXMuX2dldENvbG9yKGJsb2NrLmNvbG9yLCB2aWV3Rm9udFNpemUsIGJsb2NrLnN0cm9rZUNvbG9yKSxcbiAgICAgICAgICAgICAgX3RoaXMkX2dldENvbG9yMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJF9nZXRDb2xvciwgMiksXG4gICAgICAgICAgICAgIGZvbnRDb2xvciA9IF90aGlzJF9nZXRDb2xvcjJbMF0sXG4gICAgICAgICAgICAgIHN0cm9rZUNvbG9yID0gX3RoaXMkX2dldENvbG9yMlsxXTtcbiAgICAgICAgICAgIGlmIChibG9jay5zdHJva2VXaWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGJsb2NrLnN0cm9rZVdpZHRoO1xuICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvcjtcbiAgICAgICAgICAgICAgY3R4LmxpbmVKb2luID0gXCJyb3VuZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZvbnRDb2xvcjtcbiAgICAgICAgICAgIGlmIChibG9jay5zdHJva2VXaWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgY3R4LnN0cm9rZVRleHQoYmxvY2sudGV4dCwgeCArIHdpZHRoLCB5ICsgYmxvY2sudmFkanVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoYmxvY2sudGV4dCwgeCArIHdpZHRoLCB5ICsgYmxvY2sudmFkanVzdCk7XG4gICAgICAgICAgICB3aWR0aCArPSBibG9jay53aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgeSArPSBsaW5lLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZWxpbmVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfc2V0QWxpZ25tZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRBbGlnbm1lbnQoY3R4LCB4LCB5LCBiYXNlbGluZSkge1xuICAgICAgLy8gY2hlY2sgZm9yIGxhYmVsIGFsaWdubWVudCAoZm9yIGVkZ2VzKVxuICAgICAgLy8gVE9ETzogbWFrZSBhbGlnbm1lbnQgZm9yIG5vZGVzXG4gICAgICBpZiAodGhpcy5pc0VkZ2VMYWJlbCAmJiB0aGlzLmZvbnRPcHRpb25zLmFsaWduICE9PSBcImhvcml6b250YWxcIiAmJiB0aGlzLnBvaW50VG9TZWxmID09PSBmYWxzZSkge1xuICAgICAgICB4ID0gMDtcbiAgICAgICAgeSA9IDA7XG4gICAgICAgIHZhciBsaW5lTWFyZ2luID0gMjtcbiAgICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMuYWxpZ24gPT09IFwidG9wXCIpIHtcbiAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJhbHBoYWJldGljXCI7XG4gICAgICAgICAgeSAtPSAyICogbGluZU1hcmdpbjsgLy8gZGlzdGFuY2UgZnJvbSBlZGdlLCByZXF1aXJlZCBiZWNhdXNlIHdlIHVzZSBhbHBoYWJldGljLiBBbHBoYWJldGljIGhhcyBsZXNzIGRpZmZlcmVuY2UgYmV0d2VlbiBicm93c2Vyc1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZm9udE9wdGlvbnMuYWxpZ24gPT09IFwiYm90dG9tXCIpIHtcbiAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJoYW5naW5nXCI7XG4gICAgICAgICAgeSArPSAyICogbGluZU1hcmdpbjsgLy8gZGlzdGFuY2UgZnJvbSBlZGdlLCByZXF1aXJlZCBiZWNhdXNlIHdlIHVzZSBoYW5naW5nLiBIYW5naW5nIGhhcyBsZXNzIGRpZmZlcmVuY2UgYmV0d2VlbiBicm93c2Vyc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gYmFzZWxpbmU7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGZhZGUgaW4gd2hlbiByZWxhdGl2ZSBzY2FsZSBpcyBiZXR3ZWVuIHRocmVzaG9sZCBhbmQgdGhyZXNob2xkIC0gMS5cbiAgICAgKiBJZiB0aGUgcmVsYXRpdmUgc2NhbGUgd291bGQgYmUgc21hbGxlciB0aGFuIHRocmVzaG9sZCAtMSB0aGUgZHJhdyBmdW5jdGlvbiB3b3VsZCBoYXZlIHJldHVybmVkIGJlZm9yZSBjb21pbmcgaGVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciAgVGhlIGZvbnQgY29sb3IgdG8gdXNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZpZXdGb250U2l6ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbml0aWFsU3Ryb2tlQ29sb3JcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59IEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGZvbnQgY29sb3IgYW5kIHN0cm9rZSBjb2xvclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldENvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDb2xvcihjb2xvciwgdmlld0ZvbnRTaXplLCBpbml0aWFsU3Ryb2tlQ29sb3IpIHtcbiAgICAgIHZhciBmb250Q29sb3IgPSBjb2xvciB8fCBcIiMwMDAwMDBcIjtcbiAgICAgIHZhciBzdHJva2VDb2xvciA9IGluaXRpYWxTdHJva2VDb2xvciB8fCBcIiNmZmZmZmZcIjtcbiAgICAgIGlmICh2aWV3Rm9udFNpemUgPD0gdGhpcy5lbGVtZW50T3B0aW9ucy5zY2FsaW5nLmxhYmVsLmRyYXdUaHJlc2hvbGQpIHtcbiAgICAgICAgdmFyIG9wYWNpdHkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAxIC0gKHRoaXMuZWxlbWVudE9wdGlvbnMuc2NhbGluZy5sYWJlbC5kcmF3VGhyZXNob2xkIC0gdmlld0ZvbnRTaXplKSkpO1xuICAgICAgICBmb250Q29sb3IgPSBvdmVycmlkZU9wYWNpdHkoZm9udENvbG9yLCBvcGFjaXR5KTtcbiAgICAgICAgc3Ryb2tlQ29sb3IgPSBvdmVycmlkZU9wYWNpdHkoc3Ryb2tlQ29sb3IsIG9wYWNpdHkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtmb250Q29sb3IsIHN0cm9rZUNvbG9yXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEByZXR1cm5zIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFRleHRTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRleHRTaXplKGN0eCkge1xuICAgICAgdmFyIHNlbGVjdGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHZhciBob3ZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICB0aGlzLl9wcm9jZXNzTGFiZWwoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHRoaXMuc2l6ZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLnNpemUuaGVpZ2h0LFxuICAgICAgICBsaW5lQ291bnQ6IHRoaXMubGluZUNvdW50XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBkaW1lbnNpb25zIG9mIHRoZSBsYWJlbFxuICAgICAqXG4gICAgICogQHJldHVybnMge3JlY3R9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTaXplKCkge1xuICAgICAgdmFyIGxpbmVNYXJnaW4gPSAyO1xuICAgICAgdmFyIHggPSB0aGlzLnNpemUubGVmdDsgLy8gZGVmYXVsdCB2YWx1ZXMgd2hpY2ggbWlnaHQgYmUgb3ZlcnJpZGRlbiBiZWxvd1xuICAgICAgdmFyIHkgPSB0aGlzLnNpemUudG9wIC0gMC41ICogbGluZU1hcmdpbjsgLy8gaWRlbVxuXG4gICAgICBpZiAodGhpcy5pc0VkZ2VMYWJlbCkge1xuICAgICAgICB2YXIgeDIgPSAtdGhpcy5zaXplLndpZHRoICogMC41O1xuICAgICAgICBzd2l0Y2ggKHRoaXMuZm9udE9wdGlvbnMuYWxpZ24pIHtcbiAgICAgICAgICBjYXNlIFwibWlkZGxlXCI6XG4gICAgICAgICAgICB4ID0geDI7XG4gICAgICAgICAgICB5ID0gLXRoaXMuc2l6ZS5oZWlnaHQgKiAwLjU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgICAgICB4ID0geDI7XG4gICAgICAgICAgICB5ID0gLSh0aGlzLnNpemUuaGVpZ2h0ICsgbGluZU1hcmdpbik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgICB4ID0geDI7XG4gICAgICAgICAgICB5ID0gbGluZU1hcmdpbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgcmV0ID0ge1xuICAgICAgICBsZWZ0OiB4LFxuICAgICAgICB0b3A6IHksXG4gICAgICAgIHdpZHRoOiB0aGlzLnNpemUud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5zaXplLmhlaWdodFxuICAgICAgfTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cbiAgICAgKiBAcGFyYW0geydtaWRkbGUnfCdoYW5naW5nJ30gW2Jhc2VsaW5lPSdtaWRkbGUnXVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNhbGN1bGF0ZUxhYmVsU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVMYWJlbFNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIHZhciB4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDA7XG4gICAgICB2YXIgYmFzZWxpbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IFwibWlkZGxlXCI7XG4gICAgICB0aGlzLl9wcm9jZXNzTGFiZWwoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5zaXplLmxlZnQgPSB4IC0gdGhpcy5zaXplLndpZHRoICogMC41O1xuICAgICAgdGhpcy5zaXplLnRvcCA9IHkgLSB0aGlzLnNpemUuaGVpZ2h0ICogMC41O1xuICAgICAgdGhpcy5zaXplLnlMaW5lID0geSArICgxIC0gdGhpcy5saW5lQ291bnQpICogMC41ICogdGhpcy5mb250T3B0aW9ucy5zaXplO1xuICAgICAgaWYgKGJhc2VsaW5lID09PSBcImhhbmdpbmdcIikge1xuICAgICAgICB0aGlzLnNpemUudG9wICs9IDAuNSAqIHRoaXMuZm9udE9wdGlvbnMuc2l6ZTtcbiAgICAgICAgdGhpcy5zaXplLnRvcCArPSA0OyAvLyBkaXN0YW5jZSBmcm9tIG5vZGUsIHJlcXVpcmVkIGJlY2F1c2Ugd2UgdXNlIGhhbmdpbmcuIEhhbmdpbmcgaGFzIGxlc3MgZGlmZmVyZW5jZSBiZXR3ZWVuIGJyb3dzZXJzXG4gICAgICAgIHRoaXMuc2l6ZS55TGluZSArPSA0OyAvLyBkaXN0YW5jZSBmcm9tIG5vZGVcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RcbiAgICAgKiBAcmV0dXJucyB7e2NvbG9yLCBzaXplLCBmYWNlLCBtb2QsIHZhZGp1c3QsIHN0cm9rZVdpZHRoOiAqLCBzdHJva2VDb2xvcjogKCp8c3RyaW5nfGFsbE9wdGlvbnMuZWRnZXMuZm9udC5zdHJva2VDb2xvcnx7c3RyaW5nfXxhbGxPcHRpb25zLm5vZGVzLmZvbnQuc3Ryb2tlQ29sb3J8QXJyYXkpfX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRGb3JtYXR0aW5nVmFsdWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZvcm1hdHRpbmdWYWx1ZXMoY3R4LCBzZWxlY3RlZCwgaG92ZXIsIG1vZCkge1xuICAgICAgdmFyIGdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoZm9udE9wdGlvbnMsIG1vZCwgb3B0aW9uKSB7XG4gICAgICAgIGlmIChtb2QgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICBpZiAob3B0aW9uID09PSBcIm1vZFwiKSByZXR1cm4gXCJcIjtcbiAgICAgICAgICByZXR1cm4gZm9udE9wdGlvbnNbb3B0aW9uXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9udE9wdGlvbnNbbW9kXVtvcHRpb25dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBHcnVtYmwgbGVhdmluZyBvdXQgdGVzdCBvbiB1bmRlZmluZWQgZXF1YWxzIGZhbHNlIGZvciBcIlwiXG4gICAgICAgICAgcmV0dXJuIGZvbnRPcHRpb25zW21vZF1bb3B0aW9uXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUYWtlIGZyb20gcGFyZW50IGZvbnQgb3B0aW9uXG4gICAgICAgICAgcmV0dXJuIGZvbnRPcHRpb25zW29wdGlvbl07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgdmFsdWVzID0ge1xuICAgICAgICBjb2xvcjogZ2V0VmFsdWUodGhpcy5mb250T3B0aW9ucywgbW9kLCBcImNvbG9yXCIpLFxuICAgICAgICBzaXplOiBnZXRWYWx1ZSh0aGlzLmZvbnRPcHRpb25zLCBtb2QsIFwic2l6ZVwiKSxcbiAgICAgICAgZmFjZTogZ2V0VmFsdWUodGhpcy5mb250T3B0aW9ucywgbW9kLCBcImZhY2VcIiksXG4gICAgICAgIG1vZDogZ2V0VmFsdWUodGhpcy5mb250T3B0aW9ucywgbW9kLCBcIm1vZFwiKSxcbiAgICAgICAgdmFkanVzdDogZ2V0VmFsdWUodGhpcy5mb250T3B0aW9ucywgbW9kLCBcInZhZGp1c3RcIiksXG4gICAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLmZvbnRPcHRpb25zLnN0cm9rZVdpZHRoLFxuICAgICAgICBzdHJva2VDb2xvcjogdGhpcy5mb250T3B0aW9ucy5zdHJva2VDb2xvclxuICAgICAgfTtcbiAgICAgIGlmIChzZWxlY3RlZCB8fCBob3Zlcikge1xuICAgICAgICBpZiAobW9kID09PSBcIm5vcm1hbFwiICYmIHRoaXMuZm9udE9wdGlvbnMuY2hvb3NlciA9PT0gdHJ1ZSAmJiB0aGlzLmVsZW1lbnRPcHRpb25zLmxhYmVsSGlnaGxpZ2h0Qm9sZCkge1xuICAgICAgICAgIHZhbHVlcy5tb2QgPSBcImJvbGRcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuZm9udE9wdGlvbnMuY2hvb3NlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmZvbnRPcHRpb25zLmNob29zZXIodmFsdWVzLCB0aGlzLmVsZW1lbnRPcHRpb25zLmlkLCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGZvbnRTdHJpbmcgPSBcIlwiO1xuICAgICAgaWYgKHZhbHVlcy5tb2QgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZXMubW9kICE9PSBcIlwiKSB7XG4gICAgICAgIC8vIHNhZmVndWFyZCBmb3IgdW5kZWZpbmVkIC0gdGhpcyBoYXBwZW5lZFxuICAgICAgICBmb250U3RyaW5nICs9IHZhbHVlcy5tb2QgKyBcIiBcIjtcbiAgICAgIH1cbiAgICAgIGZvbnRTdHJpbmcgKz0gdmFsdWVzLnNpemUgKyBcInB4IFwiICsgdmFsdWVzLmZhY2U7XG4gICAgICBjdHguZm9udCA9IGZvbnRTdHJpbmcucmVwbGFjZSgvXCIvZywgXCJcIik7XG4gICAgICB2YWx1ZXMuZm9udCA9IGN0eC5mb250O1xuICAgICAgdmFsdWVzLmhlaWdodCA9IHZhbHVlcy5zaXplO1xuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlmZmVyZW50U3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlmZmVyZW50U3RhdGUoc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICByZXR1cm4gc2VsZWN0ZWQgIT09IHRoaXMuc2VsZWN0ZWRTdGF0ZSB8fCBob3ZlciAhPT0gdGhpcy5ob3ZlclN0YXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXhwbG9kZXMgdGhlIHBhc3NlZCB0ZXh0IGludG8gbGluZXMgYW5kIGRldGVybWluZXMgdGhlIHdpZHRoLCBoZWlnaHQgYW5kIG51bWJlciBvZiBsaW5lcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpblRleHQgIHRoZSB0ZXh0IHRvIGV4cGxvZGVcbiAgICAgKiBAcmV0dXJucyB7e3dpZHRoLCBoZWlnaHQsIGxpbmVzfXwqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Byb2Nlc3NMYWJlbFRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Byb2Nlc3NMYWJlbFRleHQoY3R4LCBzZWxlY3RlZCwgaG92ZXIsIGluVGV4dCkge1xuICAgICAgdmFyIHNwbGl0dGVyID0gbmV3IExhYmVsU3BsaXR0ZXIoY3R4LCB0aGlzLCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgcmV0dXJuIHNwbGl0dGVyLnByb2Nlc3MoaW5UZXh0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV4cGxvZGVzIHRoZSBsYWJlbCBzdHJpbmcgaW50byBsaW5lcyBhbmQgc2V0cyB0aGUgd2lkdGgsIGhlaWdodCBhbmQgbnVtYmVyIG9mIGxpbmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfcHJvY2Vzc0xhYmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wcm9jZXNzTGFiZWwoY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIGlmICh0aGlzLmxhYmVsRGlydHkgPT09IGZhbHNlICYmICF0aGlzLmRpZmZlcmVudFN0YXRlKHNlbGVjdGVkLCBob3ZlcikpIHJldHVybjtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3Byb2Nlc3NMYWJlbFRleHQoY3R4LCBzZWxlY3RlZCwgaG92ZXIsIHRoaXMuZWxlbWVudE9wdGlvbnMubGFiZWwpO1xuICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMubWluV2R0ID4gMCAmJiBzdGF0ZS53aWR0aCA8IHRoaXMuZm9udE9wdGlvbnMubWluV2R0KSB7XG4gICAgICAgIHN0YXRlLndpZHRoID0gdGhpcy5mb250T3B0aW9ucy5taW5XZHQ7XG4gICAgICB9XG4gICAgICB0aGlzLnNpemUubGFiZWxIZWlnaHQgPSBzdGF0ZS5oZWlnaHQ7XG4gICAgICBpZiAodGhpcy5mb250T3B0aW9ucy5taW5IZ3QgPiAwICYmIHN0YXRlLmhlaWdodCA8IHRoaXMuZm9udE9wdGlvbnMubWluSGd0KSB7XG4gICAgICAgIHN0YXRlLmhlaWdodCA9IHRoaXMuZm9udE9wdGlvbnMubWluSGd0O1xuICAgICAgfVxuICAgICAgdGhpcy5saW5lcyA9IHN0YXRlLmxpbmVzO1xuICAgICAgdGhpcy5saW5lQ291bnQgPSBzdGF0ZS5saW5lcy5sZW5ndGg7XG4gICAgICB0aGlzLnNpemUud2lkdGggPSBzdGF0ZS53aWR0aDtcbiAgICAgIHRoaXMuc2l6ZS5oZWlnaHQgPSBzdGF0ZS5oZWlnaHQ7XG4gICAgICB0aGlzLnNlbGVjdGVkU3RhdGUgPSBzZWxlY3RlZDtcbiAgICAgIHRoaXMuaG92ZXJTdGF0ZSA9IGhvdmVyO1xuICAgICAgdGhpcy5sYWJlbERpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBsYWJlbCBpcyB2aXNpYmxlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGxhYmVsIHdpbGwgYmUgc2hvdywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidmlzaWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aXNpYmxlKCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZS53aWR0aCA9PT0gMCB8fCB0aGlzLnNpemUuaGVpZ2h0ID09PSAwIHx8IHRoaXMuZWxlbWVudE9wdGlvbnMubGFiZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG5vdGhpbmcgdG8gZGlzcGxheVxuICAgICAgfVxuXG4gICAgICB2YXIgdmlld0ZvbnRTaXplID0gdGhpcy5mb250T3B0aW9ucy5zaXplICogdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICBpZiAodmlld0ZvbnRTaXplIDwgdGhpcy5lbGVtZW50T3B0aW9ucy5zY2FsaW5nLmxhYmVsLmRyYXdUaHJlc2hvbGQgLSAxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gVG9vIHNtYWxsIG9yIHRvbyBmYXIgYXdheSB0byBzaG93XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInBhcnNlRm9udFN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUZvbnRTdHJpbmcob3V0T3B0aW9ucywgaW5PcHRpb25zKSB7XG4gICAgICBpZiAoIWluT3B0aW9ucyB8fCB0eXBlb2YgaW5PcHRpb25zICE9PSBcInN0cmluZ1wiKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgbmV3T3B0aW9uc0FycmF5ID0gaW5PcHRpb25zLnNwbGl0KFwiIFwiKTtcbiAgICAgIG91dE9wdGlvbnMuc2l6ZSA9ICtuZXdPcHRpb25zQXJyYXlbMF0ucmVwbGFjZShcInB4XCIsIFwiXCIpO1xuICAgICAgb3V0T3B0aW9ucy5mYWNlID0gbmV3T3B0aW9uc0FycmF5WzFdO1xuICAgICAgb3V0T3B0aW9ucy5jb2xvciA9IG5ld09wdGlvbnNBcnJheVsyXTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTGFiZWw7XG59KCk7XG5cbnZhciBpc0NvbnN0cnVjdG9yID0gaXNDb25zdHJ1Y3RvciQ0O1xudmFyIHRyeVRvU3RyaW5nID0gdHJ5VG9TdHJpbmckNjtcblxudmFyICRUeXBlRXJyb3IkMSA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogSXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkgaXMgdHJ1ZWBcbnZhciBhQ29uc3RydWN0b3IkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IkMSh0cnlUb1N0cmluZyhhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG59O1xuXG52YXIgJCQ2ID0gX2V4cG9ydDtcbnZhciBnZXRCdWlsdEluID0gZ2V0QnVpbHRJbiRjO1xudmFyIGFwcGx5ID0gZnVuY3Rpb25BcHBseTtcbnZhciBiaW5kJDMgPSBmdW5jdGlvbkJpbmQ7XG52YXIgYUNvbnN0cnVjdG9yID0gYUNvbnN0cnVjdG9yJDE7XG52YXIgYW5PYmplY3QkMiA9IGFuT2JqZWN0JGQ7XG52YXIgaXNPYmplY3QkMyA9IGlzT2JqZWN0JGo7XG52YXIgY3JlYXRlJDMgPSBvYmplY3RDcmVhdGU7XG52YXIgZmFpbHMkMiA9IGZhaWxzJHc7XG5cbnZhciBuYXRpdmVDb25zdHJ1Y3QgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ2NvbnN0cnVjdCcpO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgcHVzaCQxID0gW10ucHVzaDtcblxuLy8gYFJlZmxlY3QuY29uc3RydWN0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVmbGVjdC5jb25zdHJ1Y3Rcbi8vIE1TIEVkZ2Ugc3VwcG9ydHMgb25seSAyIGFyZ3VtZW50cyBhbmQgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuLy8gRkYgTmlnaHRseSBzZXRzIHRoaXJkIGFyZ3VtZW50IGFzIGBuZXcudGFyZ2V0YCwgYnV0IGRvZXMgbm90IGNyZWF0ZSBgdGhpc2AgZnJvbSBpdFxudmFyIE5FV19UQVJHRVRfQlVHID0gZmFpbHMkMihmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuICEobmF0aXZlQ29uc3RydWN0KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgW10sIEYpIGluc3RhbmNlb2YgRik7XG59KTtcblxudmFyIEFSR1NfQlVHID0gIWZhaWxzJDIoZnVuY3Rpb24gKCkge1xuICBuYXRpdmVDb25zdHJ1Y3QoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbn0pO1xuXG52YXIgRk9SQ0VEJDMgPSBORVdfVEFSR0VUX0JVRyB8fCBBUkdTX0JVRztcblxuJCQ2KHsgdGFyZ2V0OiAnUmVmbGVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRk9SQ0VEJDMsIHNoYW06IEZPUkNFRCQzIH0sIHtcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzIC8qICwgbmV3VGFyZ2V0ICovKSB7XG4gICAgYUNvbnN0cnVjdG9yKFRhcmdldCk7XG4gICAgYW5PYmplY3QkMihhcmdzKTtcbiAgICB2YXIgbmV3VGFyZ2V0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBUYXJnZXQgOiBhQ29uc3RydWN0b3IoYXJndW1lbnRzWzJdKTtcbiAgICBpZiAoQVJHU19CVUcgJiYgIU5FV19UQVJHRVRfQlVHKSByZXR1cm4gbmF0aXZlQ29uc3RydWN0KFRhcmdldCwgYXJncywgbmV3VGFyZ2V0KTtcbiAgICBpZiAoVGFyZ2V0ID09PSBuZXdUYXJnZXQpIHtcbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgb3B0aW1pemF0aW9uIGZvciAwLTQgYXJndW1lbnRzXG4gICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBUYXJnZXQoKTtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdKTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgIH1cbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgbG90IG9mIGFyZ3VtZW50cyBjYXNlXG4gICAgICB2YXIgJGFyZ3MgPSBbbnVsbF07XG4gICAgICBhcHBseShwdXNoJDEsICRhcmdzLCBhcmdzKTtcbiAgICAgIHJldHVybiBuZXcgKGFwcGx5KGJpbmQkMywgVGFyZ2V0LCAkYXJncykpKCk7XG4gICAgfVxuICAgIC8vIHdpdGggYWx0ZXJlZCBuZXdUYXJnZXQsIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGNvbnN0cnVjdG9yc1xuICAgIHZhciBwcm90byA9IG5ld1RhcmdldC5wcm90b3R5cGU7XG4gICAgdmFyIGluc3RhbmNlID0gY3JlYXRlJDMoaXNPYmplY3QkMyhwcm90bykgPyBwcm90byA6IE9iamVjdFByb3RvdHlwZSk7XG4gICAgdmFyIHJlc3VsdCA9IGFwcGx5KFRhcmdldCwgaW5zdGFuY2UsIGFyZ3MpO1xuICAgIHJldHVybiBpc09iamVjdCQzKHJlc3VsdCkgPyByZXN1bHQgOiBpbnN0YW5jZTtcbiAgfVxufSk7XG5cbnZhciBwYXRoJDYgPSBwYXRoJHc7XG5cbnZhciBjb25zdHJ1Y3QkMiA9IHBhdGgkNi5SZWZsZWN0LmNvbnN0cnVjdDtcblxudmFyIHBhcmVudCRrID0gY29uc3RydWN0JDI7XG5cbnZhciBjb25zdHJ1Y3QkMSA9IHBhcmVudCRrO1xuXG52YXIgY29uc3RydWN0ID0gY29uc3RydWN0JDE7XG5cbnZhciBfUmVmbGVjdCRjb25zdHJ1Y3QgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoY29uc3RydWN0KTtcblxudmFyIHBhcmVudCRqID0gY3JlYXRlJDY7XG5cbnZhciBjcmVhdGUkMiA9IHBhcmVudCRqO1xuXG52YXIgcGFyZW50JGkgPSBjcmVhdGUkMjtcblxudmFyIGNyZWF0ZSQxID0gcGFyZW50JGk7XG5cbnZhciBjcmVhdGUgPSBjcmVhdGUkMTtcblxudmFyIF9PYmplY3QkY3JlYXRlID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGNyZWF0ZSk7XG5cbnZhciAkJDUgPSBfZXhwb3J0O1xudmFyIHNldFByb3RvdHlwZU9mJDUgPSBvYmplY3RTZXRQcm90b3R5cGVPZjtcblxuLy8gYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5zZXRwcm90b3R5cGVvZlxuJCQ1KHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSB9LCB7XG4gIHNldFByb3RvdHlwZU9mOiBzZXRQcm90b3R5cGVPZiQ1XG59KTtcblxudmFyIHBhdGgkNSA9IHBhdGgkdztcblxudmFyIHNldFByb3RvdHlwZU9mJDQgPSBwYXRoJDUuT2JqZWN0LnNldFByb3RvdHlwZU9mO1xuXG52YXIgcGFyZW50JGggPSBzZXRQcm90b3R5cGVPZiQ0O1xuXG52YXIgc2V0UHJvdG90eXBlT2YkMyA9IHBhcmVudCRoO1xuXG52YXIgcGFyZW50JGcgPSBzZXRQcm90b3R5cGVPZiQzO1xuXG52YXIgc2V0UHJvdG90eXBlT2YkMiA9IHBhcmVudCRnO1xuXG52YXIgcGFyZW50JGYgPSBzZXRQcm90b3R5cGVPZiQyO1xuXG52YXIgc2V0UHJvdG90eXBlT2YkMSA9IHBhcmVudCRmO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgPSBzZXRQcm90b3R5cGVPZiQxO1xuXG52YXIgX09iamVjdCRzZXRQcm90b3R5cGVPZiA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhzZXRQcm90b3R5cGVPZik7XG5cbnZhciBwYXJlbnQkZSA9IGJpbmQkOTtcblxudmFyIGJpbmQkMiA9IHBhcmVudCRlO1xuXG52YXIgcGFyZW50JGQgPSBiaW5kJDI7XG5cbnZhciBiaW5kJDEgPSBwYXJlbnQkZDtcblxudmFyIGJpbmQgPSBiaW5kJDE7XG5cbnZhciBfYmluZEluc3RhbmNlUHJvcGVydHkgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoYmluZCk7XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIHZhciBfY29udGV4dDtcbiAgX3NldFByb3RvdHlwZU9mID0gX09iamVjdCRzZXRQcm90b3R5cGVPZiA/IF9iaW5kSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dCA9IF9PYmplY3Qkc2V0UHJvdG90eXBlT2YpLmNhbGwoX2NvbnRleHQpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IF9PYmplY3QkY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBfT2JqZWN0JGRlZmluZVByb3BlcnR5JDEoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxudmFyIHBhcmVudCRjID0gZ2V0UHJvdG90eXBlT2YkNTtcblxudmFyIGdldFByb3RvdHlwZU9mJDMgPSBwYXJlbnQkYztcblxudmFyIHBhcmVudCRiID0gZ2V0UHJvdG90eXBlT2YkMztcblxudmFyIGdldFByb3RvdHlwZU9mJDIgPSBwYXJlbnQkYjtcblxudmFyIGdldFByb3RvdHlwZU9mJDEgPSBnZXRQcm90b3R5cGVPZiQyO1xuXG52YXIgX09iamVjdCRnZXRQcm90b3R5cGVPZiA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhnZXRQcm90b3R5cGVPZiQxKTtcblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgdmFyIF9jb250ZXh0O1xuICBfZ2V0UHJvdG90eXBlT2YgPSBfT2JqZWN0JHNldFByb3RvdHlwZU9mID8gX2JpbmRJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0ID0gX09iamVjdCRnZXRQcm90b3R5cGVPZikuY2FsbChfY29udGV4dCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBfT2JqZWN0JGdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG4vKipcbiAqIFRoZSBCYXNlIGNsYXNzIGZvciBhbGwgTm9kZXMuXG4gKi9cbnZhciBOb2RlQmFzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gTm9kZUJhc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZUJhc2UpO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5sYWJlbE1vZHVsZSA9IGxhYmVsTW9kdWxlO1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1hcmdpbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJlZnJlc2hOZWVkZWQgPSB0cnVlO1xuICAgIHRoaXMuYm91bmRpbmdCb3ggPSB7XG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDBcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoTm9kZUJhc2UsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9zZXRNYXJnaW5zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRNYXJnaW5zKGxhYmVsTW9kdWxlKSB7XG4gICAgICB0aGlzLm1hcmdpbiA9IHt9O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXJnaW4pIHtcbiAgICAgICAgaWYgKF90eXBlb2YodGhpcy5vcHRpb25zLm1hcmdpbikgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRoaXMubWFyZ2luLnRvcCA9IHRoaXMub3B0aW9ucy5tYXJnaW4udG9wO1xuICAgICAgICAgIHRoaXMubWFyZ2luLnJpZ2h0ID0gdGhpcy5vcHRpb25zLm1hcmdpbi5yaWdodDtcbiAgICAgICAgICB0aGlzLm1hcmdpbi5ib3R0b20gPSB0aGlzLm9wdGlvbnMubWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICB0aGlzLm1hcmdpbi5sZWZ0ID0gdGhpcy5vcHRpb25zLm1hcmdpbi5sZWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubWFyZ2luLnRvcCA9IHRoaXMub3B0aW9ucy5tYXJnaW47XG4gICAgICAgICAgdGhpcy5tYXJnaW4ucmlnaHQgPSB0aGlzLm9wdGlvbnMubWFyZ2luO1xuICAgICAgICAgIHRoaXMubWFyZ2luLmJvdHRvbSA9IHRoaXMub3B0aW9ucy5tYXJnaW47XG4gICAgICAgICAgdGhpcy5tYXJnaW4ubGVmdCA9IHRoaXMub3B0aW9ucy5tYXJnaW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhYmVsTW9kdWxlLmFkanVzdFNpemVzKHRoaXMubWFyZ2luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgdmFyIGJvcmRlcldpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgaWYgKGN0eCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGguYWJzKHRoaXMud2lkdGggLyAyIC8gTWF0aC5jb3MoYW5nbGUpKSwgTWF0aC5hYnModGhpcy5oZWlnaHQgLyAyIC8gTWF0aC5zaW4oYW5nbGUpKSkgKyBib3JkZXJXaWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZW5hYmxlU2hhZG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlcy5zaGFkb3cpIHtcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gdmFsdWVzLnNoYWRvd0NvbG9yO1xuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IHZhbHVlcy5zaGFkb3dTaXplO1xuICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHZhbHVlcy5zaGFkb3dYO1xuICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHZhbHVlcy5zaGFkb3dZO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkaXNhYmxlU2hhZG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuc2hhZG93KSB7XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwicmdiYSgwLDAsMCwwKVwiO1xuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDA7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJlbmFibGVCb3JkZXJEYXNoZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlQm9yZGVyRGFzaGVzKGN0eCwgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLmJvcmRlckRhc2hlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGRhc2hlcyA9IHZhbHVlcy5ib3JkZXJEYXNoZXM7XG4gICAgICAgICAgaWYgKGRhc2hlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZGFzaGVzID0gWzUsIDE1XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwic2V0TGluZURhc2ggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuIFRoZSBkYXNoZWQgYm9yZGVycyBjYW5ub3QgYmUgdXNlZC5cIik7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJEYXNoZXMgPSBmYWxzZTtcbiAgICAgICAgICB2YWx1ZXMuYm9yZGVyRGFzaGVzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzYWJsZUJvcmRlckRhc2hlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlQm9yZGVyRGFzaGVzKGN0eCwgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLmJvcmRlckRhc2hlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKFswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwic2V0TGluZURhc2ggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuIFRoZSBkYXNoZWQgYm9yZGVycyBjYW5ub3QgYmUgdXNlZC5cIik7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJEYXNoZXMgPSBmYWxzZTtcbiAgICAgICAgICB2YWx1ZXMuYm9yZGVyRGFzaGVzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgdGhlIHNoYXBlIG9mIGEgbm9kZSBuZWVkcyB0byBiZSByZWNhbGN1bGF0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJuZWVkc1JlZnJlc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgaWYgKHRoaXMucmVmcmVzaE5lZWRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IG5vdCB0aGUgYmVzdCBsb2NhdGlvbiB0byByZXNldCB0aGlzIG1lbWJlci5cbiAgICAgICAgLy8gSG93ZXZlciwgaW4gdGhlIGN1cnJlbnQgbG9naWMsIGl0IGlzIHRoZSBtb3N0IGNvbnZlbmllbnQgb25lLlxuICAgICAgICB0aGlzLnJlZnJlc2hOZWVkZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53aWR0aCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMubGFiZWxNb2R1bGUuZGlmZmVyZW50U3RhdGUoc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdENvbnRleHRGb3JEcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRDb250ZXh0Rm9yRHJhdyhjdHgsIHZhbHVlcykge1xuICAgICAgdmFyIGJvcmRlcldpZHRoID0gdmFsdWVzLmJvcmRlcldpZHRoIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICBjdHgubGluZVdpZHRoID0gTWF0aC5taW4odGhpcy53aWR0aCwgYm9yZGVyV2lkdGgpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVzLmJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHZhbHVlcy5jb2xvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicGVyZm9ybVN0cm9rZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwZXJmb3JtU3Ryb2tlKGN0eCwgdmFsdWVzKSB7XG4gICAgICB2YXIgYm9yZGVyV2lkdGggPSB2YWx1ZXMuYm9yZGVyV2lkdGggLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcblxuICAgICAgLy9kcmF3IGRhc2hlZCBib3JkZXIgaWYgZW5hYmxlZCwgc2F2ZSBhbmQgcmVzdG9yZSBpcyByZXF1aXJlZCBmb3IgZmlyZWZveCBub3QgdG8gY3Jhc2ggb24gdW5peC5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAvLyBpZiBib3JkZXJzIGFyZSB6ZXJvIHdpZHRoLCB0aGV5IHdpbGwgYmUgZHJhd24gd2l0aCB3aWR0aCAxIGJ5IGRlZmF1bHQuIFRoaXMgcHJldmVudHMgdGhhdFxuICAgICAgaWYgKGJvcmRlcldpZHRoID4gMCkge1xuICAgICAgICB0aGlzLmVuYWJsZUJvcmRlckRhc2hlcyhjdHgsIHZhbHVlcyk7XG4gICAgICAgIC8vZHJhdyB0aGUgYm9yZGVyXG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgLy9kaXNhYmxlIGRhc2hlZCBib3JkZXIgZm9yIG90aGVyIGVsZW1lbnRzXG4gICAgICAgIHRoaXMuZGlzYWJsZUJvcmRlckRhc2hlcyhjdHgsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwZXJmb3JtRmlsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwZXJmb3JtRmlsbChjdHgsIHZhbHVlcykge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB2YWx1ZXMuY29sb3I7XG4gICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICAvLyBkcmF3IHRoZSBiYWNrZ3JvdW5kXG4gICAgICBfZmlsbEluc3RhbmNlUHJvcGVydHkoY3R4KS5jYWxsKGN0eCk7XG4gICAgICAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLnBlcmZvcm1TdHJva2UoY3R4LCB2YWx1ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1hcmdpblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkZEJvdW5kaW5nQm94TWFyZ2luXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRCb3VuZGluZ0JveE1hcmdpbihtYXJnaW4pIHtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCAtPSBtYXJnaW47XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCAtPSBtYXJnaW47XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSArPSBtYXJnaW47XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ICs9IG1hcmdpbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBY3R1YWwgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgY2FsbC5cbiAgICAgKlxuICAgICAqIERvaW5nIGl0IGxpa2UgdGhpcyBtYWtlcyBpdCBlYXNpZXIgdG8gb3ZlcnJpZGVcbiAgICAgKiBpbiB0aGUgY2hpbGQgY2xhc3Nlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlQm91bmRpbmdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICBpZiAoY3R4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gdGhpcy5sZWZ0O1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB0aGlzLnRvcDtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gdGhpcy50b3AgKyB0aGlzLmhlaWdodDtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB0aGlzLmxlZnQgKyB0aGlzLndpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgY2FsbC5cbiAgICAgKiBUaGlzIGFjdHMgYXMgYSBzdHViIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgdGhpcy5fdXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgZGltZW5zaW9ucyB0byB1c2UgZm9yIG5vZGVzIHdpdGggYW4gaW50ZXJuYWwgbGFiZWxcbiAgICAgKlxuICAgICAqIEN1cnJlbnRseSwgdGhlc2UgYXJlOiBDaXJjbGUsIEVsbGlwc2UsIERhdGFiYXNlLCBCb3hcbiAgICAgKiBUaGUgb3RoZXIgbm9kZXMgaGF2ZSBleHRlcm5hbCBsYWJlbHMsIGFuZCB3aWxsIG5vdCBjYWxsIHRoaXMgbWV0aG9kXG4gICAgICpcbiAgICAgKiBJZiB0aGVyZSBpcyBubyBsYWJlbCwgZGVjZW50IGRlZmF1bHQgdmFsdWVzIGFyZSBzdXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtob3Zlcl1cbiAgICAgKiBAcmV0dXJucyB7e3dpZHRoOm51bWJlciwgaGVpZ2h0Om51bWJlcn19XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGltZW5zaW9uc0Zyb21MYWJlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaW1lbnNpb25zRnJvbUxhYmVsKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICAvLyBOT1RFOiBwcmV2aW91c2x5ICd0ZXh0U2l6ZScgd2FzIG5vdCBwdXQgaW4gJ3RoaXMnIGZvciBFbGxpcHNlXG4gICAgICAvLyBUT0RPOiBleGFtaW5lIHRoZSBjb25zZXF1ZW5jZXMuXG4gICAgICB0aGlzLnRleHRTaXplID0gdGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLnRleHRTaXplLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IHRoaXMudGV4dFNpemUuaGVpZ2h0O1xuICAgICAgdmFyIERFRkFVTFRfU0laRSA9IDE0O1xuICAgICAgaWYgKHdpZHRoID09PSAwKSB7XG4gICAgICAgIC8vIFRoaXMgaGFwcGVucyB3aGVuIHRoZXJlIGlzIG5vIGxhYmVsIHRleHQgc2V0XG4gICAgICAgIHdpZHRoID0gREVGQVVMVF9TSVpFOyAvLyB1c2UgYSBkZWNlbnQgZGVmYXVsdFxuICAgICAgICBoZWlnaHQgPSBERUZBVUxUX1NJWkU7IC8vIGlmIHdpZHRoIHplcm8sIHRoZW4gaGVpZ2h0IGFsc28gYWx3YXlzIHplcm9cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE5vZGVCYXNlO1xufSgpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkcyhEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRzKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IF9SZWZsZWN0JGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHMoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhX1JlZmxlY3QkY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChfUmVmbGVjdCRjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoX1JlZmxlY3QkY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vKipcbiAqIEEgQm94IE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgTm9kZUJhc2VcbiAqL1xudmFyIEJveCQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZUJhc2UpIHtcbiAgX2luaGVyaXRzKEJveCwgX05vZGVCYXNlKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRzKEJveCk7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gQm94KG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCb3gpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICAgIF90aGlzLl9zZXRNYXJnaW5zKGxhYmVsTW9kdWxlKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICogQHBhcmFtIHtib29sZWFufSBbaG92ZXJdXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoQm94LCBbe1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCkge1xuICAgICAgdmFyIHNlbGVjdGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnNlbGVjdGVkO1xuICAgICAgdmFyIGhvdmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLmhvdmVyO1xuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmdldERpbWVuc2lvbnNGcm9tTGFiZWwoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgICB0aGlzLndpZHRoID0gZGltZW5zaW9ucy53aWR0aCArIHRoaXMubWFyZ2luLnJpZ2h0ICsgdGhpcy5tYXJnaW4ubGVmdDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodCArIHRoaXMubWFyZ2luLnRvcCArIHRoaXMubWFyZ2luLmJvdHRvbTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICB0aGlzLmluaXRDb250ZXh0Rm9yRHJhdyhjdHgsIHZhbHVlcyk7XG4gICAgICBkcmF3Um91bmRSZWN0KGN0eCwgdGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHZhbHVlcy5ib3JkZXJSYWRpdXMpO1xuICAgICAgdGhpcy5wZXJmb3JtRmlsbChjdHgsIHZhbHVlcyk7XG4gICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHRoaXMubGVmdCArIHRoaXMudGV4dFNpemUud2lkdGggLyAyICsgdGhpcy5tYXJnaW4ubGVmdCwgdGhpcy50b3AgKyB0aGlzLnRleHRTaXplLmhlaWdodCAvIDIgKyB0aGlzLm1hcmdpbi50b3AsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICB0aGlzLl91cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB2YXIgYm9yZGVyUmFkaXVzID0gdGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJSYWRpdXM7IC8vIG9ubHkgZWZmZWN0aXZlIGZvciBib3hcbiAgICAgIHRoaXMuX2FkZEJvdW5kaW5nQm94TWFyZ2luKGJvcmRlclJhZGl1cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgaWYgKGN0eCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgpO1xuICAgICAgfVxuICAgICAgdmFyIGJvcmRlcldpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGguYWJzKHRoaXMud2lkdGggLyAyIC8gTWF0aC5jb3MoYW5nbGUpKSwgTWF0aC5hYnModGhpcy5oZWlnaHQgLyAyIC8gTWF0aC5zaW4oYW5nbGUpKSkgKyBib3JkZXJXaWR0aDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJveDtcbn0oTm9kZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRyKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IF9SZWZsZWN0JGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHIoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhX1JlZmxlY3QkY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChfUmVmbGVjdCRjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoX1JlZmxlY3QkY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vKipcbiAqIE5PVEU6IFRoaXMgaXMgYSBiYWQgYmFzZSBjbGFzc1xuICpcbiAqIENoaWxkIGNsYXNzZXMgYXJlOlxuICpcbiAqICAgSW1hZ2UgICAgICAgLSB1c2VzICpvbmx5KiBpbWFnZSBtZXRob2RzXG4gKiAgIENpcmNsZSAgICAgIC0gdXNlcyAqb25seSogX2RyYXdSYXdDaXJjbGVcbiAqICAgQ2lyY2xlSW1hZ2UgLSB1c2VzIGFsbFxuICpcbiAqIFRPRE86IFJlZmFjdG9yLCBtb3ZlIF9kcmF3UmF3Q2lyY2xlIHRvIGRpZmZlcmVudCBtb2R1bGUsIGRlcml2ZSBDaXJjbGUgZnJvbSBOb2RlQmFzZVxuICogICAgICAgUmVuYW1lIHRoaXMgdG8gSW1hZ2VCYXNlXG4gKiAgICAgICBDb25zb2xpZGF0ZSBjb21tb24gY29kZSBpbiBJbWFnZSBhbmQgQ2lyY2xlSW1hZ2UgdG8gYmFzZSBjbGFzc1xuICpcbiAqIEBhdWdtZW50cyBOb2RlQmFzZVxuICovXG52YXIgQ2lyY2xlSW1hZ2VCYXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZUJhc2UpIHtcbiAgX2luaGVyaXRzKENpcmNsZUltYWdlQmFzZSwgX05vZGVCYXNlKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRyKENpcmNsZUltYWdlQmFzZSk7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gQ2lyY2xlSW1hZ2VCYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaXJjbGVJbWFnZUJhc2UpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICAgIF90aGlzLmxhYmVsT2Zmc2V0ID0gMDtcbiAgICBfdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW2ltYWdlT2JqXVxuICAgKiBAcGFyYW0ge29iamVjdH0gW2ltYWdlT2JqQWx0XVxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKENpcmNsZUltYWdlQmFzZSwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMsIGltYWdlT2JqLCBpbWFnZU9iakFsdCkge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIGlmICghKGltYWdlT2JqID09PSB1bmRlZmluZWQgJiYgaW1hZ2VPYmpBbHQgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgdGhpcy5zZXRJbWFnZXMoaW1hZ2VPYmosIGltYWdlT2JqQWx0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGltYWdlcyBmb3IgdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogVGhlIGltYWdlcyBjYW4gYmUgdXBkYXRlZCBhZnRlciB0aGUgaW5pdGlhbCBzZXR0aW5nIG9mIG9wdGlvbnM7XG4gICAgICogdGhlcmVmb3JlLCB0aGlzIG1ldGhvZCBuZWVkcyB0byBiZSByZWVudHJhbnQuXG4gICAgICpcbiAgICAgKiBGb3IgY29ycmVjdCB3b3JraW5nIGluIGVycm9yIGNhc2VzLCBpdCBpcyBuZWNlc3NhcnkgdG8gcHJvcGVybHkgc2V0XG4gICAgICogZmllbGQgJ25vZGVzLmJyb2tlbkltYWdlJyBpbiB0aGUgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlT2JqICByZXF1aXJlZDsgbWFpbiBpbWFnZSB0byBzaG93IGZvciB0aGlzIG5vZGVcbiAgICAgKiBAcGFyYW0ge0ltYWdlfHVuZGVmaW5lZH0gaW1hZ2VPYmpBbHQgb3B0aW9uYWw7IGltYWdlIHRvIHNob3cgd2hlbiBub2RlIGlzIHNlbGVjdGVkXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0SW1hZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEltYWdlcyhpbWFnZU9iaiwgaW1hZ2VPYmpBbHQpIHtcbiAgICAgIGlmIChpbWFnZU9iakFsdCAmJiB0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgIHRoaXMuaW1hZ2VPYmogPSBpbWFnZU9iakFsdDtcbiAgICAgICAgdGhpcy5pbWFnZU9iakFsdCA9IGltYWdlT2JqO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbWFnZU9iaiA9IGltYWdlT2JqO1xuICAgICAgICB0aGlzLmltYWdlT2JqQWx0ID0gaW1hZ2VPYmpBbHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHNlbGVjdGlvbiBhbmQgc3dpdGNoIGJldHdlZW4gdGhlIGJhc2UgYW5kIHRoZSBzZWxlY3RlZCBpbWFnZS5cbiAgICAgKlxuICAgICAqIERvIHRoZSBzd2l0Y2ggb25seSBpZiBpbWFnZU9iakFsdCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkIHZhbHVlIG9mIG5ldyBzZWxlY3RlZCBzdGF0ZSBmb3IgY3VycmVudCBub2RlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic3dpdGNoSW1hZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN3aXRjaEltYWdlcyhzZWxlY3RlZCkge1xuICAgICAgdmFyIHNlbGVjdGlvbl9jaGFuZ2VkID0gc2VsZWN0ZWQgJiYgIXRoaXMuc2VsZWN0ZWQgfHwgIXNlbGVjdGVkICYmIHRoaXMuc2VsZWN0ZWQ7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gc2VsZWN0ZWQ7IC8vIFJlbWVtYmVyIG5ldyBzZWxlY3Rpb25cblxuICAgICAgaWYgKHRoaXMuaW1hZ2VPYmpBbHQgIT09IHVuZGVmaW5lZCAmJiBzZWxlY3Rpb25fY2hhbmdlZCkge1xuICAgICAgICB2YXIgaW1hZ2VUbXAgPSB0aGlzLmltYWdlT2JqO1xuICAgICAgICB0aGlzLmltYWdlT2JqID0gdGhpcy5pbWFnZU9iakFsdDtcbiAgICAgICAgdGhpcy5pbWFnZU9iakFsdCA9IGltYWdlVG1wO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgSW1hZ2UgUGFkZGluZyBmcm9tIG5vZGUgb3B0aW9uc1xuICAgICAqXG4gICAgICogQHJldHVybnMge3t0b3A6IG51bWJlcixsZWZ0OiBudW1iZXIsYm90dG9tOiBudW1iZXIscmlnaHQ6IG51bWJlcn19IGltYWdlIHBhZGRpbmcgaW5zaWRlIHRoaXMgc2hhcGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXRJbWFnZVBhZGRpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEltYWdlUGFkZGluZygpIHtcbiAgICAgIHZhciBpbWdQYWRkaW5nID0ge1xuICAgICAgICB0b3A6IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIGxlZnQ6IDBcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmltYWdlUGFkZGluZykge1xuICAgICAgICB2YXIgb3B0SW1nUGFkZGluZyA9IHRoaXMub3B0aW9ucy5pbWFnZVBhZGRpbmc7XG4gICAgICAgIGlmIChfdHlwZW9mKG9wdEltZ1BhZGRpbmcpID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBpbWdQYWRkaW5nLnRvcCA9IG9wdEltZ1BhZGRpbmcudG9wO1xuICAgICAgICAgIGltZ1BhZGRpbmcucmlnaHQgPSBvcHRJbWdQYWRkaW5nLnJpZ2h0O1xuICAgICAgICAgIGltZ1BhZGRpbmcuYm90dG9tID0gb3B0SW1nUGFkZGluZy5ib3R0b207XG4gICAgICAgICAgaW1nUGFkZGluZy5sZWZ0ID0gb3B0SW1nUGFkZGluZy5sZWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGltZ1BhZGRpbmcudG9wID0gb3B0SW1nUGFkZGluZztcbiAgICAgICAgICBpbWdQYWRkaW5nLnJpZ2h0ID0gb3B0SW1nUGFkZGluZztcbiAgICAgICAgICBpbWdQYWRkaW5nLmJvdHRvbSA9IG9wdEltZ1BhZGRpbmc7XG4gICAgICAgICAgaW1nUGFkZGluZy5sZWZ0ID0gb3B0SW1nUGFkZGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGltZ1BhZGRpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0IHRoZSBub2RlIGRpbWVuc2lvbnMgZm9yIGEgbG9hZGVkIGltYWdlLlxuICAgICAqXG4gICAgICogUHJlOiB0aGlzLmltYWdlT2JqIGlzIHZhbGlkXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc2l6ZUltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNpemVJbWFnZSgpIHtcbiAgICAgIHZhciB3aWR0aCwgaGVpZ2h0O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMudXNlSW1hZ2VTaXplID09PSBmYWxzZSkge1xuICAgICAgICAvLyBVc2UgdGhlIHNpemUgcHJvcGVydHlcbiAgICAgICAgdmFyIHJhdGlvX3dpZHRoID0gMTtcbiAgICAgICAgdmFyIHJhdGlvX2hlaWdodCA9IDE7XG5cbiAgICAgICAgLy8gT25seSBjYWxjdWxhdGUgdGhlIHByb3BlciByYXRpbyBpZiBib3RoIHdpZHRoIGFuZCBoZWlnaHQgbm90IHplcm9cbiAgICAgICAgaWYgKHRoaXMuaW1hZ2VPYmoud2lkdGggJiYgdGhpcy5pbWFnZU9iai5oZWlnaHQpIHtcbiAgICAgICAgICBpZiAodGhpcy5pbWFnZU9iai53aWR0aCA+IHRoaXMuaW1hZ2VPYmouaGVpZ2h0KSB7XG4gICAgICAgICAgICByYXRpb193aWR0aCA9IHRoaXMuaW1hZ2VPYmoud2lkdGggLyB0aGlzLmltYWdlT2JqLmhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmF0aW9faGVpZ2h0ID0gdGhpcy5pbWFnZU9iai5oZWlnaHQgLyB0aGlzLmltYWdlT2JqLndpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aWR0aCA9IHRoaXMub3B0aW9ucy5zaXplICogMiAqIHJhdGlvX3dpZHRoO1xuICAgICAgICBoZWlnaHQgPSB0aGlzLm9wdGlvbnMuc2l6ZSAqIDIgKiByYXRpb19oZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVc2UgdGhlIGltYWdlIHNpemUgd2l0aCBpbWFnZSBwYWRkaW5nXG4gICAgICAgIHZhciBpbWdQYWRkaW5nID0gdGhpcy5fZ2V0SW1hZ2VQYWRkaW5nKCk7XG4gICAgICAgIHdpZHRoID0gdGhpcy5pbWFnZU9iai53aWR0aCArIGltZ1BhZGRpbmcubGVmdCArIGltZ1BhZGRpbmcucmlnaHQ7XG4gICAgICAgIGhlaWdodCA9IHRoaXMuaW1hZ2VPYmouaGVpZ2h0ICsgaW1nUGFkZGluZy50b3AgKyBpbWdQYWRkaW5nLmJvdHRvbTtcbiAgICAgIH1cbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdSYXdDaXJjbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdSYXdDaXJjbGUoY3R4LCB4LCB5LCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMuaW5pdENvbnRleHRGb3JEcmF3KGN0eCwgdmFsdWVzKTtcbiAgICAgIGRyYXdDaXJjbGUoY3R4LCB4LCB5LCB2YWx1ZXMuc2l6ZSk7XG4gICAgICB0aGlzLnBlcmZvcm1GaWxsKGN0eCwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd0ltYWdlQXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0ltYWdlQXRQb3NpdGlvbihjdHgsIHZhbHVlcykge1xuICAgICAgaWYgKHRoaXMuaW1hZ2VPYmoud2lkdGggIT0gMCkge1xuICAgICAgICAvLyBkcmF3IHRoZSBpbWFnZVxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB2YWx1ZXMub3BhY2l0eSAhPT0gdW5kZWZpbmVkID8gdmFsdWVzLm9wYWNpdHkgOiAxO1xuXG4gICAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgICB2YXIgZmFjdG9yID0gMTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuaW50ZXJwb2xhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGZhY3RvciA9IHRoaXMuaW1hZ2VPYmoud2lkdGggLyB0aGlzLndpZHRoIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGltZ1BhZGRpbmcgPSB0aGlzLl9nZXRJbWFnZVBhZGRpbmcoKTtcbiAgICAgICAgdmFyIGltZ1Bvc0xlZnQgPSB0aGlzLmxlZnQgKyBpbWdQYWRkaW5nLmxlZnQ7XG4gICAgICAgIHZhciBpbWdQb3NUb3AgPSB0aGlzLnRvcCArIGltZ1BhZGRpbmcudG9wO1xuICAgICAgICB2YXIgaW1nV2lkdGggPSB0aGlzLndpZHRoIC0gaW1nUGFkZGluZy5sZWZ0IC0gaW1nUGFkZGluZy5yaWdodDtcbiAgICAgICAgdmFyIGltZ0hlaWdodCA9IHRoaXMuaGVpZ2h0IC0gaW1nUGFkZGluZy50b3AgLSBpbWdQYWRkaW5nLmJvdHRvbTtcbiAgICAgICAgdGhpcy5pbWFnZU9iai5kcmF3SW1hZ2VBdFBvc2l0aW9uKGN0eCwgZmFjdG9yLCBpbWdQb3NMZWZ0LCBpbWdQb3NUb3AsIGltZ1dpZHRoLCBpbWdIZWlnaHQpO1xuXG4gICAgICAgIC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG4gICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdJbWFnZUxhYmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3SW1hZ2VMYWJlbChjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICBpZiAodGhpcy5oZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvZmZzZXQgPSB0aGlzLmhlaWdodCAqIDAuNTtcbiAgICAgICAgdmFyIGxhYmVsRGltZW5zaW9ucyA9IHRoaXMubGFiZWxNb2R1bGUuZ2V0VGV4dFNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgICBpZiAobGFiZWxEaW1lbnNpb25zLmxpbmVDb3VudCA+PSAxKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IGxhYmVsRGltZW5zaW9ucy5oZWlnaHQgLyAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgeUxhYmVsID0geSArIG9mZnNldDtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwpIHtcbiAgICAgICAgdGhpcy5sYWJlbE9mZnNldCA9IG9mZnNldDtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHgsIHlMYWJlbCwgc2VsZWN0ZWQsIGhvdmVyLCBcImhhbmdpbmdcIik7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDaXJjbGVJbWFnZUJhc2U7XG59KE5vZGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJHEoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBfUmVmbGVjdCRjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRxKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIV9SZWZsZWN0JGNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoX1JlZmxlY3QkY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKF9SZWZsZWN0JGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBBIENpcmNsZSBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIENpcmNsZUltYWdlQmFzZVxuICovXG52YXIgQ2lyY2xlJDEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DaXJjbGVJbWFnZUJhc2UpIHtcbiAgX2luaGVyaXRzKENpcmNsZSwgX0NpcmNsZUltYWdlQmFzZSk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkcShDaXJjbGUpO1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIENpcmNsZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2lyY2xlKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgICBfdGhpcy5fc2V0TWFyZ2lucyhsYWJlbE1vZHVsZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2VsZWN0ZWRdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hvdmVyXVxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKENpcmNsZSwgW3tcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zZWxlY3RlZDtcbiAgICAgIHZhciBob3ZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5ob3ZlcjtcbiAgICAgIGlmICh0aGlzLm5lZWRzUmVmcmVzaChzZWxlY3RlZCwgaG92ZXIpKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5nZXREaW1lbnNpb25zRnJvbUxhYmVsKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgICAgdmFyIGRpYW1ldGVyID0gTWF0aC5tYXgoZGltZW5zaW9ucy53aWR0aCArIHRoaXMubWFyZ2luLnJpZ2h0ICsgdGhpcy5tYXJnaW4ubGVmdCwgZGltZW5zaW9ucy5oZWlnaHQgKyB0aGlzLm1hcmdpbi50b3AgKyB0aGlzLm1hcmdpbi5ib3R0b20pO1xuICAgICAgICB0aGlzLm9wdGlvbnMuc2l6ZSA9IGRpYW1ldGVyIC8gMjsgLy8gTk9URTogdGhpcyBzaXplIGZpZWxkIG9ubHkgc2V0IGhlcmUsIG5vdCBpbiBFbGxpcHNlLCBEYXRhYmFzZSwgQm94XG4gICAgICAgIHRoaXMud2lkdGggPSBkaWFtZXRlcjtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBkaWFtZXRlcjtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICB0aGlzLl9kcmF3UmF3Q2lyY2xlKGN0eCwgeCwgeSwgdmFsdWVzKTtcbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSk7XG4gICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB0aGlzLmxlZnQgKyB0aGlzLnRleHRTaXplLndpZHRoIC8gMiArIHRoaXMubWFyZ2luLmxlZnQsIHksIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpIHtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0geSAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0geCAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IHggKyB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0geSArIHRoaXMub3B0aW9ucy5zaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCkge1xuICAgICAgaWYgKGN0eCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud2lkdGggKiAwLjU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDaXJjbGU7XG59KENpcmNsZUltYWdlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRwKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHAoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gX1JlZmxlY3QkY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFfUmVmbGVjdCRjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKF9SZWZsZWN0JGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChfUmVmbGVjdCRjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogQSBDaXJjdWxhckltYWdlIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgQ2lyY2xlSW1hZ2VCYXNlXG4gKi9cbnZhciBDaXJjdWxhckltYWdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ2lyY2xlSW1hZ2VCYXNlKSB7XG4gIF9pbmhlcml0cyhDaXJjdWxhckltYWdlLCBfQ2lyY2xlSW1hZ2VCYXNlKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRwKENpcmN1bGFySW1hZ2UpO1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VPYmpcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VPYmpBbHRcbiAgICovXG4gIGZ1bmN0aW9uIENpcmN1bGFySW1hZ2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUsIGltYWdlT2JqLCBpbWFnZU9iakFsdCkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2lyY3VsYXJJbWFnZSk7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gICAgX3RoaXMuc2V0SW1hZ2VzKGltYWdlT2JqLCBpbWFnZU9iakFsdCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2VsZWN0ZWRdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hvdmVyXVxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKENpcmN1bGFySW1hZ2UsIFt7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuc2VsZWN0ZWQ7XG4gICAgICB2YXIgaG92ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuaG92ZXI7XG4gICAgICB2YXIgaW1hZ2VBYnNlbnQgPSB0aGlzLmltYWdlT2JqLnNyYyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuaW1hZ2VPYmoud2lkdGggPT09IHVuZGVmaW5lZCB8fCB0aGlzLmltYWdlT2JqLmhlaWdodCA9PT0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGltYWdlQWJzZW50KSB7XG4gICAgICAgIHZhciBkaWFtZXRlciA9IHRoaXMub3B0aW9ucy5zaXplICogMjtcbiAgICAgICAgdGhpcy53aWR0aCA9IGRpYW1ldGVyO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGRpYW1ldGVyO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IDAuNSAqIHRoaXMud2lkdGg7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQXQgdGhpcyBwb2ludCwgYW4gaW1hZ2UgaXMgcHJlc2VudCwgaS5lLiB0aGlzLmltYWdlT2JqIGlzIHZhbGlkLlxuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplSW1hZ2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLnN3aXRjaEltYWdlcyhzZWxlY3RlZCk7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgdmFyIGxhYmVsWCA9IHgsXG4gICAgICAgIGxhYmVsWSA9IHk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5jb29yZGluYXRlT3JpZ2luID09PSBcInRvcC1sZWZ0XCIpIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0geDtcbiAgICAgICAgdGhpcy50b3AgPSB5O1xuICAgICAgICBsYWJlbFggKz0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIGxhYmVsWSArPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIH1cblxuICAgICAgLy8gZHJhdyB0aGUgYmFja2dyb3VuZCBjaXJjbGUuIElNUE9SVEFOVDogdGhlIHN0cm9rZSBpbiB0aGlzIG1ldGhvZCBpcyB1c2VkIGJ5IHRoZSBjbGlwIG1ldGhvZCBiZWxvdy5cbiAgICAgIHRoaXMuX2RyYXdSYXdDaXJjbGUoY3R4LCBsYWJlbFgsIGxhYmVsWSwgdmFsdWVzKTtcblxuICAgICAgLy8gbm93IHdlIGRyYXcgaW4gdGhlIGNpcmNsZSwgd2Ugc2F2ZSBzbyB3ZSBjYW4gcmV2ZXJ0IHRoZSBjbGlwIG9wZXJhdGlvbiBhZnRlciBkcmF3aW5nLlxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIC8vIGNsaXAgaXMgdXNlZCB0byB1c2UgdGhlIHN0cm9rZSBpbiBkcmF3UmF3Q2lyY2xlIGFzIGFuIGFyZWEgdGhhdCB3ZSBjYW4gZHJhdyBpbi5cbiAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAvLyBkcmF3IHRoZSBpbWFnZVxuICAgICAgdGhpcy5fZHJhd0ltYWdlQXRQb3NpdGlvbihjdHgsIHZhbHVlcyk7XG4gICAgICAvLyByZXN0b3JlIHNvIHdlIGNhbiBhZ2FpbiBkcmF3IG9uIHRoZSBmdWxsIGNhbnZhc1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuX2RyYXdJbWFnZUxhYmVsKGN0eCwgbGFiZWxYLCBsYWJlbFksIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IGNvbXBhcmUgd2l0aCBDaXJjbGUudXBkYXRlQm91bmRpbmdCb3goKSwgY29uc29saWRhdGU/IE1vcmUgc3R1ZmYgaXMgaGFwcGVuaW5nIGhlcmVcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQm91bmRpbmdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuY29vcmRpbmF0ZU9yaWdpbiA9PT0gXCJ0b3AtbGVmdFwiKSB7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0geTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0geDtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IHggKyB0aGlzLm9wdGlvbnMuc2l6ZSAqIDI7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0geSArIHRoaXMub3B0aW9ucy5zaXplICogMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0geSAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB4IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB4ICsgdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0geSArIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBjb21wYXJlIHdpdGggSW1hZ2UudXBkYXRlQm91bmRpbmdCb3goKSwgY29uc29saWRhdGU/XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSBNYXRoLm1pbih0aGlzLmJvdW5kaW5nQm94LmxlZnQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0KTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LnJpZ2h0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCk7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3guYm90dG9tLCB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSArIHRoaXMubGFiZWxPZmZzZXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCkge1xuICAgICAgaWYgKGN0eCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud2lkdGggKiAwLjU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDaXJjdWxhckltYWdlO1xufShDaXJjbGVJbWFnZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkbyhEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRvKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IF9SZWZsZWN0JGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JG8oKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhX1JlZmxlY3QkY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChfUmVmbGVjdCRjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoX1JlZmxlY3QkY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGNvbnN0cnVjdGluZyBOb2RlL0NsdXN0ZXIgU2hhcGVzLlxuICpcbiAqIEBhdWdtZW50cyBOb2RlQmFzZVxuICovXG52YXIgU2hhcGVCYXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZUJhc2UpIHtcbiAgX2luaGVyaXRzKFNoYXBlQmFzZSwgX05vZGVCYXNlKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRvKFNoYXBlQmFzZSk7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gU2hhcGVCYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNoYXBlQmFzZSk7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NlbGVjdGVkXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtob3Zlcl1cbiAgICogQHBhcmFtIHtvYmplY3R9IFt2YWx1ZXM9e3NpemU6IHRoaXMub3B0aW9ucy5zaXplfV1cbiAgICovXG4gIF9jcmVhdGVDbGFzcyhTaGFwZUJhc2UsIFt7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuc2VsZWN0ZWQ7XG4gICAgICB2YXIgaG92ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuaG92ZXI7XG4gICAgICB2YXIgdmFsdWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7XG4gICAgICAgIHNpemU6IHRoaXMub3B0aW9ucy5zaXplXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdmFyIF90aGlzJGN1c3RvbVNpemVXaWR0aCwgX3RoaXMkY3VzdG9tU2l6ZUhlaWdoO1xuICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmdldFRleHRTaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgICAgdmFyIHNpemUgPSAyICogdmFsdWVzLnNpemU7XG4gICAgICAgIHRoaXMud2lkdGggPSAoX3RoaXMkY3VzdG9tU2l6ZVdpZHRoID0gdGhpcy5jdXN0b21TaXplV2lkdGgpICE9PSBudWxsICYmIF90aGlzJGN1c3RvbVNpemVXaWR0aCAhPT0gdm9pZCAwID8gX3RoaXMkY3VzdG9tU2l6ZVdpZHRoIDogc2l6ZTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAoX3RoaXMkY3VzdG9tU2l6ZUhlaWdoID0gdGhpcy5jdXN0b21TaXplSGVpZ2h0KSAhPT0gbnVsbCAmJiBfdGhpcyRjdXN0b21TaXplSGVpZ2ggIT09IHZvaWQgMCA/IF90aGlzJGN1c3RvbVNpemVIZWlnaCA6IHNpemU7XG4gICAgICAgIHRoaXMucmFkaXVzID0gMC41ICogdGhpcy53aWR0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2hhcGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZU11bHRpcGxpZXIgLSBVbnVzZWQhIFRPRE86IFJlbW92ZSBuZXh0IG1ham9yIHJlbGVhc2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3U2hhcGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdTaGFwZShjdHgsIHNoYXBlLCBzaXplTXVsdGlwbGllciwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIHRoaXMuaW5pdENvbnRleHRGb3JEcmF3KGN0eCwgdmFsdWVzKTtcbiAgICAgIGdldFNoYXBlKHNoYXBlKShjdHgsIHgsIHksIHZhbHVlcy5zaXplKTtcbiAgICAgIHRoaXMucGVyZm9ybUZpbGwoY3R4LCB2YWx1ZXMpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pY29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pY29uLmNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGN0eC5mb250ID0gKHNlbGVjdGVkID8gXCJib2xkIFwiIDogXCJcIikgKyB0aGlzLmhlaWdodCAvIDIgKyBcInB4IFwiICsgKHRoaXMub3B0aW9ucy5pY29uLmZhY2UgfHwgXCJGb250QXdlc29tZVwiKTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5vcHRpb25zLmljb24uY29sb3IgfHwgXCJibGFja1wiO1xuICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLm9wdGlvbnMuaWNvbi5jb2RlLCB4LCB5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZHJhd0V4dGVybmFsTGFiZWw6IGZ1bmN0aW9uIGRyYXdFeHRlcm5hbExhYmVsKCkge1xuICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gY2FsbCBmb2xsb3dpbmcgaGVyZSBpbiBvcmRlciB0byBlbnN1cmUgdmFsdWUgZm9yXG4gICAgICAgICAgICAvLyBgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmhlaWdodGAuXG4gICAgICAgICAgICBfdGhpcy5sYWJlbE1vZHVsZS5jYWxjdWxhdGVMYWJlbFNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIsIHgsIHksIFwiaGFuZ2luZ1wiKTtcbiAgICAgICAgICAgIHZhciB5TGFiZWwgPSB5ICsgMC41ICogX3RoaXMuaGVpZ2h0ICsgMC41ICogX3RoaXMubGFiZWxNb2R1bGUuc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICBfdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgeCwgeUxhYmVsLCBzZWxlY3RlZCwgaG92ZXIsIFwiaGFuZ2luZ1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQm91bmRpbmdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSkge1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB5IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB4IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0geCArIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB5ICsgdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQgJiYgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoID4gMCkge1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSBNYXRoLm1pbih0aGlzLmJvdW5kaW5nQm94LmxlZnQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0KTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3gucmlnaHQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0ICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoKTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSwgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gKyB0aGlzLmxhYmVsTW9kdWxlLnNpemUuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFNoYXBlQmFzZTtcbn0oTm9kZUJhc2UpO1xuXG5mdW5jdGlvbiBvd25LZXlzJDMoZSwgcikgeyB2YXIgdCA9IF9PYmplY3Qka2V5cyhlKTsgaWYgKF9PYmplY3QkZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gX09iamVjdCRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBfZmlsdGVySW5zdGFuY2VQcm9wZXJ0eShvKS5jYWxsKG8sIGZ1bmN0aW9uIChyKSB7IHJldHVybiBfT2JqZWN0JGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDMoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgX2NvbnRleHQsIF9jb250ZXh0MjsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IF9mb3JFYWNoSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dCA9IG93bktleXMkMyhPYmplY3QodCksICEwKSkuY2FsbChfY29udGV4dCwgZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IF9PYmplY3QkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IF9PYmplY3QkZGVmaW5lUHJvcGVydGllcyhlLCBfT2JqZWN0JGdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogX2ZvckVhY2hJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0MiA9IG93bktleXMkMyhPYmplY3QodCkpKS5jYWxsKF9jb250ZXh0MiwgZnVuY3Rpb24gKHIpIHsgX09iamVjdCRkZWZpbmVQcm9wZXJ0eShlLCByLCBfT2JqZWN0JGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRuKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JG4oKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gX1JlZmxlY3QkY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbigpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFfUmVmbGVjdCRjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKF9SZWZsZWN0JGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChfUmVmbGVjdCRjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogQSBDdXN0b21TaGFwZSBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIFNoYXBlQmFzZVxuICovXG52YXIgQ3VzdG9tU2hhcGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgX2luaGVyaXRzKEN1c3RvbVNoYXBlLCBfU2hhcGVCYXNlKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRuKEN1c3RvbVNoYXBlKTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGN0eFJlbmRlcmVyXG4gICAqL1xuICBmdW5jdGlvbiBDdXN0b21TaGFwZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSwgY3R4UmVuZGVyZXIpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1c3RvbVNoYXBlKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlLCBjdHhSZW5kZXJlcik7XG4gICAgX3RoaXMuY3R4UmVuZGVyZXIgPSBjdHhSZW5kZXJlcjtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICogQHJldHVybnMge29iamVjdH0gQ2FsbGJhY2tzIHRvIGRyYXcgbGF0ZXIgb24gZGlmZmVyZW50IGxheWVycy5cbiAgICovXG4gIF9jcmVhdGVDbGFzcyhDdXN0b21TaGFwZSwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgICAvLyBHdWFyZCByaWdodCBhd2F5IGJlY2F1c2Ugc29tZW9uZSBtYXkganVzdCBkcmF3IGluIHRoZSBmdW5jdGlvbiBpdHNlbGYuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdmFyIGRyYXdMYXRlciA9IHRoaXMuY3R4UmVuZGVyZXIoe1xuICAgICAgICBjdHg6IGN0eCxcbiAgICAgICAgaWQ6IHRoaXMub3B0aW9ucy5pZCxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICAgICAgaG92ZXI6IGhvdmVyXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkJDMoe30sIHZhbHVlcyksXG4gICAgICAgIGxhYmVsOiB0aGlzLm9wdGlvbnMubGFiZWxcbiAgICAgIH0pO1xuICAgICAgLy8gUmVuZGVyIHRoZSBub2RlIHNoYXBlIGJlbGxvdyBhcnJvd3MuXG4gICAgICBpZiAoZHJhd0xhdGVyLmRyYXdOb2RlICE9IG51bGwpIHtcbiAgICAgICAgZHJhd0xhdGVyLmRyYXdOb2RlKCk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgaWYgKGRyYXdMYXRlci5kcmF3RXh0ZXJuYWxMYWJlbCkge1xuICAgICAgICAvLyBHdWFyZCB0aGUgZXh0ZXJuYWwgbGFiZWwgKGFib3ZlIGFycm93cykgZHJhd2luZyBmdW5jdGlvbi5cbiAgICAgICAgdmFyIGRyYXdFeHRlcm5hbExhYmVsID0gZHJhd0xhdGVyLmRyYXdFeHRlcm5hbExhYmVsO1xuICAgICAgICBkcmF3TGF0ZXIuZHJhd0V4dGVybmFsTGFiZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICBkcmF3RXh0ZXJuYWxMYWJlbCgpO1xuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoZHJhd0xhdGVyLm5vZGVEaW1lbnNpb25zKSB7XG4gICAgICAgIHRoaXMuY3VzdG9tU2l6ZVdpZHRoID0gZHJhd0xhdGVyLm5vZGVEaW1lbnNpb25zLndpZHRoO1xuICAgICAgICB0aGlzLmN1c3RvbVNpemVIZWlnaHQgPSBkcmF3TGF0ZXIubm9kZURpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRyYXdMYXRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEN1c3RvbVNoYXBlO1xufShTaGFwZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkbShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRtKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IF9SZWZsZWN0JGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JG0oKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhX1JlZmxlY3QkY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChfUmVmbGVjdCRjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoX1JlZmxlY3QkY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vKipcbiAqIEEgRGF0YWJhc2UgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBOb2RlQmFzZVxuICovXG52YXIgRGF0YWJhc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICBfaW5oZXJpdHMoRGF0YWJhc2UsIF9Ob2RlQmFzZSk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkbShEYXRhYmFzZSk7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gRGF0YWJhc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGFiYXNlKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgICBfdGhpcy5fc2V0TWFyZ2lucyhsYWJlbE1vZHVsZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoRGF0YWJhc2UsIFt7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIGlmICh0aGlzLm5lZWRzUmVmcmVzaChzZWxlY3RlZCwgaG92ZXIpKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5nZXREaW1lbnNpb25zRnJvbUxhYmVsKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgICAgdmFyIHNpemUgPSBkaW1lbnNpb25zLndpZHRoICsgdGhpcy5tYXJnaW4ucmlnaHQgKyB0aGlzLm1hcmdpbi5sZWZ0O1xuICAgICAgICB0aGlzLndpZHRoID0gc2l6ZTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBzaXplO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHRoaXMud2lkdGggLyAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIHRoaXMuaW5pdENvbnRleHRGb3JEcmF3KGN0eCwgdmFsdWVzKTtcbiAgICAgIGRyYXdEYXRhYmFzZShjdHgsIHggLSB0aGlzLndpZHRoIC8gMiwgeSAtIHRoaXMuaGVpZ2h0IC8gMiwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgdGhpcy5wZXJmb3JtRmlsbChjdHgsIHZhbHVlcyk7XG4gICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHRoaXMubGVmdCArIHRoaXMudGV4dFNpemUud2lkdGggLyAyICsgdGhpcy5tYXJnaW4ubGVmdCwgdGhpcy50b3AgKyB0aGlzLnRleHRTaXplLmhlaWdodCAvIDIgKyB0aGlzLm1hcmdpbi50b3AsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRGF0YWJhc2U7XG59KE5vZGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGwoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBfUmVmbGVjdCRjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRsKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIV9SZWZsZWN0JGNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoX1JlZmxlY3QkY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKF9SZWZsZWN0JGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBBIERpYW1vbmQgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBTaGFwZUJhc2VcbiAqL1xudmFyIERpYW1vbmQkMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICBfaW5oZXJpdHMoRGlhbW9uZCwgX1NoYXBlQmFzZSk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkbChEaWFtb25kKTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBEaWFtb25kKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpYW1vbmQpO1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICogQHJldHVybnMge29iamVjdH0gQ2FsbGJhY2tzIHRvIGRyYXcgbGF0ZXIgb24gaGlnaGVyIGxheWVycy5cbiAgICovXG4gIF9jcmVhdGVDbGFzcyhEaWFtb25kLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2RyYXdTaGFwZShjdHgsIFwiZGlhbW9uZFwiLCA0LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBEaWFtb25kO1xufShTaGFwZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkayhEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRrKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IF9SZWZsZWN0JGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGsoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhX1JlZmxlY3QkY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChfUmVmbGVjdCRjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoX1JlZmxlY3QkY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vKipcbiAqIEEgRG90IE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgU2hhcGVCYXNlXG4gKi9cbnZhciBEb3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgX2luaGVyaXRzKERvdCwgX1NoYXBlQmFzZSk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkayhEb3QpO1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIERvdChvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEb3QpO1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICogQHJldHVybnMge29iamVjdH0gQ2FsbGJhY2tzIHRvIGRyYXcgbGF0ZXIgb24gaGlnaGVyIGxheWVycy5cbiAgICovXG4gIF9jcmVhdGVDbGFzcyhEb3QsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZHJhd1NoYXBlKGN0eCwgXCJjaXJjbGVcIiwgMiwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCkge1xuICAgICAgaWYgKGN0eCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zaXplO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRG90O1xufShTaGFwZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkaihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRqKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IF9SZWZsZWN0JGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGooKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhX1JlZmxlY3QkY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChfUmVmbGVjdCRjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoX1JlZmxlY3QkY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vKipcbiAqIEFtIEVsbGlwc2UgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBOb2RlQmFzZVxuICovXG52YXIgRWxsaXBzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gIF9pbmhlcml0cyhFbGxpcHNlLCBfTm9kZUJhc2UpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGooRWxsaXBzZSk7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gRWxsaXBzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbGxpcHNlKTtcbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2VsZWN0ZWRdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hvdmVyXVxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKEVsbGlwc2UsIFt7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuc2VsZWN0ZWQ7XG4gICAgICB2YXIgaG92ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuaG92ZXI7XG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZ2V0RGltZW5zaW9uc0Zyb21MYWJlbChjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQgKiAyO1xuICAgICAgICB0aGlzLndpZHRoID0gZGltZW5zaW9ucy53aWR0aCArIGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICB0aGlzLnJhZGl1cyA9IDAuNSAqIHRoaXMud2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggKiAwLjU7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAqIDAuNTtcbiAgICAgIHRoaXMuaW5pdENvbnRleHRGb3JEcmF3KGN0eCwgdmFsdWVzKTtcbiAgICAgIGRyYXdFbGxpcHNlKGN0eCwgdGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgdGhpcy5wZXJmb3JtRmlsbChjdHgsIHZhbHVlcyk7XG4gICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgaWYgKGN0eCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgpO1xuICAgICAgfVxuICAgICAgdmFyIGEgPSB0aGlzLndpZHRoICogMC41O1xuICAgICAgdmFyIGIgPSB0aGlzLmhlaWdodCAqIDAuNTtcbiAgICAgIHZhciB3ID0gTWF0aC5zaW4oYW5nbGUpICogYTtcbiAgICAgIHZhciBoID0gTWF0aC5jb3MoYW5nbGUpICogYjtcbiAgICAgIHJldHVybiBhICogYiAvIE1hdGguc3FydCh3ICogdyArIGggKiBoKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEVsbGlwc2U7XG59KE5vZGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGkoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBfUmVmbGVjdCRjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRpKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIV9SZWZsZWN0JGNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoX1JlZmxlY3QkY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKF9SZWZsZWN0JGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBBbiBpY29uIHJlcGxhY2VtZW50IGZvciB0aGUgZGVmYXVsdCBOb2RlIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBOb2RlQmFzZVxuICovXG52YXIgSWNvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gIF9pbmhlcml0cyhJY29uLCBfTm9kZUJhc2UpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGkoSWNvbik7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gSWNvbihvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSWNvbik7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gICAgX3RoaXMuX3NldE1hcmdpbnMobGFiZWxNb2R1bGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gVW51c2VkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICogQHBhcmFtIHtib29sZWFufSBbaG92ZXJdXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoSWNvbiwgW3tcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdGhpcy5pY29uU2l6ZSA9IHtcbiAgICAgICAgICB3aWR0aDogTnVtYmVyKHRoaXMub3B0aW9ucy5pY29uLnNpemUpLFxuICAgICAgICAgIGhlaWdodDogTnVtYmVyKHRoaXMub3B0aW9ucy5pY29uLnNpemUpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLmljb25TaXplLndpZHRoICsgdGhpcy5tYXJnaW4ucmlnaHQgKyB0aGlzLm1hcmdpbi5sZWZ0O1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuaWNvblNpemUuaGVpZ2h0ICsgdGhpcy5tYXJnaW4udG9wICsgdGhpcy5tYXJnaW4uYm90dG9tO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IDAuNSAqIHRoaXMud2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMub3B0aW9ucy5pY29uLnNpemUgPSB0aGlzLm9wdGlvbnMuaWNvbi5zaXplIHx8IDUwO1xuICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgdGhpcy5faWNvbihjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRyYXdFeHRlcm5hbExhYmVsOiBmdW5jdGlvbiBkcmF3RXh0ZXJuYWxMYWJlbCgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMyLm9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGljb25UZXh0U3BhY2luZyA9IDU7XG4gICAgICAgICAgICBfdGhpczIubGFiZWxNb2R1bGUuZHJhdyhjdHgsIF90aGlzMi5sZWZ0ICsgX3RoaXMyLmljb25TaXplLndpZHRoIC8gMiArIF90aGlzMi5tYXJnaW4ubGVmdCwgeSArIF90aGlzMi5oZWlnaHQgLyAyICsgaWNvblRleHRTcGFjaW5nLCBzZWxlY3RlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzMi51cGRhdGVCb3VuZGluZ0JveCh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5KSB7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCA9IHkgLSB0aGlzLm9wdGlvbnMuaWNvbi5zaXplICogMC41O1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0geCAtIHRoaXMub3B0aW9ucy5pY29uLnNpemUgKiAwLjU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0geCArIHRoaXMub3B0aW9ucy5pY29uLnNpemUgKiAwLjU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IHkgKyB0aGlzLm9wdGlvbnMuaWNvbi5zaXplICogMC41O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkICYmIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCA+IDApIHtcbiAgICAgICAgdmFyIGljb25UZXh0U3BhY2luZyA9IDU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IE1hdGgubWluKHRoaXMuYm91bmRpbmdCb3gubGVmdCwgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQpO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5yaWdodCwgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQgKyB0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGgpO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3guYm90dG9tLCB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5oZWlnaHQgKyBpY29uVGV4dFNwYWNpbmcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXIgLSBVbnVzZWRcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ljb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ljb24oY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdmFyIGljb25TaXplID0gTnVtYmVyKHRoaXMub3B0aW9ucy5pY29uLnNpemUpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pY29uLmNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdHguZm9udCA9IFt0aGlzLm9wdGlvbnMuaWNvbi53ZWlnaHQgIT0gbnVsbCA/IHRoaXMub3B0aW9ucy5pY29uLndlaWdodCA6IHNlbGVjdGVkID8gXCJib2xkXCIgOiBcIlwiLFxuICAgICAgICAvLyBJZiB0aGUgd2VpZ2h0IGlzIGZvcmNlZCAoZm9yIGV4YW1wbGUgdG8gbWFrZSBGb250IEF3ZXNvbWUgNSB3b3JrXG4gICAgICAgIC8vIHByb3Blcmx5KSBzdWJzdGl0dXRlIHNsaWdodGx5IGJpZ2dlciBzaXplIGZvciBib2xkIGZvbnQgZmFjZS5cbiAgICAgICAgKHRoaXMub3B0aW9ucy5pY29uLndlaWdodCAhPSBudWxsICYmIHNlbGVjdGVkID8gNSA6IDApICsgaWNvblNpemUgKyBcInB4XCIsIHRoaXMub3B0aW9ucy5pY29uLmZhY2VdLmpvaW4oXCIgXCIpO1xuXG4gICAgICAgIC8vIGRyYXcgaWNvblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5vcHRpb25zLmljb24uY29sb3IgfHwgXCJibGFja1wiO1xuICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG5cbiAgICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLm9wdGlvbnMuaWNvbi5jb2RlLCB4LCB5KTtcblxuICAgICAgICAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuICAgICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIldoZW4gdXNpbmcgdGhlIGljb24gc2hhcGUsIHlvdSBuZWVkIHRvIGRlZmluZSB0aGUgY29kZSBpbiB0aGUgaWNvbiBvcHRpb25zIG9iamVjdC4gVGhpcyBjYW4gYmUgZG9uZSBwZXIgbm9kZSBvciBnbG9iYWxseS5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBJY29uO1xufShOb2RlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRoKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGgoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gX1JlZmxlY3QkY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFfUmVmbGVjdCRjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKF9SZWZsZWN0JGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChfUmVmbGVjdCRjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogQW4gaW1hZ2UtYmFzZWQgcmVwbGFjZW1lbnQgZm9yIHRoZSBkZWZhdWx0IE5vZGUgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIENpcmNsZUltYWdlQmFzZVxuICovXG52YXIgSW1hZ2UkMiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NpcmNsZUltYWdlQmFzZSkge1xuICBfaW5oZXJpdHMoSW1hZ2UsIF9DaXJjbGVJbWFnZUJhc2UpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGgoSW1hZ2UpO1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VPYmpcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VPYmpBbHRcbiAgICovXG4gIGZ1bmN0aW9uIEltYWdlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlLCBpbWFnZU9iaiwgaW1hZ2VPYmpBbHQpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEltYWdlKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgICBfdGhpcy5zZXRJbWFnZXMoaW1hZ2VPYmosIGltYWdlT2JqQWx0KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIFVudXNlZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbc2VsZWN0ZWRdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hvdmVyXVxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKEltYWdlLCBbe1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCkge1xuICAgICAgdmFyIHNlbGVjdGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnNlbGVjdGVkO1xuICAgICAgdmFyIGhvdmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLmhvdmVyO1xuICAgICAgdmFyIGltYWdlQWJzZW50ID0gdGhpcy5pbWFnZU9iai5zcmMgPT09IHVuZGVmaW5lZCB8fCB0aGlzLmltYWdlT2JqLndpZHRoID09PSB1bmRlZmluZWQgfHwgdGhpcy5pbWFnZU9iai5oZWlnaHQgPT09IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpbWFnZUFic2VudCkge1xuICAgICAgICB2YXIgc2lkZSA9IHRoaXMub3B0aW9ucy5zaXplICogMjtcbiAgICAgICAgdGhpcy53aWR0aCA9IHNpZGU7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gc2lkZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplSW1hZ2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdGhpcy5zd2l0Y2hJbWFnZXMoc2VsZWN0ZWQpO1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgIHZhciBsYWJlbFggPSB4LFxuICAgICAgICBsYWJlbFkgPSB5O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuY29vcmRpbmF0ZU9yaWdpbiA9PT0gXCJ0b3AtbGVmdFwiKSB7XG4gICAgICAgIHRoaXMubGVmdCA9IHg7XG4gICAgICAgIHRoaXMudG9wID0geTtcbiAgICAgICAgbGFiZWxYICs9IHRoaXMud2lkdGggLyAyO1xuICAgICAgICBsYWJlbFkgKz0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy51c2VCb3JkZXJXaXRoSW1hZ2UgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIG5ldXRyYWxib3JkZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkxpbmVXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aFNlbGVjdGVkIHx8IDIgKiB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICAgIHZhciBib3JkZXJXaWR0aCA9IChzZWxlY3RlZCA/IHNlbGVjdGlvbkxpbmVXaWR0aCA6IG5ldXRyYWxib3JkZXJXaWR0aCkgLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IE1hdGgubWluKHRoaXMud2lkdGgsIGJvcmRlcldpZHRoKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB2YXIgc3Ryb2tlU3R5bGUgPSBzZWxlY3RlZCA/IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYm9yZGVyIDogaG92ZXIgPyB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYm9yZGVyIDogdGhpcy5vcHRpb25zLmNvbG9yLmJvcmRlcjtcbiAgICAgICAgdmFyIGZpbGxTdHlsZSA9IHNlbGVjdGVkID8gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5iYWNrZ3JvdW5kIDogaG92ZXIgPyB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYmFja2dyb3VuZCA6IHRoaXMub3B0aW9ucy5jb2xvci5iYWNrZ3JvdW5kO1xuICAgICAgICBpZiAodmFsdWVzLm9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHN0cm9rZVN0eWxlID0gb3ZlcnJpZGVPcGFjaXR5KHN0cm9rZVN0eWxlLCB2YWx1ZXMub3BhY2l0eSk7XG4gICAgICAgICAgZmlsbFN0eWxlID0gb3ZlcnJpZGVPcGFjaXR5KGZpbGxTdHlsZSwgdmFsdWVzLm9wYWNpdHkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldHVwIHRoZSBsaW5lIHByb3BlcnRpZXMuXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuXG4gICAgICAgIC8vIHNldCBhIGZpbGxzdHlsZVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuXG4gICAgICAgIC8vIGRyYXcgYSByZWN0YW5nbGUgdG8gZm9ybSB0aGUgYm9yZGVyIGFyb3VuZC4gVGhpcyByZWN0YW5nbGUgaXMgZmlsbGVkIHNvIHRoZSBvcGFjaXR5IG9mIGEgcGljdHVyZSAoaW4gZnV0dXJlIHZpcyByZWxlYXNlcz8pIGNhbiBiZSB1c2VkIHRvIHRpbnQgdGhlIGltYWdlXG4gICAgICAgIGN0eC5yZWN0KHRoaXMubGVmdCAtIDAuNSAqIGN0eC5saW5lV2lkdGgsIHRoaXMudG9wIC0gMC41ICogY3R4LmxpbmVXaWR0aCwgdGhpcy53aWR0aCArIGN0eC5saW5lV2lkdGgsIHRoaXMuaGVpZ2h0ICsgY3R4LmxpbmVXaWR0aCk7XG4gICAgICAgIF9maWxsSW5zdGFuY2VQcm9wZXJ0eShjdHgpLmNhbGwoY3R4KTtcbiAgICAgICAgdGhpcy5wZXJmb3JtU3Ryb2tlKGN0eCwgdmFsdWVzKTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZHJhd0ltYWdlQXRQb3NpdGlvbihjdHgsIHZhbHVlcyk7XG4gICAgICB0aGlzLl9kcmF3SW1hZ2VMYWJlbChjdHgsIGxhYmVsWCwgbGFiZWxZLCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQm91bmRpbmdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSkge1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmNvb3JkaW5hdGVPcmlnaW4gPT09IFwidG9wLWxlZnRcIikge1xuICAgICAgICB0aGlzLmxlZnQgPSB4O1xuICAgICAgICB0aGlzLnRvcCA9IHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IHRoaXMubGVmdDtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0gdGhpcy50b3A7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IHRoaXMudG9wICsgdGhpcy5oZWlnaHQ7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0gdGhpcy5sZWZ0ICsgdGhpcy53aWR0aDtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGggPiAwKSB7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IE1hdGgubWluKHRoaXMuYm91bmRpbmdCb3gubGVmdCwgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQpO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5yaWdodCwgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQgKyB0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGgpO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3guYm90dG9tLCB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSArIHRoaXMubGFiZWxPZmZzZXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSW1hZ2U7XG59KENpcmNsZUltYWdlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRnKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGcoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gX1JlZmxlY3QkY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZygpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFfUmVmbGVjdCRjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKF9SZWZsZWN0JGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChfUmVmbGVjdCRjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogQSBTcXVhcmUgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBTaGFwZUJhc2VcbiAqL1xudmFyIFNxdWFyZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICBfaW5oZXJpdHMoU3F1YXJlLCBfU2hhcGVCYXNlKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRnKFNxdWFyZSk7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gU3F1YXJlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNxdWFyZSk7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKFNxdWFyZSwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kcmF3U2hhcGUoY3R4LCBcInNxdWFyZVwiLCAyLCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTcXVhcmU7XG59KFNoYXBlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRmKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGYoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gX1JlZmxlY3QkY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZigpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFfUmVmbGVjdCRjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKF9SZWZsZWN0JGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChfUmVmbGVjdCRjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogQSBIZXhhZ29uIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgU2hhcGVCYXNlXG4gKi9cbnZhciBIZXhhZ29uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gIF9pbmhlcml0cyhIZXhhZ29uLCBfU2hhcGVCYXNlKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRmKEhleGFnb24pO1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIEhleGFnb24ob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGV4YWdvbik7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKEhleGFnb24sIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZHJhd1NoYXBlKGN0eCwgXCJoZXhhZ29uXCIsIDQsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEhleGFnb247XG59KFNoYXBlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRlKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGUoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gX1JlZmxlY3QkY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZSgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFfUmVmbGVjdCRjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKF9SZWZsZWN0JGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChfUmVmbGVjdCRjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogQSBTdGFyIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgU2hhcGVCYXNlXG4gKi9cbnZhciBTdGFyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gIF9pbmhlcml0cyhTdGFyLCBfU2hhcGVCYXNlKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRlKFN0YXIpO1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIFN0YXIob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3Rhcik7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKFN0YXIsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZHJhd1NoYXBlKGN0eCwgXCJzdGFyXCIsIDQsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN0YXI7XG59KFNoYXBlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRkKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGQoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gX1JlZmxlY3QkY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFfUmVmbGVjdCRjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKF9SZWZsZWN0JGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChfUmVmbGVjdCRjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogQSB0ZXh0LWJhc2VkIHJlcGxhY2VtZW50IGZvciB0aGUgZGVmYXVsdCBOb2RlIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBOb2RlQmFzZVxuICovXG52YXIgVGV4dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gIF9pbmhlcml0cyhUZXh0LCBfTm9kZUJhc2UpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGQoVGV4dCk7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dChvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dCk7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gICAgX3RoaXMuX3NldE1hcmdpbnMobGFiZWxNb2R1bGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKFRleHQsIFt7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIGlmICh0aGlzLm5lZWRzUmVmcmVzaChzZWxlY3RlZCwgaG92ZXIpKSB7XG4gICAgICAgIHRoaXMudGV4dFNpemUgPSB0aGlzLmxhYmVsTW9kdWxlLmdldFRleHRTaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMudGV4dFNpemUud2lkdGggKyB0aGlzLm1hcmdpbi5yaWdodCArIHRoaXMubWFyZ2luLmxlZnQ7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy50ZXh0U2l6ZS5oZWlnaHQgKyB0aGlzLm1hcmdpbi50b3AgKyB0aGlzLm1hcmdpbi5ib3R0b207XG4gICAgICAgIHRoaXMucmFkaXVzID0gMC41ICogdGhpcy53aWR0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHRoaXMubGVmdCArIHRoaXMudGV4dFNpemUud2lkdGggLyAyICsgdGhpcy5tYXJnaW4ubGVmdCwgdGhpcy50b3AgKyB0aGlzLnRleHRTaXplLmhlaWdodCAvIDIgKyB0aGlzLm1hcmdpbi50b3AsIHNlbGVjdGVkLCBob3Zlcik7XG5cbiAgICAgIC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG4gICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUZXh0O1xufShOb2RlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRjKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGMoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gX1JlZmxlY3QkY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkYygpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFfUmVmbGVjdCRjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKF9SZWZsZWN0JGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChfUmVmbGVjdCRjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogQSBUcmlhbmdsZSBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIFNoYXBlQmFzZVxuICovXG52YXIgVHJpYW5nbGUkMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICBfaW5oZXJpdHMoVHJpYW5nbGUsIF9TaGFwZUJhc2UpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGMoVHJpYW5nbGUpO1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIFRyaWFuZ2xlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyaWFuZ2xlKTtcbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICogQHJldHVybnMge29iamVjdH0gQ2FsbGJhY2tzIHRvIGRyYXcgbGF0ZXIgb24gaGlnaGVyIGxheWVycy5cbiAgICovXG4gIF9jcmVhdGVDbGFzcyhUcmlhbmdsZSwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kcmF3U2hhcGUoY3R4LCBcInRyaWFuZ2xlXCIsIDMsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRyaWFuZ2xlO1xufShTaGFwZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkYihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRiKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IF9SZWZsZWN0JGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGIoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhX1JlZmxlY3QkY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChfUmVmbGVjdCRjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoX1JlZmxlY3QkY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vKipcbiAqIEEgZG93bndhcmQgZmFjaW5nIFRyaWFuZ2xlIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgU2hhcGVCYXNlXG4gKi9cbnZhciBUcmlhbmdsZURvd24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgX2luaGVyaXRzKFRyaWFuZ2xlRG93biwgX1NoYXBlQmFzZSk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkYihUcmlhbmdsZURvd24pO1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIFRyaWFuZ2xlRG93bihvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmlhbmdsZURvd24pO1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKFRyaWFuZ2xlRG93biwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kcmF3U2hhcGUoY3R4LCBcInRyaWFuZ2xlRG93blwiLCAzLCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUcmlhbmdsZURvd247XG59KFNoYXBlQmFzZSk7XG5cbmZ1bmN0aW9uIG93bktleXMkMihlLCByKSB7IHZhciB0ID0gX09iamVjdCRrZXlzKGUpOyBpZiAoX09iamVjdCRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBfT2JqZWN0JGdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IF9maWx0ZXJJbnN0YW5jZVByb3BlcnR5KG8pLmNhbGwobywgZnVuY3Rpb24gKHIpIHsgcmV0dXJuIF9PYmplY3QkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMihlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciBfY29udGV4dDUsIF9jb250ZXh0NjsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IF9mb3JFYWNoSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDUgPSBvd25LZXlzJDIoT2JqZWN0KHQpLCAhMCkpLmNhbGwoX2NvbnRleHQ1LCBmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogX09iamVjdCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gX09iamVjdCRkZWZpbmVQcm9wZXJ0aWVzKGUsIF9PYmplY3QkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBfZm9yRWFjaEluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQ2ID0gb3duS2V5cyQyKE9iamVjdCh0KSkpLmNhbGwoX2NvbnRleHQ2LCBmdW5jdGlvbiAocikgeyBfT2JqZWN0JGRlZmluZVByb3BlcnR5KGUsIHIsIF9PYmplY3QkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuXG4vKipcbiAqIEEgbm9kZS4gQSBub2RlIGNhbiBiZSBjb25uZWN0ZWQgdG8gb3RoZXIgbm9kZXMgdmlhIG9uZSBvciBtdWx0aXBsZSBlZGdlcy5cbiAqL1xudmFyIE5vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9ucyBmb3IgdGhlIG5vZGUuIEFsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zIGFyZSBvcHRpb25hbCwgZXhjZXB0IGZvciB0aGUgaWQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlcn0gaWQgICAgIElkIG9mIHRoZSBub2RlLiBSZXF1aXJlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IGxhYmVsICBUZXh0IGxhYmVsIGZvciB0aGUgbm9kZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtudW1iZXJ9IHggICAgICBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBub2RlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlcn0geSAgICAgIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBub2RlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gc2hhcGUgIE5vZGUgc2hhcGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBpbWFnZSAgQW4gaW1hZ2UgdXJsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gdGl0bGUgIEEgdGl0bGUgdGV4dCwgY2FuIGJlIEhUTUxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7YW55dHlwZX0gZ3JvdXAgQSBncm91cCBuYW1lIG9yIG51bWJlclxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keSAgICAgICAgICAgICAgIFNoYXJlZCBzdGF0ZSBvZiBjdXJyZW50IG5ldHdvcmsgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOZXR3b3JrLkltYWdlc30gaW1hZ2VsaXN0ICBBIGxpc3Qgd2l0aCBpbWFnZXMuIE9ubHkgbmVlZGVkIHdoZW4gdGhlIG5vZGUgaGFzIGFuIGltYWdlXG4gICAqIEBwYXJhbSB7R3JvdXBzfSBncm91cGxpc3QgICAgICAgICAgQSBsaXN0IHdpdGggZ3JvdXBzLiBOZWVkZWQgZm9yIHJldHJpZXZpbmcgZ3JvdXAgb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsT3B0aW9ucyAgICAgIEN1cnJlbnQgZ2xvYmFsIG5vZGUgb3B0aW9uczsgdGhlc2Ugc2VydmUgYXMgZGVmYXVsdHMgZm9yIHRoZSBub2RlIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkZWZhdWx0T3B0aW9ucyAgICAgR2xvYmFsIGRlZmF1bHQgb3B0aW9ucyBmb3Igbm9kZXM7IG5vdGUgdGhhdCB0aGlzIGlzIGFsc28gdGhlIHByb3RvdHlwZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBwYXJhbWV0ZXIgYGdsb2JhbE9wdGlvbnNgLlxuICAgKi9cbiAgZnVuY3Rpb24gTm9kZShvcHRpb25zLCBib2R5LCBpbWFnZWxpc3QsIGdyb3VwbGlzdCwgZ2xvYmFsT3B0aW9ucywgZGVmYXVsdE9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZSk7XG4gICAgdGhpcy5vcHRpb25zID0gYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMpO1xuICAgIHRoaXMuZ2xvYmFsT3B0aW9ucyA9IGdsb2JhbE9wdGlvbnM7XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5lZGdlcyA9IFtdOyAvLyBhbGwgZWRnZXMgY29ubmVjdGVkIHRvIHRoaXMgbm9kZVxuXG4gICAgLy8gc2V0IGRlZmF1bHRzIGZvciB0aGUgb3B0aW9uc1xuICAgIHRoaXMuaWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbWFnZWxpc3QgPSBpbWFnZWxpc3Q7XG4gICAgdGhpcy5ncm91cGxpc3QgPSBncm91cGxpc3Q7XG5cbiAgICAvLyBzdGF0ZSBvcHRpb25zXG4gICAgdGhpcy54ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJhc2VTaXplID0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgdGhpcy5iYXNlRm9udFNpemUgPSB0aGlzLm9wdGlvbnMuZm9udC5zaXplO1xuICAgIHRoaXMucHJlZGVmaW5lZFBvc2l0aW9uID0gZmFsc2U7IC8vIHVzZWQgdG8gY2hlY2sgaWYgaW5pdGlhbCBmaXQgc2hvdWxkIGp1c3QgdGFrZSB0aGUgcmFuZ2Ugb3IgYXBwcm94aW1hdGVcbiAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5ob3ZlciA9IGZhbHNlO1xuICAgIHRoaXMubGFiZWxNb2R1bGUgPSBuZXcgTGFiZWwodGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMsIGZhbHNlIC8qIE5vdCBlZGdlIGxhYmVsICovKTtcblxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggYSBlZGdlIHRvIHRoZSBub2RlXG4gICAqXG4gICAqIEBwYXJhbSB7RWRnZX0gZWRnZVxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKE5vZGUsIFt7XG4gICAga2V5OiBcImF0dGFjaEVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoRWRnZShlZGdlKSB7XG4gICAgICB2YXIgX2NvbnRleHQ7XG4gICAgICBpZiAoX2luZGV4T2ZJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0ID0gdGhpcy5lZGdlcykuY2FsbChfY29udGV4dCwgZWRnZSkgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuZWRnZXMucHVzaChlZGdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggYSBlZGdlIGZyb20gdGhlIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWRnZX0gZWRnZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRldGFjaEVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoRWRnZShlZGdlKSB7XG4gICAgICB2YXIgX2NvbnRleHQyO1xuICAgICAgdmFyIGluZGV4ID0gX2luZGV4T2ZJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0MiA9IHRoaXMuZWRnZXMpLmNhbGwoX2NvbnRleHQyLCBlZGdlKTtcbiAgICAgIGlmIChpbmRleCAhPSAtMSkge1xuICAgICAgICB2YXIgX2NvbnRleHQzO1xuICAgICAgICBfc3BsaWNlSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDMgPSB0aGlzLmVkZ2VzKS5jYWxsKF9jb250ZXh0MywgaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBvciBvdmVyd3JpdGUgb3B0aW9ucyBmb3IgdGhlIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGFuIG9iamVjdCB3aXRoIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7bnVsbHxib29sZWFufVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB2YXIgY3VycmVudFNoYXBlID0gdGhpcy5vcHRpb25zLnNoYXBlO1xuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybjsgLy8gTm90ZSB0aGF0IHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSAndW5kZWZpbmVkJyEgVGhpcyBpcyBPSy5cbiAgICAgIH1cblxuICAgICAgLy8gU2F2ZSB0aGUgY29sb3IgZm9yIGxhdGVyLlxuICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgaW4gb3JkZXIgdG8gcHJldmVudCBsb2NhbCBjb2xvciBmcm9tIGJlaW5nIG92ZXJ3cml0dGVuIGJ5IGdyb3VwIGNvbG9yLlxuICAgICAgLy8gVE9ETzogVG8gcHJldmVudCBzdWNoIHdvcmthcm91bmRzIHRoZSB3YXkgb3B0aW9ucyBhcmUgaGFuZGxlZCBzaG91bGQgYmUgcmV3cml0dGVuIGZyb20gc2NyYXRjaC5cbiAgICAgIC8vIFRoaXMgaXMgbm90IHRoZSBvbmx5IHByb2JsZW0gd2l0aCBjdXJyZW50IG9wdGlvbnMgaGFuZGxpbmcuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29sb3IgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxDb2xvciA9IG9wdGlvbnMuY29sb3I7XG4gICAgICB9XG5cbiAgICAgIC8vIGJhc2ljIG9wdGlvbnNcbiAgICAgIGlmIChvcHRpb25zLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5pZCA9IG9wdGlvbnMuaWQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vZGUgbXVzdCBoYXZlIGFuIGlkXCIpO1xuICAgICAgfVxuICAgICAgTm9kZS5jaGVja01hc3Mob3B0aW9ucywgdGhpcy5pZCk7XG5cbiAgICAgIC8vIHNldCB0aGVzZSBvcHRpb25zIGxvY2FsbHlcbiAgICAgIC8vIGNsZWFyIHggYW5kIHkgcG9zaXRpb25zXG4gICAgICBpZiAob3B0aW9ucy54ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMueCA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMueCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB0aGlzLnByZWRlZmluZWRQb3NpdGlvbiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMueCA9IF9wYXJzZUludCQxKG9wdGlvbnMueCk7XG4gICAgICAgICAgdGhpcy5wcmVkZWZpbmVkUG9zaXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy55ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMueSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMueSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB0aGlzLnByZWRlZmluZWRQb3NpdGlvbiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMueSA9IF9wYXJzZUludCQxKG9wdGlvbnMueSk7XG4gICAgICAgICAgdGhpcy5wcmVkZWZpbmVkUG9zaXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5iYXNlU2l6ZSA9IG9wdGlvbnMuc2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy52YWx1ZSA9IF9wYXJzZUZsb2F0JDEob3B0aW9ucy52YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRoaXMgdHJhbnNmb3JtcyBhbGwgc2hvcnRoYW5kcyBpbnRvIGZ1bGx5IGRlZmluZWQgb3B0aW9uc1xuICAgICAgTm9kZS5wYXJzZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zLCB0cnVlLCB0aGlzLmdsb2JhbE9wdGlvbnMsIHRoaXMuZ3JvdXBsaXN0KTtcbiAgICAgIHZhciBwaWxlID0gW29wdGlvbnMsIHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9uc107XG4gICAgICB0aGlzLmNob29zZXIgPSBjaG9vc2lmeShcIm5vZGVcIiwgcGlsZSk7XG4gICAgICB0aGlzLl9sb2FkX2ltYWdlcygpO1xuICAgICAgdGhpcy51cGRhdGVMYWJlbE1vZHVsZShvcHRpb25zKTtcblxuICAgICAgLy8gTmVlZCB0byBzZXQgbG9jYWwgb3BhY2l0eSBhZnRlciBgdGhpcy51cGRhdGVMYWJlbE1vZHVsZShvcHRpb25zKTtgIGJlY2F1c2UgYHRoaXMudXBkYXRlTGFiZWxNb2R1bGUob3B0aW9ucyk7YCBvdmVycml0ZXMgbG9jYWwgb3BhY2l0eSB3aXRoIGdyb3VwIG9wYWNpdHlcbiAgICAgIGlmIChvcHRpb25zLm9wYWNpdHkgIT09IHVuZGVmaW5lZCAmJiBOb2RlLmNoZWNrT3BhY2l0eShvcHRpb25zLm9wYWNpdHkpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5O1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVTaGFwZShjdXJyZW50U2hhcGUpO1xuICAgICAgcmV0dXJuIG9wdGlvbnMuaGlkZGVuICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5waHlzaWNzICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZCB0aGUgaW1hZ2VzIGZyb20gdGhlIG9wdGlvbnMsIGZvciB0aGUgbm9kZXMgdGhhdCBuZWVkIHRoZW0uXG4gICAgICpcbiAgICAgKiBJbWFnZXMgYXJlIGFsd2F5cyBsb2FkZWQsIGV2ZW4gaWYgdGhleSBhcmUgbm90IHVzZWQgaW4gdGhlIGN1cnJlbnQgc2hhcGUuXG4gICAgICogVGhlIHVzZXIgbWF5IHN3aXRjaCB0byBhbiBpbWFnZSBzaGFwZSBsYXRlciBvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2xvYWRfaW1hZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2FkX2ltYWdlcygpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcGUgPT09IFwiY2lyY3VsYXJJbWFnZVwiIHx8IHRoaXMub3B0aW9ucy5zaGFwZSA9PT0gXCJpbWFnZVwiKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW1hZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wdGlvbiBpbWFnZSBtdXN0IGJlIGRlZmluZWQgZm9yIG5vZGUgdHlwZSAnXCIgKyB0aGlzLm9wdGlvbnMuc2hhcGUgKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW1hZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pbWFnZWxpc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBFcnJvcjogTm8gaW1hZ2VzIHByb3ZpZGVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuaW1hZ2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhpcy5pbWFnZU9iaiA9IHRoaXMuaW1hZ2VsaXN0LmxvYWQodGhpcy5vcHRpb25zLmltYWdlLCB0aGlzLm9wdGlvbnMuYnJva2VuSW1hZ2UsIHRoaXMuaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbWFnZS51bnNlbGVjdGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB1bnNlbGVjdGVkIGltYWdlIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW1hZ2VPYmogPSB0aGlzLmltYWdlbGlzdC5sb2FkKHRoaXMub3B0aW9ucy5pbWFnZS51bnNlbGVjdGVkLCB0aGlzLm9wdGlvbnMuYnJva2VuSW1hZ2UsIHRoaXMuaWQpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmltYWdlLnNlbGVjdGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmltYWdlT2JqQWx0ID0gdGhpcy5pbWFnZWxpc3QubG9hZCh0aGlzLm9wdGlvbnMuaW1hZ2Uuc2VsZWN0ZWQsIHRoaXMub3B0aW9ucy5icm9rZW5JbWFnZSwgdGhpcy5pZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5pbWFnZU9iakFsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgb3BhY2l0eSBpcyBvbmx5IGJldHdlZW4gMCBhbmQgMVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHlcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRGb3JtYXR0aW5nVmFsdWVzXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7e2NvbG9yOiAqLCBib3JkZXJXaWR0aDogKiwgYm9yZGVyQ29sb3I6ICosIHNpemU6ICosIGJvcmRlckRhc2hlczogKGJvb2xlYW58QXJyYXl8YWxsT3B0aW9ucy5ub2Rlcy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyRGFzaGVzfHtib29sZWFuLCBhcnJheX0pLCBib3JkZXJSYWRpdXM6IChudW1iZXJ8YWxsT3B0aW9ucy5ub2Rlcy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyUmFkaXVzfHtudW1iZXJ9fEFycmF5KSwgc2hhZG93OiAqLCBzaGFkb3dDb2xvcjogKiwgc2hhZG93U2l6ZTogKiwgc2hhZG93WDogKiwgc2hhZG93WTogKn19XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Rm9ybWF0dGluZ1ZhbHVlcygpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSB7XG4gICAgICAgIGNvbG9yOiB0aGlzLm9wdGlvbnMuY29sb3IuYmFja2dyb3VuZCxcbiAgICAgICAgb3BhY2l0eTogdGhpcy5vcHRpb25zLm9wYWNpdHksXG4gICAgICAgIGJvcmRlcldpZHRoOiB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGgsXG4gICAgICAgIGJvcmRlckNvbG9yOiB0aGlzLm9wdGlvbnMuY29sb3IuYm9yZGVyLFxuICAgICAgICBzaXplOiB0aGlzLm9wdGlvbnMuc2l6ZSxcbiAgICAgICAgYm9yZGVyRGFzaGVzOiB0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlckRhc2hlcyxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiB0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlclJhZGl1cyxcbiAgICAgICAgc2hhZG93OiB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQsXG4gICAgICAgIHNoYWRvd0NvbG9yOiB0aGlzLm9wdGlvbnMuc2hhZG93LmNvbG9yLFxuICAgICAgICBzaGFkb3dTaXplOiB0aGlzLm9wdGlvbnMuc2hhZG93LnNpemUsXG4gICAgICAgIHNoYWRvd1g6IHRoaXMub3B0aW9ucy5zaGFkb3cueCxcbiAgICAgICAgc2hhZG93WTogdGhpcy5vcHRpb25zLnNoYWRvdy55XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQgfHwgdGhpcy5ob3Zlcikge1xuICAgICAgICBpZiAodGhpcy5jaG9vc2VyID09PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGhTZWxlY3RlZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhbHVlcy5ib3JkZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aFNlbGVjdGVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsdWVzLmJvcmRlcldpZHRoICo9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXMuY29sb3IgPSB0aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQ7XG4gICAgICAgICAgICB2YWx1ZXMuYm9yZGVyQ29sb3IgPSB0aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlcjtcbiAgICAgICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhvdmVyKSB7XG4gICAgICAgICAgICB2YWx1ZXMuY29sb3IgPSB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYmFja2dyb3VuZDtcbiAgICAgICAgICAgIHZhbHVlcy5ib3JkZXJDb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvci5ob3Zlci5ib3JkZXI7XG4gICAgICAgICAgICB2YWx1ZXMuc2hhZG93ID0gdGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5jaG9vc2VyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLmNob29zZXIodmFsdWVzLCB0aGlzLm9wdGlvbnMuaWQsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpO1xuICAgICAgICAgIGlmICh2YWx1ZXMuc2hhZG93ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlcy5zaGFkb3dDb2xvciAhPT0gdGhpcy5vcHRpb25zLnNoYWRvdy5jb2xvciB8fCB2YWx1ZXMuc2hhZG93U2l6ZSAhPT0gdGhpcy5vcHRpb25zLnNoYWRvdy5zaXplIHx8IHZhbHVlcy5zaGFkb3dYICE9PSB0aGlzLm9wdGlvbnMuc2hhZG93LnggfHwgdmFsdWVzLnNoYWRvd1kgIT09IHRoaXMub3B0aW9ucy5zaGFkb3cueSkge1xuICAgICAgICAgICAgICB2YWx1ZXMuc2hhZG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgb3BhY2l0eSA9IHRoaXMub3B0aW9ucy5vcGFjaXR5O1xuICAgICAgICB2YWx1ZXMuYm9yZGVyQ29sb3IgPSBvdmVycmlkZU9wYWNpdHkodmFsdWVzLmJvcmRlckNvbG9yLCBvcGFjaXR5KTtcbiAgICAgICAgdmFsdWVzLmNvbG9yID0gb3ZlcnJpZGVPcGFjaXR5KHZhbHVlcy5jb2xvciwgb3BhY2l0eSk7XG4gICAgICAgIHZhbHVlcy5zaGFkb3dDb2xvciA9IG92ZXJyaWRlT3BhY2l0eSh2YWx1ZXMuc2hhZG93Q29sb3IsIG9wYWNpdHkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlTGFiZWxNb2R1bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlTGFiZWxNb2R1bGUob3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYWJlbCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMub3B0aW9ucy5sYWJlbCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMubGFiZWwgPSBcIlwiO1xuICAgICAgfVxuICAgICAgTm9kZS51cGRhdGVHcm91cE9wdGlvbnModGhpcy5vcHRpb25zLCBfb2JqZWN0U3ByZWFkJDIoX29iamVjdFNwcmVhZCQyKHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgY29sb3I6IG9wdGlvbnMgJiYgb3B0aW9ucy5jb2xvciB8fCB0aGlzLl9sb2NhbENvbG9yIHx8IHVuZGVmaW5lZFxuICAgICAgfSksIHRoaXMuZ3JvdXBsaXN0KTtcblxuICAgICAgLy9cbiAgICAgIC8vIE5vdGU6VGhlIHByb3RvdHlwZSBjaGFpbiBmb3IgdGhpcy5vcHRpb25zIGlzOlxuICAgICAgLy9cbiAgICAgIC8vIHRoaXMub3B0aW9ucyAtPiAgICBOb2Rlc0hhbmRsZXIub3B0aW9ucyAgICAtPiBOb2Rlc0hhbmRsZXIuZGVmYXVsdE9wdGlvbnNcbiAgICAgIC8vICAgICAgICAgICAgICAgICAoYWxzbzogdGhpcy5nbG9iYWxPcHRpb25zKVxuICAgICAgLy9cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGUgcHJvdG90eXBlcyBhcmUgbWVudGlvbmVkIGV4cGxpY2l0bHkgaW4gdGhlIHBpbGUgbGlzdCBiZWxvdztcbiAgICAgIC8vIFdFIERPTidUIFdBTlQgVEhFIE9SREVSIE9GIFRIRSBQUk9UT1RZUEVTISEhISBBdCBsZWFzdCwgbm90IGZvciBmb250IGhhbmRsaW5nIG9mIGxhYmVscy5cbiAgICAgIC8vIFRoaXMgaXMgYSBnb29kIGluZGljYXRpb24gdGhhdCB0aGUgcHJvdG90eXBlIHVzYWdlIG9mIG9wdGlvbnMgaXMgZGVmaWNpZW50LlxuICAgICAgLy9cbiAgICAgIHZhciBjdXJyZW50R3JvdXAgPSB0aGlzLmdyb3VwbGlzdC5nZXQodGhpcy5vcHRpb25zLmdyb3VwLCBmYWxzZSk7XG4gICAgICB2YXIgcGlsZSA9IFtvcHRpb25zLFxuICAgICAgLy8gbmV3IG9wdGlvbnNcbiAgICAgIHRoaXMub3B0aW9ucyxcbiAgICAgIC8vIGN1cnJlbnQgbm9kZSBvcHRpb25zLCBzZWUgY29tbWVudCBhYm92ZSBmb3IgcHJvdG90eXBlXG4gICAgICBjdXJyZW50R3JvdXAsXG4gICAgICAvLyBncm91cCBvcHRpb25zLCBpZiBhbnlcbiAgICAgIHRoaXMuZ2xvYmFsT3B0aW9ucyxcbiAgICAgIC8vIEN1cnJlbnRseSBzZXQgZ2xvYmFsIG5vZGUgb3B0aW9uc1xuICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyAvLyBEZWZhdWx0IGdsb2JhbCBub2RlIG9wdGlvbnNcbiAgICAgIF07XG5cbiAgICAgIHRoaXMubGFiZWxNb2R1bGUudXBkYXRlKHRoaXMub3B0aW9ucywgcGlsZSk7XG4gICAgICBpZiAodGhpcy5sYWJlbE1vZHVsZS5iYXNlU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYmFzZUZvbnRTaXplID0gdGhpcy5sYWJlbE1vZHVsZS5iYXNlU2l6ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjdXJyZW50U2hhcGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVTaGFwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTaGFwZShjdXJyZW50U2hhcGUpIHtcbiAgICAgIGlmIChjdXJyZW50U2hhcGUgPT09IHRoaXMub3B0aW9ucy5zaGFwZSAmJiB0aGlzLnNoYXBlKSB7XG4gICAgICAgIHRoaXMuc2hhcGUuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMsIHRoaXMuaW1hZ2VPYmosIHRoaXMuaW1hZ2VPYmpBbHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY2hvb3NlIGRyYXcgbWV0aG9kIGRlcGVuZGluZyBvbiB0aGUgc2hhcGVcbiAgICAgICAgc3dpdGNoICh0aGlzLm9wdGlvbnMuc2hhcGUpIHtcbiAgICAgICAgICBjYXNlIFwiYm94XCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IEJveCQxKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJjaXJjbGVcIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgQ2lyY2xlJDEodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImNpcmN1bGFySW1hZ2VcIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgQ2lyY3VsYXJJbWFnZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSwgdGhpcy5pbWFnZU9iaiwgdGhpcy5pbWFnZU9iakFsdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiY3VzdG9tXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IEN1c3RvbVNoYXBlKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlLCB0aGlzLm9wdGlvbnMuY3R4UmVuZGVyZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImRhdGFiYXNlXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IERhdGFiYXNlKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJkaWFtb25kXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IERpYW1vbmQkMSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZG90XCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IERvdCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZWxsaXBzZVwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBFbGxpcHNlKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJpY29uXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IEljb24odGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImltYWdlXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IEltYWdlJDIodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUsIHRoaXMuaW1hZ2VPYmosIHRoaXMuaW1hZ2VPYmpBbHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInNxdWFyZVwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBTcXVhcmUodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImhleGFnb25cIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgSGV4YWdvbih0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic3RhclwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBTdGFyKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IFRleHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInRyaWFuZ2xlXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IFRyaWFuZ2xlJDEodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInRyaWFuZ2xlRG93blwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBUcmlhbmdsZURvd24odGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgRWxsaXBzZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5uZWVkc1JlZnJlc2goKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZWxlY3QgdGhpcyBub2RlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdCgpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5uZWVkc1JlZnJlc2goKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1bnNlbGVjdCB0aGlzIG5vZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1bnNlbGVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNlbGVjdCgpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubmVlZHNSZWZyZXNoKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGNhbGN1bGF0ZWQgc2l6ZSBvZiB0aGUgbm9kZSwgZm9yY2VzIGl0IHRvIHJlY2FsY3VsYXRlIGl0cyBzaXplXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwibmVlZHNSZWZyZXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5lZWRzUmVmcmVzaCgpIHtcbiAgICAgIHRoaXMuc2hhcGUucmVmcmVzaE5lZWRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSB0aXRsZSBvZiB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aXRsZSAgICBUaGUgdGl0bGUgb2YgdGhlIG5vZGUsIG9yIHVuZGVmaW5lZCB3aGVuIG5vIHRpdGxlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBoYXMgYmVlbiBzZXQuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGl0bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGl0bGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRpdGxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgdG8gdGhlIGJvcmRlciBvZiB0aGUgTm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlICAgICAgICBBbmdsZSBpbiByYWRpYW5zXG4gICAgICogQHJldHVybnMge251bWJlcn0gZGlzdGFuY2UgICBEaXN0YW5jZSB0byB0aGUgYm9yZGVyIGluIHBpeGVsc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaGFwZS5kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgbm9kZSBoYXMgYSBmaXhlZCB4IGFuZCB5IHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gICAgICB0cnVlIGlmIGZpeGVkLCBmYWxzZSBpZiBub3RcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpc0ZpeGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRml4ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZpeGVkLnggJiYgdGhpcy5vcHRpb25zLmZpeGVkLnk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2hlY2sgaWYgdGhpcyBub2RlIGlzIHNlbGVjdGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBzZWxlY3RlZCAgIFRydWUgaWYgbm9kZSBpcyBzZWxlY3RlZCwgZWxzZSBmYWxzZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImlzU2VsZWN0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNTZWxlY3RlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSB2YWx1ZSBvZiB0aGUgbm9kZS4gQ2FuIGJlIHVuZGVmaW5lZFxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn0gdmFsdWVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGRpbWVuc2lvbnMgb2YgdGhlIGxhYmVsXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7cmVjdH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRMYWJlbFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFiZWxTaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGFiZWxNb2R1bGUuc2l6ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkanVzdCB0aGUgdmFsdWUgcmFuZ2Ugb2YgdGhlIG5vZGUuIFRoZSBub2RlIHdpbGwgYWRqdXN0IGl0J3Mgc2l6ZVxuICAgICAqIGJhc2VkIG9uIGl0cyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VmFsdWVSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZVJhbmdlKG1pbiwgbWF4LCB0b3RhbCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLmN1c3RvbVNjYWxpbmdGdW5jdGlvbihtaW4sIG1heCwgdG90YWwsIHRoaXMub3B0aW9ucy52YWx1ZSk7XG4gICAgICAgIHZhciBzaXplRGlmZiA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLm1heCAtIHRoaXMub3B0aW9ucy5zY2FsaW5nLm1pbjtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgZm9udERpZmYgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5tYXggLSB0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5taW47XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmZvbnQuc2l6ZSA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1pbiArIHNjYWxlICogZm9udERpZmY7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zLnNpemUgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5taW4gKyBzY2FsZSAqIHNpemVEaWZmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnNpemUgPSB0aGlzLmJhc2VTaXplO1xuICAgICAgICB0aGlzLm9wdGlvbnMuZm9udC5zaXplID0gdGhpcy5iYXNlRm9udFNpemU7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZUxhYmVsTW9kdWxlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyB0aGlzIG5vZGUgaW4gdGhlIGdpdmVuIGNhbnZhc1xuICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICogQHJldHVybnMge29iamVjdH0gQ2FsbGJhY2tzIHRvIGRyYXcgbGF0ZXIgb24gaGlnaGVyIGxheWVycy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICB2YXIgdmFsdWVzID0gdGhpcy5nZXRGb3JtYXR0aW5nVmFsdWVzKCk7XG4gICAgICByZXR1cm4gdGhpcy5zaGFwZS5kcmF3KGN0eCwgdGhpcy54LCB0aGlzLnksIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIHZhbHVlcykgfHwge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIHNoYXBlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gICBjdHhcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveChjdHgpIHtcbiAgICAgIHRoaXMuc2hhcGUudXBkYXRlQm91bmRpbmdCb3godGhpcy54LCB0aGlzLnksIGN0eCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjYWxjdWxhdGUgdGhlIHNpemUgb2YgdGhpcyBub2RlIGluIHRoZSBnaXZlbiBjYW52YXNcbiAgICAgKiBUaGUgMmQgY29udGV4dCBvZiBhIEhUTUwgY2FudmFzIGNhbiBiZSByZXRyaWV2ZWQgYnkgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICB2YXIgdmFsdWVzID0gdGhpcy5nZXRGb3JtYXR0aW5nVmFsdWVzKCk7XG4gICAgICB0aGlzLnNoYXBlLnJlc2l6ZShjdHgsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGFsbCB2aXN1YWwgZWxlbWVudHMgb2YgdGhpcyBub2RlIGluc3RhbmNlLCBpbiB3aGljaCB0aGUgZ2l2ZW5cbiAgICAgKiBwb2ludCBmYWxscyB3aXRoaW4gdGhlIGJvdW5kaW5nIHNoYXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtwb2ludH0gcG9pbnRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG5vZGVDbGlja0l0ZW18bm9kZUxhYmVsQ2xpY2tJdGVtPn0gbGlzdCB3aXRoIHRoZSBpdGVtcyB3aGljaCBhcmUgb24gdGhlIHBvaW50XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SXRlbXNPblBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEl0ZW1zT25Qb2ludChwb2ludCkge1xuICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgaWYgKHRoaXMubGFiZWxNb2R1bGUudmlzaWJsZSgpKSB7XG4gICAgICAgIGlmIChwb2ludEluUmVjdCh0aGlzLmxhYmVsTW9kdWxlLmdldFNpemUoKSwgcG9pbnQpKSB7XG4gICAgICAgICAgcmV0LnB1c2goe1xuICAgICAgICAgICAgbm9kZUlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgbGFiZWxJZDogMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocG9pbnRJblJlY3QodGhpcy5zaGFwZS5ib3VuZGluZ0JveCwgcG9pbnQpKSB7XG4gICAgICAgIHJldC5wdXNoKHtcbiAgICAgICAgICBub2RlSWQ6IHRoaXMuaWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgb2JqZWN0IGlzIG92ZXJsYXBwaW5nIHdpdGggdGhlIHByb3ZpZGVkIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iaiAgIGFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59ICAgICBUcnVlIGlmIGxvY2F0aW9uIGlzIGxvY2F0ZWQgb24gbm9kZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImlzT3ZlcmxhcHBpbmdXaXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzT3ZlcmxhcHBpbmdXaXRoKG9iaikge1xuICAgICAgcmV0dXJuIHRoaXMuc2hhcGUubGVmdCA8IG9iai5yaWdodCAmJiB0aGlzLnNoYXBlLmxlZnQgKyB0aGlzLnNoYXBlLndpZHRoID4gb2JqLmxlZnQgJiYgdGhpcy5zaGFwZS50b3AgPCBvYmouYm90dG9tICYmIHRoaXMuc2hhcGUudG9wICsgdGhpcy5zaGFwZS5oZWlnaHQgPiBvYmoudG9wO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgb2JqZWN0IGlzIG92ZXJsYXBwaW5nIHdpdGggdGhlIHByb3ZpZGVkIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iaiAgIGFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59ICAgICBUcnVlIGlmIGxvY2F0aW9uIGlzIGxvY2F0ZWQgb24gbm9kZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImlzQm91bmRpbmdCb3hPdmVybGFwcGluZ1dpdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNCb3VuZGluZ0JveE92ZXJsYXBwaW5nV2l0aChvYmopIHtcbiAgICAgIHJldHVybiB0aGlzLnNoYXBlLmJvdW5kaW5nQm94LmxlZnQgPCBvYmoucmlnaHQgJiYgdGhpcy5zaGFwZS5ib3VuZGluZ0JveC5yaWdodCA+IG9iai5sZWZ0ICYmIHRoaXMuc2hhcGUuYm91bmRpbmdCb3gudG9wIDwgb2JqLmJvdHRvbSAmJiB0aGlzLnNoYXBlLmJvdW5kaW5nQm94LmJvdHRvbSA+IG9iai50b3A7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdmFsaWQgdmFsdWVzIGZvciBtYXNzXG4gICAgICpcbiAgICAgKiBUaGUgbWFzcyBtYXkgbm90IGJlIG5lZ2F0aXZlIG9yIHplcm8uIElmIGl0IGlzLCByZXNldCB0byAxXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gaWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gIH1dLCBbe1xuICAgIGtleTogXCJjaGVja09wYWNpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICAgIHJldHVybiAwIDw9IG9wYWNpdHkgJiYgb3BhY2l0eSA8PSAxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgb3JpZ2luIGlzICdjZW50ZXInIG9yICd0b3AtbGVmdCdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjaGVja0Nvb3JkaW5hdGVPcmlnaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tDb29yZGluYXRlT3JpZ2luKG9yaWdpbikge1xuICAgICAgcmV0dXJuIG9yaWdpbiA9PT0gdW5kZWZpbmVkIHx8IG9yaWdpbiA9PT0gXCJjZW50ZXJcIiB8fCBvcmlnaW4gPT09IFwidG9wLWxlZnRcIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3B5IGdyb3VwIG9wdGlvbiB2YWx1ZXMgaW50byB0aGUgbm9kZSBvcHRpb25zLlxuICAgICAqXG4gICAgICogVGhlIGdyb3VwIG9wdGlvbnMgb3ZlcnJpZGUgdGhlIGdsb2JhbCBub2RlIG9wdGlvbnMsIHNvIHRoZSBjb3B5IG9mIGdyb3VwIG9wdGlvbnNcbiAgICAgKiAgbXVzdCBoYXBwZW4gKmFmdGVyKiB0aGUgZ2xvYmFsIG5vZGUgb3B0aW9ucyBoYXZlIGJlZW4gc2V0LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbXVzdCBhbHNvIGJlIGNhbGxlZCBhbHNvIGlmIHRoZSBnbG9iYWwgbm9kZSBvcHRpb25zIGhhdmUgY2hhbmdlZCBhbmQgdGhlIGdyb3VwIG9wdGlvbnMgZGlkIG5vdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRPcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5ld09wdGlvbnMgIG5ldyB2YWx1ZXMgZm9yIHRoZSBvcHRpb25zLCBjdXJyZW50bHkgb25seSBwYXNzZWQgaW4gZm9yIGNoZWNrXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGdyb3VwTGlzdFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUdyb3VwT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVHcm91cE9wdGlvbnMocGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucywgZ3JvdXBMaXN0KSB7XG4gICAgICB2YXIgX2NvbnRleHQ0O1xuICAgICAgaWYgKGdyb3VwTGlzdCA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIE5vIGdyb3Vwcywgbm90aGluZyB0byBkb1xuXG4gICAgICB2YXIgZ3JvdXAgPSBwYXJlbnRPcHRpb25zLmdyb3VwO1xuXG4gICAgICAvLyBwYXJhbm9pYTogdGhlIHNlbGVjdGVkIGdyb3VwIGlzIGFscmVhZHkgbWVyZ2VkIGludG8gbm9kZSBvcHRpb25zLCBjaGVjay5cbiAgICAgIGlmIChuZXdPcHRpb25zICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5ncm91cCAhPT0gdW5kZWZpbmVkICYmIGdyb3VwICE9PSBuZXdPcHRpb25zLmdyb3VwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVwZGF0ZUdyb3VwT3B0aW9uczogZ3JvdXAgdmFsdWVzIGluIG9wdGlvbnMgZG9uJ3QgbWF0Y2guXCIpO1xuICAgICAgfVxuICAgICAgdmFyIGhhc0dyb3VwID0gdHlwZW9mIGdyb3VwID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBncm91cCA9PT0gXCJzdHJpbmdcIiAmJiBncm91cCAhPSBcIlwiO1xuICAgICAgaWYgKCFoYXNHcm91cCkgcmV0dXJuOyAvLyBjdXJyZW50IG5vZGUgaGFzIG5vIGdyb3VwLCBubyBuZWVkIHRvIG1lcmdlXG5cbiAgICAgIHZhciBncm91cE9iaiA9IGdyb3VwTGlzdC5nZXQoZ3JvdXApO1xuICAgICAgaWYgKGdyb3VwT2JqLm9wYWNpdHkgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLm9wYWNpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIU5vZGUuY2hlY2tPcGFjaXR5KGdyb3VwT2JqLm9wYWNpdHkpKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgb3B0aW9uIGZvciBub2RlIG9wYWNpdHkuIFZhbHVlIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBmb3VuZDogXCIgKyBncm91cE9iai5vcGFjaXR5KTtcbiAgICAgICAgICBncm91cE9iai5vcGFjaXR5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFNraXAgYW55IG5ldyBvcHRpb24gdG8gYXZvaWQgdGhlbSBiZWluZyBvdmVycmlkZGVuIGJ5IHRoZSBncm91cCBvcHRpb25zLlxuICAgICAgdmFyIHNraXBQcm9wZXJ0aWVzID0gX2ZpbHRlckluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQ0ID0gX09iamVjdCRnZXRPd25Qcm9wZXJ0eU5hbWVzKG5ld09wdGlvbnMpKS5jYWxsKF9jb250ZXh0NCwgZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIG5ld09wdGlvbnNbcF0gIT0gbnVsbDtcbiAgICAgIH0pO1xuICAgICAgLy8gQWx3YXlzIHNraXAgbWVyZ2luZyBncm91cCBmb250IG9wdGlvbnMgaW50byBwYXJlbnQ7IHRoZXNlIGFyZSByZXF1aXJlZCB0byBiZSBkaXN0aW5jdCBmb3IgbGFiZWxzXG4gICAgICBza2lwUHJvcGVydGllcy5wdXNoKFwiZm9udFwiKTtcbiAgICAgIHNlbGVjdGl2ZU5vdERlZXBFeHRlbmQoc2tpcFByb3BlcnRpZXMsIHBhcmVudE9wdGlvbnMsIGdyb3VwT2JqKTtcblxuICAgICAgLy8gdGhlIGNvbG9yIG9iamVjdCBuZWVkcyB0byBiZSBjb21wbGV0ZWx5IGRlZmluZWQuXG4gICAgICAvLyBTaW5jZSBncm91cHMgY2FuIHBhcnRpYWxseSBvdmVyd3JpdGUgdGhlIGNvbG9ycywgd2UgcGFyc2UgaXQgYWdhaW4sIGp1c3QgaW4gY2FzZS5cbiAgICAgIHBhcmVudE9wdGlvbnMuY29sb3IgPSBwYXJzZUNvbG9yKHBhcmVudE9wdGlvbnMuY29sb3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgcHJvY2VzcyBhbGwgcG9zc2libGUgc2hvcnRoYW5kcyBpbiB0aGUgbmV3IG9wdGlvbnMgYW5kIG1ha2VzIHN1cmUgdGhhdCB0aGUgcGFyZW50T3B0aW9ucyBhcmUgZnVsbHkgZGVmaW5lZC5cbiAgICAgKiBTdGF0aWMgc28gaXQgY2FuIGFsc28gYmUgdXNlZCBieSB0aGUgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRPcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5ld09wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthbGxvd0RlbGV0aW9uPWZhbHNlXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbZ2xvYmFsT3B0aW9ucz17fV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2dyb3VwTGlzdF1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zKSB7XG4gICAgICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICB2YXIgZ2xvYmFsT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gICAgICB2YXIgZ3JvdXBMaXN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgZmllbGRzID0gW1wiY29sb3JcIiwgXCJmaXhlZFwiLCBcInNoYWRvd1wiXTtcbiAgICAgIHNlbGVjdGl2ZU5vdERlZXBFeHRlbmQoZmllbGRzLCBwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgIE5vZGUuY2hlY2tNYXNzKG5ld09wdGlvbnMpO1xuICAgICAgaWYgKHBhcmVudE9wdGlvbnMub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghTm9kZS5jaGVja09wYWNpdHkocGFyZW50T3B0aW9ucy5vcGFjaXR5KSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIG9wdGlvbiBmb3Igbm9kZSBvcGFjaXR5LiBWYWx1ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMSwgZm91bmQ6IFwiICsgcGFyZW50T3B0aW9ucy5vcGFjaXR5KTtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLm9wYWNpdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChuZXdPcHRpb25zLm9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIU5vZGUuY2hlY2tPcGFjaXR5KG5ld09wdGlvbnMub3BhY2l0eSkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBvcHRpb24gZm9yIG5vZGUgb3BhY2l0eS4gVmFsdWUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEsIGZvdW5kOiBcIiArIG5ld09wdGlvbnMub3BhY2l0eSk7XG4gICAgICAgICAgbmV3T3B0aW9ucy5vcGFjaXR5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobmV3T3B0aW9ucy5zaGFwZVByb3BlcnRpZXMgJiYgIU5vZGUuY2hlY2tDb29yZGluYXRlT3JpZ2luKG5ld09wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmNvb3JkaW5hdGVPcmlnaW4pKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIG9wdGlvbiBmb3Igbm9kZSBjb29yZGluYXRlT3JpZ2luLCBmb3VuZDogXCIgKyBuZXdPcHRpb25zLnNoYXBlUHJvcGVydGllcy5jb29yZGluYXRlT3JpZ2luKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWVyZ2UgdGhlIHNoYWRvdyBvcHRpb25zIGludG8gdGhlIHBhcmVudC5cbiAgICAgIG1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCBcInNoYWRvd1wiLCBnbG9iYWxPcHRpb25zKTtcblxuICAgICAgLy8gaW5kaXZpZHVhbCBzaGFwZSBuZXdPcHRpb25zXG4gICAgICBpZiAobmV3T3B0aW9ucy5jb2xvciAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuY29sb3IgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHBhcnNlZENvbG9yID0gcGFyc2VDb2xvcihuZXdPcHRpb25zLmNvbG9yKTtcbiAgICAgICAgZmlsbElmRGVmaW5lZChwYXJlbnRPcHRpb25zLmNvbG9yLCBwYXJzZWRDb2xvcik7XG4gICAgICB9IGVsc2UgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5jb2xvciA9PT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmNvbG9yID0gYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMuY29sb3IpOyAvLyBzZXQgdGhlIG9iamVjdCBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uc1xuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgdGhlIGZpeGVkIG9wdGlvbnNcbiAgICAgIGlmIChuZXdPcHRpb25zLmZpeGVkICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5maXhlZCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIG5ld09wdGlvbnMuZml4ZWQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5maXhlZC54ID0gbmV3T3B0aW9ucy5maXhlZDtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmZpeGVkLnkgPSBuZXdPcHRpb25zLmZpeGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChuZXdPcHRpb25zLmZpeGVkLnggIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgbmV3T3B0aW9ucy5maXhlZC54ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgcGFyZW50T3B0aW9ucy5maXhlZC54ID0gbmV3T3B0aW9ucy5maXhlZC54O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV3T3B0aW9ucy5maXhlZC55ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG5ld09wdGlvbnMuZml4ZWQueSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuZml4ZWQueSA9IG5ld09wdGlvbnMuZml4ZWQueTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlICYmIG5ld09wdGlvbnMuZm9udCA9PT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmZvbnQgPSBicmlkZ2VPYmplY3QoZ2xvYmFsT3B0aW9ucy5mb250KTsgLy8gc2V0IHRoZSBvYmplY3QgYmFjayB0byB0aGUgZ2xvYmFsIG9wdGlvbnNcbiAgICAgIH1cblxuICAgICAgTm9kZS51cGRhdGVHcm91cE9wdGlvbnMocGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucywgZ3JvdXBMaXN0KTtcblxuICAgICAgLy8gaGFuZGxlIHRoZSBzY2FsaW5nIG9wdGlvbnMsIHNwZWNpZmljYWxseSB0aGUgbGFiZWwgcGFydFxuICAgICAgaWYgKG5ld09wdGlvbnMuc2NhbGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLnNjYWxpbmcsIG5ld09wdGlvbnMuc2NhbGluZywgXCJsYWJlbFwiLCBnbG9iYWxPcHRpb25zLnNjYWxpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGVja01hc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tNYXNzKG9wdGlvbnMsIGlkKSB7XG4gICAgICBpZiAob3B0aW9ucy5tYXNzICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5tYXNzIDw9IDApIHtcbiAgICAgICAgdmFyIHN0cklkID0gXCJcIjtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzdHJJZCA9IFwiIGluIG5vZGUgaWQ6IFwiICsgaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihcIiVjTmVnYXRpdmUgb3IgemVybyBtYXNzIGRpc2FsbG93ZWRcIiArIHN0cklkICsgXCIsIHNldHRpbmcgbWFzcyB0byAxLlwiLCBWQUxJREFUT1JfUFJJTlRfU1RZTEUpO1xuICAgICAgICBvcHRpb25zLm1hc3MgPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTm9kZTtcbn0oKTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNShvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgX1N5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBfZ2V0SXRlcmF0b3JNZXRob2QobykgfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKF9BcnJheSRpc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ1KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ1KG8sIG1pbkxlbikgeyB2YXIgX2NvbnRleHQ0OyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNShvLCBtaW5MZW4pOyB2YXIgbiA9IF9zbGljZUluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQ0ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pKS5jYWxsKF9jb250ZXh0NCwgOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gX0FycmF5JGZyb20kMShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ1KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDUoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBOb2Rlc1xuICovXG52YXIgTm9kZXNIYW5kbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7SW1hZ2VzfSBpbWFnZXNcbiAgICogQHBhcmFtIHtBcnJheS48R3JvdXA+fSBncm91cHNcbiAgICogQHBhcmFtIHtMYXlvdXRFbmdpbmV9IGxheW91dEVuZ2luZVxuICAgKi9cbiAgZnVuY3Rpb24gTm9kZXNIYW5kbGVyKGJvZHksIGltYWdlcywgZ3JvdXBzLCBsYXlvdXRFbmdpbmUpIHtcbiAgICB2YXIgX2NvbnRleHQsXG4gICAgICBfdGhpcyA9IHRoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVzSGFuZGxlcik7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmltYWdlcyA9IGltYWdlcztcbiAgICB0aGlzLmdyb3VwcyA9IGdyb3VwcztcbiAgICB0aGlzLmxheW91dEVuZ2luZSA9IGxheW91dEVuZ2luZTtcblxuICAgIC8vIGNyZWF0ZSB0aGUgbm9kZSBBUEkgaW4gdGhlIGJvZHkgY29udGFpbmVyXG4gICAgdGhpcy5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVOb2RlID0gX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQgPSB0aGlzLmNyZWF0ZSkuY2FsbChfY29udGV4dCwgdGhpcyk7XG4gICAgdGhpcy5ub2Rlc0xpc3RlbmVycyA9IHtcbiAgICAgIGFkZDogZnVuY3Rpb24gYWRkKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgX3RoaXMuYWRkKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICBfdGhpcy51cGRhdGUocGFyYW1zLml0ZW1zLCBwYXJhbXMuZGF0YSwgcGFyYW1zLm9sZERhdGEpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgX3RoaXMucmVtb3ZlKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICBib3JkZXJXaWR0aFNlbGVjdGVkOiB1bmRlZmluZWQsXG4gICAgICBicm9rZW5JbWFnZTogdW5kZWZpbmVkLFxuICAgICAgY29sb3I6IHtcbiAgICAgICAgYm9yZGVyOiBcIiMyQjdDRTlcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjOTdDMkZDXCIsXG4gICAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICAgIGJvcmRlcjogXCIjMkI3Q0U5XCIsXG4gICAgICAgICAgYmFja2dyb3VuZDogXCIjRDJFNUZGXCJcbiAgICAgICAgfSxcbiAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICBib3JkZXI6IFwiIzJCN0NFOVwiLFxuICAgICAgICAgIGJhY2tncm91bmQ6IFwiI0QyRTVGRlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvcGFjaXR5OiB1bmRlZmluZWQsXG4gICAgICAvLyBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICBmaXhlZDoge1xuICAgICAgICB4OiBmYWxzZSxcbiAgICAgICAgeTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBmb250OiB7XG4gICAgICAgIGNvbG9yOiBcIiMzNDM0MzRcIixcbiAgICAgICAgc2l6ZTogMTQsXG4gICAgICAgIC8vIHB4XG4gICAgICAgIGZhY2U6IFwiYXJpYWxcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCJub25lXCIsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgICAgICAvLyBweFxuICAgICAgICBzdHJva2VDb2xvcjogXCIjZmZmZmZmXCIsXG4gICAgICAgIGFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICB2YWRqdXN0OiAwLFxuICAgICAgICBtdWx0aTogZmFsc2UsXG4gICAgICAgIGJvbGQ6IHtcbiAgICAgICAgICBtb2Q6IFwiYm9sZFwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvbGRpdGFsOiB7XG4gICAgICAgICAgbW9kOiBcImJvbGQgaXRhbGljXCJcbiAgICAgICAgfSxcbiAgICAgICAgaXRhbDoge1xuICAgICAgICAgIG1vZDogXCJpdGFsaWNcIlxuICAgICAgICB9LFxuICAgICAgICBtb25vOiB7XG4gICAgICAgICAgbW9kOiBcIlwiLFxuICAgICAgICAgIHNpemU6IDE1LFxuICAgICAgICAgIC8vIHB4XG4gICAgICAgICAgZmFjZTogXCJtb25vc3BhY2VcIixcbiAgICAgICAgICB2YWRqdXN0OiAyXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBncm91cDogdW5kZWZpbmVkLFxuICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgIGljb246IHtcbiAgICAgICAgZmFjZTogXCJGb250QXdlc29tZVwiLFxuICAgICAgICAvLydGb250QXdlc29tZScsXG4gICAgICAgIGNvZGU6IHVuZGVmaW5lZCxcbiAgICAgICAgLy8nXFx1ZjAwNycsXG4gICAgICAgIHNpemU6IDUwLFxuICAgICAgICAvLzUwLFxuICAgICAgICBjb2xvcjogXCIjMkI3Q0U5XCIgLy8nI2FhMDBmZidcbiAgICAgIH0sXG5cbiAgICAgIGltYWdlOiB1bmRlZmluZWQsXG4gICAgICAvLyAtLT4gVVJMXG4gICAgICBpbWFnZVBhZGRpbmc6IHtcbiAgICAgICAgLy8gb25seSBmb3IgaW1hZ2Ugc2hhcGVcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICBsZWZ0OiAwXG4gICAgICB9LFxuICAgICAgbGFiZWw6IHVuZGVmaW5lZCxcbiAgICAgIGxhYmVsSGlnaGxpZ2h0Qm9sZDogdHJ1ZSxcbiAgICAgIGxldmVsOiB1bmRlZmluZWQsXG4gICAgICBtYXJnaW46IHtcbiAgICAgICAgdG9wOiA1LFxuICAgICAgICByaWdodDogNSxcbiAgICAgICAgYm90dG9tOiA1LFxuICAgICAgICBsZWZ0OiA1XG4gICAgICB9LFxuICAgICAgbWFzczogMSxcbiAgICAgIHBoeXNpY3M6IHRydWUsXG4gICAgICBzY2FsaW5nOiB7XG4gICAgICAgIG1pbjogMTAsXG4gICAgICAgIG1heDogMzAsXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgbWluOiAxNCxcbiAgICAgICAgICBtYXg6IDMwLFxuICAgICAgICAgIG1heFZpc2libGU6IDMwLFxuICAgICAgICAgIGRyYXdUaHJlc2hvbGQ6IDVcbiAgICAgICAgfSxcbiAgICAgICAgY3VzdG9tU2NhbGluZ0Z1bmN0aW9uOiBmdW5jdGlvbiBjdXN0b21TY2FsaW5nRnVuY3Rpb24obWluLCBtYXgsIHRvdGFsLCB2YWx1ZSkge1xuICAgICAgICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gMSAvIChtYXggLSBtaW4pO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsICh2YWx1ZSAtIG1pbikgKiBzY2FsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2hhZG93OiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBjb2xvcjogXCJyZ2JhKDAsMCwwLDAuNSlcIixcbiAgICAgICAgc2l6ZTogMTAsXG4gICAgICAgIHg6IDUsXG4gICAgICAgIHk6IDVcbiAgICAgIH0sXG4gICAgICBzaGFwZTogXCJlbGxpcHNlXCIsXG4gICAgICBzaGFwZVByb3BlcnRpZXM6IHtcbiAgICAgICAgYm9yZGVyRGFzaGVzOiBmYWxzZSxcbiAgICAgICAgLy8gb25seSBmb3IgYm9yZGVyc1xuICAgICAgICBib3JkZXJSYWRpdXM6IDYsXG4gICAgICAgIC8vIG9ubHkgZm9yIGJveCBzaGFwZVxuICAgICAgICBpbnRlcnBvbGF0aW9uOiB0cnVlLFxuICAgICAgICAvLyBvbmx5IGZvciBpbWFnZSBhbmQgY2lyY3VsYXJJbWFnZSBzaGFwZXNcbiAgICAgICAgdXNlSW1hZ2VTaXplOiBmYWxzZSxcbiAgICAgICAgLy8gb25seSBmb3IgaW1hZ2UgYW5kIGNpcmN1bGFySW1hZ2Ugc2hhcGVzXG4gICAgICAgIHVzZUJvcmRlcldpdGhJbWFnZTogZmFsc2UsXG4gICAgICAgIC8vIG9ubHkgZm9yIGltYWdlIHNoYXBlXG4gICAgICAgIGNvb3JkaW5hdGVPcmlnaW46IFwiY2VudGVyXCIgLy8gb25seSBmb3IgaW1hZ2UgYW5kIGNpcmN1bGFySW1hZ2Ugc2hhcGVzXG4gICAgICB9LFxuXG4gICAgICBzaXplOiAyNSxcbiAgICAgIHRpdGxlOiB1bmRlZmluZWQsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgeDogdW5kZWZpbmVkLFxuICAgICAgeTogdW5kZWZpbmVkXG4gICAgfTtcblxuICAgIC8vIFByb3RlY3QgZnJvbSBpZGlvY3lcbiAgICBpZiAodGhpcy5kZWZhdWx0T3B0aW9ucy5tYXNzIDw9IDApIHtcbiAgICAgIHRocm93IFwiSW50ZXJuYWwgZXJyb3I6IG1hc3MgaW4gZGVmYXVsdE9wdGlvbnMgb2YgTm9kZXNIYW5kbGVyIG1heSBub3QgYmUgemVybyBvciBuZWdhdGl2ZVwiO1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMgPSBicmlkZ2VPYmplY3QodGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhOb2Rlc0hhbmRsZXIsIFt7XG4gICAga2V5OiBcImJpbmRFdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX2NvbnRleHQyLFxuICAgICAgICBfY29udGV4dDMsXG4gICAgICAgIF90aGlzMiA9IHRoaXM7XG4gICAgICAvLyByZWZyZXNoIHRoZSBub2Rlcy4gVXNlZCB3aGVuIHJldmVydGluZyBmcm9tIGhpZXJhcmNoaWNhbCBsYXlvdXRcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwicmVmcmVzaE5vZGVzXCIsIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MiA9IHRoaXMucmVmcmVzaCkuY2FsbChfY29udGV4dDIsIHRoaXMpKTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwicmVmcmVzaFwiLCBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDMgPSB0aGlzLnJlZnJlc2gpLmNhbGwoX2NvbnRleHQzLCB0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3JFYWNoJDEoX3RoaXMyLm5vZGVzTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgaWYgKF90aGlzMi5ib2R5LmRhdGEubm9kZXMpIF90aGlzMi5ib2R5LmRhdGEubm9kZXMub2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgX3RoaXMyLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZU5vZGU7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIubm9kZXNMaXN0ZW5lcnMuYWRkO1xuICAgICAgICBkZWxldGUgX3RoaXMyLm5vZGVzTGlzdGVuZXJzLnVwZGF0ZTtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5ub2Rlc0xpc3RlbmVycy5yZW1vdmU7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIubm9kZXNMaXN0ZW5lcnM7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgTm9kZS5wYXJzZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBOZWVkIHRvIHNldCBvcGFjaXR5IGhlcmUgYmVjYXVzZSBOb2RlLnBhcnNlT3B0aW9ucyBpcyBhbHNvIHVzZWQgZm9yIGdyb3VwcyxcbiAgICAgICAgLy8gaWYgeW91IHNldCBvcGFjaXR5IGluIE5vZGUucGFyc2VPcHRpb25zIGl0IG92ZXJ3cml0ZXMgZ3JvdXAgb3BhY2l0eS5cbiAgICAgICAgaWYgKG9wdGlvbnMub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKF9OdW1iZXIkaXNOYU4ob3B0aW9ucy5vcGFjaXR5KSB8fCAhX051bWJlciRpc0Zpbml0ZShvcHRpb25zLm9wYWNpdHkpIHx8IG9wdGlvbnMub3BhY2l0eSA8IDAgfHwgb3B0aW9ucy5vcGFjaXR5ID4gMSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgb3B0aW9uIGZvciBub2RlIG9wYWNpdHkuIFZhbHVlIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBmb3VuZDogXCIgKyBvcHRpb25zLm9wYWNpdHkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wdGlvbnMub3BhY2l0eTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHNoYXBlIGluIGFsbCBub2Rlc1xuICAgICAgICBpZiAob3B0aW9ucy5zaGFwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkubm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0udXBkYXRlU2hhcGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGxhYmVscyBvZiBub2RlcyBpZiBhbnkgcmVsZXZhbnQgb3B0aW9ucyBjaGFuZ2VkLlxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZm9udCAhPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2Ygb3B0aW9ucy53aWR0aENvbnN0cmFpbnQgIT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIG9wdGlvbnMuaGVpZ2h0Q29uc3RyYWludCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX09iamVjdCRrZXlzJDEgPSBfT2JqZWN0JGtleXModGhpcy5ib2R5Lm5vZGVzKTsgX2kgPCBfT2JqZWN0JGtleXMkMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBfbm9kZUlkID0gX09iamVjdCRrZXlzJDFbX2ldO1xuICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW19ub2RlSWRdLnVwZGF0ZUxhYmVsTW9kdWxlKCk7XG4gICAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbX25vZGVJZF0ubmVlZHNSZWZyZXNoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBzaGFwZSBzaXplIGluIGFsbCBub2Rlc1xuICAgICAgICBpZiAob3B0aW9ucy5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBfbm9kZUlkMiBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5Lm5vZGVzLCBfbm9kZUlkMikpIHtcbiAgICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW19ub2RlSWQyXS5uZWVkc1JlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHN0YXRlIG9mIHRoZSB2YXJpYWJsZXMgaWYgbmVlZGVkXG4gICAgICAgIGlmIChvcHRpb25zLmhpZGRlbiAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucGh5c2ljcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBhIGRhdGEgc2V0IHdpdGggbm9kZXMgZm9yIHRoZSBuZXR3b3JrXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5IHwgRGF0YVNldCB8IERhdGFWaWV3fSBub2RlcyAgICAgICAgIFRoZSBkYXRhIGNvbnRhaW5pbmcgdGhlIG5vZGVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RvTm90RW1pdD1mYWxzZV0gLSBTdXBwcmVzcyBkYXRhIGNoYW5nZWQgZXZlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXREYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERhdGEobm9kZXMpIHtcbiAgICAgIHZhciBkb05vdEVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIG9sZE5vZGVzRGF0YSA9IHRoaXMuYm9keS5kYXRhLm5vZGVzO1xuICAgICAgaWYgKGlzRGF0YVZpZXdMaWtlKFwiaWRcIiwgbm9kZXMpKSB7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLm5vZGVzID0gbm9kZXM7XG4gICAgICB9IGVsc2UgaWYgKF9BcnJheSRpc0FycmF5KG5vZGVzKSkge1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5ub2RlcyA9IG5ldyBEYXRhU2V0KCk7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLm5vZGVzLmFkZChub2Rlcyk7XG4gICAgICB9IGVsc2UgaWYgKCFub2Rlcykge1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5ub2RlcyA9IG5ldyBEYXRhU2V0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJyYXkgb3IgRGF0YVNldCBleHBlY3RlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvbGROb2Rlc0RhdGEpIHtcbiAgICAgICAgLy8gdW5zdWJzY3JpYmUgZnJvbSBvbGQgZGF0YXNldFxuICAgICAgICBmb3JFYWNoJDEodGhpcy5ub2Rlc0xpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICAgIG9sZE5vZGVzRGF0YS5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlbW92ZSBkcmF3biBub2Rlc1xuICAgICAgdGhpcy5ib2R5Lm5vZGVzID0ge307XG4gICAgICBpZiAodGhpcy5ib2R5LmRhdGEubm9kZXMpIHtcbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIG5ldyBkYXRhc2V0XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGZvckVhY2gkMSh0aGlzLm5vZGVzTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgbWUuYm9keS5kYXRhLm5vZGVzLm9uKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGRyYXcgYWxsIG5ldyBub2Rlc1xuICAgICAgICB2YXIgaWRzID0gdGhpcy5ib2R5LmRhdGEubm9kZXMuZ2V0SWRzKCk7XG4gICAgICAgIHRoaXMuYWRkKGlkcywgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoZG9Ob3RFbWl0ID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBub2Rlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBpZHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkb05vdEVtaXQ9ZmFsc2VdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGlkcykge1xuICAgICAgdmFyIGRvTm90RW1pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgaWQ7XG4gICAgICB2YXIgbmV3Tm9kZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlkID0gaWRzW2ldO1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuYm9keS5kYXRhLm5vZGVzLmdldChpZCk7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGUocHJvcGVydGllcyk7XG4gICAgICAgIG5ld05vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIHRoaXMuYm9keS5ub2Rlc1tpZF0gPSBub2RlOyAvLyBub3RlOiB0aGlzIG1heSByZXBsYWNlIGFuIGV4aXN0aW5nIG5vZGVcbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXlvdXRFbmdpbmUucG9zaXRpb25Jbml0aWFsbHkobmV3Tm9kZXMpO1xuICAgICAgaWYgKGRvTm90RW1pdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZXhpc3Rpbmcgbm9kZXMsIG9yIGNyZWF0ZSB0aGVtIHdoZW4gbm90IHlldCBleGlzdGluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBpZHMgaWQncyBvZiBjaGFuZ2VkIG5vZGVzXG4gICAgICogQHBhcmFtIHtBcnJheX0gY2hhbmdlZERhdGEgYXJyYXkgd2l0aCBjaGFuZ2VkIGRhdGFcbiAgICAgKiBAcGFyYW0ge0FycmF5fHVuZGVmaW5lZH0gb2xkRGF0YSBvcHRpb25hbDsgYXJyYXkgd2l0aCBwcmV2aW91cyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKGlkcywgY2hhbmdlZERhdGEsIG9sZERhdGEpIHtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBkYXRhQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlkID0gaWRzW2ldO1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2lkXTtcbiAgICAgICAgdmFyIGRhdGEgPSBjaGFuZ2VkRGF0YVtpXTtcbiAgICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHVwZGF0ZSBub2RlXG4gICAgICAgICAgaWYgKG5vZGUuc2V0T3B0aW9ucyhkYXRhKSkge1xuICAgICAgICAgICAgZGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgLy8gY3JlYXRlIG5vZGVcbiAgICAgICAgICBub2RlID0gdGhpcy5jcmVhdGUoZGF0YSk7XG4gICAgICAgICAgbm9kZXNbaWRdID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFkYXRhQ2hhbmdlZCAmJiBvbGREYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGFueSBjaGFuZ2VzIHdoaWNoIHNob3VsZCB0cmlnZ2VyIGEgbGF5b3V0IHJlY2FsY3VsYXRpb25cbiAgICAgICAgLy8gRm9yIG5vdywgdGhpcyBpcyBqdXN0ICdsZXZlbCcgZm9yIGhpZXJhcmNoaWNhbCBsYXlvdXRcbiAgICAgICAgLy8gQXNzdW1wdGlvbjogb2xkIGFuZCBuZXcgZGF0YSBhcnJhbmdlZCBpbiBzYW1lIG9yZGVyOyBhdCB0aW1lIG9mIHdyaXRpbmcsIHRoaXMgaG9sZHMuXG4gICAgICAgIGRhdGFDaGFuZ2VkID0gX3NvbWVJbnN0YW5jZVByb3BlcnR5KGNoYW5nZWREYXRhKS5jYWxsKGNoYW5nZWREYXRhLCBmdW5jdGlvbiAobmV3VmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIG9sZFZhbHVlID0gb2xkRGF0YVtpbmRleF07XG4gICAgICAgICAgcmV0dXJuIG9sZFZhbHVlICYmIG9sZFZhbHVlLmxldmVsICE9PSBuZXdWYWx1ZS5sZXZlbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YUNoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YVVwZGF0ZWRcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGV4aXN0aW5nIG5vZGVzLiBJZiBub2RlcyBkbyBub3QgZXhpc3QsIHRoZSBtZXRob2Qgd2lsbCBqdXN0IGlnbm9yZSBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW10gfCBzdHJpbmdbXX0gaWRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGlkcykge1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlkID0gaWRzW2ldO1xuICAgICAgICBkZWxldGUgbm9kZXNbaWRdO1xuICAgICAgfVxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgYSBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7Y2xhc3N9IFtjb25zdHJ1Y3RvckNsYXNzPU5vZGUuZGVmYXVsdF1cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciBjb25zdHJ1Y3RvckNsYXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBOb2RlO1xuICAgICAgcmV0dXJuIG5ldyBjb25zdHJ1Y3RvckNsYXNzKHByb3BlcnRpZXMsIHRoaXMuYm9keSwgdGhpcy5pbWFnZXMsIHRoaXMuZ3JvdXBzLCB0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY2xlYXJQb3NpdGlvbnM9ZmFsc2VdXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVmcmVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgY2xlYXJQb3NpdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgICAgZm9yRWFjaCQxKHRoaXMuYm9keS5ub2RlcywgZnVuY3Rpb24gKG5vZGUsIG5vZGVJZCkge1xuICAgICAgICB2YXIgZGF0YSA9IF90aGlzMy5ib2R5LmRhdGEubm9kZXMuZ2V0KG5vZGVJZCk7XG4gICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoY2xlYXJQb3NpdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAgIHg6IG51bGwsXG4gICAgICAgICAgICAgIHk6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgZml4ZWQ6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbm9kZS5zZXRPcHRpb25zKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbnMgb2YgdGhlIG5vZGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZS5pZD4gfCBzdHJpbmd9IFtpZHNdICAtLT4gb3B0aW9uYWwsIGNhbiBiZSBhcnJheSBvZiBub2RlSWRzLCBjYW4gYmUgc3RyaW5nXG4gICAgICogQHJldHVybnMge3t9fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFBvc2l0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb3NpdGlvbnMoaWRzKSB7XG4gICAgICB2YXIgZGF0YUFycmF5ID0ge307XG4gICAgICBpZiAoaWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKF9BcnJheSRpc0FycmF5KGlkcykgPT09IHRydWUpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tpZHNbaV1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbaWRzW2ldXTtcbiAgICAgICAgICAgICAgZGF0YUFycmF5W2lkc1tpXV0gPSB7XG4gICAgICAgICAgICAgICAgeDogTWF0aC5yb3VuZChub2RlLngpLFxuICAgICAgICAgICAgICAgIHk6IE1hdGgucm91bmQobm9kZS55KVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2lkc10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIF9ub2RlID0gdGhpcy5ib2R5Lm5vZGVzW2lkc107XG4gICAgICAgICAgICBkYXRhQXJyYXlbaWRzXSA9IHtcbiAgICAgICAgICAgICAgeDogTWF0aC5yb3VuZChfbm9kZS54KSxcbiAgICAgICAgICAgICAgeTogTWF0aC5yb3VuZChfbm9kZS55KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgdmFyIF9ub2RlMiA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbX2kyXV07XG4gICAgICAgICAgZGF0YUFycmF5W3RoaXMuYm9keS5ub2RlSW5kaWNlc1tfaTJdXSA9IHtcbiAgICAgICAgICAgIHg6IE1hdGgucm91bmQoX25vZGUyLngpLFxuICAgICAgICAgICAgeTogTWF0aC5yb3VuZChfbm9kZTIueSlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YUFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgeCB5IHBvc2l0aW9uIG9mIGEgc3BlY2lmaWMgaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGlkIHRvIHJldHJpZXZlLlxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgbm8gaWQgaXMgaW5jbHVkZWQuXG4gICAgICogQHRocm93cyB7UmVmZXJlbmNlRXJyb3J9IElmIGFuIGludmFsaWQgaWQgaXMgcHJvdmlkZWQuXG4gICAgICogQHJldHVybnMge3sgeDogbnVtYmVyLCB5OiBudW1iZXIgfX0gUmV0dXJucyBYLCBZIGNhbnZhcyBwb3NpdGlvbiBvZiB0aGUgbm9kZSB3aXRoIGdpdmVuIGlkLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvc2l0aW9uKGlkKSB7XG4gICAgICBpZiAoaWQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJObyBpZCB3YXMgc3BlY2lmaWVkIGZvciBnZXRQb3NpdGlvbiBtZXRob2QuXCIpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmJvZHkubm9kZXNbaWRdID09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJOb2RlSWQgcHJvdmlkZWQgZm9yIGdldFBvc2l0aW9uIGRvZXMgbm90IGV4aXN0LiBQcm92aWRlZDogXCIuY29uY2F0KGlkKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IE1hdGgucm91bmQodGhpcy5ib2R5Lm5vZGVzW2lkXS54KSxcbiAgICAgICAgICB5OiBNYXRoLnJvdW5kKHRoaXMuYm9keS5ub2Rlc1tpZF0ueSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSBYWSBwb3NpdGlvbnMgb2YgdGhlIG5vZGVzIGludG8gdGhlIGRhdGFzZXQuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcmVQb3NpdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcmVQb3NpdGlvbnMoKSB7XG4gICAgICAvLyB0b2RvOiBhZGQgc3VwcG9ydCBmb3IgY2x1c3RlcnMgYW5kIGhpZXJhcmNoaWNhbC5cbiAgICAgIHZhciBkYXRhQXJyYXkgPSBbXTtcbiAgICAgIHZhciBkYXRhc2V0ID0gdGhpcy5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpO1xuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDUoZGF0YXNldC5nZXQoKSksXG4gICAgICAgIF9zdGVwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgZHNOb2RlID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIGlkID0gZHNOb2RlLmlkO1xuICAgICAgICAgIHZhciBib2R5Tm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tpZF07XG4gICAgICAgICAgdmFyIHggPSBNYXRoLnJvdW5kKGJvZHlOb2RlLngpO1xuICAgICAgICAgIHZhciB5ID0gTWF0aC5yb3VuZChib2R5Tm9kZS55KTtcbiAgICAgICAgICBpZiAoZHNOb2RlLnggIT09IHggfHwgZHNOb2RlLnkgIT09IHkpIHtcbiAgICAgICAgICAgIGRhdGFBcnJheS5wdXNoKHtcbiAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICAgIGRhdGFzZXQudXBkYXRlKGRhdGFBcnJheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBib3VuZGluZyBib3ggb2YgYSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7anwqfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvdW5kaW5nQm94KG5vZGVJZCkge1xuICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLnNoYXBlLmJvdW5kaW5nQm94O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgSWRzIG9mIG5vZGVzIGNvbm5lY3RlZCB0byB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEBwYXJhbSB7J3RvJ3wnZnJvbSd8dW5kZWZpbmVkfSBkaXJlY3Rpb24gdmFsdWVzICdmcm9tJyBhbmQgJ3RvJyBzZWxlY3QgcmVzcGVjdGl2ZWx5IHBhcmVudCBhbmQgY2hpbGQgbm9kZXMgb25seS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFueSBvdGhlciB2YWx1ZSByZXR1cm5zIGJvdGggcGFyZW50IGFuZCBjaGlsZCBub2Rlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29ubmVjdGVkTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29ubmVjdGVkTm9kZXMobm9kZUlkLCBkaXJlY3Rpb24pIHtcbiAgICAgIHZhciBub2RlTGlzdCA9IFtdO1xuICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgdmFyIG5vZGVPYmogPSB7fTsgLy8gdXNlZCB0byBxdWlja2x5IGNoZWNrIGlmIG5vZGUgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBub2RlLmVkZ2VzW2ldO1xuICAgICAgICAgIGlmIChkaXJlY3Rpb24gIT09IFwidG9cIiAmJiBlZGdlLnRvSWQgPT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgLy8gdGhlc2UgYXJlIGRvdWJsZSBlcXVhbHMgc2luY2UgaWRzIGNhbiBiZSBudW1lcmljIG9yIHN0cmluZ1xuICAgICAgICAgICAgaWYgKG5vZGVPYmpbZWRnZS5mcm9tSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbm9kZUxpc3QucHVzaChlZGdlLmZyb21JZCk7XG4gICAgICAgICAgICAgIG5vZGVPYmpbZWRnZS5mcm9tSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAhPT0gXCJmcm9tXCIgJiYgZWRnZS5mcm9tSWQgPT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgLy8gdGhlc2UgYXJlIGRvdWJsZSBlcXVhbHMgc2luY2UgaWRzIGNhbiBiZSBudW1lcmljIG9yIHN0cmluZ1xuICAgICAgICAgICAgaWYgKG5vZGVPYmpbZWRnZS50b0lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIG5vZGVMaXN0LnB1c2goZWRnZS50b0lkKTtcbiAgICAgICAgICAgICAgbm9kZU9ialtlZGdlLnRvSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlTGlzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlkcyBvZiB0aGUgZWRnZXMgY29ubmVjdGVkIHRvIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29ubmVjdGVkRWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29ubmVjdGVkRWRnZXMobm9kZUlkKSB7XG4gICAgICB2YXIgZWRnZUxpc3QgPSBbXTtcbiAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGVkZ2VMaXN0LnB1c2gobm9kZS5lZGdlc1tpXS5pZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJOb2RlSWQgcHJvdmlkZWQgZm9yIGdldENvbm5lY3RlZEVkZ2VzIGRvZXMgbm90IGV4aXN0LiBQcm92aWRlZDogXCIsIG5vZGVJZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWRnZUxpc3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZSBhIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJtb3ZlTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlTm9kZShub2RlSWQsIHgsIHkpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0ueCA9IE51bWJlcih4KTtcbiAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0ueSA9IE51bWJlcih5KTtcbiAgICAgICAgX3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNC5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTm9kZSBpZCBzdXBwbGllZCB0byBtb3ZlTm9kZSBkb2VzIG5vdCBleGlzdC4gUHJvdmlkZWQ6IFwiLCBub2RlSWQpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTm9kZXNIYW5kbGVyO1xufSgpO1xuXG52YXIgaGFzT3duJDEgPSBoYXNPd25Qcm9wZXJ0eV8xO1xuXG52YXIgaXNEYXRhRGVzY3JpcHRvciQxID0gZnVuY3Rpb24gKGRlc2NyaXB0b3IpIHtcbiAgcmV0dXJuIGRlc2NyaXB0b3IgIT09IHVuZGVmaW5lZCAmJiAoaGFzT3duJDEoZGVzY3JpcHRvciwgJ3ZhbHVlJykgfHwgaGFzT3duJDEoZGVzY3JpcHRvciwgJ3dyaXRhYmxlJykpO1xufTtcblxudmFyICQkNCA9IF9leHBvcnQ7XG52YXIgY2FsbCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBpc09iamVjdCQyID0gaXNPYmplY3QkajtcbnZhciBhbk9iamVjdCQxID0gYW5PYmplY3QkZDtcbnZhciBpc0RhdGFEZXNjcmlwdG9yID0gaXNEYXRhRGVzY3JpcHRvciQxO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IG9iamVjdEdldFByb3RvdHlwZU9mO1xuXG4vLyBgUmVmbGVjdC5nZXRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWZsZWN0LmdldFxuZnVuY3Rpb24gZ2V0JDUodGFyZ2V0LCBwcm9wZXJ0eUtleSAvKiAsIHJlY2VpdmVyICovKSB7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdO1xuICB2YXIgZGVzY3JpcHRvciwgcHJvdG90eXBlO1xuICBpZiAoYW5PYmplY3QkMSh0YXJnZXQpID09PSByZWNlaXZlcikgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZih0YXJnZXQsIHByb3BlcnR5S2V5KTtcbiAgaWYgKGRlc2NyaXB0b3IpIHJldHVybiBpc0RhdGFEZXNjcmlwdG9yKGRlc2NyaXB0b3IpXG4gICAgPyBkZXNjcmlwdG9yLnZhbHVlXG4gICAgOiBkZXNjcmlwdG9yLmdldCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY2FsbChkZXNjcmlwdG9yLmdldCwgcmVjZWl2ZXIpO1xuICBpZiAoaXNPYmplY3QkMihwcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSkgcmV0dXJuIGdldCQ1KHByb3RvdHlwZSwgcHJvcGVydHlLZXksIHJlY2VpdmVyKTtcbn1cblxuJCQ0KHsgdGFyZ2V0OiAnUmVmbGVjdCcsIHN0YXQ6IHRydWUgfSwge1xuICBnZXQ6IGdldCQ1XG59KTtcblxudmFyIHBhdGgkNCA9IHBhdGgkdztcblxudmFyIGdldCQ0ID0gcGF0aCQ0LlJlZmxlY3QuZ2V0O1xuXG52YXIgcGFyZW50JGEgPSBnZXQkNDtcblxudmFyIGdldCQzID0gcGFyZW50JGE7XG5cbnZhciBwYXJlbnQkOSA9IGdldCQzO1xuXG52YXIgZ2V0JDIgPSBwYXJlbnQkOTtcblxudmFyIHBhcmVudCQ4ID0gZ2V0JDI7XG5cbnZhciBnZXQkMSA9IHBhcmVudCQ4O1xuXG52YXIgZ2V0ID0gZ2V0JDE7XG5cbnZhciBfUmVmbGVjdCRnZXQgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZ2V0KTtcblxudmFyIHBhcmVudCQ3ID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDQ7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMiA9IHBhcmVudCQ3O1xuXG52YXIgcGFyZW50JDYgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMjtcblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gcGFyZW50JDY7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMTtcblxudmFyIF9PYmplY3QkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGdldE93blByb3BlcnR5RGVzY3JpcHRvcik7XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5mdW5jdGlvbiBfZ2V0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgX1JlZmxlY3QkZ2V0KSB7XG4gICAgdmFyIF9jb250ZXh0O1xuICAgIF9nZXQgPSBfYmluZEluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQgPSBfUmVmbGVjdCRnZXQpLmNhbGwoX2NvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICB2YXIgZGVzYyA9IF9PYmplY3QkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcbiAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IHJlY2VpdmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIF9nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxudmFyICQkMyA9IF9leHBvcnQ7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1tYXRoLWh5cG90IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG52YXIgJGh5cG90ID0gTWF0aC5oeXBvdDtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuXG4vLyBDaHJvbWUgNzcgYnVnXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05NTQ2XG52YXIgRk9SQ0VEJDIgPSAhISRoeXBvdCAmJiAkaHlwb3QoSW5maW5pdHksIE5hTikgIT09IEluZmluaXR5O1xuXG4vLyBgTWF0aC5oeXBvdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hdGguaHlwb3RcbiQkMyh7IHRhcmdldDogJ01hdGgnLCBzdGF0OiB0cnVlLCBhcml0eTogMiwgZm9yY2VkOiBGT1JDRUQkMiB9LCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIGh5cG90OiBmdW5jdGlvbiBoeXBvdCh2YWx1ZTEsIHZhbHVlMikge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGxhcmcgPSAwO1xuICAgIHZhciBhcmcsIGRpdjtcbiAgICB3aGlsZSAoaSA8IGFMZW4pIHtcbiAgICAgIGFyZyA9IGFicyhhcmd1bWVudHNbaSsrXSk7XG4gICAgICBpZiAobGFyZyA8IGFyZykge1xuICAgICAgICBkaXYgPSBsYXJnIC8gYXJnO1xuICAgICAgICBzdW0gPSBzdW0gKiBkaXYgKiBkaXYgKyAxO1xuICAgICAgICBsYXJnID0gYXJnO1xuICAgICAgfSBlbHNlIGlmIChhcmcgPiAwKSB7XG4gICAgICAgIGRpdiA9IGFyZyAvIGxhcmc7XG4gICAgICAgIHN1bSArPSBkaXYgKiBkaXY7XG4gICAgICB9IGVsc2Ugc3VtICs9IGFyZztcbiAgICB9XG4gICAgcmV0dXJuIGxhcmcgPT09IEluZmluaXR5ID8gSW5maW5pdHkgOiBsYXJnICogc3FydChzdW0pO1xuICB9XG59KTtcblxudmFyIHBhdGgkMyA9IHBhdGgkdztcblxudmFyIGh5cG90JDIgPSBwYXRoJDMuTWF0aC5oeXBvdDtcblxudmFyIHBhcmVudCQ1ID0gaHlwb3QkMjtcblxudmFyIGh5cG90JDEgPSBwYXJlbnQkNTtcblxudmFyIGh5cG90ID0gaHlwb3QkMTtcblxudmFyIF9NYXRoJGh5cG90ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGh5cG90KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGEoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkYSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBfUmVmbGVjdCRjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRhKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIV9SZWZsZWN0JGNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoX1JlZmxlY3QkY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKF9SZWZsZWN0JGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxyXG4gKiBDb21tb24gbWV0aG9kcyBmb3IgZW5kcG9pbnRzXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKi9cbnZhciBFbmRQb2ludCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVuZFBvaW50KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbmRQb2ludCk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKEVuZFBvaW50LCBudWxsLCBbe1xuICAgIGtleTogXCJ0cmFuc2Zvcm1cIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIEFwcGx5IHRyYW5zZm9ybWF0aW9uIG9uIHBvaW50cyBmb3IgZGlzcGxheS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZm9sbG93aW5nIGlzIGRvbmU6XHJcbiAgICAgKiAtIHJvdGF0ZSBieSB0aGUgc3BlY2lmaWVkIGFuZ2xlXHJcbiAgICAgKiAtIG11bHRpcGx5IHRoZSAobm9ybWFsaXplZCkgY29vcmRpbmF0ZXMgYnkgdGhlIHBhc3NlZCBsZW5ndGhcclxuICAgICAqIC0gb2Zmc2V0IGJ5IHRoZSB0YXJnZXQgY29vcmRpbmF0ZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcG9pbnRzIC0gVGhlIHBvaW50KHMpIHRvIGJlIHRyYW5zZm9ybWVkLlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSByZXN1bHQgb2YgdGhlIHRyYW5zZm9ybWF0aW9uLlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKSB7XG4gICAgICBpZiAoIV9BcnJheSRpc0FycmF5KHBvaW50cykpIHtcbiAgICAgICAgcG9pbnRzID0gW3BvaW50c107XG4gICAgICB9XG4gICAgICB2YXIgeCA9IGFycm93RGF0YS5wb2ludC54O1xuICAgICAgdmFyIHkgPSBhcnJvd0RhdGEucG9pbnQueTtcbiAgICAgIHZhciBhbmdsZSA9IGFycm93RGF0YS5hbmdsZTtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJvd0RhdGEubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHAgPSBwb2ludHNbaV07XG4gICAgICAgIHZhciB4dCA9IHAueCAqIE1hdGguY29zKGFuZ2xlKSAtIHAueSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgdmFyIHl0ID0gcC54ICogTWF0aC5zaW4oYW5nbGUpICsgcC55ICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBwLnggPSB4ICsgbGVuZ3RoICogeHQ7XG4gICAgICAgIHAueSA9IHkgKyBsZW5ndGggKiB5dDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGEgY2xvc2VkIHBhdGggdXNpbmcgdGhlIGdpdmVuIHJlYWwgY29vcmRpbmF0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBwYXRoIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gcG9pbnRzIC0gVGhlIHBvaW50cyBvZiB0aGUgcGF0aC5cclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRyYXdQYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdQYXRoKGN0eCwgcG9pbnRzKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHBvaW50c1swXS54LCBwb2ludHNbMF0ueSk7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjdHgubGluZVRvKHBvaW50c1tpXS54LCBwb2ludHNbaV0ueSk7XG4gICAgICB9XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBFbmRQb2ludDtcbn0oKTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBhcnJvdyBlbmRwb2ludC5cclxuICovXG52YXIgSW1hZ2UkMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VuZFBvaW50KSB7XG4gIF9pbmhlcml0cyhJbWFnZSwgX0VuZFBvaW50KTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRhKEltYWdlKTtcbiAgZnVuY3Rpb24gSW1hZ2UoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEltYWdlKTtcbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKEltYWdlLCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqIEByZXR1cm5zIEZhbHNlIGFzIHRoZXJlIGlzIG5vIHdheSB0byBmaWxsIGFuIGltYWdlLlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgaWYgKGFycm93RGF0YS5pbWFnZSkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKGFycm93RGF0YS5wb2ludC54LCBhcnJvd0RhdGEucG9pbnQueSk7XG4gICAgICAgIGN0eC5yb3RhdGUoTWF0aC5QSSAvIDIgKyBhcnJvd0RhdGEuYW5nbGUpO1xuICAgICAgICB2YXIgd2lkdGggPSBhcnJvd0RhdGEuaW1hZ2VXaWR0aCAhPSBudWxsID8gYXJyb3dEYXRhLmltYWdlV2lkdGggOiBhcnJvd0RhdGEuaW1hZ2Uud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSBhcnJvd0RhdGEuaW1hZ2VIZWlnaHQgIT0gbnVsbCA/IGFycm93RGF0YS5pbWFnZUhlaWdodCA6IGFycm93RGF0YS5pbWFnZS5oZWlnaHQ7XG4gICAgICAgIGFycm93RGF0YS5pbWFnZS5kcmF3SW1hZ2VBdFBvc2l0aW9uKGN0eCwgMSxcbiAgICAgICAgLy8gc2NhbGVcbiAgICAgICAgLXdpZHRoIC8gMixcbiAgICAgICAgLy8geFxuICAgICAgICAwLFxuICAgICAgICAvLyB5XG4gICAgICAgIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSW1hZ2U7XG59KEVuZFBvaW50KTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBhcnJvdyBlbmRwb2ludC5cclxuICovXG52YXIgQXJyb3cgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbmRQb2ludDIpIHtcbiAgX2luaGVyaXRzKEFycm93LCBfRW5kUG9pbnQyKTtcbiAgdmFyIF9zdXBlcjIgPSBfY3JlYXRlU3VwZXIkYShBcnJvdyk7XG4gIGZ1bmN0aW9uIEFycm93KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBcnJvdyk7XG4gICAgcmV0dXJuIF9zdXBlcjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoQXJyb3csIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBiZWNhdXNlIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3cuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvLyBOb3JtYWxpemVkIHBvaW50cyBvZiBjbG9zZWQgcGF0aCwgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBzaG91bGQgYmUgZHJhd24uXG4gICAgICAvLyAoMCwgMCkgaXMgdGhlIGF0dGFjaG1lbnQgcG9pbnQsIGFuZCB0aGUgcG9pbnQgYXJvdW5kIHdoaWNoIHNob3VsZCBiZSByb3RhdGVkXG4gICAgICB2YXIgcG9pbnRzID0gW3tcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSwge1xuICAgICAgICB4OiAtMSxcbiAgICAgICAgeTogMC4zXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0wLjksXG4gICAgICAgIHk6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTEsXG4gICAgICAgIHk6IC0wLjNcbiAgICAgIH1dO1xuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcbiAgICAgIEVuZFBvaW50LmRyYXdQYXRoKGN0eCwgcG9pbnRzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQXJyb3c7XG59KEVuZFBvaW50KTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBjcm93IGVuZHBvaW50LlxyXG4gKi9cbnZhciBDcm93ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ3JvdygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3Jvdyk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKENyb3csIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBiZWNhdXNlIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3cuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvLyBOb3JtYWxpemVkIHBvaW50cyBvZiBjbG9zZWQgcGF0aCwgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBzaG91bGQgYmUgZHJhd24uXG4gICAgICAvLyAoMCwgMCkgaXMgdGhlIGF0dGFjaG1lbnQgcG9pbnQsIGFuZCB0aGUgcG9pbnQgYXJvdW5kIHdoaWNoIHNob3VsZCBiZSByb3RhdGVkXG4gICAgICB2YXIgcG9pbnRzID0gW3tcbiAgICAgICAgeDogLTEsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMC4zXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0wLjQsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogLTAuM1xuICAgICAgfV07XG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpO1xuICAgICAgRW5kUG9pbnQuZHJhd1BhdGgoY3R4LCBwb2ludHMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDcm93O1xufSgpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGN1cnZlIGVuZHBvaW50LlxyXG4gKi9cbnZhciBDdXJ2ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEN1cnZlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDdXJ2ZSk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKEN1cnZlLCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqIEByZXR1cm5zIFRydWUgYmVjYXVzZSBjdHguZmlsbCgpIGNhbiBiZSB1c2VkIHRvIGZpbGwgdGhlIGFycm93LlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgLy8gTm9ybWFsaXplZCBwb2ludHMgb2YgY2xvc2VkIHBhdGgsIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgc2hvdWxkIGJlIGRyYXduLlxuICAgICAgLy8gKDAsIDApIGlzIHRoZSBhdHRhY2htZW50IHBvaW50LCBhbmQgdGhlIHBvaW50IGFyb3VuZCB3aGljaCBzaG91bGQgYmUgcm90YXRlZFxuICAgICAgdmFyIHBvaW50ID0ge1xuICAgICAgICB4OiAtMC40LFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50LCBhcnJvd0RhdGEpO1xuICAgICAgLy8gVXBkYXRlIGVuZHBvaW50IHN0eWxlIGZvciBkcmF3aW5nIHRyYW5zcGFyZW50IGFyYy5cbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGU7XG4gICAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2JhKDAsIDAsIDAsIDApXCI7XG4gICAgICAvLyBEZWZpbmUgY3VydmUgZW5kcG9pbnQgYXMgc2VtaWNpcmNsZS5cbiAgICAgIHZhciBwaSA9IE1hdGguUEk7XG4gICAgICB2YXIgc3RhcnRBbmdsZSA9IGFycm93RGF0YS5hbmdsZSAtIHBpIC8gMjtcbiAgICAgIHZhciBlbmRBbmdsZSA9IGFycm93RGF0YS5hbmdsZSArIHBpIC8gMjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5hcmMocG9pbnQueCwgcG9pbnQueSwgYXJyb3dEYXRhLmxlbmd0aCAqIDAuNCwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGZhbHNlKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ3VydmU7XG59KCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgaW52ZXJ0ZWQgY3VydmUgZW5kcG9pbnQuXHJcbiAqL1xudmFyIEludmVydGVkQ3VydmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbnZlcnRlZEN1cnZlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnZlcnRlZEN1cnZlKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoSW52ZXJ0ZWRDdXJ2ZSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGJlY2F1c2UgY3R4LmZpbGwoKSBjYW4gYmUgdXNlZCB0byBmaWxsIHRoZSBhcnJvdy5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZWQgcG9pbnRzIG9mIGNsb3NlZCBwYXRoLCBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgIC8vICgwLCAwKSBpcyB0aGUgYXR0YWNobWVudCBwb2ludCwgYW5kIHRoZSBwb2ludCBhcm91bmQgd2hpY2ggc2hvdWxkIGJlIHJvdGF0ZWRcbiAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgeDogLTAuMyxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludCwgYXJyb3dEYXRhKTtcbiAgICAgIC8vIFVwZGF0ZSBlbmRwb2ludCBzdHlsZSBmb3IgZHJhd2luZyB0cmFuc3BhcmVudCBhcmMuXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwicmdiYSgwLCAwLCAwLCAwKVwiO1xuICAgICAgLy8gRGVmaW5lIGludmVydGVkIGN1cnZlIGVuZHBvaW50IGFzIHNlbWljaXJjbGUuXG4gICAgICB2YXIgcGkgPSBNYXRoLlBJO1xuICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBhcnJvd0RhdGEuYW5nbGUgKyBwaSAvIDI7XG4gICAgICB2YXIgZW5kQW5nbGUgPSBhcnJvd0RhdGEuYW5nbGUgKyAzICogcGkgLyAyO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmFyYyhwb2ludC54LCBwb2ludC55LCBhcnJvd0RhdGEubGVuZ3RoICogMC40LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZmFsc2UpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBJbnZlcnRlZEN1cnZlO1xufSgpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIHRyaW5hZ2xlIGVuZHBvaW50LlxyXG4gKi9cbnZhciBUcmlhbmdsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRyaWFuZ2xlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmlhbmdsZSk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFRyaWFuZ2xlLCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqIEByZXR1cm5zIFRydWUgYmVjYXVzZSBjdHguZmlsbCgpIGNhbiBiZSB1c2VkIHRvIGZpbGwgdGhlIGFycm93LlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgLy8gTm9ybWFsaXplZCBwb2ludHMgb2YgY2xvc2VkIHBhdGgsIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgc2hvdWxkIGJlIGRyYXduLlxuICAgICAgLy8gKDAsIDApIGlzIHRoZSBhdHRhY2htZW50IHBvaW50LCBhbmQgdGhlIHBvaW50IGFyb3VuZCB3aGljaCBzaG91bGQgYmUgcm90YXRlZFxuICAgICAgdmFyIHBvaW50cyA9IFt7XG4gICAgICAgIHg6IDAuMDIsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTEsXG4gICAgICAgIHk6IDAuM1xuICAgICAgfSwge1xuICAgICAgICB4OiAtMSxcbiAgICAgICAgeTogLTAuM1xuICAgICAgfV07XG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpO1xuICAgICAgRW5kUG9pbnQuZHJhd1BhdGgoY3R4LCBwb2ludHMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUcmlhbmdsZTtcbn0oKTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBpbnZlcnRlZCB0cmluYWdsZSBlbmRwb2ludC5cclxuICovXG52YXIgSW52ZXJ0ZWRUcmlhbmdsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEludmVydGVkVHJpYW5nbGUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEludmVydGVkVHJpYW5nbGUpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhJbnZlcnRlZFRyaWFuZ2xlLCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqIEByZXR1cm5zIFRydWUgYmVjYXVzZSBjdHguZmlsbCgpIGNhbiBiZSB1c2VkIHRvIGZpbGwgdGhlIGFycm93LlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgLy8gTm9ybWFsaXplZCBwb2ludHMgb2YgY2xvc2VkIHBhdGgsIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgc2hvdWxkIGJlIGRyYXduLlxuICAgICAgLy8gKDAsIDApIGlzIHRoZSBhdHRhY2htZW50IHBvaW50LCBhbmQgdGhlIHBvaW50IGFyb3VuZCB3aGljaCBzaG91bGQgYmUgcm90YXRlZFxuICAgICAgdmFyIHBvaW50cyA9IFt7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAuM1xuICAgICAgfSwge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAtMC4zXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB5OiAwXG4gICAgICB9XTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XG4gICAgICBFbmRQb2ludC5kcmF3UGF0aChjdHgsIHBvaW50cyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEludmVydGVkVHJpYW5nbGU7XG59KCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgY2lyY2xlIGVuZHBvaW50LlxyXG4gKi9cbnZhciBDaXJjbGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDaXJjbGUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENpcmNsZSk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKENpcmNsZSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGJlY2F1c2UgY3R4LmZpbGwoKSBjYW4gYmUgdXNlZCB0byBmaWxsIHRoZSBhcnJvdy5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgeDogLTAuNCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludCwgYXJyb3dEYXRhKTtcbiAgICAgIGRyYXdDaXJjbGUoY3R4LCBwb2ludC54LCBwb2ludC55LCBhcnJvd0RhdGEubGVuZ3RoICogMC40KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ2lyY2xlO1xufSgpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGJhciBlbmRwb2ludC5cclxuICovXG52YXIgQmFyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXIpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhCYXIsIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBiZWNhdXNlIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3cuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvKlxyXG4gICAgICB2YXIgcG9pbnRzID0gW1xyXG4gICAgICAgIHt4OjAsIHk6MC41fSxcclxuICAgICAgICB7eDowLCB5Oi0wLjV9XHJcbiAgICAgIF07XHJcbiAgICAgICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcclxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICBjdHgubW92ZVRvKHBvaW50c1swXS54LCBwb2ludHNbMF0ueSk7XHJcbiAgICAgIGN0eC5saW5lVG8ocG9pbnRzWzFdLngsIHBvaW50c1sxXS55KTtcclxuICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAqL1xuICAgICAgdmFyIHBvaW50cyA9IFt7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAuNVxuICAgICAgfSwge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAtMC41XG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0wLjE1LFxuICAgICAgICB5OiAtMC41XG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0wLjE1LFxuICAgICAgICB5OiAwLjVcbiAgICAgIH1dO1xuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcbiAgICAgIEVuZFBvaW50LmRyYXdQYXRoKGN0eCwgcG9pbnRzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQmFyO1xufSgpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGJveCBlbmRwb2ludC5cclxuICovXG52YXIgQm94ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQm94KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCb3gpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhCb3gsIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBiZWNhdXNlIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3cuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICB2YXIgcG9pbnRzID0gW3tcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMC4zXG4gICAgICB9LCB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IC0wLjNcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTAuNixcbiAgICAgICAgeTogLTAuM1xuICAgICAgfSwge1xuICAgICAgICB4OiAtMC42LFxuICAgICAgICB5OiAwLjNcbiAgICAgIH1dO1xuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcbiAgICAgIEVuZFBvaW50LmRyYXdQYXRoKGN0eCwgcG9pbnRzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQm94O1xufSgpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGRpYW1vbmQgZW5kcG9pbnQuXHJcbiAqL1xudmFyIERpYW1vbmQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEaWFtb25kKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaWFtb25kKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoRGlhbW9uZCwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGJlY2F1c2UgY3R4LmZpbGwoKSBjYW4gYmUgdXNlZCB0byBmaWxsIHRoZSBhcnJvdy5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIHZhciBwb2ludHMgPSBbe1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0wLjUsXG4gICAgICAgIHk6IC0wLjNcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTEsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTAuNSxcbiAgICAgICAgeTogMC4zXG4gICAgICB9XTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XG4gICAgICBFbmRQb2ludC5kcmF3UGF0aChjdHgsIHBvaW50cyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIERpYW1vbmQ7XG59KCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgdmVlIGVuZHBvaW50LlxyXG4gKi9cbnZhciBWZWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWZWUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZlZSk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFZlZSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGJlY2F1c2UgY3R4LmZpbGwoKSBjYW4gYmUgdXNlZCB0byBmaWxsIHRoZSBhcnJvdy5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZWQgcG9pbnRzIG9mIGNsb3NlZCBwYXRoLCBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgIC8vICgwLCAwKSBpcyB0aGUgYXR0YWNobWVudCBwb2ludCwgYW5kIHRoZSBwb2ludCBhcm91bmQgd2hpY2ggc2hvdWxkIGJlIHJvdGF0ZWRcbiAgICAgIHZhciBwb2ludHMgPSBbe1xuICAgICAgICB4OiAtMSxcbiAgICAgICAgeTogMC4zXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0wLjUsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTEsXG4gICAgICAgIHk6IC0wLjNcbiAgICAgIH0sIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfV07XG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpO1xuICAgICAgRW5kUG9pbnQuZHJhd1BhdGgoY3R4LCBwb2ludHMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBWZWU7XG59KCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgZW5kcG9pbnRzLlxyXG4gKi9cbnZhciBFbmRQb2ludHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFbmRQb2ludHMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVuZFBvaW50cyk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKEVuZFBvaW50cywgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhbiBlbmRwb2ludC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBjdHguZmlsbCgpIGNhbiBiZSB1c2VkIHRvIGZpbGwgdGhlIGFycm93LCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICB2YXIgdHlwZTtcbiAgICAgIGlmIChhcnJvd0RhdGEudHlwZSkge1xuICAgICAgICB0eXBlID0gYXJyb3dEYXRhLnR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgICAgICByZXR1cm4gSW1hZ2UkMS5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcbiAgICAgICAgY2FzZSBcImNpcmNsZVwiOlxuICAgICAgICAgIHJldHVybiBDaXJjbGUuZHJhdyhjdHgsIGFycm93RGF0YSk7XG4gICAgICAgIGNhc2UgXCJib3hcIjpcbiAgICAgICAgICByZXR1cm4gQm94LmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuICAgICAgICBjYXNlIFwiY3Jvd1wiOlxuICAgICAgICAgIHJldHVybiBDcm93LmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuICAgICAgICBjYXNlIFwiY3VydmVcIjpcbiAgICAgICAgICByZXR1cm4gQ3VydmUuZHJhdyhjdHgsIGFycm93RGF0YSk7XG4gICAgICAgIGNhc2UgXCJkaWFtb25kXCI6XG4gICAgICAgICAgcmV0dXJuIERpYW1vbmQuZHJhdyhjdHgsIGFycm93RGF0YSk7XG4gICAgICAgIGNhc2UgXCJpbnZfY3VydmVcIjpcbiAgICAgICAgICByZXR1cm4gSW52ZXJ0ZWRDdXJ2ZS5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcbiAgICAgICAgY2FzZSBcInRyaWFuZ2xlXCI6XG4gICAgICAgICAgcmV0dXJuIFRyaWFuZ2xlLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuICAgICAgICBjYXNlIFwiaW52X3RyaWFuZ2xlXCI6XG4gICAgICAgICAgcmV0dXJuIEludmVydGVkVHJpYW5nbGUuZHJhdyhjdHgsIGFycm93RGF0YSk7XG4gICAgICAgIGNhc2UgXCJiYXJcIjpcbiAgICAgICAgICByZXR1cm4gQmFyLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuICAgICAgICBjYXNlIFwidmVlXCI6XG4gICAgICAgICAgcmV0dXJuIFZlZS5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcbiAgICAgICAgY2FzZSBcImFycm93XCI6IC8vIGZhbGwtdGhyb3VnaFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBBcnJvdy5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEVuZFBvaW50cztcbn0oKTtcblxuZnVuY3Rpb24gb3duS2V5cyQxKGUsIHIpIHsgdmFyIHQgPSBfT2JqZWN0JGtleXMoZSk7IGlmIChfT2JqZWN0JGdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IF9PYmplY3QkZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gX2ZpbHRlckluc3RhbmNlUHJvcGVydHkobykuY2FsbChvLCBmdW5jdGlvbiAocikgeyByZXR1cm4gX09iamVjdCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMShlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQxKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIF9jb250ZXh0MiwgX2NvbnRleHQzOyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gX2ZvckVhY2hJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0MiA9IG93bktleXMkMShPYmplY3QodCksICEwKSkuY2FsbChfY29udGV4dDIsIGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBfT2JqZWN0JGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBfT2JqZWN0JGRlZmluZVByb3BlcnRpZXMoZSwgX09iamVjdCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IF9mb3JFYWNoSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDMgPSBvd25LZXlzJDEoT2JqZWN0KHQpKSkuY2FsbChfY29udGV4dDMsIGZ1bmN0aW9uIChyKSB7IF9PYmplY3QkZGVmaW5lUHJvcGVydHkoZSwgciwgX09iamVjdCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSh0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4vKipcclxuICogVGhlIEJhc2UgQ2xhc3MgZm9yIGFsbCBlZGdlcy5cclxuICovXG52YXIgRWRnZUJhc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdCBvZiBnaXZlbiBlZGdlLlxyXG4gICAqIEBwYXJhbSBfYm9keSAtIFRoZSBib2R5IG9mIHRoZSBuZXR3b3JrLlxyXG4gICAqIEBwYXJhbSBfbGFiZWxNb2R1bGUgLSBMYWJlbCBtb2R1bGUuXHJcbiAgICovXG4gIGZ1bmN0aW9uIEVkZ2VCYXNlKG9wdGlvbnMsIF9ib2R5LCBfbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWRnZUJhc2UpO1xuICAgIHRoaXMuX2JvZHkgPSBfYm9keTtcbiAgICB0aGlzLl9sYWJlbE1vZHVsZSA9IF9sYWJlbE1vZHVsZTtcbiAgICB0aGlzLmNvbG9yID0ge307XG4gICAgdGhpcy5jb2xvckRpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLmhvdmVyV2lkdGggPSAxLjU7XG4gICAgdGhpcy5zZWxlY3Rpb25XaWR0aCA9IDI7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuZnJvbVBvaW50ID0gdGhpcy5mcm9tO1xuICAgIHRoaXMudG9Qb2ludCA9IHRoaXMudG87XG4gIH1cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIF9jcmVhdGVDbGFzcyhFZGdlQmFzZSwgW3tcbiAgICBrZXk6IFwiY29ubmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25uZWN0KCkge1xuICAgICAgdGhpcy5mcm9tID0gdGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMuZnJvbV07XG4gICAgICB0aGlzLnRvID0gdGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMudG9dO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJjbGVhbnVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogU2V0IG5ldyBlZGdlIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgbmV3IGVkZ2Ugb3B0aW9ucyBvYmplY3QuXHJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMuZnJvbSA9IHRoaXMuX2JvZHkubm9kZXNbdGhpcy5vcHRpb25zLmZyb21dO1xuICAgICAgdGhpcy50byA9IHRoaXMuX2JvZHkubm9kZXNbdGhpcy5vcHRpb25zLnRvXTtcbiAgICAgIHRoaXMuaWQgPSB0aGlzLm9wdGlvbnMuaWQ7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcImRyYXdMaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdMaW5lKGN0eCwgdmFsdWVzLCBfc2VsZWN0ZWQsIF9ob3Zlcikge1xuICAgICAgdmFyIHZpYU5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRoaXMuZ2V0VmlhTm9kZSgpO1xuICAgICAgLy8gc2V0IHN0eWxlXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmdldENvbG9yKGN0eCwgdmFsdWVzKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSB2YWx1ZXMud2lkdGg7XG4gICAgICBpZiAodmFsdWVzLmRhc2hlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fZHJhd0Rhc2hlZExpbmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZHJhd0xpbmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIERyYXcgYSBsaW5lIHdpdGggZ2l2ZW4gc3R5bGUgYmV0d2VlbiB0d28gbm9kZXMgdGhyb3VnaCBzdXBwbGllZCBub2RlKHMpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIEZvcm1hdHRpbmcgdmFsdWVzIGxpa2UgY29sb3IsIG9wYWNpdHkgb3Igc2hhZG93LlxyXG4gICAgICogQHBhcmFtIHZpYU5vZGUgLSBBZGRpdGlvbmFsIGNvbnRyb2wgcG9pbnQocykgZm9yIHRoZSBlZGdlLlxyXG4gICAgICogQHBhcmFtIGZyb21Qb2ludCAtIFRPRE86IFNlZW1zIGlnbm9yZWQsIHJlbW92ZT9cclxuICAgICAqIEBwYXJhbSB0b1BvaW50IC0gVE9ETzogU2VlbXMgaWdub3JlZCwgcmVtb3ZlP1xyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdMaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3TGluZShjdHgsIHZhbHVlcywgdmlhTm9kZSwgZnJvbVBvaW50LCB0b1BvaW50KSB7XG4gICAgICBpZiAodGhpcy5mcm9tICE9IHRoaXMudG8pIHtcbiAgICAgICAgLy8gZHJhdyBsaW5lXG4gICAgICAgIHRoaXMuX2xpbmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUsIGZyb21Qb2ludCwgdG9Qb2ludCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3RoaXMkX2dldENpcmNsZURhdGEgPSB0aGlzLl9nZXRDaXJjbGVEYXRhKGN0eCksXG4gICAgICAgICAgX3RoaXMkX2dldENpcmNsZURhdGEyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX2dldENpcmNsZURhdGEsIDMpLFxuICAgICAgICAgIHggPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTJbMF0sXG4gICAgICAgICAgeSA9IF90aGlzJF9nZXRDaXJjbGVEYXRhMlsxXSxcbiAgICAgICAgICByYWRpdXMgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTJbMl07XG4gICAgICAgIHRoaXMuX2NpcmNsZShjdHgsIHZhbHVlcywgeCwgeSwgcmFkaXVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGEgZGFzaGVkIGxpbmUgd2l0aCBnaXZlbiBzdHlsZSBiZXR3ZWVuIHR3byBub2RlcyB0aHJvdWdoIHN1cHBsaWVkIG5vZGUocykuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gRm9ybWF0dGluZyB2YWx1ZXMgbGlrZSBjb2xvciwgb3BhY2l0eSBvciBzaGFkb3cuXHJcbiAgICAgKiBAcGFyYW0gdmlhTm9kZSAtIEFkZGl0aW9uYWwgY29udHJvbCBwb2ludChzKSBmb3IgdGhlIGVkZ2UuXHJcbiAgICAgKiBAcGFyYW0gX2Zyb21Qb2ludCAtIElnbm9yZWQgKFRPRE86IHJlbW92ZSBpbiB0aGUgZnV0dXJlKS5cclxuICAgICAqIEBwYXJhbSBfdG9Qb2ludCAtIElnbm9yZWQgKFRPRE86IHJlbW92ZSBpbiB0aGUgZnV0dXJlKS5cclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3RGFzaGVkTGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0Rhc2hlZExpbmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUsIF9mcm9tUG9pbnQsIF90b1BvaW50KSB7XG4gICAgICBjdHgubGluZUNhcCA9IFwicm91bmRcIjtcbiAgICAgIHZhciBwYXR0ZXJuID0gX0FycmF5JGlzQXJyYXkodmFsdWVzLmRhc2hlcykgPyB2YWx1ZXMuZGFzaGVzIDogWzUsIDVdO1xuICAgICAgLy8gb25seSBmaXJlZm94IGFuZCBjaHJvbWUgc3VwcG9ydCB0aGlzIG1ldGhvZCwgZWxzZSB3ZSB1c2UgdGhlIGxlZ2FjeSBvbmUuXG4gICAgICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgLy8gc2V0IGRhc2ggc2V0dGluZ3MgZm9yIGNocm9tZSBvciBmaXJlZm94XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChwYXR0ZXJuKTtcbiAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgICAgICAgLy8gZHJhdyB0aGUgbGluZVxuICAgICAgICBpZiAodGhpcy5mcm9tICE9IHRoaXMudG8pIHtcbiAgICAgICAgICAvLyBkcmF3IGxpbmVcbiAgICAgICAgICB0aGlzLl9saW5lKGN0eCwgdmFsdWVzLCB2aWFOb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX3RoaXMkX2dldENpcmNsZURhdGEzID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YShjdHgpLFxuICAgICAgICAgICAgX3RoaXMkX2dldENpcmNsZURhdGE0ID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX2dldENpcmNsZURhdGEzLCAzKSxcbiAgICAgICAgICAgIHggPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTRbMF0sXG4gICAgICAgICAgICB5ID0gX3RoaXMkX2dldENpcmNsZURhdGE0WzFdLFxuICAgICAgICAgICAgcmFkaXVzID0gX3RoaXMkX2dldENpcmNsZURhdGE0WzJdO1xuICAgICAgICAgIHRoaXMuX2NpcmNsZShjdHgsIHZhbHVlcywgeCwgeSwgcmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXN0b3JlIHRoZSBkYXNoIHNldHRpbmdzLlxuICAgICAgICBjdHguc2V0TGluZURhc2goWzBdKTtcbiAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVuc3VwcG9ydGluZyBzbW9vdGggbGluZXNcbiAgICAgICAgaWYgKHRoaXMuZnJvbSAhPSB0aGlzLnRvKSB7XG4gICAgICAgICAgLy8gZHJhdyBsaW5lXG4gICAgICAgICAgZHJhd0Rhc2hlZExpbmUoY3R4LCB0aGlzLmZyb20ueCwgdGhpcy5mcm9tLnksIHRoaXMudG8ueCwgdGhpcy50by55LCBwYXR0ZXJuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX3RoaXMkX2dldENpcmNsZURhdGE1ID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YShjdHgpLFxuICAgICAgICAgICAgX3RoaXMkX2dldENpcmNsZURhdGE2ID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX2dldENpcmNsZURhdGE1LCAzKSxcbiAgICAgICAgICAgIF94ID0gX3RoaXMkX2dldENpcmNsZURhdGE2WzBdLFxuICAgICAgICAgICAgX3kgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTZbMV0sXG4gICAgICAgICAgICBfcmFkaXVzID0gX3RoaXMkX2dldENpcmNsZURhdGE2WzJdO1xuICAgICAgICAgIHRoaXMuX2NpcmNsZShjdHgsIHZhbHVlcywgX3gsIF95LCBfcmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuICAgICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIEZpbmQgdGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIHRoZSBib3JkZXIgb2YgdGhlIG5vZGUgYW5kIHRoZSBlZGdlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgKGVpdGhlciBmcm9tIG9yIHRvIG5vZGUgb2YgdGhlIGVkZ2UpLlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucy5cclxuICAgICAqIEByZXR1cm5zIENhcnRlc2lhbiBjb29yZGluYXRlcyBvZiB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhlIGJvcmRlciBvZiB0aGUgbm9kZSBhbmQgdGhlIGVkZ2UuXHJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJmaW5kQm9yZGVyUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEJvcmRlclBvc2l0aW9uKG5vZGUsIGN0eCwgb3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuZnJvbSAhPSB0aGlzLnRvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb24obm9kZSwgY3R4LCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUobm9kZSwgY3R4LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZEJvcmRlclBvc2l0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQm9yZGVyUG9zaXRpb25zKGN0eCkge1xuICAgICAgaWYgKHRoaXMuZnJvbSAhPSB0aGlzLnRvKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZnJvbTogdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uKHRoaXMuZnJvbSwgY3R4KSxcbiAgICAgICAgICB0bzogdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uKHRoaXMudG8sIGN0eClcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfY29udGV4dDtcbiAgICAgICAgdmFyIF90aGlzJF9nZXRDaXJjbGVEYXRhJCA9IF9zbGljZUluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQgPSB0aGlzLl9nZXRDaXJjbGVEYXRhKGN0eCkpLmNhbGwoX2NvbnRleHQsIDAsIDIpLFxuICAgICAgICAgIF90aGlzJF9nZXRDaXJjbGVEYXRhJDIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0Q2lyY2xlRGF0YSQsIDIpLFxuICAgICAgICAgIHggPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YSQyWzBdLFxuICAgICAgICAgIHkgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YSQyWzFdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZyb206IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZSh0aGlzLmZyb20sIGN0eCwge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBsb3c6IDAuMjUsXG4gICAgICAgICAgICBoaWdoOiAwLjYsXG4gICAgICAgICAgICBkaXJlY3Rpb246IC0xXG4gICAgICAgICAgfSksXG4gICAgICAgICAgdG86IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZSh0aGlzLmZyb20sIGN0eCwge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBsb3c6IDAuNixcbiAgICAgICAgICAgIGhpZ2g6IDAuOCxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogMVxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZSB0aGUgY2VudGVyIHBvaW50IGFuZCByYWRpdXMgb2YgYW4gZWRnZSBjb25uZWN0ZWQgdG8gdGhlIHNhbWUgbm9kZSBhdCBib3RoIGVuZHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKiBAcmV0dXJucyBgW3gsIHksIHJhZGl1c11gXHJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q2lyY2xlRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q2lyY2xlRGF0YShjdHgpIHtcbiAgICAgIHZhciByYWRpdXMgPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5zaXplO1xuICAgICAgaWYgKGN0eCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0aGlzLmZyb20uc2hhcGUud2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuZnJvbS5zaGFwZS5yZXNpemUoY3R4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZ2V0IGNpcmNsZSBjb29yZGluYXRlc1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gZ2V0U2VsZlJlZkNvb3JkaW5hdGVzKGN0eCwgdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGUsIHJhZGl1cywgdGhpcy5mcm9tKTtcbiAgICAgIHJldHVybiBbY29vcmRpbmF0ZXMueCwgY29vcmRpbmF0ZXMueSwgcmFkaXVzXTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYSBwb2ludCBvbiBhIGNpcmNsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geCAtIENlbnRlciBvZiB0aGUgY2lyY2xlIG9uIHRoZSB4IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0geSAtIENlbnRlciBvZiB0aGUgY2lyY2xlIG9uIHRoZSB5IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0gcmFkaXVzIC0gUmFkaXVzIG9mIHRoZSBjaXJjbGUuXHJcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gLSBWYWx1ZSBiZXR3ZWVuIDAgKGxpbmUgc3RhcnQpIGFuZCAxIChsaW5lIGVuZCkuXHJcbiAgICAgKiBAcmV0dXJucyBDYXJ0ZXNpYW4gY29vcmRpbmF0ZXMgb2YgcmVxdWVzdGVkIHBvaW50IG9uIHRoZSBjaXJjbGUuXHJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfcG9pbnRPbkNpcmNsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcG9pbnRPbkNpcmNsZSh4LCB5LCByYWRpdXMsIHBvc2l0aW9uKSB7XG4gICAgICB2YXIgYW5nbGUgPSBwb3NpdGlvbiAqIDIgKiBNYXRoLlBJO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCArIHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgeTogeSAtIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0aGUgYm9yZGVyIG9mIHRoZSBub2RlIGFuZCB0aGUgZWRnZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICogVGhpcyBmdW5jdGlvbiB1c2VzIGJpbmFyeSBzZWFyY2ggdG8gbG9vayBmb3IgdGhlIHBvaW50IHdoZXJlIHRoZSBjaXJjbGUgY3Jvc3NlcyB0aGUgYm9yZGVyIG9mIHRoZSBub2RlLlxyXG4gICAgICogQHBhcmFtIG5lYXJOb2RlIC0gVGhlIG5vZGUgKGVpdGhlciBmcm9tIG9yIHRvIG5vZGUgb2YgdGhlIGVkZ2UpLlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucy5cclxuICAgICAqIEByZXR1cm5zIENhcnRlc2lhbiBjb29yZGluYXRlcyBvZiB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhlIGJvcmRlciBvZiB0aGUgbm9kZSBhbmQgdGhlIGVkZ2UuXHJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUobmVhck5vZGUsIGN0eCwgb3B0aW9ucykge1xuICAgICAgdmFyIHggPSBvcHRpb25zLng7XG4gICAgICB2YXIgeSA9IG9wdGlvbnMueTtcbiAgICAgIHZhciBsb3cgPSBvcHRpb25zLmxvdztcbiAgICAgIHZhciBoaWdoID0gb3B0aW9ucy5oaWdoO1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IG9wdGlvbnMuZGlyZWN0aW9uO1xuICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSAxMDtcbiAgICAgIHZhciByYWRpdXMgPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5zaXplO1xuICAgICAgdmFyIHRocmVzaG9sZCA9IDAuMDU7XG4gICAgICB2YXIgcG9zO1xuICAgICAgdmFyIG1pZGRsZSA9IChsb3cgKyBoaWdoKSAqIDAuNTtcbiAgICAgIHZhciBlbmRQb2ludE9mZnNldCA9IDA7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFycm93U3RyaWtldGhyb3VnaCA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAtMSkge1xuICAgICAgICAgIGVuZFBvaW50T2Zmc2V0ID0gdGhpcy5vcHRpb25zLmVuZFBvaW50T2Zmc2V0LmZyb207XG4gICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAxKSB7XG4gICAgICAgICAgZW5kUG9pbnRPZmZzZXQgPSB0aGlzLm9wdGlvbnMuZW5kUG9pbnRPZmZzZXQudG87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRpb24gPSAwO1xuICAgICAgZG8ge1xuICAgICAgICBtaWRkbGUgPSAobG93ICsgaGlnaCkgKiAwLjU7XG4gICAgICAgIHBvcyA9IHRoaXMuX3BvaW50T25DaXJjbGUoeCwgeSwgcmFkaXVzLCBtaWRkbGUpO1xuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKG5lYXJOb2RlLnkgLSBwb3MueSwgbmVhck5vZGUueCAtIHBvcy54KTtcbiAgICAgICAgdmFyIGRpc3RhbmNlVG9Cb3JkZXIgPSBuZWFyTm9kZS5kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpICsgZW5kUG9pbnRPZmZzZXQ7XG4gICAgICAgIHZhciBkaXN0YW5jZVRvUG9pbnQgPSBNYXRoLnNxcnQoTWF0aC5wb3cocG9zLnggLSBuZWFyTm9kZS54LCAyKSArIE1hdGgucG93KHBvcy55IC0gbmVhck5vZGUueSwgMikpO1xuICAgICAgICB2YXIgZGlmZmVyZW5jZSA9IGRpc3RhbmNlVG9Cb3JkZXIgLSBkaXN0YW5jZVRvUG9pbnQ7XG4gICAgICAgIGlmIChNYXRoLmFicyhkaWZmZXJlbmNlKSA8IHRocmVzaG9sZCkge1xuICAgICAgICAgIGJyZWFrOyAvLyBmb3VuZFxuICAgICAgICB9IGVsc2UgaWYgKGRpZmZlcmVuY2UgPiAwKSB7XG4gICAgICAgICAgLy8gZGlzdGFuY2UgdG8gbm9kZXMgaXMgbGFyZ2VyIHRoYW4gZGlzdGFuY2UgdG8gYm9yZGVyIC0tPiB0IG5lZWRzIHRvIGJlIGJpZ2dlciBpZiB3ZSdyZSBsb29raW5nIGF0IHRoZSB0byBub2RlLlxuICAgICAgICAgIGlmIChkaXJlY3Rpb24gPiAwKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWRkbGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWRkbGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChkaXJlY3Rpb24gPiAwKSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkZGxlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb3cgPSBtaWRkbGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICsraXRlcmF0aW9uO1xuICAgICAgfSB3aGlsZSAobG93IDw9IGhpZ2ggJiYgaXRlcmF0aW9uIDwgbWF4SXRlcmF0aW9ucyk7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMSh7fSwgcG9zKSwge30sIHtcbiAgICAgICAgdDogbWlkZGxlXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGxpbmUgd2lkdGggb2YgdGhlIGVkZ2UuIERlcGVuZHMgb24gd2lkdGggYW5kIHdoZXRoZXIgb25lIG9mIHRoZSBjb25uZWN0ZWQgbm9kZXMgaXMgc2VsZWN0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNlbGVjdGVkIC0gRGV0ZXJtaW5lcyB3aGV0ZXIgdGhlIGxpbmUgaXMgc2VsZWN0ZWQuXHJcbiAgICAgKiBAcGFyYW0gaG92ZXIgLSBEZXRlcm1pbmVzIHdoZXRlciB0aGUgbGluZSBpcyBiZWluZyBob3ZlcmVkLCBvbmx5IGFwcGxpZXMgaWYgc2VsZWN0ZWQgaXMgZmFsc2UuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgd2lkdGggb2YgdGhlIGxpbmUuXHJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRMaW5lV2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGluZVdpZHRoKHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgaWYgKHNlbGVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnNlbGVjdGlvbldpZHRoLCAwLjMgLyB0aGlzLl9ib2R5LnZpZXcuc2NhbGUpO1xuICAgICAgfSBlbHNlIGlmIChob3ZlciA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5ob3ZlcldpZHRoLCAwLjMgLyB0aGlzLl9ib2R5LnZpZXcuc2NhbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMub3B0aW9ucy53aWR0aCwgMC4zIC8gdGhpcy5fYm9keS52aWV3LnNjYWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlIHRoZSBjb2xvciBvciBncmFkaWVudCBmb3IgZ2l2ZW4gZWRnZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBGb3JtYXR0aW5nIHZhbHVlcyBsaWtlIGNvbG9yLCBvcGFjaXR5IG9yIHNoYWRvdy5cclxuICAgICAqIEBwYXJhbSBfc2VsZWN0ZWQgLSBJZ25vcmVkIChUT0RPOiByZW1vdmUgaW4gdGhlIGZ1dHVyZSkuXHJcbiAgICAgKiBAcGFyYW0gX2hvdmVyIC0gSWdub3JlZCAoVE9ETzogcmVtb3ZlIGluIHRoZSBmdXR1cmUpLlxyXG4gICAgICogQHJldHVybnMgQ29sb3Igc3RyaW5nIGlmIHNpbmdsZSBjb2xvciBpcyBpbmhlcml0ZWQgb3IgZ3JhZGllbnQgaWYgdHdvLlxyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29sb3IoY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuaW5oZXJpdHNDb2xvciAhPT0gZmFsc2UpIHtcbiAgICAgICAgLy8gd2hlbiB0aGlzIGlzIGEgbG9vcCBlZGdlLCBqdXN0IHVzZSB0aGUgJ2Zyb20nIG1ldGhvZFxuICAgICAgICBpZiAodmFsdWVzLmluaGVyaXRzQ29sb3IgPT09IFwiYm90aFwiICYmIHRoaXMuZnJvbS5pZCAhPT0gdGhpcy50by5pZCkge1xuICAgICAgICAgIHZhciBncmQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQodGhpcy5mcm9tLngsIHRoaXMuZnJvbS55LCB0aGlzLnRvLngsIHRoaXMudG8ueSk7XG4gICAgICAgICAgdmFyIGZyb21Db2xvciA9IHRoaXMuZnJvbS5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5ib3JkZXI7XG4gICAgICAgICAgdmFyIHRvQ29sb3IgPSB0aGlzLnRvLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlcjtcbiAgICAgICAgICBpZiAodGhpcy5mcm9tLnNlbGVjdGVkID09PSBmYWxzZSAmJiB0aGlzLnRvLnNlbGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZnJvbUNvbG9yID0gb3ZlcnJpZGVPcGFjaXR5KHRoaXMuZnJvbS5vcHRpb25zLmNvbG9yLmJvcmRlciwgdmFsdWVzLm9wYWNpdHkpO1xuICAgICAgICAgICAgdG9Db2xvciA9IG92ZXJyaWRlT3BhY2l0eSh0aGlzLnRvLm9wdGlvbnMuY29sb3IuYm9yZGVyLCB2YWx1ZXMub3BhY2l0eSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZyb20uc2VsZWN0ZWQgPT09IHRydWUgJiYgdGhpcy50by5zZWxlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRvQ29sb3IgPSB0aGlzLnRvLm9wdGlvbnMuY29sb3IuYm9yZGVyO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5mcm9tLnNlbGVjdGVkID09PSBmYWxzZSAmJiB0aGlzLnRvLnNlbGVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICBmcm9tQ29sb3IgPSB0aGlzLmZyb20ub3B0aW9ucy5jb2xvci5ib3JkZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdyZC5hZGRDb2xvclN0b3AoMCwgZnJvbUNvbG9yKTtcbiAgICAgICAgICBncmQuYWRkQ29sb3JTdG9wKDEsIHRvQ29sb3IpO1xuICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tIHRoaXMgcmV0dXJucyAtLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICAgICAgICAgIHJldHVybiBncmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlcy5pbmhlcml0c0NvbG9yID09PSBcInRvXCIpIHtcbiAgICAgICAgICByZXR1cm4gb3ZlcnJpZGVPcGFjaXR5KHRoaXMudG8ub3B0aW9ucy5jb2xvci5ib3JkZXIsIHZhbHVlcy5vcGFjaXR5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBcImZyb21cIlxuICAgICAgICAgIHJldHVybiBvdmVycmlkZU9wYWNpdHkodGhpcy5mcm9tLm9wdGlvbnMuY29sb3IuYm9yZGVyLCB2YWx1ZXMub3BhY2l0eSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvdmVycmlkZU9wYWNpdHkodmFsdWVzLmNvbG9yLCB2YWx1ZXMub3BhY2l0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhIGxpbmUgZnJvbSBhIG5vZGUgdG8gaXRzZWxmLCBhIGNpcmNsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBGb3JtYXR0aW5nIHZhbHVlcyBsaWtlIGNvbG9yLCBvcGFjaXR5IG9yIHNoYWRvdy5cclxuICAgICAqIEBwYXJhbSB4IC0gQ2VudGVyIG9mIHRoZSBjaXJjbGUgb24gdGhlIHggYXhpcy5cclxuICAgICAqIEBwYXJhbSB5IC0gQ2VudGVyIG9mIHRoZSBjaXJjbGUgb24gdGhlIHkgYXhpcy5cclxuICAgICAqIEBwYXJhbSByYWRpdXMgLSBSYWRpdXMgb2YgdGhlIGNpcmNsZS5cclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jaXJjbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NpcmNsZShjdHgsIHZhbHVlcywgeCwgeSwgcmFkaXVzKSB7XG4gICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICAvL2Z1bGwgY2lyY2xlXG4gICAgICB2YXIgYW5nbGVGcm9tID0gMDtcbiAgICAgIHZhciBhbmdsZVRvID0gTWF0aC5QSSAqIDI7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLnJlbmRlckJlaGluZFRoZU5vZGUpIHtcbiAgICAgICAgLy9yZW5kZXIgb25seSBwYXJ0cyB3aGljaCBhcmUgbm90IG92ZXJsYXBpbmcgd2l0aCBwYXJlbnQgbm9kZVxuICAgICAgICAvL25lZWQgdG8gZmluZCB4LHkgb2YgZnJvbSBwb2ludCBhbmQgeCx5IHRvIHBvaW50XG4gICAgICAgIC8vY2FsY3VsYXRpbmcgcmFkaWFuc1xuICAgICAgICB2YXIgbG93ID0gdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGU7XG4gICAgICAgIHZhciBoaWdoID0gdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGUgKyBNYXRoLlBJO1xuICAgICAgICB2YXIgcG9pbnRURnJvbSA9IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZSh0aGlzLmZyb20sIGN0eCwge1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICBsb3c6IGxvdyxcbiAgICAgICAgICBoaWdoOiBoaWdoLFxuICAgICAgICAgIGRpcmVjdGlvbjogLTFcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwb2ludFRUbyA9IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZSh0aGlzLmZyb20sIGN0eCwge1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICBsb3c6IGxvdyxcbiAgICAgICAgICBoaWdoOiBoaWdoLFxuICAgICAgICAgIGRpcmVjdGlvbjogMVxuICAgICAgICB9KTtcbiAgICAgICAgYW5nbGVGcm9tID0gTWF0aC5hdGFuMihwb2ludFRGcm9tLnkgLSB5LCBwb2ludFRGcm9tLnggLSB4KTtcbiAgICAgICAgYW5nbGVUbyA9IE1hdGguYXRhbjIocG9pbnRUVG8ueSAtIHksIHBvaW50VFRvLnggLSB4KTtcbiAgICAgIH1cbiAgICAgIC8vIGRyYXcgYSBjaXJjbGVcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCBhbmdsZUZyb20sIGFuZ2xlVG8sIGZhbHNlKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG4gICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEBpbmhlcml0RG9jXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NDkyMTEvc2hvcnRlc3QtZGlzdGFuY2FlLWJldHdlZW4tYS1wb2ludC1hbmQtYS1saW5lLXNlZ21lbnRcclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldERpc3RhbmNlVG9FZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpc3RhbmNlVG9FZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgIGlmICh0aGlzLmZyb20gIT0gdGhpcy50bykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3RoaXMkX2dldENpcmNsZURhdGE3ID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YSh1bmRlZmluZWQpLFxuICAgICAgICAgIF90aGlzJF9nZXRDaXJjbGVEYXRhOCA9IF9zbGljZWRUb0FycmF5KF90aGlzJF9nZXRDaXJjbGVEYXRhNywgMyksXG4gICAgICAgICAgeCA9IF90aGlzJF9nZXRDaXJjbGVEYXRhOFswXSxcbiAgICAgICAgICB5ID0gX3RoaXMkX2dldENpcmNsZURhdGE4WzFdLFxuICAgICAgICAgIHJhZGl1cyA9IF90aGlzJF9nZXRDaXJjbGVEYXRhOFsyXTtcbiAgICAgICAgdmFyIGR4ID0geCAtIHgzO1xuICAgICAgICB2YXIgZHkgPSB5IC0geTM7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpIC0gcmFkaXVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBwb2ludCAoeDMsIHkzKSBhbmQgYSBsaW5lIHNlZ21lbnQgZnJvbSAoeDEsIHkxKSB0byAoeDIsIHkyKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geDEgLSBGaXJzdCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeCBheGlzLlxyXG4gICAgICogQHBhcmFtIHkxIC0gRmlyc3QgZW5kIG9mIHRoZSBsaW5lIHNlZ21lbnQgb24gdGhlIHkgYXhpcy5cclxuICAgICAqIEBwYXJhbSB4MiAtIFNlY29uZCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeCBheGlzLlxyXG4gICAgICogQHBhcmFtIHkyIC0gU2Vjb25kIGVuZCBvZiB0aGUgbGluZSBzZWdtZW50IG9uIHRoZSB5IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0geDMgLSBQb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHggYXhpcy5cclxuICAgICAqIEBwYXJhbSB5MyAtIFBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeSBheGlzLlxyXG4gICAgICogQHJldHVybnMgVGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGxpbmUgc2VnbWVudCBhbmQgdGhlIHBvaW50LlxyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldERpc3RhbmNlVG9MaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0YW5jZVRvTGluZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICB2YXIgcHggPSB4MiAtIHgxO1xuICAgICAgdmFyIHB5ID0geTIgLSB5MTtcbiAgICAgIHZhciBzb21ldGhpbmcgPSBweCAqIHB4ICsgcHkgKiBweTtcbiAgICAgIHZhciB1ID0gKCh4MyAtIHgxKSAqIHB4ICsgKHkzIC0geTEpICogcHkpIC8gc29tZXRoaW5nO1xuICAgICAgaWYgKHUgPiAxKSB7XG4gICAgICAgIHUgPSAxO1xuICAgICAgfSBlbHNlIGlmICh1IDwgMCkge1xuICAgICAgICB1ID0gMDtcbiAgICAgIH1cbiAgICAgIHZhciB4ID0geDEgKyB1ICogcHg7XG4gICAgICB2YXIgeSA9IHkxICsgdSAqIHB5O1xuICAgICAgdmFyIGR4ID0geCAtIHgzO1xuICAgICAgdmFyIGR5ID0geSAtIHkzO1xuICAgICAgLy8jIE5vdGU6IElmIHRoZSBhY3R1YWwgZGlzdGFuY2UgZG9lcyBub3QgbWF0dGVyLFxuICAgICAgLy8jIGlmIHlvdSBvbmx5IHdhbnQgdG8gY29tcGFyZSB3aGF0IHRoaXMgZnVuY3Rpb25cbiAgICAgIC8vIyByZXR1cm5zIHRvIG90aGVyIHJlc3VsdHMgb2YgdGhpcyBmdW5jdGlvbiwgeW91XG4gICAgICAvLyMgY2FuIGp1c3QgcmV0dXJuIHRoZSBzcXVhcmVkIGRpc3RhbmNlIGluc3RlYWRcbiAgICAgIC8vIyAoaS5lLiByZW1vdmUgdGhlIHNxcnQpIHRvIGdhaW4gYSBsaXR0bGUgcGVyZm9ybWFuY2VcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRBcnJvd0RhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXJyb3dEYXRhKGN0eCwgcG9zaXRpb24sIHZpYU5vZGUsIF9zZWxlY3RlZCwgX2hvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIC8vIHNldCBsZXRzXG4gICAgICB2YXIgYW5nbGU7XG4gICAgICB2YXIgYXJyb3dQb2ludDtcbiAgICAgIHZhciBub2RlMTtcbiAgICAgIHZhciBub2RlMjtcbiAgICAgIHZhciByZXZlcnNlZDtcbiAgICAgIHZhciBzY2FsZUZhY3RvcjtcbiAgICAgIHZhciB0eXBlO1xuICAgICAgdmFyIGxpbmVXaWR0aCA9IHZhbHVlcy53aWR0aDtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gXCJmcm9tXCIpIHtcbiAgICAgICAgbm9kZTEgPSB0aGlzLmZyb207XG4gICAgICAgIG5vZGUyID0gdGhpcy50bztcbiAgICAgICAgcmV2ZXJzZWQgPSB2YWx1ZXMuZnJvbUFycm93U2NhbGUgPCAwO1xuICAgICAgICBzY2FsZUZhY3RvciA9IE1hdGguYWJzKHZhbHVlcy5mcm9tQXJyb3dTY2FsZSk7XG4gICAgICAgIHR5cGUgPSB2YWx1ZXMuZnJvbUFycm93VHlwZTtcbiAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IFwidG9cIikge1xuICAgICAgICBub2RlMSA9IHRoaXMudG87XG4gICAgICAgIG5vZGUyID0gdGhpcy5mcm9tO1xuICAgICAgICByZXZlcnNlZCA9IHZhbHVlcy50b0Fycm93U2NhbGUgPCAwO1xuICAgICAgICBzY2FsZUZhY3RvciA9IE1hdGguYWJzKHZhbHVlcy50b0Fycm93U2NhbGUpO1xuICAgICAgICB0eXBlID0gdmFsdWVzLnRvQXJyb3dUeXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZTEgPSB0aGlzLnRvO1xuICAgICAgICBub2RlMiA9IHRoaXMuZnJvbTtcbiAgICAgICAgcmV2ZXJzZWQgPSB2YWx1ZXMubWlkZGxlQXJyb3dTY2FsZSA8IDA7XG4gICAgICAgIHNjYWxlRmFjdG9yID0gTWF0aC5hYnModmFsdWVzLm1pZGRsZUFycm93U2NhbGUpO1xuICAgICAgICB0eXBlID0gdmFsdWVzLm1pZGRsZUFycm93VHlwZTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSAxNSAqIHNjYWxlRmFjdG9yICsgMyAqIGxpbmVXaWR0aDsgLy8gMyogbGluZVdpZHRoIGlzIHRoZSB3aWR0aCBvZiB0aGUgZWRnZS5cbiAgICAgIC8vIGlmIG5vdCBjb25uZWN0ZWQgdG8gaXRzZWxmXG4gICAgICBpZiAobm9kZTEgIT0gbm9kZTIpIHtcbiAgICAgICAgdmFyIGFwcHJveGltYXRlRWRnZUxlbmd0aCA9IF9NYXRoJGh5cG90KG5vZGUxLnggLSBub2RlMi54LCBub2RlMS55IC0gbm9kZTIueSk7XG4gICAgICAgIHZhciByZWxhdGl2ZUxlbmd0aCA9IGxlbmd0aCAvIGFwcHJveGltYXRlRWRnZUxlbmd0aDtcbiAgICAgICAgaWYgKHBvc2l0aW9uICE9PSBcIm1pZGRsZVwiKSB7XG4gICAgICAgICAgLy8gZHJhdyBhcnJvdyBoZWFkXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbW9vdGguZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHBvaW50VCA9IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbihub2RlMSwgY3R4LCB7XG4gICAgICAgICAgICAgIHZpYTogdmlhTm9kZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgZ3VpZGVQb3MgPSB0aGlzLmdldFBvaW50KHBvaW50VC50ICsgcmVsYXRpdmVMZW5ndGggKiAocG9zaXRpb24gPT09IFwiZnJvbVwiID8gMSA6IC0xKSwgdmlhTm9kZSk7XG4gICAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIocG9pbnRULnkgLSBndWlkZVBvcy55LCBwb2ludFQueCAtIGd1aWRlUG9zLngpO1xuICAgICAgICAgICAgYXJyb3dQb2ludCA9IHBvaW50VDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKG5vZGUxLnkgLSBub2RlMi55LCBub2RlMS54IC0gbm9kZTIueCk7XG4gICAgICAgICAgICBhcnJvd1BvaW50ID0gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uKG5vZGUxLCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOZWdhdGl2ZSBoYWxmIGxlbmd0aCByZXZlcnNlcyBhcnJvdyBkaXJlY3Rpb24uXG4gICAgICAgICAgdmFyIGhhbGZMZW5ndGggPSAocmV2ZXJzZWQgPyAtcmVsYXRpdmVMZW5ndGggOiByZWxhdGl2ZUxlbmd0aCkgLyAyO1xuICAgICAgICAgIHZhciBndWlkZVBvczEgPSB0aGlzLmdldFBvaW50KDAuNSArIGhhbGZMZW5ndGgsIHZpYU5vZGUpO1xuICAgICAgICAgIHZhciBndWlkZVBvczIgPSB0aGlzLmdldFBvaW50KDAuNSAtIGhhbGZMZW5ndGgsIHZpYU5vZGUpO1xuICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMihndWlkZVBvczEueSAtIGd1aWRlUG9zMi55LCBndWlkZVBvczEueCAtIGd1aWRlUG9zMi54KTtcbiAgICAgICAgICBhcnJvd1BvaW50ID0gdGhpcy5nZXRQb2ludCgwLjUsIHZpYU5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkcmF3IGNpcmNsZVxuICAgICAgICB2YXIgX3RoaXMkX2dldENpcmNsZURhdGE5ID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YShjdHgpLFxuICAgICAgICAgIF90aGlzJF9nZXRDaXJjbGVEYXRhMTAgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0Q2lyY2xlRGF0YTksIDMpLFxuICAgICAgICAgIHggPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTEwWzBdLFxuICAgICAgICAgIHkgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTEwWzFdLFxuICAgICAgICAgIHJhZGl1cyA9IF90aGlzJF9nZXRDaXJjbGVEYXRhMTBbMl07XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gXCJmcm9tXCIpIHtcbiAgICAgICAgICB2YXIgbG93ID0gdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGU7XG4gICAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZSArIE1hdGguUEk7XG4gICAgICAgICAgdmFyIF9wb2ludFQgPSB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUodGhpcy5mcm9tLCBjdHgsIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgbG93OiBsb3csXG4gICAgICAgICAgICBoaWdoOiBoaWdoLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiAtMVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFuZ2xlID0gX3BvaW50VC50ICogLTIgKiBNYXRoLlBJICsgMS41ICogTWF0aC5QSSArIDAuMSAqIE1hdGguUEk7XG4gICAgICAgICAgYXJyb3dQb2ludCA9IF9wb2ludFQ7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IFwidG9cIikge1xuICAgICAgICAgIHZhciBfbG93ID0gdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGU7XG4gICAgICAgICAgdmFyIF9oaWdoID0gdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGUgKyBNYXRoLlBJO1xuICAgICAgICAgIHZhciBfcG9pbnRUMiA9IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZSh0aGlzLmZyb20sIGN0eCwge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBsb3c6IF9sb3csXG4gICAgICAgICAgICBoaWdoOiBfaGlnaCxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogMVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFuZ2xlID0gX3BvaW50VDIudCAqIC0yICogTWF0aC5QSSArIDEuNSAqIE1hdGguUEkgLSAxLjEgKiBNYXRoLlBJO1xuICAgICAgICAgIGFycm93UG9pbnQgPSBfcG9pbnRUMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcG9zID0gdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGUgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICAgIGFycm93UG9pbnQgPSB0aGlzLl9wb2ludE9uQ2lyY2xlKHgsIHksIHJhZGl1cywgcG9zKTtcbiAgICAgICAgICBhbmdsZSA9IHBvcyAqIC0yICogTWF0aC5QSSArIDEuNSAqIE1hdGguUEkgKyAwLjEgKiBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgeGkgPSBhcnJvd1BvaW50LnggLSBsZW5ndGggKiAwLjkgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICB2YXIgeWkgPSBhcnJvd1BvaW50LnkgLSBsZW5ndGggKiAwLjkgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICB2YXIgYXJyb3dDb3JlID0ge1xuICAgICAgICB4OiB4aSxcbiAgICAgICAgeTogeWlcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb2ludDogYXJyb3dQb2ludCxcbiAgICAgICAgY29yZTogYXJyb3dDb3JlLFxuICAgICAgICBhbmdsZTogYW5nbGUsXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICB0eXBlOiB0eXBlXG4gICAgICB9O1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJkcmF3QXJyb3dIZWFkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdBcnJvd0hlYWQoY3R4LCB2YWx1ZXMsIF9zZWxlY3RlZCwgX2hvdmVyLCBhcnJvd0RhdGEpIHtcbiAgICAgIC8vIHNldCBzdHlsZVxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5nZXRDb2xvcihjdHgsIHZhbHVlcyk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gY3R4LnN0cm9rZVN0eWxlO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHZhbHVlcy53aWR0aDtcbiAgICAgIHZhciBjYW5GaWxsID0gRW5kUG9pbnRzLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuICAgICAgaWYgKGNhbkZpbGwpIHtcbiAgICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICAgIF9maWxsSW5zdGFuY2VQcm9wZXJ0eShjdHgpLmNhbGwoY3R4KTtcbiAgICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHNoYWRvdyBmb3JtYXR0aW5nIHZhbHVlcyBpbiB0aGUgY29udGV4dCBpZiBlbmFibGVkLCBkbyBub3RoaW5nIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBGb3JtYXR0aW5nIHZhbHVlcyBmb3IgdGhlIHNoYWRvdy5cclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZVNoYWRvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuc2hhZG93ID09PSB0cnVlKSB7XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHZhbHVlcy5zaGFkb3dDb2xvcjtcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSB2YWx1ZXMuc2hhZG93U2l6ZTtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSB2YWx1ZXMuc2hhZG93WDtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSB2YWx1ZXMuc2hhZG93WTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgc2hhZG93IGZvcm1hdHRpbmcgdmFsdWVzIGluIHRoZSBjb250ZXh0IGlmIGVuYWJsZWQsIGRvIG5vdGhpbmcgb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIEZvcm1hdHRpbmcgdmFsdWVzIGZvciB0aGUgc2hhZG93LlxyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzYWJsZVNoYWRvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLnNoYWRvdyA9PT0gdHJ1ZSkge1xuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBcInJnYmEoMCwwLDAsMClcIjtcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSAwO1xuICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IDA7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXIgdGhlIGJhY2tncm91bmQgYWNjb3JkaW5nIHRvIHRoZSBmb3JtYXR0aW5nIHZhbHVlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBGb3JtYXR0aW5nIHZhbHVlcyBmb3IgdGhlIGJhY2tncm91bmQuXHJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkcmF3QmFja2dyb3VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QmFja2dyb3VuZChjdHgsIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlcy5iYWNrZ3JvdW5kICE9PSBmYWxzZSkge1xuICAgICAgICAvLyBzYXZlIG9yaWdpbmFsIGxpbmUgYXR0cnNcbiAgICAgICAgdmFyIG9yaWdDdHhBdHRyID0ge1xuICAgICAgICAgIHN0cm9rZVN0eWxlOiBjdHguc3Ryb2tlU3R5bGUsXG4gICAgICAgICAgbGluZVdpZHRoOiBjdHgubGluZVdpZHRoLFxuICAgICAgICAgIGRhc2hlczogY3R4LmRhc2hlc1xuICAgICAgICB9O1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZXMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gdmFsdWVzLmJhY2tncm91bmRTaXplO1xuICAgICAgICB0aGlzLnNldFN0cm9rZURhc2hlZChjdHgsIHZhbHVlcy5iYWNrZ3JvdW5kRGFzaGVzKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIGxpbmUgYXR0cnNcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3JpZ0N0eEF0dHIuc3Ryb2tlU3R5bGU7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBvcmlnQ3R4QXR0ci5saW5lV2lkdGg7XG4gICAgICAgIGN0eC5kYXNoZXMgPSBvcmlnQ3R4QXR0ci5kYXNoZXM7XG4gICAgICAgIHRoaXMuc2V0U3Ryb2tlRGFzaGVkKGN0eCwgdmFsdWVzLmRhc2hlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBsaW5lIGRhc2ggcGF0dGVybiBpZiBzdXBwb3J0ZWQuIExvZ3MgYSB3YXJuaW5nIHRvIHRoZSBjb25zb2xlIGlmIGl0IGlzbid0IHN1cHBvcnRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSBkYXNoZXMgLSBUaGUgcGF0dGVybiBbbGluZSwgc3BhY2UsIGxpbmXigKZdLCB0cnVlIGZvciBkZWZhdWx0IGRhc2hlZCBsaW5lIG9yIGZhbHNlIGZvciBub3JtYWwgbGluZS5cclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldFN0cm9rZURhc2hlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTdHJva2VEYXNoZWQoY3R4LCBkYXNoZXMpIHtcbiAgICAgIGlmIChkYXNoZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBwYXR0ZXJuID0gX0FycmF5JGlzQXJyYXkoZGFzaGVzKSA/IGRhc2hlcyA6IFs1LCA1XTtcbiAgICAgICAgICBjdHguc2V0TGluZURhc2gocGF0dGVybik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwic2V0TGluZURhc2ggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuIFRoZSBkYXNoZWQgc3Ryb2tlIGNhbm5vdCBiZSB1c2VkLlwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJzZXRMaW5lRGFzaCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4gVGhlIGRhc2hlZCBzdHJva2UgY2Fubm90IGJlIHVzZWQuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBFZGdlQmFzZTtcbn0oKTtcblxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gX09iamVjdCRrZXlzKGUpOyBpZiAoX09iamVjdCRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBfT2JqZWN0JGdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IF9maWx0ZXJJbnN0YW5jZVByb3BlcnR5KG8pLmNhbGwobywgZnVuY3Rpb24gKHIpIHsgcmV0dXJuIF9PYmplY3QkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgX2NvbnRleHQsIF9jb250ZXh0MjsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IF9mb3JFYWNoSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dCA9IG93bktleXMoT2JqZWN0KHQpLCAhMCkpLmNhbGwoX2NvbnRleHQsIGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBfT2JqZWN0JGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBfT2JqZWN0JGRlZmluZVByb3BlcnRpZXMoZSwgX09iamVjdCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IF9mb3JFYWNoSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDIgPSBvd25LZXlzKE9iamVjdCh0KSkpLmNhbGwoX2NvbnRleHQyLCBmdW5jdGlvbiAocikgeyBfT2JqZWN0JGRlZmluZVByb3BlcnR5KGUsIHIsIF9PYmplY3QkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDkoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkOSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBfUmVmbGVjdCRjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ5KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIV9SZWZsZWN0JGNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoX1JlZmxlY3QkY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKF9SZWZsZWN0JGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxyXG4gKiBUaGUgQmFzZSBDbGFzcyBmb3IgYWxsIEJlemllciBlZGdlcy5cclxuICogQmV6aWVyIGN1cnZlcyBhcmUgdXNlZCB0byBtb2RlbCBzbW9vdGggZ3JhZHVhbCBjdXJ2ZXMgaW4gcGF0aHMgYmV0d2VlbiBub2Rlcy5cclxuICovXG52YXIgQmV6aWVyRWRnZUJhc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FZGdlQmFzZSkge1xuICBfaW5oZXJpdHMoQmV6aWVyRWRnZUJhc2UsIF9FZGdlQmFzZSk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkOShCZXppZXJFZGdlQmFzZSk7XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0IG9mIGdpdmVuIGVkZ2UuXHJcbiAgICogQHBhcmFtIGJvZHkgLSBUaGUgYm9keSBvZiB0aGUgbmV0d29yay5cclxuICAgKiBAcGFyYW0gbGFiZWxNb2R1bGUgLSBMYWJlbCBtb2R1bGUuXHJcbiAgICovXG4gIGZ1bmN0aW9uIEJlemllckVkZ2VCYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJlemllckVkZ2VCYXNlKTtcbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG4gIC8qKlxyXG4gICAqIEZpbmQgdGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIHRoZSBib3JkZXIgb2YgdGhlIG5vZGUgYW5kIHRoZSBlZGdlLlxyXG4gICAqXHJcbiAgICogQHJlbWFya3NcclxuICAgKiBUaGlzIGZ1bmN0aW9uIHVzZXMgYmluYXJ5IHNlYXJjaCB0byBsb29rIGZvciB0aGUgcG9pbnQgd2hlcmUgdGhlIGJlemllciBjdXJ2ZSBjcm9zc2VzIHRoZSBib3JkZXIgb2YgdGhlIG5vZGUuXHJcbiAgICogQHBhcmFtIG5lYXJOb2RlIC0gVGhlIG5vZGUgKGVpdGhlciBmcm9tIG9yIHRvIG5vZGUgb2YgdGhlIGVkZ2UpLlxyXG4gICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAqIEBwYXJhbSB2aWFOb2RlIC0gQWRkaXRpb25hbCBub2RlKHMpIHRoZSBlZGdlIHBhc3NlcyB0aHJvdWdoLlxyXG4gICAqIEByZXR1cm5zIENhcnRlc2lhbiBjb29yZGluYXRlcyBvZiB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhlIGJvcmRlciBvZiB0aGUgbm9kZSBhbmQgdGhlIGVkZ2UuXHJcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhCZXppZXJFZGdlQmFzZSwgW3tcbiAgICBrZXk6IFwiX2ZpbmRCb3JkZXJQb3NpdGlvbkJlemllclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZEJvcmRlclBvc2l0aW9uQmV6aWVyKG5lYXJOb2RlLCBjdHgpIHtcbiAgICAgIHZhciB2aWFOb2RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpO1xuICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSAxMDtcbiAgICAgIHZhciB0aHJlc2hvbGQgPSAwLjI7XG4gICAgICB2YXIgZnJvbSA9IGZhbHNlO1xuICAgICAgdmFyIGhpZ2ggPSAxO1xuICAgICAgdmFyIGxvdyA9IDA7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMudG87XG4gICAgICB2YXIgcG9zO1xuICAgICAgdmFyIG1pZGRsZTtcbiAgICAgIHZhciBlbmRQb2ludE9mZnNldCA9IHRoaXMub3B0aW9ucy5lbmRQb2ludE9mZnNldCA/IHRoaXMub3B0aW9ucy5lbmRQb2ludE9mZnNldC50byA6IDA7XG4gICAgICBpZiAobmVhck5vZGUuaWQgPT09IHRoaXMuZnJvbS5pZCkge1xuICAgICAgICBub2RlID0gdGhpcy5mcm9tO1xuICAgICAgICBmcm9tID0gdHJ1ZTtcbiAgICAgICAgZW5kUG9pbnRPZmZzZXQgPSB0aGlzLm9wdGlvbnMuZW5kUG9pbnRPZmZzZXQgPyB0aGlzLm9wdGlvbnMuZW5kUG9pbnRPZmZzZXQuZnJvbSA6IDA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFycm93U3RyaWtldGhyb3VnaCA9PT0gZmFsc2UpIHtcbiAgICAgICAgZW5kUG9pbnRPZmZzZXQgPSAwO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdGlvbiA9IDA7XG4gICAgICBkbyB7XG4gICAgICAgIG1pZGRsZSA9IChsb3cgKyBoaWdoKSAqIDAuNTtcbiAgICAgICAgcG9zID0gdGhpcy5nZXRQb2ludChtaWRkbGUsIHZpYU5vZGUpO1xuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKG5vZGUueSAtIHBvcy55LCBub2RlLnggLSBwb3MueCk7XG4gICAgICAgIHZhciBkaXN0YW5jZVRvQm9yZGVyID0gbm9kZS5kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpICsgZW5kUG9pbnRPZmZzZXQ7XG4gICAgICAgIHZhciBkaXN0YW5jZVRvUG9pbnQgPSBNYXRoLnNxcnQoTWF0aC5wb3cocG9zLnggLSBub2RlLngsIDIpICsgTWF0aC5wb3cocG9zLnkgLSBub2RlLnksIDIpKTtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSBkaXN0YW5jZVRvQm9yZGVyIC0gZGlzdGFuY2VUb1BvaW50O1xuICAgICAgICBpZiAoTWF0aC5hYnMoZGlmZmVyZW5jZSkgPCB0aHJlc2hvbGQpIHtcbiAgICAgICAgICBicmVhazsgLy8gZm91bmRcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmZXJlbmNlIDwgMCkge1xuICAgICAgICAgIC8vIGRpc3RhbmNlIHRvIG5vZGVzIGlzIGxhcmdlciB0aGFuIGRpc3RhbmNlIHRvIGJvcmRlciAtLT4gdCBuZWVkcyB0byBiZSBiaWdnZXIgaWYgd2UncmUgbG9va2luZyBhdCB0aGUgdG8gbm9kZS5cbiAgICAgICAgICBpZiAoZnJvbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZGRsZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZGRsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZyb20gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkZGxlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb3cgPSBtaWRkbGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICsraXRlcmF0aW9uO1xuICAgICAgfSB3aGlsZSAobG93IDw9IGhpZ2ggJiYgaXRlcmF0aW9uIDwgbWF4SXRlcmF0aW9ucyk7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwb3MpLCB7fSwge1xuICAgICAgICB0OiBtaWRkbGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiBhIHBvaW50ICh4Myx5MykgYW5kIGEgbGluZSBzZWdtZW50IGZyb20gKHgxLHkxKSB0byAoeDIseTIpLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg0OTIxMS9zaG9ydGVzdC1kaXN0YW5jYWUtYmV0d2Vlbi1hLXBvaW50LWFuZC1hLWxpbmUtc2VnbWVudFxyXG4gICAgICogQHBhcmFtIHgxIC0gRmlyc3QgZW5kIG9mIHRoZSBsaW5lIHNlZ21lbnQgb24gdGhlIHggYXhpcy5cclxuICAgICAqIEBwYXJhbSB5MSAtIEZpcnN0IGVuZCBvZiB0aGUgbGluZSBzZWdtZW50IG9uIHRoZSB5IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0geDIgLSBTZWNvbmQgZW5kIG9mIHRoZSBsaW5lIHNlZ21lbnQgb24gdGhlIHggYXhpcy5cclxuICAgICAqIEBwYXJhbSB5MiAtIFNlY29uZCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeSBheGlzLlxyXG4gICAgICogQHBhcmFtIHgzIC0gUG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB4IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0geTMgLSBQb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHkgYXhpcy5cclxuICAgICAqIEBwYXJhbSB2aWEgLSBUaGUgY29udHJvbCBwb2ludCBmb3IgdGhlIGVkZ2UuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbGluZSBzZWdtZW50IGFuZCB0aGUgcG9pbnQuXHJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RGlzdGFuY2VUb0JlemllckVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9CZXppZXJFZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHZpYSkge1xuICAgICAgLy8geDMseTMgaXMgdGhlIHBvaW50XG4gICAgICB2YXIgbWluRGlzdGFuY2UgPSAxZTk7XG4gICAgICB2YXIgZGlzdGFuY2U7XG4gICAgICB2YXIgaSwgdCwgeCwgeTtcbiAgICAgIHZhciBsYXN0WCA9IHgxO1xuICAgICAgdmFyIGxhc3RZID0geTE7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgMTA7IGkrKykge1xuICAgICAgICB0ID0gMC4xICogaTtcbiAgICAgICAgeCA9IE1hdGgucG93KDEgLSB0LCAyKSAqIHgxICsgMiAqIHQgKiAoMSAtIHQpICogdmlhLnggKyBNYXRoLnBvdyh0LCAyKSAqIHgyO1xuICAgICAgICB5ID0gTWF0aC5wb3coMSAtIHQsIDIpICogeTEgKyAyICogdCAqICgxIC0gdCkgKiB2aWEueSArIE1hdGgucG93KHQsIDIpICogeTI7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIGRpc3RhbmNlID0gdGhpcy5fZ2V0RGlzdGFuY2VUb0xpbmUobGFzdFgsIGxhc3RZLCB4LCB5LCB4MywgeTMpO1xuICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSA/IGRpc3RhbmNlIDogbWluRGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFggPSB4O1xuICAgICAgICBsYXN0WSA9IHk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWluRGlzdGFuY2U7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmVuZGVyIGEgYmV6aWVyIGN1cnZlIGJldHdlZW4gdHdvIG5vZGVzLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBUaGUgbWV0aG9kIGFjY2VwdHMgemVybywgb25lIG9yIHR3byBjb250cm9sIHBvaW50cy5cclxuICAgICAqIFBhc3NpbmcgemVybyBjb250cm9sIHBvaW50cyBqdXN0IGRyYXdzIGEgc3RyYWlnaHQgbGluZS5cclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIFN0eWxlIG9wdGlvbnMgZm9yIGVkZ2UgZHJhd2luZy5cclxuICAgICAqIEBwYXJhbSB2aWFOb2RlMSAtIEZpcnN0IGNvbnRyb2wgcG9pbnQgZm9yIGN1cnZlIGRyYXdpbmcuXHJcbiAgICAgKiBAcGFyYW0gdmlhTm9kZTIgLSBTZWNvbmQgY29udHJvbCBwb2ludCBmb3IgY3VydmUgZHJhd2luZy5cclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9iZXppZXJDdXJ2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmV6aWVyQ3VydmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUxLCB2aWFOb2RlMikge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyh0aGlzLmZyb21Qb2ludC54LCB0aGlzLmZyb21Qb2ludC55KTtcbiAgICAgIGlmICh2aWFOb2RlMSAhPSBudWxsICYmIHZpYU5vZGUxLnggIT0gbnVsbCkge1xuICAgICAgICBpZiAodmlhTm9kZTIgIT0gbnVsbCAmJiB2aWFOb2RlMi54ICE9IG51bGwpIHtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh2aWFOb2RlMS54LCB2aWFOb2RlMS55LCB2aWFOb2RlMi54LCB2aWFOb2RlMi55LCB0aGlzLnRvUG9pbnQueCwgdGhpcy50b1BvaW50LnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHZpYU5vZGUxLngsIHZpYU5vZGUxLnksIHRoaXMudG9Qb2ludC54LCB0aGlzLnRvUG9pbnQueSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIG5vcm1hbCBzdHJhaWdodCBlZGdlXG4gICAgICAgIGN0eC5saW5lVG8odGhpcy50b1BvaW50LngsIHRoaXMudG9Qb2ludC55KTtcbiAgICAgIH1cbiAgICAgIC8vIGRyYXcgYSBiYWNrZ3JvdW5kXG4gICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKGN0eCwgdmFsdWVzKTtcbiAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFZpYU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmlhTm9kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQmV6aWVyRWRnZUJhc2U7XG59KEVkZ2VCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDgoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkOCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBfUmVmbGVjdCRjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ4KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIV9SZWZsZWN0JGNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoX1JlZmxlY3QkY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKF9SZWZsZWN0JGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxyXG4gKiBBIER5bmFtaWMgQmV6aWVyIEVkZ2UuIEJlemllciBjdXJ2ZXMgYXJlIHVzZWQgdG8gbW9kZWwgc21vb3RoIGdyYWR1YWxcclxuICogY3VydmVzIGluIHBhdGhzIGJldHdlZW4gbm9kZXMuIFRoZSBEeW5hbWljIHBpZWNlIHJlZmVycyB0byBob3cgdGhlIGN1cnZlXHJcbiAqIHJlYWN0cyB0byBwaHlzaWNzIGNoYW5nZXMuXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBCZXppZXJFZGdlQmFzZVxyXG4gKi9cbnZhciBCZXppZXJFZGdlRHluYW1pYyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0JlemllckVkZ2VCYXNlKSB7XG4gIF9pbmhlcml0cyhCZXppZXJFZGdlRHluYW1pYywgX0JlemllckVkZ2VCYXNlKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQ4KEJlemllckVkZ2VEeW5hbWljKTtcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3Qgb2YgZ2l2ZW4gZWRnZS5cclxuICAgKiBAcGFyYW0gYm9keSAtIFRoZSBib2R5IG9mIHRoZSBuZXR3b3JrLlxyXG4gICAqIEBwYXJhbSBsYWJlbE1vZHVsZSAtIExhYmVsIG1vZHVsZS5cclxuICAgKi9cbiAgZnVuY3Rpb24gQmV6aWVyRWRnZUR5bmFtaWMob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJlemllckVkZ2VEeW5hbWljKTtcbiAgICAvL3RoaXMudmlhID0gdW5kZWZpbmVkOyAvLyBIZXJlIGZvciBjb21wbGV0ZW5lc3MgYnV0IG5vdCBhbGxvd2VkIHRvIGRlZmluZWQgYmVmb3JlIHN1cGVyKCkgaXMgaW52b2tlZC5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTsgLy8gLS0+IHRoaXMgY2FsbHMgdGhlIHNldE9wdGlvbnMgYmVsb3dcbiAgICBfdGhpcy52aWEgPSBfdGhpcy52aWE7IC8vIGNvbnN0cnVjdG9yIOKGkiBzdXBlciDihpIgc3VwZXIg4oaSIHNldE9wdGlvbnMg4oaSIHNldHVwU3VwcG9ydE5vZGVcbiAgICBfdGhpcy5fYm91bmRGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnBvc2l0aW9uQmV6aWVyTm9kZSgpO1xuICAgIH07XG4gICAgX3RoaXMuX2JvZHkuZW1pdHRlci5vbihcIl9yZXBvc2l0aW9uQmV6aWVyTm9kZXNcIiwgX3RoaXMuX2JvdW5kRnVuY3Rpb24pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgX2NyZWF0ZUNsYXNzKEJlemllckVkZ2VEeW5hbWljLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoQmV6aWVyRWRnZUR5bmFtaWMucHJvdG90eXBlKSwgXCJzZXRPcHRpb25zXCIsIHRoaXMpLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAvLyBjaGVjayBpZiB0aGUgcGh5c2ljcyBoYXMgY2hhbmdlZC5cbiAgICAgIHZhciBwaHlzaWNzQ2hhbmdlID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBoeXNpY3MgIT09IG9wdGlvbnMucGh5c2ljcykge1xuICAgICAgICBwaHlzaWNzQ2hhbmdlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIHNldCB0aGUgb3B0aW9ucyBhbmQgdGhlIHRvIGFuZCBmcm9tIG5vZGVzXG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgdGhpcy5pZCA9IHRoaXMub3B0aW9ucy5pZDtcbiAgICAgIHRoaXMuZnJvbSA9IHRoaXMuX2JvZHkubm9kZXNbdGhpcy5vcHRpb25zLmZyb21dO1xuICAgICAgdGhpcy50byA9IHRoaXMuX2JvZHkubm9kZXNbdGhpcy5vcHRpb25zLnRvXTtcbiAgICAgIC8vIHNldHVwIHRoZSBzdXBwb3J0IG5vZGUgYW5kIGNvbm5lY3RcbiAgICAgIHRoaXMuc2V0dXBTdXBwb3J0Tm9kZSgpO1xuICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAvLyB3aGVuIHdlIGNoYW5nZSB0aGUgcGh5c2ljcyBzdGF0ZSBvZiB0aGUgZWRnZSwgd2UgcmVwb3NpdGlvbiB0aGUgc3VwcG9ydCBub2RlLlxuICAgICAgaWYgKHBoeXNpY3NDaGFuZ2UgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy52aWEuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgcGh5c2ljczogdGhpcy5vcHRpb25zLnBoeXNpY3NcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucG9zaXRpb25CZXppZXJOb2RlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcImNvbm5lY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAgIHRoaXMuZnJvbSA9IHRoaXMuX2JvZHkubm9kZXNbdGhpcy5vcHRpb25zLmZyb21dO1xuICAgICAgdGhpcy50byA9IHRoaXMuX2JvZHkubm9kZXNbdGhpcy5vcHRpb25zLnRvXTtcbiAgICAgIGlmICh0aGlzLmZyb20gPT09IHVuZGVmaW5lZCB8fCB0aGlzLnRvID09PSB1bmRlZmluZWQgfHwgdGhpcy5vcHRpb25zLnBoeXNpY3MgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMudmlhLnNldE9wdGlvbnMoe1xuICAgICAgICAgIHBoeXNpY3M6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZml4IHdlaXJkIGJlaGF2aW91ciB3aGVyZSBhIHNlbGYgcmVmZXJlbmNpbmcgbm9kZSBoYXMgcGh5c2ljcyBlbmFibGVkXG4gICAgICAgIGlmICh0aGlzLmZyb20uaWQgPT09IHRoaXMudG8uaWQpIHtcbiAgICAgICAgICB0aGlzLnZpYS5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIHBoeXNpY3M6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy52aWEuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICBwaHlzaWNzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYW51cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgdGhpcy5fYm9keS5lbWl0dGVyLm9mZihcIl9yZXBvc2l0aW9uQmV6aWVyTm9kZXNcIiwgdGhpcy5fYm91bmRGdW5jdGlvbik7XG4gICAgICBpZiAodGhpcy52aWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fYm9keS5ub2Rlc1t0aGlzLnZpYS5pZF07XG4gICAgICAgIHRoaXMudmlhID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW5kIGFkZCBhIHN1cHBvcnQgbm9kZSBpZiBub3QgYWxyZWFkeSBwcmVzZW50LlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBCZXppZXIgY3VydmVzIHJlcXVpcmUgYW4gYW5jaG9yIHBvaW50IHRvIGNhbGN1bGF0ZSB0aGUgc21vb3RoIGZsb3cuXHJcbiAgICAgKiBUaGVzZSBwb2ludHMgYXJlIG5vZGVzLlxyXG4gICAgICogVGhlc2Ugbm9kZXMgYXJlIGludmlzaWJsZSBidXQgYXJlIHVzZWQgZm9yIHRoZSBmb3JjZSBjYWxjdWxhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgY2hhbmdlZCBkYXRhIGlzIG5vdCBjYWxsZWQsIGlmIG5lZWRlZCwgaXQgaXMgcmV0dXJuZWQgYnkgdGhlIG1haW4gZWRnZSBjb25zdHJ1Y3Rvci5cclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldHVwU3VwcG9ydE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBTdXBwb3J0Tm9kZSgpIHtcbiAgICAgIGlmICh0aGlzLnZpYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBub2RlSWQgPSBcImVkZ2VJZDpcIiArIHRoaXMuaWQ7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fYm9keS5mdW5jdGlvbnMuY3JlYXRlTm9kZSh7XG4gICAgICAgICAgaWQ6IG5vZGVJZCxcbiAgICAgICAgICBzaGFwZTogXCJjaXJjbGVcIixcbiAgICAgICAgICBwaHlzaWNzOiB0cnVlLFxuICAgICAgICAgIGhpZGRlbjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fYm9keS5ub2Rlc1tub2RlSWRdID0gbm9kZTtcbiAgICAgICAgdGhpcy52aWEgPSBub2RlO1xuICAgICAgICB0aGlzLnZpYS5wYXJlbnRFZGdlSWQgPSB0aGlzLmlkO1xuICAgICAgICB0aGlzLnBvc2l0aW9uQmV6aWVyTm9kZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIFBvc2l0aW9uIGJlemllciBub2RlLlxyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicG9zaXRpb25CZXppZXJOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc2l0aW9uQmV6aWVyTm9kZSgpIHtcbiAgICAgIGlmICh0aGlzLnZpYSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZnJvbSAhPT0gdW5kZWZpbmVkICYmIHRoaXMudG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnZpYS54ID0gMC41ICogKHRoaXMuZnJvbS54ICsgdGhpcy50by54KTtcbiAgICAgICAgdGhpcy52aWEueSA9IDAuNSAqICh0aGlzLmZyb20ueSArIHRoaXMudG8ueSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudmlhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy52aWEueCA9IDA7XG4gICAgICAgIHRoaXMudmlhLnkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJfbGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbGluZShjdHgsIHZhbHVlcywgdmlhTm9kZSkge1xuICAgICAgdGhpcy5fYmV6aWVyQ3VydmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUpO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0VmlhQ29vcmRpbmF0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFZpYUNvb3JkaW5hdGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmlhO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRWaWFOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpYU5vZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy52aWE7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50KHBvc2l0aW9uKSB7XG4gICAgICB2YXIgdmlhTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy52aWE7XG4gICAgICBpZiAodGhpcy5mcm9tID09PSB0aGlzLnRvKSB7XG4gICAgICAgIHZhciBfdGhpcyRfZ2V0Q2lyY2xlRGF0YSA9IHRoaXMuX2dldENpcmNsZURhdGEoKSxcbiAgICAgICAgICBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0Q2lyY2xlRGF0YSwgMyksXG4gICAgICAgICAgY3ggPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTJbMF0sXG4gICAgICAgICAgY3kgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTJbMV0sXG4gICAgICAgICAgY3IgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTJbMl07XG4gICAgICAgIHZhciBhID0gMiAqIE1hdGguUEkgKiAoMSAtIHBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBjeCArIGNyICogTWF0aC5zaW4oYSksXG4gICAgICAgICAgeTogY3kgKyBjciAtIGNyICogKDEgLSBNYXRoLmNvcyhhKSlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogTWF0aC5wb3coMSAtIHBvc2l0aW9uLCAyKSAqIHRoaXMuZnJvbVBvaW50LnggKyAyICogcG9zaXRpb24gKiAoMSAtIHBvc2l0aW9uKSAqIHZpYU5vZGUueCArIE1hdGgucG93KHBvc2l0aW9uLCAyKSAqIHRoaXMudG9Qb2ludC54LFxuICAgICAgICAgIHk6IE1hdGgucG93KDEgLSBwb3NpdGlvbiwgMikgKiB0aGlzLmZyb21Qb2ludC55ICsgMiAqIHBvc2l0aW9uICogKDEgLSBwb3NpdGlvbikgKiB2aWFOb2RlLnkgKyBNYXRoLnBvdyhwb3NpdGlvbiwgMikgKiB0aGlzLnRvUG9pbnQueVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZmluZEJvcmRlclBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb24obmVhck5vZGUsIGN0eCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkJlemllcihuZWFyTm9kZSwgY3R4LCB0aGlzLnZpYSk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXREaXN0YW5jZVRvRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgLy8geDMseTMgaXMgdGhlIHBvaW50XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdGhpcy52aWEpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQmV6aWVyRWRnZUR5bmFtaWM7XG59KEJlemllckVkZ2VCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDcoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNygpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBfUmVmbGVjdCRjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ3KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIV9SZWZsZWN0JGNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoX1JlZmxlY3QkY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKF9SZWZsZWN0JGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxyXG4gKiBBIFN0YXRpYyBCZXppZXIgRWRnZS4gQmV6aWVyIGN1cnZlcyBhcmUgdXNlZCB0byBtb2RlbCBzbW9vdGggZ3JhZHVhbCBjdXJ2ZXMgaW4gcGF0aHMgYmV0d2VlbiBub2Rlcy5cclxuICovXG52YXIgQmV6aWVyRWRnZVN0YXRpYyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0JlemllckVkZ2VCYXNlKSB7XG4gIF9pbmhlcml0cyhCZXppZXJFZGdlU3RhdGljLCBfQmV6aWVyRWRnZUJhc2UpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJDcoQmV6aWVyRWRnZVN0YXRpYyk7XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0IG9mIGdpdmVuIGVkZ2UuXHJcbiAgICogQHBhcmFtIGJvZHkgLSBUaGUgYm9keSBvZiB0aGUgbmV0d29yay5cclxuICAgKiBAcGFyYW0gbGFiZWxNb2R1bGUgLSBMYWJlbCBtb2R1bGUuXHJcbiAgICovXG4gIGZ1bmN0aW9uIEJlemllckVkZ2VTdGF0aWMob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmV6aWVyRWRnZVN0YXRpYyk7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgX2NyZWF0ZUNsYXNzKEJlemllckVkZ2VTdGF0aWMsIFt7XG4gICAga2V5OiBcIl9saW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9saW5lKGN0eCwgdmFsdWVzLCB2aWFOb2RlKSB7XG4gICAgICB0aGlzLl9iZXppZXJDdXJ2ZShjdHgsIHZhbHVlcywgdmlhTm9kZSk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFZpYU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmlhTm9kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIENvbXB1dGUgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSB2aWEgbm9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICogV2UgZG8gbm90IHVzZSB0aGUgdG8gYW5kIGZyb21Qb2ludHMgaGVyZSB0byBtYWtlIHRoZSB2aWEgbm9kZXMgdGhlIHNhbWUgYXMgZWRnZXMgd2l0aG91dCBhcnJvd3MuXHJcbiAgICAgKiBAcmV0dXJucyBDYXJ0ZXNpYW4gY29vcmRpbmF0ZXMgb2YgdGhlIHZpYSBub2RlLlxyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFZpYUNvb3JkaW5hdGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRWaWFDb29yZGluYXRlcygpIHtcbiAgICAgIC8vIEFzc3VtcHRpb246IHgveSBjb29yZGluYXRlcyBpbiBmcm9tL3RvIGFsd2F5cyBkZWZpbmVkXG4gICAgICB2YXIgZmFjdG9yID0gdGhpcy5vcHRpb25zLnNtb290aC5yb3VuZG5lc3M7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMub3B0aW9ucy5zbW9vdGgudHlwZTtcbiAgICAgIHZhciBkeCA9IE1hdGguYWJzKHRoaXMuZnJvbS54IC0gdGhpcy50by54KTtcbiAgICAgIHZhciBkeSA9IE1hdGguYWJzKHRoaXMuZnJvbS55IC0gdGhpcy50by55KTtcbiAgICAgIGlmICh0eXBlID09PSBcImRpc2NyZXRlXCIgfHwgdHlwZSA9PT0gXCJkaWFnb25hbENyb3NzXCIpIHtcbiAgICAgICAgdmFyIHN0ZXBYO1xuICAgICAgICB2YXIgc3RlcFk7XG4gICAgICAgIGlmIChkeCA8PSBkeSkge1xuICAgICAgICAgIHN0ZXBYID0gc3RlcFkgPSBmYWN0b3IgKiBkeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGVwWCA9IHN0ZXBZID0gZmFjdG9yICogZHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZnJvbS54ID4gdGhpcy50by54KSB7XG4gICAgICAgICAgc3RlcFggPSAtc3RlcFg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZnJvbS55ID49IHRoaXMudG8ueSkge1xuICAgICAgICAgIHN0ZXBZID0gLXN0ZXBZO1xuICAgICAgICB9XG4gICAgICAgIHZhciB4VmlhID0gdGhpcy5mcm9tLnggKyBzdGVwWDtcbiAgICAgICAgdmFyIHlWaWEgPSB0aGlzLmZyb20ueSArIHN0ZXBZO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJkaXNjcmV0ZVwiKSB7XG4gICAgICAgICAgaWYgKGR4IDw9IGR5KSB7XG4gICAgICAgICAgICB4VmlhID0gZHggPCBmYWN0b3IgKiBkeSA/IHRoaXMuZnJvbS54IDogeFZpYTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeVZpYSA9IGR5IDwgZmFjdG9yICogZHggPyB0aGlzLmZyb20ueSA6IHlWaWE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeFZpYSxcbiAgICAgICAgICB5OiB5VmlhXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwic3RyYWlnaHRDcm9zc1wiKSB7XG4gICAgICAgIHZhciBfc3RlcFggPSAoMSAtIGZhY3RvcikgKiBkeDtcbiAgICAgICAgdmFyIF9zdGVwWSA9ICgxIC0gZmFjdG9yKSAqIGR5O1xuICAgICAgICBpZiAoZHggPD0gZHkpIHtcbiAgICAgICAgICAvLyB1cCAtIGRvd25cbiAgICAgICAgICBfc3RlcFggPSAwO1xuICAgICAgICAgIGlmICh0aGlzLmZyb20ueSA8IHRoaXMudG8ueSkge1xuICAgICAgICAgICAgX3N0ZXBZID0gLV9zdGVwWTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbGVmdCAtIHJpZ2h0XG4gICAgICAgICAgaWYgKHRoaXMuZnJvbS54IDwgdGhpcy50by54KSB7XG4gICAgICAgICAgICBfc3RlcFggPSAtX3N0ZXBYO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfc3RlcFkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogdGhpcy50by54ICsgX3N0ZXBYLFxuICAgICAgICAgIHk6IHRoaXMudG8ueSArIF9zdGVwWVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgICB2YXIgX3N0ZXBYMiA9ICgxIC0gZmFjdG9yKSAqIGR4O1xuICAgICAgICBpZiAodGhpcy5mcm9tLnggPCB0aGlzLnRvLngpIHtcbiAgICAgICAgICBfc3RlcFgyID0gLV9zdGVwWDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB0aGlzLnRvLnggKyBfc3RlcFgyLFxuICAgICAgICAgIHk6IHRoaXMuZnJvbS55XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwidmVydGljYWxcIikge1xuICAgICAgICB2YXIgX3N0ZXBZMiA9ICgxIC0gZmFjdG9yKSAqIGR5O1xuICAgICAgICBpZiAodGhpcy5mcm9tLnkgPCB0aGlzLnRvLnkpIHtcbiAgICAgICAgICBfc3RlcFkyID0gLV9zdGVwWTI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB0aGlzLmZyb20ueCxcbiAgICAgICAgICB5OiB0aGlzLnRvLnkgKyBfc3RlcFkyXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY3VydmVkQ1dcIikge1xuICAgICAgICBkeCA9IHRoaXMudG8ueCAtIHRoaXMuZnJvbS54O1xuICAgICAgICBkeSA9IHRoaXMuZnJvbS55IC0gdGhpcy50by55O1xuICAgICAgICB2YXIgcmFkaXVzID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgdmFyIHBpID0gTWF0aC5QSTtcbiAgICAgICAgdmFyIG9yaWdpbmFsQW5nbGUgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG4gICAgICAgIHZhciBteUFuZ2xlID0gKG9yaWdpbmFsQW5nbGUgKyAoZmFjdG9yICogMC41ICsgMC41KSAqIHBpKSAlICgyICogcGkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHRoaXMuZnJvbS54ICsgKGZhY3RvciAqIDAuNSArIDAuNSkgKiByYWRpdXMgKiBNYXRoLnNpbihteUFuZ2xlKSxcbiAgICAgICAgICB5OiB0aGlzLmZyb20ueSArIChmYWN0b3IgKiAwLjUgKyAwLjUpICogcmFkaXVzICogTWF0aC5jb3MobXlBbmdsZSlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjdXJ2ZWRDQ1dcIikge1xuICAgICAgICBkeCA9IHRoaXMudG8ueCAtIHRoaXMuZnJvbS54O1xuICAgICAgICBkeSA9IHRoaXMuZnJvbS55IC0gdGhpcy50by55O1xuICAgICAgICB2YXIgX3JhZGl1cyA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIHZhciBfcGkgPSBNYXRoLlBJO1xuICAgICAgICB2YXIgX29yaWdpbmFsQW5nbGUgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG4gICAgICAgIHZhciBfbXlBbmdsZSA9IChfb3JpZ2luYWxBbmdsZSArICgtZmFjdG9yICogMC41ICsgMC41KSAqIF9waSkgJSAoMiAqIF9waSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogdGhpcy5mcm9tLnggKyAoZmFjdG9yICogMC41ICsgMC41KSAqIF9yYWRpdXMgKiBNYXRoLnNpbihfbXlBbmdsZSksXG4gICAgICAgICAgeTogdGhpcy5mcm9tLnkgKyAoZmFjdG9yICogMC41ICsgMC41KSAqIF9yYWRpdXMgKiBNYXRoLmNvcyhfbXlBbmdsZSlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnRpbnVvdXNcbiAgICAgICAgdmFyIF9zdGVwWDM7XG4gICAgICAgIHZhciBfc3RlcFkzO1xuICAgICAgICBpZiAoZHggPD0gZHkpIHtcbiAgICAgICAgICBfc3RlcFgzID0gX3N0ZXBZMyA9IGZhY3RvciAqIGR5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9zdGVwWDMgPSBfc3RlcFkzID0gZmFjdG9yICogZHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZnJvbS54ID4gdGhpcy50by54KSB7XG4gICAgICAgICAgX3N0ZXBYMyA9IC1fc3RlcFgzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZyb20ueSA+PSB0aGlzLnRvLnkpIHtcbiAgICAgICAgICBfc3RlcFkzID0gLV9zdGVwWTM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF94VmlhID0gdGhpcy5mcm9tLnggKyBfc3RlcFgzO1xuICAgICAgICB2YXIgX3lWaWEgPSB0aGlzLmZyb20ueSArIF9zdGVwWTM7XG4gICAgICAgIGlmIChkeCA8PSBkeSkge1xuICAgICAgICAgIGlmICh0aGlzLmZyb20ueCA8PSB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgIF94VmlhID0gdGhpcy50by54IDwgX3hWaWEgPyB0aGlzLnRvLnggOiBfeFZpYTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3hWaWEgPSB0aGlzLnRvLnggPiBfeFZpYSA/IHRoaXMudG8ueCA6IF94VmlhO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5mcm9tLnkgPj0gdGhpcy50by55KSB7XG4gICAgICAgICAgICBfeVZpYSA9IHRoaXMudG8ueSA+IF95VmlhID8gdGhpcy50by55IDogX3lWaWE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF95VmlhID0gdGhpcy50by55IDwgX3lWaWEgPyB0aGlzLnRvLnkgOiBfeVZpYTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBfeFZpYSxcbiAgICAgICAgICB5OiBfeVZpYVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZmluZEJvcmRlclBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb24obmVhck5vZGUsIGN0eCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkJlemllcihuZWFyTm9kZSwgY3R4LCBvcHRpb25zLnZpYSk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXREaXN0YW5jZVRvRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgdmFyIHZpYU5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG4gICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgIHJldHVybiB0aGlzLl9nZXREaXN0YW5jZVRvQmV6aWVyRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB2aWFOb2RlKTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnQocG9zaXRpb24pIHtcbiAgICAgIHZhciB2aWFOb2RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpO1xuICAgICAgdmFyIHQgPSBwb3NpdGlvbjtcbiAgICAgIHZhciB4ID0gTWF0aC5wb3coMSAtIHQsIDIpICogdGhpcy5mcm9tUG9pbnQueCArIDIgKiB0ICogKDEgLSB0KSAqIHZpYU5vZGUueCArIE1hdGgucG93KHQsIDIpICogdGhpcy50b1BvaW50Lng7XG4gICAgICB2YXIgeSA9IE1hdGgucG93KDEgLSB0LCAyKSAqIHRoaXMuZnJvbVBvaW50LnkgKyAyICogdCAqICgxIC0gdCkgKiB2aWFOb2RlLnkgKyBNYXRoLnBvdyh0LCAyKSAqIHRoaXMudG9Qb2ludC55O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJlemllckVkZ2VTdGF0aWM7XG59KEJlemllckVkZ2VCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDYoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNigpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBfUmVmbGVjdCRjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ2KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIV9SZWZsZWN0JGNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoX1JlZmxlY3QkY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKF9SZWZsZWN0JGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxyXG4gKiBBIEJhc2UgQ2xhc3MgZm9yIGFsbCBDdWJpYyBCZXppZXIgRWRnZXMuIEJlemllciBjdXJ2ZXMgYXJlIHVzZWQgdG8gbW9kZWxcclxuICogc21vb3RoIGdyYWR1YWwgY3VydmVzIGluIHBhdGhzIGJldHdlZW4gbm9kZXMuXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBCZXppZXJFZGdlQmFzZVxyXG4gKi9cbnZhciBDdWJpY0JlemllckVkZ2VCYXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmV6aWVyRWRnZUJhc2UpIHtcbiAgX2luaGVyaXRzKEN1YmljQmV6aWVyRWRnZUJhc2UsIF9CZXppZXJFZGdlQmFzZSk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkNihDdWJpY0JlemllckVkZ2VCYXNlKTtcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3Qgb2YgZ2l2ZW4gZWRnZS5cclxuICAgKiBAcGFyYW0gYm9keSAtIFRoZSBib2R5IG9mIHRoZSBuZXR3b3JrLlxyXG4gICAqIEBwYXJhbSBsYWJlbE1vZHVsZSAtIExhYmVsIG1vZHVsZS5cclxuICAgKi9cbiAgZnVuY3Rpb24gQ3ViaWNCZXppZXJFZGdlQmFzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDdWJpY0JlemllckVkZ2VCYXNlKTtcbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiBhIHBvaW50ICh4Myx5MykgYW5kIGEgbGluZSBzZWdtZW50IGZyb20gKHgxLHkxKSB0byAoeDIseTIpLlxyXG4gICAqXHJcbiAgICogQHJlbWFya3NcclxuICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg0OTIxMS9zaG9ydGVzdC1kaXN0YW5jYWUtYmV0d2Vlbi1hLXBvaW50LWFuZC1hLWxpbmUtc2VnbWVudFxyXG4gICAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0IlQzMlQTl6aWVyX2N1cnZlXHJcbiAgICogQHBhcmFtIHgxIC0gRmlyc3QgZW5kIG9mIHRoZSBsaW5lIHNlZ21lbnQgb24gdGhlIHggYXhpcy5cclxuICAgKiBAcGFyYW0geTEgLSBGaXJzdCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeSBheGlzLlxyXG4gICAqIEBwYXJhbSB4MiAtIFNlY29uZCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeCBheGlzLlxyXG4gICAqIEBwYXJhbSB5MiAtIFNlY29uZCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeSBheGlzLlxyXG4gICAqIEBwYXJhbSB4MyAtIFBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeCBheGlzLlxyXG4gICAqIEBwYXJhbSB5MyAtIFBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeSBheGlzLlxyXG4gICAqIEBwYXJhbSB2aWExIC0gVGhlIGZpcnN0IHBvaW50IHRoaXMgZWRnZSBwYXNzZXMgdGhyb3VnaC5cclxuICAgKiBAcGFyYW0gdmlhMiAtIFRoZSBzZWNvbmQgcG9pbnQgdGhpcyBlZGdlIHBhc3NlcyB0aHJvdWdoLlxyXG4gICAqIEByZXR1cm5zIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBsaW5lIHNlZ21lbnQgYW5kIHRoZSBwb2ludC5cclxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKEN1YmljQmV6aWVyRWRnZUJhc2UsIFt7XG4gICAga2V5OiBcIl9nZXREaXN0YW5jZVRvQmV6aWVyRWRnZTJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9CZXppZXJFZGdlMih4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB2aWExLCB2aWEyKSB7XG4gICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgIHZhciBtaW5EaXN0YW5jZSA9IDFlOTtcbiAgICAgIHZhciBsYXN0WCA9IHgxO1xuICAgICAgdmFyIGxhc3RZID0geTE7XG4gICAgICB2YXIgdmVjID0gWzAsIDAsIDAsIDBdO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIHZhciB0ID0gMC4xICogaTtcbiAgICAgICAgdmVjWzBdID0gTWF0aC5wb3coMSAtIHQsIDMpO1xuICAgICAgICB2ZWNbMV0gPSAzICogdCAqIE1hdGgucG93KDEgLSB0LCAyKTtcbiAgICAgICAgdmVjWzJdID0gMyAqIE1hdGgucG93KHQsIDIpICogKDEgLSB0KTtcbiAgICAgICAgdmVjWzNdID0gTWF0aC5wb3codCwgMyk7XG4gICAgICAgIHZhciB4ID0gdmVjWzBdICogeDEgKyB2ZWNbMV0gKiB2aWExLnggKyB2ZWNbMl0gKiB2aWEyLnggKyB2ZWNbM10gKiB4MjtcbiAgICAgICAgdmFyIHkgPSB2ZWNbMF0gKiB5MSArIHZlY1sxXSAqIHZpYTEueSArIHZlY1syXSAqIHZpYTIueSArIHZlY1szXSAqIHkyO1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICB2YXIgZGlzdGFuY2UgPSB0aGlzLl9nZXREaXN0YW5jZVRvTGluZShsYXN0WCwgbGFzdFksIHgsIHksIHgzLCB5Myk7XG4gICAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZSA8IG1pbkRpc3RhbmNlID8gZGlzdGFuY2UgOiBtaW5EaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0WCA9IHg7XG4gICAgICAgIGxhc3RZID0geTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtaW5EaXN0YW5jZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEN1YmljQmV6aWVyRWRnZUJhc2U7XG59KEJlemllckVkZ2VCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDUoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBfUmVmbGVjdCRjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ1KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIV9SZWZsZWN0JGNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoX1JlZmxlY3QkY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKF9SZWZsZWN0JGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxyXG4gKiBBIEN1YmljIEJlemllciBFZGdlLiBCZXppZXIgY3VydmVzIGFyZSB1c2VkIHRvIG1vZGVsIHNtb290aCBncmFkdWFsIGN1cnZlcyBpbiBwYXRocyBiZXR3ZWVuIG5vZGVzLlxyXG4gKi9cbnZhciBDdWJpY0JlemllckVkZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DdWJpY0JlemllckVkZ2VCYXNlKSB7XG4gIF9pbmhlcml0cyhDdWJpY0JlemllckVkZ2UsIF9DdWJpY0JlemllckVkZ2VCYXNlKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQ1KEN1YmljQmV6aWVyRWRnZSk7XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0IG9mIGdpdmVuIGVkZ2UuXHJcbiAgICogQHBhcmFtIGJvZHkgLSBUaGUgYm9keSBvZiB0aGUgbmV0d29yay5cclxuICAgKiBAcGFyYW0gbGFiZWxNb2R1bGUgLSBMYWJlbCBtb2R1bGUuXHJcbiAgICovXG4gIGZ1bmN0aW9uIEN1YmljQmV6aWVyRWRnZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDdWJpY0JlemllckVkZ2UpO1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIF9jcmVhdGVDbGFzcyhDdWJpY0JlemllckVkZ2UsIFt7XG4gICAga2V5OiBcIl9saW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9saW5lKGN0eCwgdmFsdWVzLCB2aWFOb2Rlcykge1xuICAgICAgLy8gZ2V0IHRoZSBjb29yZGluYXRlcyBvZiB0aGUgc3VwcG9ydCBwb2ludHMuXG4gICAgICB2YXIgdmlhMSA9IHZpYU5vZGVzWzBdO1xuICAgICAgdmFyIHZpYTIgPSB2aWFOb2Rlc1sxXTtcbiAgICAgIHRoaXMuX2JlemllckN1cnZlKGN0eCwgdmFsdWVzLCB2aWExLCB2aWEyKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlIHRoZSBhZGRpdGlvbmFsIHBvaW50cyB0aGUgZWRnZSBwYXNzZXMgdGhyb3VnaC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBDYXJ0ZXNpYW4gY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50cyB0aGUgZWRnZSBwYXNzZXMgdGhyb3VnaC5cclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXRWaWFDb29yZGluYXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VmlhQ29vcmRpbmF0ZXMoKSB7XG4gICAgICB2YXIgZHggPSB0aGlzLmZyb20ueCAtIHRoaXMudG8ueDtcbiAgICAgIHZhciBkeSA9IHRoaXMuZnJvbS55IC0gdGhpcy50by55O1xuICAgICAgdmFyIHgxO1xuICAgICAgdmFyIHkxO1xuICAgICAgdmFyIHgyO1xuICAgICAgdmFyIHkyO1xuICAgICAgdmFyIHJvdW5kbmVzcyA9IHRoaXMub3B0aW9ucy5zbW9vdGgucm91bmRuZXNzO1xuICAgICAgLy8gaG9yaXpvbnRhbCBpZiB4ID4geSBvciBpZiBkaXJlY3Rpb24gaXMgZm9yY2VkIG9yIGlmIGRpcmVjdGlvbiBpcyBob3Jpem9udGFsXG4gICAgICBpZiAoKE1hdGguYWJzKGR4KSA+IE1hdGguYWJzKGR5KSB8fCB0aGlzLm9wdGlvbnMuc21vb3RoLmZvcmNlRGlyZWN0aW9uID09PSB0cnVlIHx8IHRoaXMub3B0aW9ucy5zbW9vdGguZm9yY2VEaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiKSAmJiB0aGlzLm9wdGlvbnMuc21vb3RoLmZvcmNlRGlyZWN0aW9uICE9PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgICAgeTEgPSB0aGlzLmZyb20ueTtcbiAgICAgICAgeTIgPSB0aGlzLnRvLnk7XG4gICAgICAgIHgxID0gdGhpcy5mcm9tLnggLSByb3VuZG5lc3MgKiBkeDtcbiAgICAgICAgeDIgPSB0aGlzLnRvLnggKyByb3VuZG5lc3MgKiBkeDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkxID0gdGhpcy5mcm9tLnkgLSByb3VuZG5lc3MgKiBkeTtcbiAgICAgICAgeTIgPSB0aGlzLnRvLnkgKyByb3VuZG5lc3MgKiBkeTtcbiAgICAgICAgeDEgPSB0aGlzLmZyb20ueDtcbiAgICAgICAgeDIgPSB0aGlzLnRvLng7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgeDogeDEsXG4gICAgICAgIHk6IHkxXG4gICAgICB9LCB7XG4gICAgICAgIHg6IHgyLFxuICAgICAgICB5OiB5MlxuICAgICAgfV07XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFZpYU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmlhTm9kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZmluZEJvcmRlclBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb24obmVhck5vZGUsIGN0eCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkJlemllcihuZWFyTm9kZSwgY3R4KTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldERpc3RhbmNlVG9FZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0YW5jZVRvRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogdGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKSxcbiAgICAgICAgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgdmlhMSA9IF9yZWYyWzBdLFxuICAgICAgICB2aWEyID0gX3JlZjJbMV07XG4gICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgIHJldHVybiB0aGlzLl9nZXREaXN0YW5jZVRvQmV6aWVyRWRnZTIoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdmlhMSwgdmlhMik7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50KHBvc2l0aW9uKSB7XG4gICAgICB2YXIgX3JlZjMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCksXG4gICAgICAgIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDIpLFxuICAgICAgICB2aWExID0gX3JlZjRbMF0sXG4gICAgICAgIHZpYTIgPSBfcmVmNFsxXTtcbiAgICAgIHZhciB0ID0gcG9zaXRpb247XG4gICAgICB2YXIgdmVjID0gW01hdGgucG93KDEgLSB0LCAzKSwgMyAqIHQgKiBNYXRoLnBvdygxIC0gdCwgMiksIDMgKiBNYXRoLnBvdyh0LCAyKSAqICgxIC0gdCksIE1hdGgucG93KHQsIDMpXTtcbiAgICAgIHZhciB4ID0gdmVjWzBdICogdGhpcy5mcm9tUG9pbnQueCArIHZlY1sxXSAqIHZpYTEueCArIHZlY1syXSAqIHZpYTIueCArIHZlY1szXSAqIHRoaXMudG9Qb2ludC54O1xuICAgICAgdmFyIHkgPSB2ZWNbMF0gKiB0aGlzLmZyb21Qb2ludC55ICsgdmVjWzFdICogdmlhMS55ICsgdmVjWzJdICogdmlhMi55ICsgdmVjWzNdICogdGhpcy50b1BvaW50Lnk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ3ViaWNCZXppZXJFZGdlO1xufShDdWJpY0JlemllckVkZ2VCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDQoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBfUmVmbGVjdCRjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIV9SZWZsZWN0JGNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoX1JlZmxlY3QkY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKF9SZWZsZWN0JGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxyXG4gKiBBIFN0cmFpZ2h0IEVkZ2UuXHJcbiAqL1xudmFyIFN0cmFpZ2h0RWRnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VkZ2VCYXNlKSB7XG4gIF9pbmhlcml0cyhTdHJhaWdodEVkZ2UsIF9FZGdlQmFzZSk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkNChTdHJhaWdodEVkZ2UpO1xuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdCBvZiBnaXZlbiBlZGdlLlxyXG4gICAqIEBwYXJhbSBib2R5IC0gVGhlIGJvZHkgb2YgdGhlIG5ldHdvcmsuXHJcbiAgICogQHBhcmFtIGxhYmVsTW9kdWxlIC0gTGFiZWwgbW9kdWxlLlxyXG4gICAqL1xuICBmdW5jdGlvbiBTdHJhaWdodEVkZ2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RyYWlnaHRFZGdlKTtcbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBfY3JlYXRlQ2xhc3MoU3RyYWlnaHRFZGdlLCBbe1xuICAgIGtleTogXCJfbGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbGluZShjdHgsIHZhbHVlcykge1xuICAgICAgLy8gZHJhdyBhIHN0cmFpZ2h0IGxpbmVcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8odGhpcy5mcm9tUG9pbnQueCwgdGhpcy5mcm9tUG9pbnQueSk7XG4gICAgICBjdHgubGluZVRvKHRoaXMudG9Qb2ludC54LCB0aGlzLnRvUG9pbnQueSk7XG4gICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRWaWFOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpYU5vZGUoKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludChwb3NpdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogKDEgLSBwb3NpdGlvbikgKiB0aGlzLmZyb21Qb2ludC54ICsgcG9zaXRpb24gKiB0aGlzLnRvUG9pbnQueCxcbiAgICAgICAgeTogKDEgLSBwb3NpdGlvbikgKiB0aGlzLmZyb21Qb2ludC55ICsgcG9zaXRpb24gKiB0aGlzLnRvUG9pbnQueVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmRCb3JkZXJQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZEJvcmRlclBvc2l0aW9uKG5lYXJOb2RlLCBjdHgpIHtcbiAgICAgIHZhciBub2RlMSA9IHRoaXMudG87XG4gICAgICB2YXIgbm9kZTIgPSB0aGlzLmZyb207XG4gICAgICBpZiAobmVhck5vZGUuaWQgPT09IHRoaXMuZnJvbS5pZCkge1xuICAgICAgICBub2RlMSA9IHRoaXMuZnJvbTtcbiAgICAgICAgbm9kZTIgPSB0aGlzLnRvO1xuICAgICAgfVxuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihub2RlMS55IC0gbm9kZTIueSwgbm9kZTEueCAtIG5vZGUyLngpO1xuICAgICAgdmFyIGR4ID0gbm9kZTEueCAtIG5vZGUyLng7XG4gICAgICB2YXIgZHkgPSBub2RlMS55IC0gbm9kZTIueTtcbiAgICAgIHZhciBlZGdlU2VnbWVudExlbmd0aCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICB2YXIgdG9Cb3JkZXJEaXN0ID0gbmVhck5vZGUuZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICAgIHZhciB0b0JvcmRlclBvaW50ID0gKGVkZ2VTZWdtZW50TGVuZ3RoIC0gdG9Cb3JkZXJEaXN0KSAvIGVkZ2VTZWdtZW50TGVuZ3RoO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogKDEgLSB0b0JvcmRlclBvaW50KSAqIG5vZGUyLnggKyB0b0JvcmRlclBvaW50ICogbm9kZTEueCxcbiAgICAgICAgeTogKDEgLSB0b0JvcmRlclBvaW50KSAqIG5vZGUyLnkgKyB0b0JvcmRlclBvaW50ICogbm9kZTEueSxcbiAgICAgICAgdDogMFxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldERpc3RhbmNlVG9FZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0YW5jZVRvRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgIHJldHVybiB0aGlzLl9nZXREaXN0YW5jZVRvTGluZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN0cmFpZ2h0RWRnZTtcbn0oRWRnZUJhc2UpO1xuXG4vKipcbiAqIEFuIGVkZ2UgY29ubmVjdHMgdHdvIG5vZGVzIGFuZCBoYXMgYSBzcGVjaWZpYyBkaXJlY3Rpb24uXG4gKi9cbnZhciBFZGdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICAgICAgICB2YWx1ZXMgc3BlY2lmaWMgdG8gdGhpcyBlZGdlLCBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgJ2Zyb20nIGFuZCAndG8nXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5ICAgICAgICAgICBzaGFyZWQgc3RhdGUgZnJvbSBOZXR3b3JrIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TmV0d29yay5JbWFnZXN9IGltYWdlbGlzdCAgQSBsaXN0IHdpdGggaW1hZ2VzLiBPbmx5IG5lZWRlZCB3aGVuIHRoZSBlZGdlIGhhcyBpbWFnZSBhcnJvd3MuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxPcHRpb25zICBvcHRpb25zIGZyb20gdGhlIEVkZ2VzSGFuZGxlciBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge29iamVjdH0gZGVmYXVsdE9wdGlvbnMgZGVmYXVsdCBvcHRpb25zIGZyb20gdGhlIEVkZ2VIYW5kbGVyIGluc3RhbmNlLiBWYWx1ZSBhbmQgcmVmZXJlbmNlIGFyZSBjb25zdGFudFxuICAgKi9cbiAgZnVuY3Rpb24gRWRnZShvcHRpb25zLCBib2R5LCBpbWFnZWxpc3QsIGdsb2JhbE9wdGlvbnMsIGRlZmF1bHRPcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkZ2UpO1xuICAgIGlmIChib2R5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGJvZHkgcHJvdmlkZWRcIik7XG4gICAgfVxuXG4gICAgLy8gU2luY2UgZ2xvYmFsT3B0aW9ucyBpcyBjb25zdGFudCBpbiB2YWx1ZXMgYXMgd2VsbCBhcyByZWZlcmVuY2UsXG4gICAgLy8gRm9sbG93aW5nIG5lZWRzIHRvIGJlIGRvbmUgb25seSBvbmNlLlxuXG4gICAgdGhpcy5vcHRpb25zID0gYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMpO1xuICAgIHRoaXMuZ2xvYmFsT3B0aW9ucyA9IGdsb2JhbE9wdGlvbnM7XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5pbWFnZWxpc3QgPSBpbWFnZWxpc3Q7XG5cbiAgICAvLyBpbml0aWFsaXplIHZhcmlhYmxlc1xuICAgIHRoaXMuaWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mcm9tSWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b0lkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmhvdmVyID0gZmFsc2U7XG4gICAgdGhpcy5sYWJlbERpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLmJhc2VXaWR0aCA9IHRoaXMub3B0aW9ucy53aWR0aDtcbiAgICB0aGlzLmJhc2VGb250U2l6ZSA9IHRoaXMub3B0aW9ucy5mb250LnNpemU7XG4gICAgdGhpcy5mcm9tID0gdW5kZWZpbmVkOyAvLyBhIG5vZGVcbiAgICB0aGlzLnRvID0gdW5kZWZpbmVkOyAvLyBhIG5vZGVcblxuICAgIHRoaXMuZWRnZVR5cGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxhYmVsTW9kdWxlID0gbmV3IExhYmVsKHRoaXMuYm9keSwgdGhpcy5vcHRpb25zLCB0cnVlIC8qIEl0J3MgYW4gZWRnZSBsYWJlbCAqLyk7XG5cbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IG9yIG92ZXJ3cml0ZSBvcHRpb25zIGZvciB0aGUgZWRnZVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgYW4gb2JqZWN0IHdpdGggb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfGJvb2xlYW59IHVuZGVmaW5lZCBpZiBubyBvcHRpb25zLCB0cnVlIGlmIGxheW91dCBhZmZlY3RpbmcgZGF0YSBjaGFuZ2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoRWRnZSwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEZvbGxvd2luZyBvcHRpb25zIGlmIGNoYW5nZWQgYWZmZWN0IHRoZSBsYXlvdXQuXG4gICAgICB2YXIgYWZmZWN0c0xheW91dCA9IHR5cGVvZiBvcHRpb25zLnBoeXNpY3MgIT09IFwidW5kZWZpbmVkXCIgJiYgdGhpcy5vcHRpb25zLnBoeXNpY3MgIT09IG9wdGlvbnMucGh5c2ljcyB8fCB0eXBlb2Ygb3B0aW9ucy5oaWRkZW4gIT09IFwidW5kZWZpbmVkXCIgJiYgKHRoaXMub3B0aW9ucy5oaWRkZW4gfHwgZmFsc2UpICE9PSAob3B0aW9ucy5oaWRkZW4gfHwgZmFsc2UpIHx8IHR5cGVvZiBvcHRpb25zLmZyb20gIT09IFwidW5kZWZpbmVkXCIgJiYgdGhpcy5vcHRpb25zLmZyb20gIT09IG9wdGlvbnMuZnJvbSB8fCB0eXBlb2Ygb3B0aW9ucy50byAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0aGlzLm9wdGlvbnMudG8gIT09IG9wdGlvbnMudG87XG4gICAgICBFZGdlLnBhcnNlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsIHRydWUsIHRoaXMuZ2xvYmFsT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaWQgPSBvcHRpb25zLmlkO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZnJvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZnJvbUlkID0gb3B0aW9ucy5mcm9tO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnRvSWQgPSBvcHRpb25zLnRvO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudGl0bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnRpdGxlID0gb3B0aW9ucy50aXRsZTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy52YWx1ZSA9IF9wYXJzZUZsb2F0JDEob3B0aW9ucy52YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgcGlsZSA9IFtvcHRpb25zLCB0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnNdO1xuICAgICAgdGhpcy5jaG9vc2VyID0gY2hvb3NpZnkoXCJlZGdlXCIsIHBpbGUpO1xuXG4gICAgICAvLyB1cGRhdGUgbGFiZWwgTW9kdWxlXG4gICAgICB0aGlzLnVwZGF0ZUxhYmVsTW9kdWxlKG9wdGlvbnMpO1xuXG4gICAgICAvLyBVcGRhdGUgZWRnZSB0eXBlLCB0aGlzIGlmIGNoYW5nZWQgYWZmZWN0cyB0aGUgbGF5b3V0LlxuICAgICAgYWZmZWN0c0xheW91dCA9IHRoaXMudXBkYXRlRWRnZVR5cGUoKSB8fCBhZmZlY3RzTGF5b3V0O1xuXG4gICAgICAvLyBpZiBhbnl0aGluZyBoYXMgYmVlbiB1cGRhdGVzLCByZXNldCB0aGUgc2VsZWN0aW9uIHdpZHRoIGFuZCB0aGUgaG92ZXIgd2lkdGhcbiAgICAgIHRoaXMuX3NldEludGVyYWN0aW9uV2lkdGhzKCk7XG5cbiAgICAgIC8vIEEgbm9kZSBpcyBjb25uZWN0ZWQgd2hlbiBpdCBoYXMgYSBmcm9tIGFuZCB0byBub2RlIHRoYXQgYm90aCBleGlzdCBpbiB0aGUgbmV0d29yay5ib2R5Lm5vZGVzLlxuICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICByZXR1cm4gYWZmZWN0c0xheW91dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRPcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5ld09wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthbGxvd0RlbGV0aW9uPWZhbHNlXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbZ2xvYmFsT3B0aW9ucz17fV1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjb3B5RnJvbUdsb2JhbHM9ZmFsc2VdXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Rm9ybWF0dGluZ1ZhbHVlc1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Fycm93T3B0aW9uc31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRGb3JtYXR0aW5nVmFsdWVzKCkge1xuICAgICAgdmFyIHRvQXJyb3cgPSB0aGlzLm9wdGlvbnMuYXJyb3dzLnRvID09PSB0cnVlIHx8IHRoaXMub3B0aW9ucy5hcnJvd3MudG8uZW5hYmxlZCA9PT0gdHJ1ZTtcbiAgICAgIHZhciBmcm9tQXJyb3cgPSB0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20gPT09IHRydWUgfHwgdGhpcy5vcHRpb25zLmFycm93cy5mcm9tLmVuYWJsZWQgPT09IHRydWU7XG4gICAgICB2YXIgbWlkZGxlQXJyb3cgPSB0aGlzLm9wdGlvbnMuYXJyb3dzLm1pZGRsZSA9PT0gdHJ1ZSB8fCB0aGlzLm9wdGlvbnMuYXJyb3dzLm1pZGRsZS5lbmFibGVkID09PSB0cnVlO1xuICAgICAgdmFyIGluaGVyaXRzQ29sb3IgPSB0aGlzLm9wdGlvbnMuY29sb3IuaW5oZXJpdDtcbiAgICAgIHZhciB2YWx1ZXMgPSB7XG4gICAgICAgIHRvQXJyb3c6IHRvQXJyb3csXG4gICAgICAgIHRvQXJyb3dTY2FsZTogdGhpcy5vcHRpb25zLmFycm93cy50by5zY2FsZUZhY3RvcixcbiAgICAgICAgdG9BcnJvd1R5cGU6IHRoaXMub3B0aW9ucy5hcnJvd3MudG8udHlwZSxcbiAgICAgICAgdG9BcnJvd1NyYzogdGhpcy5vcHRpb25zLmFycm93cy50by5zcmMsXG4gICAgICAgIHRvQXJyb3dJbWFnZVdpZHRoOiB0aGlzLm9wdGlvbnMuYXJyb3dzLnRvLmltYWdlV2lkdGgsXG4gICAgICAgIHRvQXJyb3dJbWFnZUhlaWdodDogdGhpcy5vcHRpb25zLmFycm93cy50by5pbWFnZUhlaWdodCxcbiAgICAgICAgbWlkZGxlQXJyb3c6IG1pZGRsZUFycm93LFxuICAgICAgICBtaWRkbGVBcnJvd1NjYWxlOiB0aGlzLm9wdGlvbnMuYXJyb3dzLm1pZGRsZS5zY2FsZUZhY3RvcixcbiAgICAgICAgbWlkZGxlQXJyb3dUeXBlOiB0aGlzLm9wdGlvbnMuYXJyb3dzLm1pZGRsZS50eXBlLFxuICAgICAgICBtaWRkbGVBcnJvd1NyYzogdGhpcy5vcHRpb25zLmFycm93cy5taWRkbGUuc3JjLFxuICAgICAgICBtaWRkbGVBcnJvd0ltYWdlV2lkdGg6IHRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlLmltYWdlV2lkdGgsXG4gICAgICAgIG1pZGRsZUFycm93SW1hZ2VIZWlnaHQ6IHRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlLmltYWdlSGVpZ2h0LFxuICAgICAgICBmcm9tQXJyb3c6IGZyb21BcnJvdyxcbiAgICAgICAgZnJvbUFycm93U2NhbGU6IHRoaXMub3B0aW9ucy5hcnJvd3MuZnJvbS5zY2FsZUZhY3RvcixcbiAgICAgICAgZnJvbUFycm93VHlwZTogdGhpcy5vcHRpb25zLmFycm93cy5mcm9tLnR5cGUsXG4gICAgICAgIGZyb21BcnJvd1NyYzogdGhpcy5vcHRpb25zLmFycm93cy5mcm9tLnNyYyxcbiAgICAgICAgZnJvbUFycm93SW1hZ2VXaWR0aDogdGhpcy5vcHRpb25zLmFycm93cy5mcm9tLmltYWdlV2lkdGgsXG4gICAgICAgIGZyb21BcnJvd0ltYWdlSGVpZ2h0OiB0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20uaW1hZ2VIZWlnaHQsXG4gICAgICAgIGFycm93U3RyaWtldGhyb3VnaDogdGhpcy5vcHRpb25zLmFycm93U3RyaWtldGhyb3VnaCxcbiAgICAgICAgY29sb3I6IGluaGVyaXRzQ29sb3IgPyB1bmRlZmluZWQgOiB0aGlzLm9wdGlvbnMuY29sb3IuY29sb3IsXG4gICAgICAgIGluaGVyaXRzQ29sb3I6IGluaGVyaXRzQ29sb3IsXG4gICAgICAgIG9wYWNpdHk6IHRoaXMub3B0aW9ucy5jb2xvci5vcGFjaXR5LFxuICAgICAgICBoaWRkZW46IHRoaXMub3B0aW9ucy5oaWRkZW4sXG4gICAgICAgIGxlbmd0aDogdGhpcy5vcHRpb25zLmxlbmd0aCxcbiAgICAgICAgc2hhZG93OiB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQsXG4gICAgICAgIHNoYWRvd0NvbG9yOiB0aGlzLm9wdGlvbnMuc2hhZG93LmNvbG9yLFxuICAgICAgICBzaGFkb3dTaXplOiB0aGlzLm9wdGlvbnMuc2hhZG93LnNpemUsXG4gICAgICAgIHNoYWRvd1g6IHRoaXMub3B0aW9ucy5zaGFkb3cueCxcbiAgICAgICAgc2hhZG93WTogdGhpcy5vcHRpb25zLnNoYWRvdy55LFxuICAgICAgICBkYXNoZXM6IHRoaXMub3B0aW9ucy5kYXNoZXMsXG4gICAgICAgIHdpZHRoOiB0aGlzLm9wdGlvbnMud2lkdGgsXG4gICAgICAgIGJhY2tncm91bmQ6IHRoaXMub3B0aW9ucy5iYWNrZ3JvdW5kLmVuYWJsZWQsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5vcHRpb25zLmJhY2tncm91bmQuY29sb3IsXG4gICAgICAgIGJhY2tncm91bmRTaXplOiB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZC5zaXplLFxuICAgICAgICBiYWNrZ3JvdW5kRGFzaGVzOiB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZC5kYXNoZXNcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZCB8fCB0aGlzLmhvdmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNob29zZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkV2lkdGggPSB0aGlzLm9wdGlvbnMuc2VsZWN0aW9uV2lkdGg7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGVjdGVkV2lkdGggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICB2YWx1ZXMud2lkdGggPSBzZWxlY3RlZFdpZHRoKHZhbHVlcy53aWR0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxlY3RlZFdpZHRoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgIHZhbHVlcy53aWR0aCArPSBzZWxlY3RlZFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzLndpZHRoID0gTWF0aC5tYXgodmFsdWVzLndpZHRoLCAwLjMgLyB0aGlzLmJvZHkudmlldy5zY2FsZSk7XG4gICAgICAgICAgICB2YWx1ZXMuY29sb3IgPSB0aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0O1xuICAgICAgICAgICAgdmFsdWVzLnNoYWRvdyA9IHRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaG92ZXIpIHtcbiAgICAgICAgICAgIHZhciBob3ZlcldpZHRoID0gdGhpcy5vcHRpb25zLmhvdmVyV2lkdGg7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGhvdmVyV2lkdGggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICB2YWx1ZXMud2lkdGggPSBob3ZlcldpZHRoKHZhbHVlcy53aWR0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBob3ZlcldpZHRoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgIHZhbHVlcy53aWR0aCArPSBob3ZlcldpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzLndpZHRoID0gTWF0aC5tYXgodmFsdWVzLndpZHRoLCAwLjMgLyB0aGlzLmJvZHkudmlldy5zY2FsZSk7XG4gICAgICAgICAgICB2YWx1ZXMuY29sb3IgPSB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXI7XG4gICAgICAgICAgICB2YWx1ZXMuc2hhZG93ID0gdGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5jaG9vc2VyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLmNob29zZXIodmFsdWVzLCB0aGlzLm9wdGlvbnMuaWQsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpO1xuICAgICAgICAgIGlmICh2YWx1ZXMuY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWVzLmluaGVyaXRzQ29sb3IgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlcy5zaGFkb3cgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzLnNoYWRvd0NvbG9yICE9PSB0aGlzLm9wdGlvbnMuc2hhZG93LmNvbG9yIHx8IHZhbHVlcy5zaGFkb3dTaXplICE9PSB0aGlzLm9wdGlvbnMuc2hhZG93LnNpemUgfHwgdmFsdWVzLnNoYWRvd1ggIT09IHRoaXMub3B0aW9ucy5zaGFkb3cueCB8fCB2YWx1ZXMuc2hhZG93WSAhPT0gdGhpcy5vcHRpb25zLnNoYWRvdy55KSB7XG4gICAgICAgICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzLnNoYWRvdyA9IHRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZDtcbiAgICAgICAgdmFsdWVzLndpZHRoID0gTWF0aC5tYXgodmFsdWVzLndpZHRoLCAwLjMgLyB0aGlzLmJvZHkudmlldy5zY2FsZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgb3B0aW9ucyBpbiB0aGUgbGFiZWwgbW9kdWxlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUxhYmVsTW9kdWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUxhYmVsTW9kdWxlKG9wdGlvbnMpIHtcbiAgICAgIHZhciBwaWxlID0gW29wdGlvbnMsIHRoaXMub3B0aW9ucywgdGhpcy5nbG9iYWxPcHRpb25zLFxuICAgICAgLy8gQ3VycmVudGx5IHNldCBnbG9iYWwgZWRnZSBvcHRpb25zXG4gICAgICB0aGlzLmRlZmF1bHRPcHRpb25zXTtcbiAgICAgIHRoaXMubGFiZWxNb2R1bGUudXBkYXRlKHRoaXMub3B0aW9ucywgcGlsZSk7XG4gICAgICBpZiAodGhpcy5sYWJlbE1vZHVsZS5iYXNlU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYmFzZUZvbnRTaXplID0gdGhpcy5sYWJlbE1vZHVsZS5iYXNlU2l6ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIGVkZ2UgdHlwZSwgc2V0IHRoZSBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVFZGdlVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVFZGdlVHlwZSgpIHtcbiAgICAgIHZhciBzbW9vdGggPSB0aGlzLm9wdGlvbnMuc21vb3RoO1xuICAgICAgdmFyIGRhdGFDaGFuZ2VkID0gZmFsc2U7XG4gICAgICB2YXIgY2hhbmdlSW5UeXBlID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLmVkZ2VUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuZWRnZVR5cGUgaW5zdGFuY2VvZiBCZXppZXJFZGdlRHluYW1pYyAmJiBzbW9vdGguZW5hYmxlZCA9PT0gdHJ1ZSAmJiBzbW9vdGgudHlwZSA9PT0gXCJkeW5hbWljXCIgfHwgdGhpcy5lZGdlVHlwZSBpbnN0YW5jZW9mIEN1YmljQmV6aWVyRWRnZSAmJiBzbW9vdGguZW5hYmxlZCA9PT0gdHJ1ZSAmJiBzbW9vdGgudHlwZSA9PT0gXCJjdWJpY0JlemllclwiIHx8IHRoaXMuZWRnZVR5cGUgaW5zdGFuY2VvZiBCZXppZXJFZGdlU3RhdGljICYmIHNtb290aC5lbmFibGVkID09PSB0cnVlICYmIHNtb290aC50eXBlICE9PSBcImR5bmFtaWNcIiAmJiBzbW9vdGgudHlwZSAhPT0gXCJjdWJpY0JlemllclwiIHx8IHRoaXMuZWRnZVR5cGUgaW5zdGFuY2VvZiBTdHJhaWdodEVkZ2UgJiYgc21vb3RoLnR5cGUuZW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjaGFuZ2VJblR5cGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlSW5UeXBlID09PSB0cnVlKSB7XG4gICAgICAgICAgZGF0YUNoYW5nZWQgPSB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoYW5nZUluVHlwZSA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoc21vb3RoLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAoc21vb3RoLnR5cGUgPT09IFwiZHluYW1pY1wiKSB7XG4gICAgICAgICAgICBkYXRhQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVkZ2VUeXBlID0gbmV3IEJlemllckVkZ2VEeW5hbWljKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNtb290aC50eXBlID09PSBcImN1YmljQmV6aWVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZWRnZVR5cGUgPSBuZXcgQ3ViaWNCZXppZXJFZGdlKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lZGdlVHlwZSA9IG5ldyBCZXppZXJFZGdlU3RhdGljKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lZGdlVHlwZSA9IG5ldyBTdHJhaWdodEVkZ2UodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBub3RoaW5nIGNoYW5nZXMsIHdlIGp1c3Qgc2V0IHRoZSBvcHRpb25zLlxuICAgICAgICB0aGlzLmVkZ2VUeXBlLnNldE9wdGlvbnModGhpcy5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhQ2hhbmdlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IGFuIGVkZ2UgdG8gaXRzIG5vZGVzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY29ubmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25uZWN0KCkge1xuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLmZyb20gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5mcm9tSWRdIHx8IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMudG8gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy50b0lkXSB8fCB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmNvbm5lY3RlZCA9IHRoaXMuZnJvbSAhPT0gdW5kZWZpbmVkICYmIHRoaXMudG8gIT09IHVuZGVmaW5lZDtcbiAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmZyb20uYXR0YWNoRWRnZSh0aGlzKTtcbiAgICAgICAgdGhpcy50by5hdHRhY2hFZGdlKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZnJvbSkge1xuICAgICAgICAgIHRoaXMuZnJvbS5kZXRhY2hFZGdlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRvKSB7XG4gICAgICAgICAgdGhpcy50by5kZXRhY2hFZGdlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmVkZ2VUeXBlLmNvbm5lY3QoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0IGFuIGVkZ2UgZnJvbSBpdHMgbm9kZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkaXNjb25uZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2Nvbm5lY3QoKSB7XG4gICAgICBpZiAodGhpcy5mcm9tKSB7XG4gICAgICAgIHRoaXMuZnJvbS5kZXRhY2hFZGdlKHRoaXMpO1xuICAgICAgICB0aGlzLmZyb20gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50bykge1xuICAgICAgICB0aGlzLnRvLmRldGFjaEVkZ2UodGhpcyk7XG4gICAgICAgIHRoaXMudG8gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgdGl0bGUgb2YgdGhpcyBlZGdlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdGl0bGUgICAgVGhlIHRpdGxlIG9mIHRoZSBlZGdlLCBvciB1bmRlZmluZWQgd2hlbiBubyB0aXRsZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzIGJlZW4gc2V0LlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFRpdGxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRpdGxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGl0bGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2hlY2sgaWYgdGhpcyBub2RlIGlzIHNlbGVjdGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBzZWxlY3RlZCAgIFRydWUgaWYgbm9kZSBpcyBzZWxlY3RlZCwgZWxzZSBmYWxzZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImlzU2VsZWN0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNTZWxlY3RlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSB2YWx1ZSBvZiB0aGUgZWRnZS4gQ2FuIGJlIHVuZGVmaW5lZFxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn0gdmFsdWVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0IHRoZSB2YWx1ZSByYW5nZSBvZiB0aGUgZWRnZS4gVGhlIGVkZ2Ugd2lsbCBhZGp1c3QgaXQncyB3aWR0aFxuICAgICAqIGJhc2VkIG9uIGl0cyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VmFsdWVSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZVJhbmdlKG1pbiwgbWF4LCB0b3RhbCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLmN1c3RvbVNjYWxpbmdGdW5jdGlvbihtaW4sIG1heCwgdG90YWwsIHRoaXMub3B0aW9ucy52YWx1ZSk7XG4gICAgICAgIHZhciB3aWR0aERpZmYgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5tYXggLSB0aGlzLm9wdGlvbnMuc2NhbGluZy5taW47XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGZvbnREaWZmID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWF4IC0gdGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWluO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5mb250LnNpemUgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5taW4gKyBzY2FsZSAqIGZvbnREaWZmO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucy53aWR0aCA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLm1pbiArIHNjYWxlICogd2lkdGhEaWZmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLndpZHRoID0gdGhpcy5iYXNlV2lkdGg7XG4gICAgICAgIHRoaXMub3B0aW9ucy5mb250LnNpemUgPSB0aGlzLmJhc2VGb250U2l6ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldEludGVyYWN0aW9uV2lkdGhzKCk7XG4gICAgICB0aGlzLnVwZGF0ZUxhYmVsTW9kdWxlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9zZXRJbnRlcmFjdGlvbldpZHRoc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0SW50ZXJhY3Rpb25XaWR0aHMoKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5ob3ZlcldpZHRoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5lZGdlVHlwZS5ob3ZlcldpZHRoID0gdGhpcy5vcHRpb25zLmhvdmVyV2lkdGgodGhpcy5vcHRpb25zLndpZHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWRnZVR5cGUuaG92ZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ob3ZlcldpZHRoICsgdGhpcy5vcHRpb25zLndpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuc2VsZWN0aW9uV2lkdGggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLnNlbGVjdGlvbldpZHRoID0gdGhpcy5vcHRpb25zLnNlbGVjdGlvbldpZHRoKHRoaXMub3B0aW9ucy53aWR0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLnNlbGVjdGlvbldpZHRoID0gdGhpcy5vcHRpb25zLnNlbGVjdGlvbldpZHRoICsgdGhpcy5vcHRpb25zLndpZHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZHJhdyBhIGVkZ2VcbiAgICAgKiBEcmF3IHRoaXMgZWRnZSBpbiB0aGUgZ2l2ZW4gY2FudmFzXG4gICAgICogVGhlIDJkIGNvbnRleHQgb2YgYSBIVE1MIGNhbnZhcyBjYW4gYmUgcmV0cmlldmVkIGJ5IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gICBjdHhcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICB2YXIgdmFsdWVzID0gdGhpcy5nZXRGb3JtYXR0aW5nVmFsdWVzKCk7XG4gICAgICBpZiAodmFsdWVzLmhpZGRlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGdldCB0aGUgdmlhIG5vZGUgZnJvbSB0aGUgZWRnZSB0eXBlXG4gICAgICB2YXIgdmlhTm9kZSA9IHRoaXMuZWRnZVR5cGUuZ2V0VmlhTm9kZSgpO1xuXG4gICAgICAvLyBkcmF3IGxpbmUgYW5kIGxhYmVsXG4gICAgICB0aGlzLmVkZ2VUeXBlLmRyYXdMaW5lKGN0eCwgdmFsdWVzLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCB2aWFOb2RlKTtcbiAgICAgIHRoaXMuZHJhd0xhYmVsKGN0eCwgdmlhTm9kZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVkcmF3IGFycm93c1xuICAgICAqIERyYXcgdGhpcyBhcnJvd3MgaW4gdGhlIGdpdmVuIGNhbnZhc1xuICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0Fycm93c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QXJyb3dzKGN0eCkge1xuICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZ2V0Rm9ybWF0dGluZ1ZhbHVlcygpO1xuICAgICAgaWYgKHZhbHVlcy5oaWRkZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQgdGhlIHZpYSBub2RlIGZyb20gdGhlIGVkZ2UgdHlwZVxuICAgICAgdmFyIHZpYU5vZGUgPSB0aGlzLmVkZ2VUeXBlLmdldFZpYU5vZGUoKTtcbiAgICAgIHZhciBhcnJvd0RhdGEgPSB7fTtcblxuICAgICAgLy8gcmVzdG9yZSBlZGdlIHRhcmdldHMgdG8gZGVmYXVsdHNcbiAgICAgIHRoaXMuZWRnZVR5cGUuZnJvbVBvaW50ID0gdGhpcy5lZGdlVHlwZS5mcm9tO1xuICAgICAgdGhpcy5lZGdlVHlwZS50b1BvaW50ID0gdGhpcy5lZGdlVHlwZS50bztcblxuICAgICAgLy8gZnJvbSBhbmQgdG8gYXJyb3dzIGdpdmUgYSBkaWZmZXJlbnQgZW5kIHBvaW50IGZvciBlZGdlcy4gd2Ugc2V0IHRoZW0gaGVyZVxuICAgICAgaWYgKHZhbHVlcy5mcm9tQXJyb3cpIHtcbiAgICAgICAgYXJyb3dEYXRhLmZyb20gPSB0aGlzLmVkZ2VUeXBlLmdldEFycm93RGF0YShjdHgsIFwiZnJvbVwiLCB2aWFOb2RlLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCB2YWx1ZXMpO1xuICAgICAgICBpZiAodmFsdWVzLmFycm93U3RyaWtldGhyb3VnaCA9PT0gZmFsc2UpIHRoaXMuZWRnZVR5cGUuZnJvbVBvaW50ID0gYXJyb3dEYXRhLmZyb20uY29yZTtcbiAgICAgICAgaWYgKHZhbHVlcy5mcm9tQXJyb3dTcmMpIHtcbiAgICAgICAgICBhcnJvd0RhdGEuZnJvbS5pbWFnZSA9IHRoaXMuaW1hZ2VsaXN0LmxvYWQodmFsdWVzLmZyb21BcnJvd1NyYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlcy5mcm9tQXJyb3dJbWFnZVdpZHRoKSB7XG4gICAgICAgICAgYXJyb3dEYXRhLmZyb20uaW1hZ2VXaWR0aCA9IHZhbHVlcy5mcm9tQXJyb3dJbWFnZVdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZXMuZnJvbUFycm93SW1hZ2VIZWlnaHQpIHtcbiAgICAgICAgICBhcnJvd0RhdGEuZnJvbS5pbWFnZUhlaWdodCA9IHZhbHVlcy5mcm9tQXJyb3dJbWFnZUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZhbHVlcy50b0Fycm93KSB7XG4gICAgICAgIGFycm93RGF0YS50byA9IHRoaXMuZWRnZVR5cGUuZ2V0QXJyb3dEYXRhKGN0eCwgXCJ0b1wiLCB2aWFOb2RlLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCB2YWx1ZXMpO1xuICAgICAgICBpZiAodmFsdWVzLmFycm93U3RyaWtldGhyb3VnaCA9PT0gZmFsc2UpIHRoaXMuZWRnZVR5cGUudG9Qb2ludCA9IGFycm93RGF0YS50by5jb3JlO1xuICAgICAgICBpZiAodmFsdWVzLnRvQXJyb3dTcmMpIHtcbiAgICAgICAgICBhcnJvd0RhdGEudG8uaW1hZ2UgPSB0aGlzLmltYWdlbGlzdC5sb2FkKHZhbHVlcy50b0Fycm93U3JjKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVzLnRvQXJyb3dJbWFnZVdpZHRoKSB7XG4gICAgICAgICAgYXJyb3dEYXRhLnRvLmltYWdlV2lkdGggPSB2YWx1ZXMudG9BcnJvd0ltYWdlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlcy50b0Fycm93SW1hZ2VIZWlnaHQpIHtcbiAgICAgICAgICBhcnJvd0RhdGEudG8uaW1hZ2VIZWlnaHQgPSB2YWx1ZXMudG9BcnJvd0ltYWdlSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRoZSBtaWRkbGUgYXJyb3cgZGVwZW5kcyBvbiB0aGUgbGluZSwgd2hpY2ggY2FuIGRlcGVuZCBvbiB0aGUgdG8gYW5kIGZyb20gYXJyb3dzIHNvIHdlIGRvIHRoaXMgb25lIGxhc3RseS5cbiAgICAgIGlmICh2YWx1ZXMubWlkZGxlQXJyb3cpIHtcbiAgICAgICAgYXJyb3dEYXRhLm1pZGRsZSA9IHRoaXMuZWRnZVR5cGUuZ2V0QXJyb3dEYXRhKGN0eCwgXCJtaWRkbGVcIiwgdmlhTm9kZSwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlciwgdmFsdWVzKTtcbiAgICAgICAgaWYgKHZhbHVlcy5taWRkbGVBcnJvd1NyYykge1xuICAgICAgICAgIGFycm93RGF0YS5taWRkbGUuaW1hZ2UgPSB0aGlzLmltYWdlbGlzdC5sb2FkKHZhbHVlcy5taWRkbGVBcnJvd1NyYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlcy5taWRkbGVBcnJvd0ltYWdlV2lkdGgpIHtcbiAgICAgICAgICBhcnJvd0RhdGEubWlkZGxlLmltYWdlV2lkdGggPSB2YWx1ZXMubWlkZGxlQXJyb3dJbWFnZVdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZXMubWlkZGxlQXJyb3dJbWFnZUhlaWdodCkge1xuICAgICAgICAgIGFycm93RGF0YS5taWRkbGUuaW1hZ2VIZWlnaHQgPSB2YWx1ZXMubWlkZGxlQXJyb3dJbWFnZUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZhbHVlcy5mcm9tQXJyb3cpIHtcbiAgICAgICAgdGhpcy5lZGdlVHlwZS5kcmF3QXJyb3dIZWFkKGN0eCwgdmFsdWVzLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCBhcnJvd0RhdGEuZnJvbSk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVzLm1pZGRsZUFycm93KSB7XG4gICAgICAgIHRoaXMuZWRnZVR5cGUuZHJhd0Fycm93SGVhZChjdHgsIHZhbHVlcywgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlciwgYXJyb3dEYXRhLm1pZGRsZSk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVzLnRvQXJyb3cpIHtcbiAgICAgICAgdGhpcy5lZGdlVHlwZS5kcmF3QXJyb3dIZWFkKGN0eCwgdmFsdWVzLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCBhcnJvd0RhdGEudG8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gdmlhTm9kZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRyYXdMYWJlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3TGFiZWwoY3R4LCB2aWFOb2RlKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gc2V0IHN0eWxlXG4gICAgICAgIHZhciBub2RlMSA9IHRoaXMuZnJvbTtcbiAgICAgICAgdmFyIG5vZGUyID0gdGhpcy50bztcbiAgICAgICAgaWYgKHRoaXMubGFiZWxNb2R1bGUuZGlmZmVyZW50U3RhdGUodGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlcikpIHtcbiAgICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmdldFRleHRTaXplKGN0eCwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3Zlcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBvaW50O1xuICAgICAgICBpZiAobm9kZTEuaWQgIT0gbm9kZTIuaWQpIHtcbiAgICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLnBvaW50VG9TZWxmID0gZmFsc2U7XG4gICAgICAgICAgcG9pbnQgPSB0aGlzLmVkZ2VUeXBlLmdldFBvaW50KDAuNSwgdmlhTm9kZSk7XG4gICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICB2YXIgcm90YXRpb25Qb2ludCA9IHRoaXMuX2dldFJvdGF0aW9uKGN0eCk7XG4gICAgICAgICAgaWYgKHJvdGF0aW9uUG9pbnQuYW5nbGUgIT0gMCkge1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShyb3RhdGlvblBvaW50LngsIHJvdGF0aW9uUG9pbnQueSk7XG4gICAgICAgICAgICBjdHgucm90YXRlKHJvdGF0aW9uUG9pbnQuYW5nbGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGRyYXcgdGhlIGxhYmVsXG4gICAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3Zlcik7XG5cbiAgICAgICAgICAvKlxuICAgICAgICAgIC8vIFVzZWZ1bCBkZWJ1ZyBjb2RlOiBkcmF3IGEgYm9yZGVyIGFyb3VuZCB0aGUgbGFiZWxcbiAgICAgICAgICAvLyBUaGlzIHNob3VsZCAqKm5vdCoqIGJlIGVuYWJsZWQgaW4gcHJvZHVjdGlvbiFcbiAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMubGFiZWxNb2R1bGUuZ2V0U2l6ZSgpOzsgLy8gOzsgaW50ZW50aW9uYWwgc28gbGludCBjYXRjaGVzIGl0XG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCIjZmYwMDAwXCI7XG4gICAgICAgICAgY3R4LnN0cm9rZVJlY3Qoc2l6ZS5sZWZ0LCBzaXplLnRvcCwgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuICAgICAgICAgIC8vIEVuZCAgZGVidWcgY29kZVxuICAgICAgICAgICovXG5cbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElnbm9yZSB0aGUgb3JpZW50YXRpb25zLlxuICAgICAgICAgIHRoaXMubGFiZWxNb2R1bGUucG9pbnRUb1NlbGYgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gZ2V0IGNpcmNsZSBjb29yZGluYXRlc1xuICAgICAgICAgIHZhciBjb29yZGluYXRlcyA9IGdldFNlbGZSZWZDb29yZGluYXRlcyhjdHgsIHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLmFuZ2xlLCB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5zaXplLCBub2RlMSk7XG4gICAgICAgICAgcG9pbnQgPSB0aGlzLl9wb2ludE9uQ2lyY2xlKGNvb3JkaW5hdGVzLngsIGNvb3JkaW5hdGVzLnksIHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLnNpemUsIHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLmFuZ2xlKTtcbiAgICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCBwb2ludC54LCBwb2ludC55LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBhbGwgdmlzdWFsIGVsZW1lbnRzIG9mIHRoaXMgZWRnZSBpbnN0YW5jZSwgaW4gd2hpY2ggdGhlIGdpdmVuXG4gICAgICogcG9pbnQgZmFsbHMgd2l0aGluIHRoZSBib3VuZGluZyBzaGFwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7cG9pbnR9IHBvaW50XG4gICAgICogQHJldHVybnMge0FycmF5LjxlZGdlQ2xpY2tJdGVtfGVkZ2VMYWJlbENsaWNrSXRlbT59IGxpc3Qgd2l0aCB0aGUgaXRlbXMgd2hpY2ggYXJlIG9uIHRoZSBwb2ludFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEl0ZW1zT25Qb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJdGVtc09uUG9pbnQocG9pbnQpIHtcbiAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgIGlmICh0aGlzLmxhYmVsTW9kdWxlLnZpc2libGUoKSkge1xuICAgICAgICB2YXIgcm90YXRpb25Qb2ludCA9IHRoaXMuX2dldFJvdGF0aW9uKCk7XG4gICAgICAgIGlmIChwb2ludEluUmVjdCh0aGlzLmxhYmVsTW9kdWxlLmdldFNpemUoKSwgcG9pbnQsIHJvdGF0aW9uUG9pbnQpKSB7XG4gICAgICAgICAgcmV0LnB1c2goe1xuICAgICAgICAgICAgZWRnZUlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgbGFiZWxJZDogMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0ge1xuICAgICAgICBsZWZ0OiBwb2ludC54LFxuICAgICAgICB0b3A6IHBvaW50LnlcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5pc092ZXJsYXBwaW5nV2l0aChvYmopKSB7XG4gICAgICAgIHJldC5wdXNoKHtcbiAgICAgICAgICBlZGdlSWQ6IHRoaXMuaWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgb2JqZWN0IGlzIG92ZXJsYXBwaW5nIHdpdGggdGhlIHByb3ZpZGVkIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iaiAgIGFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59ICAgICBUcnVlIGlmIGxvY2F0aW9uIGlzIGxvY2F0ZWQgb24gdGhlIGVkZ2VcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpc092ZXJsYXBwaW5nV2l0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc092ZXJsYXBwaW5nV2l0aChvYmopIHtcbiAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICB2YXIgZGlzdE1heCA9IDEwO1xuICAgICAgICB2YXIgeEZyb20gPSB0aGlzLmZyb20ueDtcbiAgICAgICAgdmFyIHlGcm9tID0gdGhpcy5mcm9tLnk7XG4gICAgICAgIHZhciB4VG8gPSB0aGlzLnRvLng7XG4gICAgICAgIHZhciB5VG8gPSB0aGlzLnRvLnk7XG4gICAgICAgIHZhciB4T2JqID0gb2JqLmxlZnQ7XG4gICAgICAgIHZhciB5T2JqID0gb2JqLnRvcDtcbiAgICAgICAgdmFyIGRpc3QgPSB0aGlzLmVkZ2VUeXBlLmdldERpc3RhbmNlVG9FZGdlKHhGcm9tLCB5RnJvbSwgeFRvLCB5VG8sIHhPYmosIHlPYmopO1xuICAgICAgICByZXR1cm4gZGlzdCA8IGRpc3RNYXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSByb3RhdGlvbiBwb2ludCwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFtjdHhdIGlmIHBhc3NlZCwgZG8gYSByZWNhbGN1bGF0aW9uIG9mIHRoZSBsYWJlbCBzaXplXG4gICAgICogQHJldHVybnMge3JvdGF0aW9uUG9pbnR9IHRoZSBwb2ludCB0byByb3RhdGUgYXJvdW5kIGFuZCB0aGUgYW5nbGUgaW4gcmFkaWFucyB0byByb3RhdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXRSb3RhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Um90YXRpb24oY3R4KSB7XG4gICAgICB2YXIgdmlhTm9kZSA9IHRoaXMuZWRnZVR5cGUuZ2V0VmlhTm9kZSgpO1xuICAgICAgdmFyIHBvaW50ID0gdGhpcy5lZGdlVHlwZS5nZXRQb2ludCgwLjUsIHZpYU5vZGUpO1xuICAgICAgaWYgKGN0eCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubGFiZWxNb2R1bGUuY2FsY3VsYXRlTGFiZWxTaXplKGN0eCwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlciwgcG9pbnQueCwgcG9pbnQueSk7XG4gICAgICB9XG4gICAgICB2YXIgcmV0ID0ge1xuICAgICAgICB4OiBwb2ludC54LFxuICAgICAgICB5OiB0aGlzLmxhYmVsTW9kdWxlLnNpemUueUxpbmUsXG4gICAgICAgIGFuZ2xlOiAwXG4gICAgICB9O1xuICAgICAgaWYgKCF0aGlzLmxhYmVsTW9kdWxlLnZpc2libGUoKSkge1xuICAgICAgICByZXR1cm4gcmV0OyAvLyBEb24ndCBldmVuIGJvdGhlciBkb2luZyB0aGUgYXRhbjIsIHRoZXJlJ3Mgbm90aGluZyB0byBkcmF3XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZm9udC5hbGlnbiA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgcmV0dXJuIHJldDsgLy8gTm8gbmVlZCB0byBjYWxjdWxhdGUgYW5nbGVcbiAgICAgIH1cblxuICAgICAgdmFyIGR5ID0gdGhpcy5mcm9tLnkgLSB0aGlzLnRvLnk7XG4gICAgICB2YXIgZHggPSB0aGlzLmZyb20ueCAtIHRoaXMudG8ueDtcbiAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoZHksIGR4KTsgLy8gcmFkaWFuc1xuXG4gICAgICAvLyByb3RhdGUgc28gdGhhdCBsYWJlbCBpcyByZWFkYWJsZVxuICAgICAgaWYgKGFuZ2xlIDwgLTEgJiYgZHggPCAwIHx8IGFuZ2xlID4gMCAmJiBkeCA8IDApIHtcbiAgICAgICAgYW5nbGUgKz0gTWF0aC5QSTtcbiAgICAgIH1cbiAgICAgIHJldC5hbmdsZSA9IGFuZ2xlO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBwb2ludCBvbiBhIGNpcmNsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BvaW50T25DaXJjbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BvaW50T25DaXJjbGUoeCwgeSwgcmFkaXVzLCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCArIHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgeTogeSAtIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNlbGVjdGVkIHN0YXRlIHRvIHRydWVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0KCkge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzZWxlY3RlZCBzdGF0ZSB0byBmYWxzZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVuc2VsZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2VsZWN0KCkge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNsZWFucyBhbGwgcmVxdWlyZWQgdGhpbmdzIG9uIGRlbGV0ZVxuICAgICAqXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYW51cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWRnZVR5cGUuY2xlYW51cCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBlZGdlIGZyb20gdGhlIGxpc3QgYW5kIHBlcmZvcm0gbmVjZXNzYXJ5IGNsZWFudXAuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICBkZWxldGUgdGhpcy5ib2R5LmVkZ2VzW3RoaXMuaWRdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGJvdGggY29ubmVjdGluZyBub2RlcyBleGlzdFxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kUG9pbnRzVmFsaWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kUG9pbnRzVmFsaWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ib2R5Lm5vZGVzW3RoaXMuZnJvbUlkXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuYm9keS5ub2Rlc1t0aGlzLnRvSWRdICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicGFyc2VPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zKSB7XG4gICAgICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICB2YXIgZ2xvYmFsT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gICAgICB2YXIgY29weUZyb21HbG9iYWxzID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcbiAgICAgIHZhciBmaWVsZHMgPSBbXCJlbmRQb2ludE9mZnNldFwiLCBcImFycm93U3RyaWtldGhyb3VnaFwiLCBcImlkXCIsIFwiZnJvbVwiLCBcImhpZGRlblwiLCBcImhvdmVyV2lkdGhcIiwgXCJsYWJlbEhpZ2hsaWdodEJvbGRcIiwgXCJsZW5ndGhcIiwgXCJsaW5lXCIsIFwib3BhY2l0eVwiLCBcInBoeXNpY3NcIiwgXCJzY2FsaW5nXCIsIFwic2VsZWN0aW9uV2lkdGhcIiwgXCJzZWxmUmVmZXJlbmNlU2l6ZVwiLCBcInNlbGZSZWZlcmVuY2VcIiwgXCJ0b1wiLCBcInRpdGxlXCIsIFwidmFsdWVcIiwgXCJ3aWR0aFwiLCBcImZvbnRcIiwgXCJjaG9zZW5cIiwgXCJ3aWR0aENvbnN0cmFpbnRcIl07XG5cbiAgICAgIC8vIG9ubHkgZGVlcCBleHRlbmQgdGhlIGl0ZW1zIGluIHRoZSBmaWVsZCBhcnJheS4gVGhlc2UgZG8gbm90IGhhdmUgc2hvcnRoYW5kLlxuICAgICAgc2VsZWN0aXZlRGVlcEV4dGVuZChmaWVsZHMsIHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsIGFsbG93RGVsZXRpb24pO1xuXG4gICAgICAvLyBPbmx5IHVzZSBlbmRQb2ludE9mZnNldCB2YWx1ZXMgKGZyb20gYW5kIHRvKSBpZiBpdCdzIHZhbGlkIHZhbHVlc1xuICAgICAgaWYgKG5ld09wdGlvbnMuZW5kUG9pbnRPZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmVuZFBvaW50T2Zmc2V0LmZyb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoX051bWJlciRpc0Zpbml0ZShuZXdPcHRpb25zLmVuZFBvaW50T2Zmc2V0LmZyb20pKSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5lbmRQb2ludE9mZnNldC5mcm9tID0gbmV3T3B0aW9ucy5lbmRQb2ludE9mZnNldC5mcm9tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuZW5kUG9pbnRPZmZzZXQuZnJvbSA9IGdsb2JhbE9wdGlvbnMuZW5kUG9pbnRPZmZzZXQuZnJvbSAhPT0gdW5kZWZpbmVkID8gZ2xvYmFsT3B0aW9ucy5lbmRQb2ludE9mZnNldC5mcm9tIDogMDtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiZW5kUG9pbnRPZmZzZXQuZnJvbSBpcyBub3QgYSB2YWxpZCBudW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChuZXdPcHRpb25zLmVuZFBvaW50T2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5lbmRQb2ludE9mZnNldC50byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChfTnVtYmVyJGlzRmluaXRlKG5ld09wdGlvbnMuZW5kUG9pbnRPZmZzZXQudG8pKSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5lbmRQb2ludE9mZnNldC50byA9IG5ld09wdGlvbnMuZW5kUG9pbnRPZmZzZXQudG87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5lbmRQb2ludE9mZnNldC50byA9IGdsb2JhbE9wdGlvbnMuZW5kUG9pbnRPZmZzZXQudG8gIT09IHVuZGVmaW5lZCA/IGdsb2JhbE9wdGlvbnMuZW5kUG9pbnRPZmZzZXQudG8gOiAwO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJlbmRQb2ludE9mZnNldC50byBpcyBub3QgYSB2YWxpZCBudW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT25seSBjb3B5IGxhYmVsIGlmIGl0J3MgYSBsZWdhbCB2YWx1ZS5cbiAgICAgIGlmIChpc1ZhbGlkTGFiZWwobmV3T3B0aW9ucy5sYWJlbCkpIHtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5sYWJlbCA9IG5ld09wdGlvbnMubGFiZWw7XG4gICAgICB9IGVsc2UgaWYgKCFpc1ZhbGlkTGFiZWwocGFyZW50T3B0aW9ucy5sYWJlbCkpIHtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5sYWJlbCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIG1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCBcInNtb290aFwiLCBnbG9iYWxPcHRpb25zKTtcbiAgICAgIG1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCBcInNoYWRvd1wiLCBnbG9iYWxPcHRpb25zKTtcbiAgICAgIG1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCBcImJhY2tncm91bmRcIiwgZ2xvYmFsT3B0aW9ucyk7XG4gICAgICBpZiAobmV3T3B0aW9ucy5kYXNoZXMgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmRhc2hlcyAhPT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmRhc2hlcyA9IG5ld09wdGlvbnMuZGFzaGVzO1xuICAgICAgfSBlbHNlIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlICYmIG5ld09wdGlvbnMuZGFzaGVzID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuZGFzaGVzID0gX09iamVjdCRjcmVhdGUkMShnbG9iYWxPcHRpb25zLmRhc2hlcyk7IC8vIHRoaXMgc2V0cyB0aGUgcG9pbnRlciBvZiB0aGUgb3B0aW9uIGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb24uXG4gICAgICB9XG5cbiAgICAgIC8vIHNldCB0aGUgc2NhbGluZyBuZXdPcHRpb25zXG4gICAgICBpZiAobmV3T3B0aW9ucy5zY2FsaW5nICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5zY2FsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChuZXdPcHRpb25zLnNjYWxpbmcubWluICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLnNjYWxpbmcubWluID0gbmV3T3B0aW9ucy5zY2FsaW5nLm1pbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3T3B0aW9ucy5zY2FsaW5nLm1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5zY2FsaW5nLm1heCA9IG5ld09wdGlvbnMuc2NhbGluZy5tYXg7XG4gICAgICAgIH1cbiAgICAgICAgbWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMuc2NhbGluZywgbmV3T3B0aW9ucy5zY2FsaW5nLCBcImxhYmVsXCIsIGdsb2JhbE9wdGlvbnMuc2NhbGluZyk7XG4gICAgICB9IGVsc2UgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5zY2FsaW5nID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuc2NhbGluZyA9IF9PYmplY3QkY3JlYXRlJDEoZ2xvYmFsT3B0aW9ucy5zY2FsaW5nKTsgLy8gdGhpcyBzZXRzIHRoZSBwb2ludGVyIG9mIHRoZSBvcHRpb24gYmFjayB0byB0aGUgZ2xvYmFsIG9wdGlvbi5cbiAgICAgIH1cblxuICAgICAgLy8gaGFuZGxlIG11bHRpcGxlIGlucHV0IGNhc2VzIGZvciBhcnJvd3NcbiAgICAgIGlmIChuZXdPcHRpb25zLmFycm93cyAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuYXJyb3dzICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3T3B0aW9ucy5hcnJvd3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB2YXIgYXJyb3dzID0gbmV3T3B0aW9ucy5hcnJvd3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmFycm93cy50by5lbmFibGVkID0gX2luZGV4T2ZJbnN0YW5jZVByb3BlcnR5KGFycm93cykuY2FsbChhcnJvd3MsIFwidG9cIikgIT0gLTE7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5hcnJvd3MubWlkZGxlLmVuYWJsZWQgPSBfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkoYXJyb3dzKS5jYWxsKGFycm93cywgXCJtaWRkbGVcIikgIT0gLTE7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5hcnJvd3MuZnJvbS5lbmFibGVkID0gX2luZGV4T2ZJbnN0YW5jZVByb3BlcnR5KGFycm93cykuY2FsbChhcnJvd3MsIFwiZnJvbVwiKSAhPSAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKG5ld09wdGlvbnMuYXJyb3dzKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIG1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLmFycm93cywgbmV3T3B0aW9ucy5hcnJvd3MsIFwidG9cIiwgZ2xvYmFsT3B0aW9ucy5hcnJvd3MpO1xuICAgICAgICAgIG1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLmFycm93cywgbmV3T3B0aW9ucy5hcnJvd3MsIFwibWlkZGxlXCIsIGdsb2JhbE9wdGlvbnMuYXJyb3dzKTtcbiAgICAgICAgICBtZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucy5hcnJvd3MsIG5ld09wdGlvbnMuYXJyb3dzLCBcImZyb21cIiwgZ2xvYmFsT3B0aW9ucy5hcnJvd3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBhcnJvdyBuZXdPcHRpb25zIGNhbiBvbmx5IGJlIGFuIG9iamVjdCBvciBhIHN0cmluZy4gUmVmZXIgdG8gdGhlIGRvY3VtZW50YXRpb24uIFlvdSB1c2VkOlwiICsgX0pTT04kc3RyaW5naWZ5KG5ld09wdGlvbnMuYXJyb3dzKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLmFycm93cyA9PT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmFycm93cyA9IF9PYmplY3QkY3JlYXRlJDEoZ2xvYmFsT3B0aW9ucy5hcnJvd3MpOyAvLyB0aGlzIHNldHMgdGhlIHBvaW50ZXIgb2YgdGhlIG9wdGlvbiBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uLlxuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgbXVsdGlwbGUgaW5wdXQgY2FzZXMgZm9yIGNvbG9yXG4gICAgICBpZiAobmV3T3B0aW9ucy5jb2xvciAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuY29sb3IgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGZyb21Db2xvciA9IGlzU3RyaW5nKG5ld09wdGlvbnMuY29sb3IpID8ge1xuICAgICAgICAgIGNvbG9yOiBuZXdPcHRpb25zLmNvbG9yLFxuICAgICAgICAgIGhpZ2hsaWdodDogbmV3T3B0aW9ucy5jb2xvcixcbiAgICAgICAgICBob3ZlcjogbmV3T3B0aW9ucy5jb2xvcixcbiAgICAgICAgICBpbmhlcml0OiBmYWxzZSxcbiAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgIH0gOiBuZXdPcHRpb25zLmNvbG9yO1xuICAgICAgICB2YXIgdG9Db2xvciA9IHBhcmVudE9wdGlvbnMuY29sb3I7XG5cbiAgICAgICAgLy8gSWYgcGFzc2VkLCBmaWxsIGluIHZhbHVlcyBmcm9tIGRlZmF1bHQgb3B0aW9ucyAtIHJlcXVpcmVkIGluIHRoZSBjYXNlIG9mIG5vIHByb3RvdHlwZSBicmlkZ2luZ1xuICAgICAgICBpZiAoY29weUZyb21HbG9iYWxzKSB7XG4gICAgICAgICAgZGVlcEV4dGVuZCh0b0NvbG9yLCBnbG9iYWxPcHRpb25zLmNvbG9yLCBmYWxzZSwgYWxsb3dEZWxldGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ2xlYXIgbG9jYWwgcHJvcGVydGllcyAtIG5lZWQgdG8gZG8gaXQgbGlrZSB0aGlzIGluIG9yZGVyIHRvIHJldGFpbiBwcm90b3R5cGUgYnJpZGdlc1xuICAgICAgICAgIGZvciAodmFyIGkgaW4gdG9Db2xvcikge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0b0NvbG9yLCBpKSkge1xuICAgICAgICAgICAgICBkZWxldGUgdG9Db2xvcltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaW5nKHRvQ29sb3IpKSB7XG4gICAgICAgICAgdG9Db2xvci5jb2xvciA9IHRvQ29sb3I7XG4gICAgICAgICAgdG9Db2xvci5oaWdobGlnaHQgPSB0b0NvbG9yO1xuICAgICAgICAgIHRvQ29sb3IuaG92ZXIgPSB0b0NvbG9yO1xuICAgICAgICAgIHRvQ29sb3IuaW5oZXJpdCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChmcm9tQ29sb3Iub3BhY2l0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0b0NvbG9yLm9wYWNpdHkgPSAxLjA7IC8vIHNldCBkZWZhdWx0XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjb2xvcnNEZWZpbmVkID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGZyb21Db2xvci5jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0b0NvbG9yLmNvbG9yID0gZnJvbUNvbG9yLmNvbG9yO1xuICAgICAgICAgICAgY29sb3JzRGVmaW5lZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmcm9tQ29sb3IuaGlnaGxpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRvQ29sb3IuaGlnaGxpZ2h0ID0gZnJvbUNvbG9yLmhpZ2hsaWdodDtcbiAgICAgICAgICAgIGNvbG9yc0RlZmluZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZnJvbUNvbG9yLmhvdmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRvQ29sb3IuaG92ZXIgPSBmcm9tQ29sb3IuaG92ZXI7XG4gICAgICAgICAgICBjb2xvcnNEZWZpbmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZyb21Db2xvci5pbmhlcml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRvQ29sb3IuaW5oZXJpdCA9IGZyb21Db2xvci5pbmhlcml0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZnJvbUNvbG9yLm9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG9Db2xvci5vcGFjaXR5ID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgZnJvbUNvbG9yLm9wYWNpdHkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbG9yc0RlZmluZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRvQ29sb3IuaW5oZXJpdCA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodG9Db2xvci5pbmhlcml0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdG9Db2xvci5pbmhlcml0ID0gXCJmcm9tXCI7IC8vIFNldCBkZWZhdWx0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5jb2xvciA9PT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmNvbG9yID0gYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMuY29sb3IpOyAvLyBzZXQgdGhlIG9iamVjdCBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uc1xuICAgICAgfVxuXG4gICAgICBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLmZvbnQgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5mb250ID0gYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMuZm9udCk7IC8vIHNldCB0aGUgb2JqZWN0IGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb25zXG4gICAgICB9XG5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobmV3T3B0aW9ucywgXCJzZWxmUmVmZXJlbmNlU2l6ZVwiKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgc2VsZlJlZmVyZW5jZVNpemUgcHJvcGVydHkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBzZWxmUmVmZXJlbmNlIHByb3BlcnR5IGluc3RlYWQuIFRoZSBzZWxmUmVmZXJlbmNlIGNhbiBiZSBzZXQgbGlrZSB0aGlzZSBzZWxmUmVmZXJlbmNlOntzaXplOjMwLCBhbmdsZTpNYXRoLlBJIC8gNH1cIik7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuc2VsZlJlZmVyZW5jZS5zaXplID0gbmV3T3B0aW9ucy5zZWxmUmVmZXJlbmNlU2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEVkZ2U7XG59KCk7XG5cbi8qKlxuICogSGFuZGxlciBmb3IgRWRnZXNcbiAqL1xudmFyIEVkZ2VzSGFuZGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0FycmF5LjxJbWFnZT59IGltYWdlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxHcm91cD59IGdyb3Vwc1xuICAgKi9cbiAgZnVuY3Rpb24gRWRnZXNIYW5kbGVyKGJvZHksIGltYWdlcywgZ3JvdXBzKSB7XG4gICAgdmFyIF9jb250ZXh0LFxuICAgICAgX3RoaXMgPSB0aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGdlc0hhbmRsZXIpO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5pbWFnZXMgPSBpbWFnZXM7XG4gICAgdGhpcy5ncm91cHMgPSBncm91cHM7XG5cbiAgICAvLyBjcmVhdGUgdGhlIGVkZ2UgQVBJIGluIHRoZSBib2R5IGNvbnRhaW5lclxuICAgIHRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlRWRnZSA9IF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0ID0gdGhpcy5jcmVhdGUpLmNhbGwoX2NvbnRleHQsIHRoaXMpO1xuICAgIHRoaXMuZWRnZXNMaXN0ZW5lcnMgPSB7XG4gICAgICBhZGQ6IGZ1bmN0aW9uIGFkZChldmVudCwgcGFyYW1zKSB7XG4gICAgICAgIF90aGlzLmFkZChwYXJhbXMuaXRlbXMpO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgX3RoaXMudXBkYXRlKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICBfdGhpcy5yZW1vdmUocGFyYW1zLml0ZW1zKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBhcnJvd3M6IHtcbiAgICAgICAgdG86IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBzY2FsZUZhY3RvcjogMSxcbiAgICAgICAgICB0eXBlOiBcImFycm93XCJcbiAgICAgICAgfSxcbiAgICAgICAgLy8gYm9vbGVhbiAvIHthcnJvd1NjYWxlRmFjdG9yOjF9IC8ge2VuYWJsZWQ6IGZhbHNlLCBhcnJvd1NjYWxlRmFjdG9yOjF9XG4gICAgICAgIG1pZGRsZToge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIHNjYWxlRmFjdG9yOiAxLFxuICAgICAgICAgIHR5cGU6IFwiYXJyb3dcIlxuICAgICAgICB9LFxuICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgc2NhbGVGYWN0b3I6IDEsXG4gICAgICAgICAgdHlwZTogXCJhcnJvd1wiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlbmRQb2ludE9mZnNldDoge1xuICAgICAgICBmcm9tOiAwLFxuICAgICAgICB0bzogMFxuICAgICAgfSxcbiAgICAgIGFycm93U3RyaWtldGhyb3VnaDogdHJ1ZSxcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIGNvbG9yOiBcIiM4NDg0ODRcIixcbiAgICAgICAgaGlnaGxpZ2h0OiBcIiM4NDg0ODRcIixcbiAgICAgICAgaG92ZXI6IFwiIzg0ODQ4NFwiLFxuICAgICAgICBpbmhlcml0OiBcImZyb21cIixcbiAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICB9LFxuICAgICAgZGFzaGVzOiBmYWxzZSxcbiAgICAgIGZvbnQ6IHtcbiAgICAgICAgY29sb3I6IFwiIzM0MzQzNFwiLFxuICAgICAgICBzaXplOiAxNCxcbiAgICAgICAgLy8gcHhcbiAgICAgICAgZmFjZTogXCJhcmlhbFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIm5vbmVcIixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgICAgIC8vIHB4XG4gICAgICAgIHN0cm9rZUNvbG9yOiBcIiNmZmZmZmZcIixcbiAgICAgICAgYWxpZ246IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgICBtdWx0aTogZmFsc2UsXG4gICAgICAgIHZhZGp1c3Q6IDAsXG4gICAgICAgIGJvbGQ6IHtcbiAgICAgICAgICBtb2Q6IFwiYm9sZFwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvbGRpdGFsOiB7XG4gICAgICAgICAgbW9kOiBcImJvbGQgaXRhbGljXCJcbiAgICAgICAgfSxcbiAgICAgICAgaXRhbDoge1xuICAgICAgICAgIG1vZDogXCJpdGFsaWNcIlxuICAgICAgICB9LFxuICAgICAgICBtb25vOiB7XG4gICAgICAgICAgbW9kOiBcIlwiLFxuICAgICAgICAgIHNpemU6IDE1LFxuICAgICAgICAgIC8vIHB4XG4gICAgICAgICAgZmFjZTogXCJjb3VyaWVyIG5ld1wiLFxuICAgICAgICAgIHZhZGp1c3Q6IDJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICBob3ZlcldpZHRoOiAxLjUsXG4gICAgICBsYWJlbDogdW5kZWZpbmVkLFxuICAgICAgbGFiZWxIaWdobGlnaHRCb2xkOiB0cnVlLFxuICAgICAgbGVuZ3RoOiB1bmRlZmluZWQsXG4gICAgICBwaHlzaWNzOiB0cnVlLFxuICAgICAgc2NhbGluZzoge1xuICAgICAgICBtaW46IDEsXG4gICAgICAgIG1heDogMTUsXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICBtaW46IDE0LFxuICAgICAgICAgIG1heDogMzAsXG4gICAgICAgICAgbWF4VmlzaWJsZTogMzAsXG4gICAgICAgICAgZHJhd1RocmVzaG9sZDogNVxuICAgICAgICB9LFxuICAgICAgICBjdXN0b21TY2FsaW5nRnVuY3Rpb246IGZ1bmN0aW9uIGN1c3RvbVNjYWxpbmdGdW5jdGlvbihtaW4sIG1heCwgdG90YWwsIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICAgICAgICByZXR1cm4gMC41O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSAxIC8gKG1heCAtIG1pbik7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgKHZhbHVlIC0gbWluKSAqIHNjYWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZWxlY3Rpb25XaWR0aDogMS41LFxuICAgICAgc2VsZlJlZmVyZW5jZToge1xuICAgICAgICBzaXplOiAyMCxcbiAgICAgICAgYW5nbGU6IE1hdGguUEkgLyA0LFxuICAgICAgICByZW5kZXJCZWhpbmRUaGVOb2RlOiB0cnVlXG4gICAgICB9LFxuICAgICAgc2hhZG93OiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBjb2xvcjogXCJyZ2JhKDAsMCwwLDAuNSlcIixcbiAgICAgICAgc2l6ZTogMTAsXG4gICAgICAgIHg6IDUsXG4gICAgICAgIHk6IDVcbiAgICAgIH0sXG4gICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBjb2xvcjogXCJyZ2JhKDExMSwxMTEsMTExLDEpXCIsXG4gICAgICAgIHNpemU6IDEwLFxuICAgICAgICBkYXNoZXM6IGZhbHNlXG4gICAgICB9LFxuICAgICAgc21vb3RoOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIHR5cGU6IFwiZHluYW1pY1wiLFxuICAgICAgICBmb3JjZURpcmVjdGlvbjogXCJub25lXCIsXG4gICAgICAgIHJvdW5kbmVzczogMC41XG4gICAgICB9LFxuICAgICAgdGl0bGU6IHVuZGVmaW5lZCxcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgZGVlcEV4dGVuZCh0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogQmluZHMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoRWRnZXNIYW5kbGVyLCBbe1xuICAgIGtleTogXCJiaW5kRXZlbnRMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXMsXG4gICAgICAgIF9jb250ZXh0MixcbiAgICAgICAgX2NvbnRleHQzO1xuICAgICAgLy8gdGhpcyBhbGxvd3MgZXh0ZXJuYWwgbW9kdWxlcyB0byBmb3JjZSBhbGwgZHluYW1pYyBjdXJ2ZXMgdG8gdHVybiBzdGF0aWMuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9mb3JjZURpc2FibGVEeW5hbWljQ3VydmVzXCIsIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBlbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJkeW5hbWljXCIpIHtcbiAgICAgICAgICB0eXBlID0gXCJjb250aW51b3VzXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGFDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiBfdGhpczIuYm9keS5lZGdlcykge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX3RoaXMyLmJvZHkuZWRnZXMsIGVkZ2VJZCkpIHtcbiAgICAgICAgICAgIHZhciBlZGdlID0gX3RoaXMyLmJvZHkuZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgICAgIHZhciBlZGdlRGF0YSA9IF90aGlzMi5ib2R5LmRhdGEuZWRnZXMuZ2V0KGVkZ2VJZCk7XG5cbiAgICAgICAgICAgIC8vIG9ubHkgZm9yY2libHkgcmVtb3ZlIHRoZSBzbW9vdGggY3VydmUgaWYgdGhlIGRhdGEgaGFzIGJlZW4gc2V0IG9mIHRoZSBlZGdlIGhhcyB0aGUgc21vb3RoIGN1cnZlcyBkZWZpbmVkLlxuICAgICAgICAgICAgLy8gdGhpcyBpcyBiZWNhdXNlIGEgY2hhbmdlIGluIHRoZSBnbG9iYWwgd291bGQgbm90IGFmZmVjdCB0aGVzZSBjdXJ2ZXMuXG4gICAgICAgICAgICBpZiAoZWRnZURhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgc21vb3RoT3B0aW9ucyA9IGVkZ2VEYXRhLnNtb290aDtcbiAgICAgICAgICAgICAgaWYgKHNtb290aE9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChzbW9vdGhPcHRpb25zLmVuYWJsZWQgPT09IHRydWUgJiYgc21vb3RoT3B0aW9ucy50eXBlID09PSBcImR5bmFtaWNcIikge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBlZGdlLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICAgIHNtb290aDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlZGdlLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICAgIHNtb290aDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBkYXRhQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbWl0ID09PSB0cnVlICYmIGRhdGFDaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgX3RoaXMyLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gdGhpcyBpcyBjYWxsZWQgd2hlbiBvcHRpb25zIG9mIEVYSVNUSU5HIG5vZGVzIG9yIGVkZ2VzIGhhdmUgY2hhbmdlZC5cbiAgICAgIC8vXG4gICAgICAvLyBOT1RFOiBOb3QgdHJ1ZSwgY2FsbGVkIHdoZW4gb3B0aW9ucyBoYXZlIE5PVCBjaGFuZ2VkLCBmb3IgYm90aCBleGlzdGluZyBhcyB3ZWxsIGFzIG5ldyBub2Rlcy5cbiAgICAgIC8vICAgICAgIFNlZSB1cGRhdGUoKSBmb3IgbG9naWMuXG4gICAgICAvLyBUT0RPOiBWZXJpZnkgYW5kIGV4YW1pbmUgdGhlIGNvbnNlcXVlbmNlcyBvZiB0aGlzLiBJdCBtaWdodCBzdGlsbCB0cmlnZ2VyIHdoZW5cbiAgICAgIC8vICAgICAgIG5vbi1vcHRpb24gZmllbGRzIGhhdmUgY2hhbmdlZCwgYnV0IHRoZW4gcmVjb25uZWN0aW5nIGVkZ2VzIGlzIHN0aWxsIHVzZWxlc3MuXG4gICAgICAvLyAgICAgICBBbHRlcm5hdGl2ZWx5LCBpdCBtaWdodCBhbHNvIGJlIGNhbGxlZCB3aGVuIGVkZ2VzIGFyZSByZW1vdmVkLlxuICAgICAgLy9cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFVcGRhdGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnJlY29ubmVjdEVkZ2VzKCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gcmVmcmVzaCB0aGUgZWRnZXMuIFVzZWQgd2hlbiByZXZlcnRpbmcgZnJvbSBoaWVyYXJjaGljYWwgbGF5b3V0XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInJlZnJlc2hFZGdlc1wiLCBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDIgPSB0aGlzLnJlZnJlc2gpLmNhbGwoX2NvbnRleHQyLCB0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInJlZnJlc2hcIiwgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQzID0gdGhpcy5yZWZyZXNoKS5jYWxsKF9jb250ZXh0MywgdGhpcykpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yRWFjaCQxKF90aGlzMi5lZGdlc0xpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICAgIGlmIChfdGhpczIuYm9keS5kYXRhLmVkZ2VzKSBfdGhpczIuYm9keS5kYXRhLmVkZ2VzLm9mZihldmVudCwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVFZGdlO1xuICAgICAgICBkZWxldGUgX3RoaXMyLmVkZ2VzTGlzdGVuZXJzLmFkZDtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5lZGdlc0xpc3RlbmVycy51cGRhdGU7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIuZWRnZXNMaXN0ZW5lcnMucmVtb3ZlO1xuICAgICAgICBkZWxldGUgX3RoaXMyLmVkZ2VzTGlzdGVuZXJzO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHVzZSB0aGUgcGFyc2VyIGZyb20gdGhlIEVkZ2UgY2xhc3MgdG8gZmlsbCBpbiBhbGwgc2hvcnRoYW5kIG5vdGF0aW9uc1xuICAgICAgICBFZGdlLnBhcnNlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsIHRydWUsIHRoaXMuZGVmYXVsdE9wdGlvbnMsIHRydWUpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBzbW9vdGggc2V0dGluZ3MgaW4gYWxsIGVkZ2VzXG4gICAgICAgIHZhciBkYXRhQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBpZiAob3B0aW9ucy5zbW9vdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLmJvZHkuZWRnZXMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5LmVkZ2VzLCBlZGdlSWQpKSB7XG4gICAgICAgICAgICAgIGRhdGFDaGFuZ2VkID0gdGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF0udXBkYXRlRWRnZVR5cGUoKSB8fCBkYXRhQ2hhbmdlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgZm9udHMgaW4gYWxsIGVkZ2VzXG4gICAgICAgIGlmIChvcHRpb25zLmZvbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIF9lZGdlSWQgaW4gdGhpcy5ib2R5LmVkZ2VzKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5lZGdlcywgX2VkZ2VJZCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5ib2R5LmVkZ2VzW19lZGdlSWRdLnVwZGF0ZUxhYmVsTW9kdWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBzdGF0ZSBvZiB0aGUgdmFyaWFibGVzIGlmIG5lZWRlZFxuICAgICAgICBpZiAob3B0aW9ucy5oaWRkZW4gIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnBoeXNpY3MgIT09IHVuZGVmaW5lZCB8fCBkYXRhQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIGVkZ2VzIGJ5IHJlYWRpbmcgdGhlIGRhdGEgdGFibGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkgfCBEYXRhU2V0IHwgRGF0YVZpZXd9IGVkZ2VzICAgIFRoZSBkYXRhIGNvbnRhaW5pbmcgdGhlIGVkZ2VzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RvTm90RW1pdD1mYWxzZV0gLSBTdXBwcmVzcyBkYXRhIGNoYW5nZWQgZXZlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXREYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERhdGEoZWRnZXMpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgdmFyIGRvTm90RW1pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgb2xkRWRnZXNEYXRhID0gdGhpcy5ib2R5LmRhdGEuZWRnZXM7XG4gICAgICBpZiAoaXNEYXRhVmlld0xpa2UoXCJpZFwiLCBlZGdlcykpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMgPSBlZGdlcztcbiAgICAgIH0gZWxzZSBpZiAoX0FycmF5JGlzQXJyYXkoZWRnZXMpKSB7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLmVkZ2VzID0gbmV3IERhdGFTZXQoKTtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMuYWRkKGVkZ2VzKTtcbiAgICAgIH0gZWxzZSBpZiAoIWVkZ2VzKSB7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLmVkZ2VzID0gbmV3IERhdGFTZXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcnJheSBvciBEYXRhU2V0IGV4cGVjdGVkXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBpcyB0aGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIGZhbHNlP1xuICAgICAgaWYgKG9sZEVkZ2VzRGF0YSkge1xuICAgICAgICAvLyB1bnN1YnNjcmliZSBmcm9tIG9sZCBkYXRhc2V0XG4gICAgICAgIGZvckVhY2gkMSh0aGlzLmVkZ2VzTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgb2xkRWRnZXNEYXRhLm9mZihldmVudCwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIGRyYXduIGVkZ2VzXG4gICAgICB0aGlzLmJvZHkuZWRnZXMgPSB7fTtcblxuICAgICAgLy8gVE9ETzogaXMgdGhpcyBudWxsIG9yIHVuZGVmaW5lZCBvciBmYWxzZT9cbiAgICAgIGlmICh0aGlzLmJvZHkuZGF0YS5lZGdlcykge1xuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gbmV3IGRhdGFzZXRcbiAgICAgICAgZm9yRWFjaCQxKHRoaXMuZWRnZXNMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczMuYm9keS5kYXRhLmVkZ2VzLm9uKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGRyYXcgYWxsIG5ldyBub2Rlc1xuICAgICAgICB2YXIgaWRzID0gdGhpcy5ib2R5LmRhdGEuZWRnZXMuZ2V0SWRzKCk7XG4gICAgICAgIHRoaXMuYWRkKGlkcywgdHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2FkanVzdEVkZ2VzRm9ySGllcmFyY2hpY2FsTGF5b3V0XCIpO1xuICAgICAgaWYgKGRvTm90RW1pdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgZWRnZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW10gfCBzdHJpbmdbXX0gaWRzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZG9Ob3RFbWl0PWZhbHNlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChpZHMpIHtcbiAgICAgIHZhciBkb05vdEVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgdmFyIGVkZ2VzRGF0YSA9IHRoaXMuYm9keS5kYXRhLmVkZ2VzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlkID0gaWRzW2ldO1xuICAgICAgICB2YXIgb2xkRWRnZSA9IGVkZ2VzW2lkXTtcbiAgICAgICAgaWYgKG9sZEVkZ2UpIHtcbiAgICAgICAgICBvbGRFZGdlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YSA9IGVkZ2VzRGF0YS5nZXQoaWQsIHtcbiAgICAgICAgICBzaG93SW50ZXJuYWxJZHM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGVkZ2VzW2lkXSA9IHRoaXMuY3JlYXRlKGRhdGEpO1xuICAgICAgfVxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9hZGp1c3RFZGdlc0ZvckhpZXJhcmNoaWNhbExheW91dFwiKTtcbiAgICAgIGlmIChkb05vdEVtaXQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGV4aXN0aW5nIGVkZ2VzLCBvciBjcmVhdGUgdGhlbSB3aGVuIG5vdCB5ZXQgZXhpc3RpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW10gfCBzdHJpbmdbXX0gaWRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKGlkcykge1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgdmFyIGVkZ2VzRGF0YSA9IHRoaXMuYm9keS5kYXRhLmVkZ2VzO1xuICAgICAgdmFyIGRhdGFDaGFuZ2VkID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICAgIHZhciBkYXRhID0gZWRnZXNEYXRhLmdldChpZCk7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbaWRdO1xuICAgICAgICBpZiAoZWRnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gdXBkYXRlIGVkZ2VcbiAgICAgICAgICBlZGdlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICBkYXRhQ2hhbmdlZCA9IGVkZ2Uuc2V0T3B0aW9ucyhkYXRhKSB8fCBkYXRhQ2hhbmdlZDsgLy8gaWYgYSBzdXBwb3J0IG5vZGUgaXMgYWRkZWQsIGRhdGEgY2FuIGJlIGNoYW5nZWQuXG4gICAgICAgICAgZWRnZS5jb25uZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY3JlYXRlIGVkZ2VcbiAgICAgICAgICB0aGlzLmJvZHkuZWRnZXNbaWRdID0gdGhpcy5jcmVhdGUoZGF0YSk7XG4gICAgICAgICAgZGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGF0YUNoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9hZGp1c3RFZGdlc0ZvckhpZXJhcmNoaWNhbExheW91dFwiKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YVVwZGF0ZWRcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGV4aXN0aW5nIGVkZ2VzLiBOb24gZXhpc3RpbmcgaWRzIHdpbGwgYmUgaWdub3JlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBpZHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtlbWl0PXRydWVdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGlkcykge1xuICAgICAgdmFyIGVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICBpZiAoaWRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuOyAvLyBlYXJseSBvdXRcblxuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgZm9yRWFjaCQxKGlkcywgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbaWRdO1xuICAgICAgICBpZiAoZWRnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZWRnZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoZW1pdCkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZnJlc2hlcyBFZGdlIEhhbmRsZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZWZyZXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgIGZvckVhY2gkMSh0aGlzLmJvZHkuZWRnZXMsIGZ1bmN0aW9uIChlZGdlLCBlZGdlSWQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBfdGhpczQuYm9keS5kYXRhLmVkZ2VzLmdldChlZGdlSWQpO1xuICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZWRnZS5zZXRPcHRpb25zKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzXG4gICAgICogQHJldHVybnMge0VkZ2V9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gbmV3IEVkZ2UocHJvcGVydGllcywgdGhpcy5ib2R5LCB0aGlzLmltYWdlcywgdGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWNvbm5lY3QgYWxsIGVkZ2VzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlY29ubmVjdEVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlY29ubmVjdEVkZ2VzKCkge1xuICAgICAgdmFyIGlkO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgZm9yIChpZCBpbiBub2Rlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGVzLCBpZCkpIHtcbiAgICAgICAgICBub2Rlc1tpZF0uZWRnZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChpZCBpbiBlZGdlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVkZ2VzLCBpZCkpIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2lkXTtcbiAgICAgICAgICBlZGdlLmZyb20gPSBudWxsO1xuICAgICAgICAgIGVkZ2UudG8gPSBudWxsO1xuICAgICAgICAgIGVkZ2UuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VkZ2UuaWR9IGVkZ2VJZFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb25uZWN0ZWROb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb25uZWN0ZWROb2RlcyhlZGdlSWQpIHtcbiAgICAgIHZhciBub2RlTGlzdCA9IFtdO1xuICAgICAgaWYgKHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgaWYgKGVkZ2UuZnJvbUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub2RlTGlzdC5wdXNoKGVkZ2UuZnJvbUlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWRnZS50b0lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub2RlTGlzdC5wdXNoKGVkZ2UudG9JZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlTGlzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGVyZSBpcyBubyBkaXJlY3QgcmVsYXRpb24gYmV0d2VlbiB0aGUgbm9kZXMgYW5kIHRoZSBlZGdlcyBEYXRhU2V0LFxuICAgICAqIHNvIHRoZSByaWdodCBwbGFjZSB0byBkbyBjYWxsIHRoaXMgaXMgaW4gdGhlIGhhbmRsZXIgZm9yIGV2ZW50IGBfZGF0YVVwZGF0ZWRgLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlU3RhdGUoKSB7XG4gICAgICB0aGlzLl9hZGRNaXNzaW5nRWRnZXMoKTtcbiAgICAgIHRoaXMuX3JlbW92ZUludmFsaWRFZGdlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjYW4gZm9yIG1pc3Npbmcgbm9kZXMgYW5kIHJlbW92ZSBjb3JyZXNwb25kaW5nIGVkZ2VzLCBpZiBhbnkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9yZW1vdmVJbnZhbGlkRWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUludmFsaWRFZGdlcygpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuICAgICAgdmFyIGVkZ2VzVG9EZWxldGUgPSBbXTtcbiAgICAgIGZvckVhY2gkMSh0aGlzLmJvZHkuZWRnZXMsIGZ1bmN0aW9uIChlZGdlLCBpZCkge1xuICAgICAgICB2YXIgdG9Ob2RlID0gX3RoaXM1LmJvZHkubm9kZXNbZWRnZS50b0lkXTtcbiAgICAgICAgdmFyIGZyb21Ob2RlID0gX3RoaXM1LmJvZHkubm9kZXNbZWRnZS5mcm9tSWRdO1xuXG4gICAgICAgIC8vIFNraXAgY2x1c3RlcmluZyBlZGdlcyBoZXJlLCBsZXQgdGhlIENsdXN0ZXJpbmcgbW9kdWxlIGhhbmRsZSB0aG9zZVxuICAgICAgICBpZiAodG9Ob2RlICE9PSB1bmRlZmluZWQgJiYgdG9Ob2RlLmlzQ2x1c3RlciA9PT0gdHJ1ZSB8fCBmcm9tTm9kZSAhPT0gdW5kZWZpbmVkICYmIGZyb21Ob2RlLmlzQ2x1c3RlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9Ob2RlID09PSB1bmRlZmluZWQgfHwgZnJvbU5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGVkZ2VzVG9EZWxldGUucHVzaChpZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5yZW1vdmUoZWRnZXNUb0RlbGV0ZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFkZCBhbGwgZWRnZXMgZnJvbSBkYXRhc2V0IHRoYXQgYXJlIG5vdCBpbiB0aGUgY2FjaGVkIHN0YXRlXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9hZGRNaXNzaW5nRWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZE1pc3NpbmdFZGdlcygpIHtcbiAgICAgIHZhciBlZGdlc0RhdGEgPSB0aGlzLmJvZHkuZGF0YS5lZGdlcztcbiAgICAgIGlmIChlZGdlc0RhdGEgPT09IHVuZGVmaW5lZCB8fCBlZGdlc0RhdGEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBObyBlZGdlcyBEYXRhU2V0IHlldDsgY2FuIGhhcHBlbiBvbiBzdGFydHVwXG4gICAgICB9XG5cbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgIHZhciBhZGRJZHMgPSBbXTtcbiAgICAgIF9mb3JFYWNoSW5zdGFuY2VQcm9wZXJ0eShlZGdlc0RhdGEpLmNhbGwoZWRnZXNEYXRhLCBmdW5jdGlvbiAoZWRnZURhdGEsIGVkZ2VJZCkge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VkZ2VJZF07XG4gICAgICAgIGlmIChlZGdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhZGRJZHMucHVzaChlZGdlSWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYWRkKGFkZElkcywgdHJ1ZSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBFZGdlc0hhbmRsZXI7XG59KCk7XG5cbi8qKlxuICogQmFybmVzIEh1dCBTb2x2ZXJcbiAqL1xudmFyIEJhcm5lc0h1dFNvbHZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge3twaHlzaWNzTm9kZUluZGljZXM6IEFycmF5LCBwaHlzaWNzRWRnZUluZGljZXM6IEFycmF5LCBmb3JjZXM6IHt9LCB2ZWxvY2l0aWVzOiB7fX19IHBoeXNpY3NCb2R5XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBCYXJuZXNIdXRTb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFybmVzSHV0U29sdmVyKTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMucGh5c2ljc0JvZHkgPSBwaHlzaWNzQm9keTtcbiAgICB0aGlzLmJhcm5lc0h1dFRyZWU7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuX3JuZyA9IEFsZWEoXCJCQVJORVMgSFVUIFNPTFZFUlwiKTtcblxuICAgIC8vIGRlYnVnOiBzaG93IGdyaWRcbiAgICAvLyB0aGlzLmJvZHkuZW1pdHRlci5vbihcImFmdGVyRHJhd2luZ1wiLCAoY3R4KSA9PiB7dGhpcy5fZGVidWcoY3R4LCcjZmYwMDAwJyl9KVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoQmFybmVzSHV0U29sdmVyLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMudGhldGFJbnZlcnNlZCA9IDEgLyB0aGlzLm9wdGlvbnMudGhldGE7XG5cbiAgICAgIC8vIGlmIDEgdGhlbiBtaW4gZGlzdGFuY2UgPSAwLjUsIGlmIDAuNSB0aGVuIG1pbiBkaXN0YW5jZSA9IDAuNSArIDAuNSpub2RlLnNoYXBlLnJhZGl1c1xuICAgICAgdGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yID0gMSAtIE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHRoaXMub3B0aW9ucy5hdm9pZE92ZXJsYXApKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIGZvcmNlcyB0aGUgbm9kZXMgYXBwbHkgb24gZWFjaCBvdGhlciBiYXNlZCBvbiBhIGdyYXZpdGF0aW9uYWwgbW9kZWwuXG4gICAgICogVGhlIEJhcm5lcyBIdXQgbWV0aG9kIGlzIHVzZWQgdG8gc3BlZWQgdXAgdGhpcyBOLWJvZHkgc2ltdWxhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmdyYXZpdGF0aW9uYWxDb25zdGFudCAhPT0gMCAmJiB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzO1xuICAgICAgICB2YXIgbm9kZUNvdW50ID0gbm9kZUluZGljZXMubGVuZ3RoO1xuXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgdHJlZVxuICAgICAgICB2YXIgYmFybmVzSHV0VHJlZSA9IHRoaXMuX2Zvcm1CYXJuZXNIdXRUcmVlKG5vZGVzLCBub2RlSW5kaWNlcyk7XG5cbiAgICAgICAgLy8gZm9yIGRlYnVnZ2luZ1xuICAgICAgICB0aGlzLmJhcm5lc0h1dFRyZWUgPSBiYXJuZXNIdXRUcmVlO1xuXG4gICAgICAgIC8vIHBsYWNlIHRoZSBub2RlcyBvbmUgYnkgb25lIHJlY3Vyc2l2ZWx5XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUNvdW50OyBpKyspIHtcbiAgICAgICAgICBub2RlID0gbm9kZXNbbm9kZUluZGljZXNbaV1dO1xuICAgICAgICAgIGlmIChub2RlLm9wdGlvbnMubWFzcyA+IDApIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0aW5nIHdpdGggcm9vdCBpcyBpcnJlbGV2YW50LCBpdCBuZXZlciBwYXNzZXMgdGhlIEJhcm5lc0h1dFNvbHZlciBjb25kaXRpb25cbiAgICAgICAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9ucyhiYXJuZXNIdXRUcmVlLnJvb3QsIG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXRGb3JjZUNvbnRyaWJ1dGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEZvcmNlQ29udHJpYnV0aW9ucyhwYXJlbnRCcmFuY2gsIG5vZGUpIHtcbiAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9uKHBhcmVudEJyYW5jaC5jaGlsZHJlbi5OVywgbm9kZSk7XG4gICAgICB0aGlzLl9nZXRGb3JjZUNvbnRyaWJ1dGlvbihwYXJlbnRCcmFuY2guY2hpbGRyZW4uTkUsIG5vZGUpO1xuICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24ocGFyZW50QnJhbmNoLmNoaWxkcmVuLlNXLCBub2RlKTtcbiAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9uKHBhcmVudEJyYW5jaC5jaGlsZHJlbi5TRSwgbm9kZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB0cmF2ZXJzZXMgdGhlIGJhcm5lc0h1dFRyZWUuIEl0IGNoZWNrcyB3aGVuIGl0IGNhbiBhcHByb3hpbWF0ZSBkaXN0YW50IG5vZGVzIHdpdGggdGhlaXIgY2VudGVyIG9mIG1hc3MuXG4gICAgICogSWYgYSByZWdpb24gY29udGFpbnMgYSBzaW5nbGUgbm9kZSwgd2UgY2hlY2sgaWYgaXQgaXMgbm90IGl0c2VsZiwgdGhlbiB3ZSBhcHBseSB0aGUgZm9yY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50QnJhbmNoXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Rm9yY2VDb250cmlidXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEZvcmNlQ29udHJpYnV0aW9uKHBhcmVudEJyYW5jaCwgbm9kZSkge1xuICAgICAgLy8gd2UgZ2V0IG5vIGZvcmNlIGNvbnRyaWJ1dGlvbiBmcm9tIGFuIGVtcHR5IHJlZ2lvblxuICAgICAgaWYgKHBhcmVudEJyYW5jaC5jaGlsZHJlbkNvdW50ID4gMCkge1xuICAgICAgICAvLyBnZXQgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciBvZiBtYXNzIHRvIHRoZSBub2RlLlxuICAgICAgICB2YXIgZHggPSBwYXJlbnRCcmFuY2guY2VudGVyT2ZNYXNzLnggLSBub2RlLng7XG4gICAgICAgIHZhciBkeSA9IHBhcmVudEJyYW5jaC5jZW50ZXJPZk1hc3MueSAtIG5vZGUueTtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICAvLyBCYXJuZXNIdXRTb2x2ZXIgY29uZGl0aW9uXG4gICAgICAgIC8vIG9yaWdpbmFsIGNvbmRpdGlvbiA6IHMvZCA8IHRoZXRhID0gcGFzc2VkICA9PT0gIGQvcyA+IDEvdGhldGEgPSBwYXNzZWRcbiAgICAgICAgLy8gY2FsY1NpemUgPSAxL3MgLS0+IGQgKiAxL3MgPiAxL3RoZXRhID0gcGFzc2VkXG4gICAgICAgIGlmIChkaXN0YW5jZSAqIHBhcmVudEJyYW5jaC5jYWxjU2l6ZSA+IHRoaXMudGhldGFJbnZlcnNlZCkge1xuICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBub2RlLCBwYXJlbnRCcmFuY2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERpZCBub3QgcGFzcyB0aGUgY29uZGl0aW9uLCBnbyBpbnRvIGNoaWxkcmVuIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIGlmIChwYXJlbnRCcmFuY2guY2hpbGRyZW5Db3VudCA9PT0gNCkge1xuICAgICAgICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb25zKHBhcmVudEJyYW5jaCwgbm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhcmVudEJyYW5jaCBtdXN0IGhhdmUgb25seSBvbmUgbm9kZSwgaWYgaXQgd2FzIGVtcHR5IHdlIHdvdWxkbnQgYmUgaGVyZVxuICAgICAgICAgICAgaWYgKHBhcmVudEJyYW5jaC5jaGlsZHJlbi5kYXRhLmlkICE9IG5vZGUuaWQpIHtcbiAgICAgICAgICAgICAgLy8gaWYgaXQgaXMgbm90IHNlbGZcbiAgICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIG5vZGUsIHBhcmVudEJyYW5jaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBmb3JjZXMgYmFzZWQgb24gdGhlIGRpc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR5XG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudEJyYW5jaFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NhbGN1bGF0ZUZvcmNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIG5vZGUsIHBhcmVudEJyYW5jaCkge1xuICAgICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAgIGRpc3RhbmNlID0gMC4xO1xuICAgICAgICBkeCA9IGRpc3RhbmNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvciA8IDEgJiYgbm9kZS5zaGFwZS5yYWRpdXMpIHtcbiAgICAgICAgZGlzdGFuY2UgPSBNYXRoLm1heCgwLjEgKyB0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IgKiBub2RlLnNoYXBlLnJhZGl1cywgZGlzdGFuY2UgLSBub2RlLnNoYXBlLnJhZGl1cyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRoZSBkaXZpZGluZyBieSB0aGUgZGlzdGFuY2UgY3ViZWQgaW5zdGVhZCBvZiBzcXVhcmVkIGFsbG93cyB1cyB0byBnZXQgdGhlIGZ4IGFuZCBmeSBjb21wb25lbnRzIHdpdGhvdXQgc2luZXMgYW5kIGNvc2luZXNcbiAgICAgIC8vIGl0IGlzIHNob3J0aGFuZCBmb3IgZ3Jhdml0eWZvcmNlIHdpdGggZGlzdGFuY2Ugc3F1YXJlZCBhbmQgZnggPSBkeC9kaXN0YW5jZSAqIGdyYXZpdHlGb3JjZVxuICAgICAgdmFyIGdyYXZpdHlGb3JjZSA9IHRoaXMub3B0aW9ucy5ncmF2aXRhdGlvbmFsQ29uc3RhbnQgKiBwYXJlbnRCcmFuY2gubWFzcyAqIG5vZGUub3B0aW9ucy5tYXNzIC8gTWF0aC5wb3coZGlzdGFuY2UsIDMpO1xuICAgICAgdmFyIGZ4ID0gZHggKiBncmF2aXR5Rm9yY2U7XG4gICAgICB2YXIgZnkgPSBkeSAqIGdyYXZpdHlGb3JjZTtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUuaWRdLnggKz0gZng7XG4gICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlLmlkXS55ICs9IGZ5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY29uc3RydWN0cyB0aGUgYmFybmVzSHV0IHRyZWUgcmVjdXJzaXZlbHkuIEl0IGNyZWF0ZXMgdGhlIHJvb3QsIHNwbGl0cyBpdCBhbmQgc3RhcnRzIHBsYWNpbmcgdGhlIG5vZGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IG5vZGVzXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbm9kZUluZGljZXNcbiAgICAgKiBAcmV0dXJucyB7e3Jvb3Q6IHtjZW50ZXJPZk1hc3M6IHt4OiBudW1iZXIsIHk6IG51bWJlcn0sIG1hc3M6IG51bWJlciwgcmFuZ2U6IHttaW5YOiBudW1iZXIsIG1heFg6IG51bWJlciwgbWluWTogbnVtYmVyLCBtYXhZOiBudW1iZXJ9LCBzaXplOiBudW1iZXIsIGNhbGNTaXplOiBudW1iZXIsIGNoaWxkcmVuOiB7ZGF0YTogbnVsbH0sIG1heFdpZHRoOiBudW1iZXIsIGxldmVsOiBudW1iZXIsIGNoaWxkcmVuQ291bnQ6IG51bWJlcn19fSBCYXJuZXNIdXRUcmVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZm9ybUJhcm5lc0h1dFRyZWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Zvcm1CYXJuZXNIdXRUcmVlKG5vZGVzLCBub2RlSW5kaWNlcykge1xuICAgICAgdmFyIG5vZGU7XG4gICAgICB2YXIgbm9kZUNvdW50ID0gbm9kZUluZGljZXMubGVuZ3RoO1xuICAgICAgdmFyIG1pblggPSBub2Rlc1tub2RlSW5kaWNlc1swXV0ueDtcbiAgICAgIHZhciBtaW5ZID0gbm9kZXNbbm9kZUluZGljZXNbMF1dLnk7XG4gICAgICB2YXIgbWF4WCA9IG5vZGVzW25vZGVJbmRpY2VzWzBdXS54O1xuICAgICAgdmFyIG1heFkgPSBub2Rlc1tub2RlSW5kaWNlc1swXV0ueTtcblxuICAgICAgLy8gZ2V0IHRoZSByYW5nZSBvZiB0aGUgbm9kZXNcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbm9kZUNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIF9ub2RlID0gbm9kZXNbbm9kZUluZGljZXNbaV1dO1xuICAgICAgICB2YXIgeCA9IF9ub2RlLng7XG4gICAgICAgIHZhciB5ID0gX25vZGUueTtcbiAgICAgICAgaWYgKF9ub2RlLm9wdGlvbnMubWFzcyA+IDApIHtcbiAgICAgICAgICBpZiAoeCA8IG1pblgpIHtcbiAgICAgICAgICAgIG1pblggPSB4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoeCA+IG1heFgpIHtcbiAgICAgICAgICAgIG1heFggPSB4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgICAgIG1pblkgPSB5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgICAgIG1heFkgPSB5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gbWFrZSB0aGUgcmFuZ2UgYSBzcXVhcmVcbiAgICAgIHZhciBzaXplRGlmZiA9IE1hdGguYWJzKG1heFggLSBtaW5YKSAtIE1hdGguYWJzKG1heFkgLSBtaW5ZKTsgLy8gZGlmZmVyZW5jZSBiZXR3ZWVuIFggYW5kIFlcbiAgICAgIGlmIChzaXplRGlmZiA+IDApIHtcbiAgICAgICAgbWluWSAtPSAwLjUgKiBzaXplRGlmZjtcbiAgICAgICAgbWF4WSArPSAwLjUgKiBzaXplRGlmZjtcbiAgICAgIH0gLy8geFNpemUgPiB5U2l6ZVxuICAgICAgZWxzZSB7XG4gICAgICAgIG1pblggKz0gMC41ICogc2l6ZURpZmY7XG4gICAgICAgIG1heFggLT0gMC41ICogc2l6ZURpZmY7XG4gICAgICB9IC8vIHhTaXplIDwgeVNpemVcblxuICAgICAgdmFyIG1pbmltdW1UcmVlU2l6ZSA9IDFlLTU7XG4gICAgICB2YXIgcm9vdFNpemUgPSBNYXRoLm1heChtaW5pbXVtVHJlZVNpemUsIE1hdGguYWJzKG1heFggLSBtaW5YKSk7XG4gICAgICB2YXIgaGFsZlJvb3RTaXplID0gMC41ICogcm9vdFNpemU7XG4gICAgICB2YXIgY2VudGVyWCA9IDAuNSAqIChtaW5YICsgbWF4WCksXG4gICAgICAgIGNlbnRlclkgPSAwLjUgKiAobWluWSArIG1heFkpO1xuXG4gICAgICAvLyBjb25zdHJ1Y3QgdGhlIGJhcm5lc0h1dFRyZWVcbiAgICAgIHZhciBiYXJuZXNIdXRUcmVlID0ge1xuICAgICAgICByb290OiB7XG4gICAgICAgICAgY2VudGVyT2ZNYXNzOiB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWFzczogMCxcbiAgICAgICAgICByYW5nZToge1xuICAgICAgICAgICAgbWluWDogY2VudGVyWCAtIGhhbGZSb290U2l6ZSxcbiAgICAgICAgICAgIG1heFg6IGNlbnRlclggKyBoYWxmUm9vdFNpemUsXG4gICAgICAgICAgICBtaW5ZOiBjZW50ZXJZIC0gaGFsZlJvb3RTaXplLFxuICAgICAgICAgICAgbWF4WTogY2VudGVyWSArIGhhbGZSb290U2l6ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2l6ZTogcm9vdFNpemUsXG4gICAgICAgICAgY2FsY1NpemU6IDEgLyByb290U2l6ZSxcbiAgICAgICAgICBjaGlsZHJlbjoge1xuICAgICAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWF4V2lkdGg6IDAsXG4gICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgY2hpbGRyZW5Db3VudDogNFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5fc3BsaXRCcmFuY2goYmFybmVzSHV0VHJlZS5yb290KTtcblxuICAgICAgLy8gcGxhY2UgdGhlIG5vZGVzIG9uZSBieSBvbmUgcmVjdXJzaXZlbHlcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2RlQ291bnQ7IF9pKyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW25vZGVJbmRpY2VzW19pXV07XG4gICAgICAgIGlmIChub2RlLm9wdGlvbnMubWFzcyA+IDApIHtcbiAgICAgICAgICB0aGlzLl9wbGFjZUluVHJlZShiYXJuZXNIdXRUcmVlLnJvb3QsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG1ha2UgZ2xvYmFsXG4gICAgICByZXR1cm4gYmFybmVzSHV0VHJlZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0aGlzIHVwZGF0ZXMgdGhlIG1hc3Mgb2YgYSBicmFuY2guIHRoaXMgaXMgaW5jcmVhc2VkIGJ5IGFkZGluZyBhIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50QnJhbmNoXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlQnJhbmNoTWFzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQnJhbmNoTWFzcyhwYXJlbnRCcmFuY2gsIG5vZGUpIHtcbiAgICAgIHZhciBjZW50ZXJPZk1hc3MgPSBwYXJlbnRCcmFuY2guY2VudGVyT2ZNYXNzO1xuICAgICAgdmFyIHRvdGFsTWFzcyA9IHBhcmVudEJyYW5jaC5tYXNzICsgbm9kZS5vcHRpb25zLm1hc3M7XG4gICAgICB2YXIgdG90YWxNYXNzSW52ID0gMSAvIHRvdGFsTWFzcztcbiAgICAgIGNlbnRlck9mTWFzcy54ID0gY2VudGVyT2ZNYXNzLnggKiBwYXJlbnRCcmFuY2gubWFzcyArIG5vZGUueCAqIG5vZGUub3B0aW9ucy5tYXNzO1xuICAgICAgY2VudGVyT2ZNYXNzLnggKj0gdG90YWxNYXNzSW52O1xuICAgICAgY2VudGVyT2ZNYXNzLnkgPSBjZW50ZXJPZk1hc3MueSAqIHBhcmVudEJyYW5jaC5tYXNzICsgbm9kZS55ICogbm9kZS5vcHRpb25zLm1hc3M7XG4gICAgICBjZW50ZXJPZk1hc3MueSAqPSB0b3RhbE1hc3NJbnY7XG4gICAgICBwYXJlbnRCcmFuY2gubWFzcyA9IHRvdGFsTWFzcztcbiAgICAgIHZhciBiaWdnZXN0U2l6ZSA9IE1hdGgubWF4KE1hdGgubWF4KG5vZGUuaGVpZ2h0LCBub2RlLnJhZGl1cyksIG5vZGUud2lkdGgpO1xuICAgICAgcGFyZW50QnJhbmNoLm1heFdpZHRoID0gcGFyZW50QnJhbmNoLm1heFdpZHRoIDwgYmlnZ2VzdFNpemUgPyBiaWdnZXN0U2l6ZSA6IHBhcmVudEJyYW5jaC5tYXhXaWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBkZXRlcm1pbmUgaW4gd2hpY2ggYnJhbmNoIHRoZSBub2RlIHdpbGwgYmUgcGxhY2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudEJyYW5jaFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2tpcE1hc3NVcGRhdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9wbGFjZUluVHJlZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGxhY2VJblRyZWUocGFyZW50QnJhbmNoLCBub2RlLCBza2lwTWFzc1VwZGF0ZSkge1xuICAgICAgaWYgKHNraXBNYXNzVXBkYXRlICE9IHRydWUgfHwgc2tpcE1hc3NVcGRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB1cGRhdGUgdGhlIG1hc3Mgb2YgdGhlIGJyYW5jaC5cbiAgICAgICAgdGhpcy5fdXBkYXRlQnJhbmNoTWFzcyhwYXJlbnRCcmFuY2gsIG5vZGUpO1xuICAgICAgfVxuICAgICAgdmFyIHJhbmdlID0gcGFyZW50QnJhbmNoLmNoaWxkcmVuLk5XLnJhbmdlO1xuICAgICAgdmFyIHJlZ2lvbjtcbiAgICAgIGlmIChyYW5nZS5tYXhYID4gbm9kZS54KSB7XG4gICAgICAgIC8vIGluIE5XIG9yIFNXXG4gICAgICAgIGlmIChyYW5nZS5tYXhZID4gbm9kZS55KSB7XG4gICAgICAgICAgcmVnaW9uID0gXCJOV1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZ2lvbiA9IFwiU1dcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaW4gTkUgb3IgU0VcbiAgICAgICAgaWYgKHJhbmdlLm1heFkgPiBub2RlLnkpIHtcbiAgICAgICAgICByZWdpb24gPSBcIk5FXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVnaW9uID0gXCJTRVwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9wbGFjZUluUmVnaW9uKHBhcmVudEJyYW5jaCwgbm9kZSwgcmVnaW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhY3R1YWxseSBwbGFjZSB0aGUgbm9kZSBpbiBhIHJlZ2lvbiAob3IgYnJhbmNoKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudEJyYW5jaFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7J05XJ3wgJ05FJyB8ICdTVycgfCAnU0UnfSByZWdpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9wbGFjZUluUmVnaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wbGFjZUluUmVnaW9uKHBhcmVudEJyYW5jaCwgbm9kZSwgcmVnaW9uKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnRCcmFuY2guY2hpbGRyZW5bcmVnaW9uXTtcbiAgICAgIHN3aXRjaCAoY2hpbGRyZW4uY2hpbGRyZW5Db3VudCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgLy8gcGxhY2Ugbm9kZSBoZXJlXG4gICAgICAgICAgY2hpbGRyZW4uY2hpbGRyZW4uZGF0YSA9IG5vZGU7XG4gICAgICAgICAgY2hpbGRyZW4uY2hpbGRyZW5Db3VudCA9IDE7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlQnJhbmNoTWFzcyhjaGlsZHJlbiwgbm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAvLyBjb252ZXJ0IGludG8gY2hpbGRyZW5cbiAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgdHdvIG5vZGVzIGV4YWN0bHkgb3ZlcmxhcHBpbmcgKG9uIGluaXQsIG9uIG9wZW5pbmcgb2YgY2x1c3RlciBldGMuKVxuICAgICAgICAgIC8vIHdlIG1vdmUgb25lIG5vZGUgYSBsaXR0bGUgYml0IGFuZCB3ZSBkbyBub3QgcHV0IGl0IGluIHRoZSB0cmVlLlxuICAgICAgICAgIGlmIChjaGlsZHJlbi5jaGlsZHJlbi5kYXRhLnggPT09IG5vZGUueCAmJiBjaGlsZHJlbi5jaGlsZHJlbi5kYXRhLnkgPT09IG5vZGUueSkge1xuICAgICAgICAgICAgbm9kZS54ICs9IHRoaXMuX3JuZygpO1xuICAgICAgICAgICAgbm9kZS55ICs9IHRoaXMuX3JuZygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zcGxpdEJyYW5jaChjaGlsZHJlbik7XG4gICAgICAgICAgICB0aGlzLl9wbGFjZUluVHJlZShjaGlsZHJlbiwgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgLy8gcGxhY2UgaW4gYnJhbmNoXG4gICAgICAgICAgdGhpcy5fcGxhY2VJblRyZWUoY2hpbGRyZW4sIG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRoaXMgZnVuY3Rpb24gc3BsaXRzIGEgYnJhbmNoIGludG8gNCBzdWIgYnJhbmNoZXMuIElmIHRoZSBicmFuY2ggY29udGFpbmVkIGEgbm9kZSwgd2UgcGxhY2UgaXQgaW4gdGhlIHN1YmJyYW5jaFxuICAgICAqIGFmdGVyIHRoZSBzcGxpdCBpcyBjb21wbGV0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9zcGxpdEJyYW5jaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3BsaXRCcmFuY2gocGFyZW50QnJhbmNoKSB7XG4gICAgICAvLyBpZiB0aGUgYnJhbmNoIGlzIHNoYWRlZCB3aXRoIGEgbm9kZSwgcmVwbGFjZSB0aGUgbm9kZSBpbiB0aGUgbmV3IHN1YnNldC5cbiAgICAgIHZhciBjb250YWluZWROb2RlID0gbnVsbDtcbiAgICAgIGlmIChwYXJlbnRCcmFuY2guY2hpbGRyZW5Db3VudCA9PT0gMSkge1xuICAgICAgICBjb250YWluZWROb2RlID0gcGFyZW50QnJhbmNoLmNoaWxkcmVuLmRhdGE7XG4gICAgICAgIHBhcmVudEJyYW5jaC5tYXNzID0gMDtcbiAgICAgICAgcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy54ID0gMDtcbiAgICAgICAgcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy55ID0gMDtcbiAgICAgIH1cbiAgICAgIHBhcmVudEJyYW5jaC5jaGlsZHJlbkNvdW50ID0gNDtcbiAgICAgIHBhcmVudEJyYW5jaC5jaGlsZHJlbi5kYXRhID0gbnVsbDtcbiAgICAgIHRoaXMuX2luc2VydFJlZ2lvbihwYXJlbnRCcmFuY2gsIFwiTldcIik7XG4gICAgICB0aGlzLl9pbnNlcnRSZWdpb24ocGFyZW50QnJhbmNoLCBcIk5FXCIpO1xuICAgICAgdGhpcy5faW5zZXJ0UmVnaW9uKHBhcmVudEJyYW5jaCwgXCJTV1wiKTtcbiAgICAgIHRoaXMuX2luc2VydFJlZ2lvbihwYXJlbnRCcmFuY2gsIFwiU0VcIik7XG4gICAgICBpZiAoY29udGFpbmVkTm9kZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3BsYWNlSW5UcmVlKHBhcmVudEJyYW5jaCwgY29udGFpbmVkTm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzdWJkaXZpZGVzIHRoZSByZWdpb24gaW50byBmb3VyIG5ldyBzZWdtZW50cy5cbiAgICAgKiBTcGVjaWZpY2FsbHksIHRoaXMgaW5zZXJ0cyBhIHNpbmdsZSBuZXcgc2VnbWVudC5cbiAgICAgKiBJdCBmaWxscyB0aGUgY2hpbGRyZW4gc2VjdGlvbiBvZiB0aGUgcGFyZW50QnJhbmNoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50QnJhbmNoXG4gICAgICogQHBhcmFtIHsnTlcnfCAnTkUnIHwgJ1NXJyB8ICdTRSd9IHJlZ2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luc2VydFJlZ2lvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5zZXJ0UmVnaW9uKHBhcmVudEJyYW5jaCwgcmVnaW9uKSB7XG4gICAgICB2YXIgbWluWCwgbWF4WCwgbWluWSwgbWF4WTtcbiAgICAgIHZhciBjaGlsZFNpemUgPSAwLjUgKiBwYXJlbnRCcmFuY2guc2l6ZTtcbiAgICAgIHN3aXRjaCAocmVnaW9uKSB7XG4gICAgICAgIGNhc2UgXCJOV1wiOlxuICAgICAgICAgIG1pblggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWDtcbiAgICAgICAgICBtYXhYID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblggKyBjaGlsZFNpemU7XG4gICAgICAgICAgbWluWSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZO1xuICAgICAgICAgIG1heFkgPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWSArIGNoaWxkU2l6ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk5FXCI6XG4gICAgICAgICAgbWluWCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YICsgY2hpbGRTaXplO1xuICAgICAgICAgIG1heFggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWF4WDtcbiAgICAgICAgICBtaW5ZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblk7XG4gICAgICAgICAgbWF4WSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZICsgY2hpbGRTaXplO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiU1dcIjpcbiAgICAgICAgICBtaW5YID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblg7XG4gICAgICAgICAgbWF4WCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YICsgY2hpbGRTaXplO1xuICAgICAgICAgIG1pblkgPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWSArIGNoaWxkU2l6ZTtcbiAgICAgICAgICBtYXhZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1heFk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJTRVwiOlxuICAgICAgICAgIG1pblggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWCArIGNoaWxkU2l6ZTtcbiAgICAgICAgICBtYXhYID0gcGFyZW50QnJhbmNoLnJhbmdlLm1heFg7XG4gICAgICAgICAgbWluWSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZICsgY2hpbGRTaXplO1xuICAgICAgICAgIG1heFkgPSBwYXJlbnRCcmFuY2gucmFuZ2UubWF4WTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHBhcmVudEJyYW5jaC5jaGlsZHJlbltyZWdpb25dID0ge1xuICAgICAgICBjZW50ZXJPZk1hc3M6IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSxcbiAgICAgICAgbWFzczogMCxcbiAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICBtaW5YOiBtaW5YLFxuICAgICAgICAgIG1heFg6IG1heFgsXG4gICAgICAgICAgbWluWTogbWluWSxcbiAgICAgICAgICBtYXhZOiBtYXhZXG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IDAuNSAqIHBhcmVudEJyYW5jaC5zaXplLFxuICAgICAgICBjYWxjU2l6ZTogMiAqIHBhcmVudEJyYW5jaC5jYWxjU2l6ZSxcbiAgICAgICAgY2hpbGRyZW46IHtcbiAgICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIG1heFdpZHRoOiAwLFxuICAgICAgICBsZXZlbDogcGFyZW50QnJhbmNoLmxldmVsICsgMSxcbiAgICAgICAgY2hpbGRyZW5Db3VudDogMFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgREVCVUdHSU5HIEJFTE9XICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBmb3IgZGVidWdnaW5nIHB1cnBvc2VkLCBpdCBkcmF3cyB0aGUgdHJlZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9kZWJ1Z1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVidWcoY3R4LCBjb2xvcikge1xuICAgICAgaWYgKHRoaXMuYmFybmVzSHV0VHJlZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICB0aGlzLl9kcmF3QnJhbmNoKHRoaXMuYmFybmVzSHV0VHJlZS5yb290LCBjdHgsIGNvbG9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuIEl0IGRyYXdzIHRoZSBicmFuY2hlcyByZWN1cnNpdmVseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBicmFuY2hcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd0JyYW5jaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0JyYW5jaChicmFuY2gsIGN0eCwgY29sb3IpIHtcbiAgICAgIGlmIChjb2xvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbG9yID0gXCIjRkYwMDAwXCI7XG4gICAgICB9XG4gICAgICBpZiAoYnJhbmNoLmNoaWxkcmVuQ291bnQgPT09IDQpIHtcbiAgICAgICAgdGhpcy5fZHJhd0JyYW5jaChicmFuY2guY2hpbGRyZW4uTlcsIGN0eCk7XG4gICAgICAgIHRoaXMuX2RyYXdCcmFuY2goYnJhbmNoLmNoaWxkcmVuLk5FLCBjdHgpO1xuICAgICAgICB0aGlzLl9kcmF3QnJhbmNoKGJyYW5jaC5jaGlsZHJlbi5TRSwgY3R4KTtcbiAgICAgICAgdGhpcy5fZHJhd0JyYW5jaChicmFuY2guY2hpbGRyZW4uU1csIGN0eCk7XG4gICAgICB9XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oYnJhbmNoLnJhbmdlLm1pblgsIGJyYW5jaC5yYW5nZS5taW5ZKTtcbiAgICAgIGN0eC5saW5lVG8oYnJhbmNoLnJhbmdlLm1heFgsIGJyYW5jaC5yYW5nZS5taW5ZKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oYnJhbmNoLnJhbmdlLm1heFgsIGJyYW5jaC5yYW5nZS5taW5ZKTtcbiAgICAgIGN0eC5saW5lVG8oYnJhbmNoLnJhbmdlLm1heFgsIGJyYW5jaC5yYW5nZS5tYXhZKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oYnJhbmNoLnJhbmdlLm1heFgsIGJyYW5jaC5yYW5nZS5tYXhZKTtcbiAgICAgIGN0eC5saW5lVG8oYnJhbmNoLnJhbmdlLm1pblgsIGJyYW5jaC5yYW5nZS5tYXhZKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oYnJhbmNoLnJhbmdlLm1pblgsIGJyYW5jaC5yYW5nZS5tYXhZKTtcbiAgICAgIGN0eC5saW5lVG8oYnJhbmNoLnJhbmdlLm1pblgsIGJyYW5jaC5yYW5nZS5taW5ZKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgLypcbiAgICAgICBpZiAoYnJhbmNoLm1hc3MgPiAwKSB7XG4gICAgICAgY3R4LmNpcmNsZShicmFuY2guY2VudGVyT2ZNYXNzLngsIGJyYW5jaC5jZW50ZXJPZk1hc3MueSwgMypicmFuY2gubWFzcyk7XG4gICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgIH1cbiAgICAgICAqL1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQmFybmVzSHV0U29sdmVyO1xufSgpO1xuXG4vKipcbiAqIFJlcHVsc2lvbiBTb2x2ZXJcbiAqL1xudmFyIFJlcHVsc2lvblNvbHZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge3twaHlzaWNzTm9kZUluZGljZXM6IEFycmF5LCBwaHlzaWNzRWRnZUluZGljZXM6IEFycmF5LCBmb3JjZXM6IHt9LCB2ZWxvY2l0aWVzOiB7fX19IHBoeXNpY3NCb2R5XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBSZXB1bHNpb25Tb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVwdWxzaW9uU29sdmVyKTtcbiAgICB0aGlzLl9ybmcgPSBBbGVhKFwiUkVQVUxTSU9OIFNPTFZFUlwiKTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMucGh5c2ljc0JvZHkgPSBwaHlzaWNzQm9keTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhSZXB1bHNpb25Tb2x2ZXIsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZm9yY2VzIHRoZSBub2RlcyBhcHBseSBvbiBlYWNoIG90aGVyIGJhc2VkIG9uIGEgcmVwdWxzaW9uIGZpZWxkLlxuICAgICAqIFRoaXMgZmllbGQgaXMgbGluZWFybHkgYXBwcm94aW1hdGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZSgpIHtcbiAgICAgIHZhciBkeCwgZHksIGRpc3RhbmNlLCBmeCwgZnksIHJlcHVsc2luZ0ZvcmNlLCBub2RlMSwgbm9kZTI7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcztcbiAgICAgIHZhciBmb3JjZXMgPSB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlcztcblxuICAgICAgLy8gcmVwdWxzaW5nIGZvcmNlcyBiZXR3ZWVuIG5vZGVzXG4gICAgICB2YXIgbm9kZURpc3RhbmNlID0gdGhpcy5vcHRpb25zLm5vZGVEaXN0YW5jZTtcblxuICAgICAgLy8gYXBwcm94aW1hdGlvbiBjb25zdGFudHNcbiAgICAgIHZhciBhID0gLTIgLyAzIC8gbm9kZURpc3RhbmNlO1xuICAgICAgdmFyIGIgPSA0IC8gMztcblxuICAgICAgLy8gd2UgbG9vcCBmcm9tIGkgb3ZlciBhbGwgYnV0IHRoZSBsYXN0IGVudHJlZSBpbiB0aGUgYXJyYXlcbiAgICAgIC8vIGogbG9vcHMgZnJvbSBpKzEgdG8gdGhlIGxhc3QuIFRoaXMgd2F5IHdlIGRvIG5vdCBkb3VibGUgY291bnQgYW55IG9mIHRoZSBpbmRpY2VzLCBub3IgaSA9PT0galxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlSW5kaWNlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgbm9kZTEgPSBub2Rlc1tub2RlSW5kaWNlc1tpXV07XG4gICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgbm9kZTIgPSBub2Rlc1tub2RlSW5kaWNlc1tqXV07XG4gICAgICAgICAgZHggPSBub2RlMi54IC0gbm9kZTEueDtcbiAgICAgICAgICBkeSA9IG5vZGUyLnkgLSBub2RlMS55O1xuICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICAgIC8vIHNhbWUgY29uZGl0aW9uIGFzIEJhcm5lc0h1dFNvbHZlciwgbWFraW5nIHN1cmUgbm9kZXMgYXJlIG5ldmVyIDEwMCUgb3ZlcmxhcHBpbmcuXG4gICAgICAgICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IDAuMSAqIHRoaXMuX3JuZygpO1xuICAgICAgICAgICAgZHggPSBkaXN0YW5jZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRpc3RhbmNlIDwgMiAqIG5vZGVEaXN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgMC41ICogbm9kZURpc3RhbmNlKSB7XG4gICAgICAgICAgICAgIHJlcHVsc2luZ0ZvcmNlID0gMS4wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSBhICogZGlzdGFuY2UgKyBiOyAvLyBsaW5lYXIgYXBwcm94IG9mICAxIC8gKDEgKyBNYXRoLmV4cCgoZGlzdGFuY2UgLyBub2RlRGlzdGFuY2UgLSAxKSAqIHN0ZWVwbmVzcykpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlcHVsc2luZ0ZvcmNlID0gcmVwdWxzaW5nRm9yY2UgLyBkaXN0YW5jZTtcbiAgICAgICAgICAgIGZ4ID0gZHggKiByZXB1bHNpbmdGb3JjZTtcbiAgICAgICAgICAgIGZ5ID0gZHkgKiByZXB1bHNpbmdGb3JjZTtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMS5pZF0ueCAtPSBmeDtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMS5pZF0ueSAtPSBmeTtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMi5pZF0ueCArPSBmeDtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMi5pZF0ueSArPSBmeTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJlcHVsc2lvblNvbHZlcjtcbn0oKTtcblxuLyoqXG4gKiBIaWVyYXJjaGljYWwgUmVwdWxzaW9uIFNvbHZlclxuICovXG52YXIgSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIaWVyYXJjaGljYWxSZXB1bHNpb25Tb2x2ZXIpO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlciwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB0aGlzLm9wdGlvbnMuYXZvaWRPdmVybGFwIHx8IDApKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyB0aGUgbm9kZXMgYXBwbHkgb24gZWFjaCBvdGhlciBiYXNlZCBvbiBhIHJlcHVsc2lvbiBmaWVsZC5cbiAgICAgKiBUaGlzIGZpZWxkIGlzIGxpbmVhcmx5IGFwcHJveGltYXRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcztcbiAgICAgIHZhciBmb3JjZXMgPSB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlcztcblxuICAgICAgLy8gcmVwdWxzaW5nIGZvcmNlcyBiZXR3ZWVuIG5vZGVzXG4gICAgICB2YXIgbm9kZURpc3RhbmNlID0gdGhpcy5vcHRpb25zLm5vZGVEaXN0YW5jZTtcblxuICAgICAgLy8gd2UgbG9vcCBmcm9tIGkgb3ZlciBhbGwgYnV0IHRoZSBsYXN0IGVudHJlZSBpbiB0aGUgYXJyYXlcbiAgICAgIC8vIGogbG9vcHMgZnJvbSBpKzEgdG8gdGhlIGxhc3QuIFRoaXMgd2F5IHdlIGRvIG5vdCBkb3VibGUgY291bnQgYW55IG9mIHRoZSBpbmRpY2VzLCBub3IgaSA9PT0galxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlSW5kaWNlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUxID0gbm9kZXNbbm9kZUluZGljZXNbaV1dO1xuICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBub2RlSW5kaWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBub2RlMiA9IG5vZGVzW25vZGVJbmRpY2VzW2pdXTtcblxuICAgICAgICAgIC8vIG5vZGVzIG9ubHkgYWZmZWN0IG5vZGVzIG9uIHRoZWlyIGxldmVsXG4gICAgICAgICAgaWYgKG5vZGUxLmxldmVsID09PSBub2RlMi5sZXZlbCkge1xuICAgICAgICAgICAgdmFyIHRoZXNlTm9kZXNEaXN0YW5jZSA9IG5vZGVEaXN0YW5jZSArIHRoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvciAqICgobm9kZTEuc2hhcGUucmFkaXVzIHx8IDApIC8gMiArIChub2RlMi5zaGFwZS5yYWRpdXMgfHwgMCkgLyAyKTtcbiAgICAgICAgICAgIHZhciBkeCA9IG5vZGUyLnggLSBub2RlMS54O1xuICAgICAgICAgICAgdmFyIGR5ID0gbm9kZTIueSAtIG5vZGUxLnk7XG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgICAgdmFyIHN0ZWVwbmVzcyA9IDAuMDU7XG4gICAgICAgICAgICB2YXIgcmVwdWxzaW5nRm9yY2UgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCB0aGVzZU5vZGVzRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSAtTWF0aC5wb3coc3RlZXBuZXNzICogZGlzdGFuY2UsIDIpICsgTWF0aC5wb3coc3RlZXBuZXNzICogdGhlc2VOb2Rlc0Rpc3RhbmNlLCAyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlcHVsc2luZ0ZvcmNlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBmb3JjZSB3aXRoXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgIT09IDApIHtcbiAgICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSByZXB1bHNpbmdGb3JjZSAvIGRpc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZ4ID0gZHggKiByZXB1bHNpbmdGb3JjZTtcbiAgICAgICAgICAgIHZhciBmeSA9IGR5ICogcmVwdWxzaW5nRm9yY2U7XG4gICAgICAgICAgICBmb3JjZXNbbm9kZTEuaWRdLnggLT0gZng7XG4gICAgICAgICAgICBmb3JjZXNbbm9kZTEuaWRdLnkgLT0gZnk7XG4gICAgICAgICAgICBmb3JjZXNbbm9kZTIuaWRdLnggKz0gZng7XG4gICAgICAgICAgICBmb3JjZXNbbm9kZTIuaWRdLnkgKz0gZnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBIaWVyYXJjaGljYWxSZXB1bHNpb25Tb2x2ZXI7XG59KCk7XG5cbi8qKlxuICogU3ByaW5nIFNvbHZlclxuICovXG52YXIgU3ByaW5nU29sdmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIFNwcmluZ1NvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTcHJpbmdTb2x2ZXIpO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKFNwcmluZ1NvbHZlciwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBzcHJpbmdmb3JjZXMgb24gdGhlIG5vZGVzLCBhY2NvdW50aW5nIGZvciB0aGUgc3VwcG9ydCBub2Rlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICB2YXIgZWRnZUxlbmd0aCwgZWRnZTtcbiAgICAgIHZhciBlZGdlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc0VkZ2VJbmRpY2VzO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgdmFyIG5vZGUxLCBub2RlMiwgbm9kZTM7XG5cbiAgICAgIC8vIGZvcmNlcyBjYXVzZWQgYnkgdGhlIGVkZ2VzLCBtb2RlbGxlZCBhcyBzcHJpbmdzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVkZ2UgPSBlZGdlc1tlZGdlSW5kaWNlc1tpXV07XG4gICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCA9PT0gdHJ1ZSAmJiBlZGdlLnRvSWQgIT09IGVkZ2UuZnJvbUlkKSB7XG4gICAgICAgICAgLy8gb25seSBjYWxjdWxhdGUgZm9yY2VzIGlmIG5vZGVzIGFyZSBpbiB0aGUgc2FtZSBzZWN0b3JcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2VkZ2UudG9JZF0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmJvZHkubm9kZXNbZWRnZS5mcm9tSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChlZGdlLmVkZ2VUeXBlLnZpYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGVkZ2VMZW5ndGggPSBlZGdlLm9wdGlvbnMubGVuZ3RoID09PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuc3ByaW5nTGVuZ3RoIDogZWRnZS5vcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgICAgbm9kZTEgPSBlZGdlLnRvO1xuICAgICAgICAgICAgICBub2RlMiA9IGVkZ2UuZWRnZVR5cGUudmlhO1xuICAgICAgICAgICAgICBub2RlMyA9IGVkZ2UuZnJvbTtcbiAgICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlU3ByaW5nRm9yY2Uobm9kZTEsIG5vZGUyLCAwLjUgKiBlZGdlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlU3ByaW5nRm9yY2Uobm9kZTIsIG5vZGUzLCAwLjUgKiBlZGdlTGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHRoZSAqIDEuNSBpcyBoZXJlIHNvIHRoZSBlZGdlIGxvb2tzIGFzIGxhcmdlIGFzIGEgc21vb3RoIGVkZ2UuIEl0IGRvZXMgbm90IGluaXRpYWxseSBiZWNhdXNlIHRoZSBzbW9vdGggZWRnZXMgdXNlXG4gICAgICAgICAgICAgIC8vIHRoZSBzdXBwb3J0IG5vZGVzIHdoaWNoIGV4ZXJ0IGEgcmVwdWxzaXZlIGZvcmNlIG9uIHRoZSB0byBhbmQgZnJvbSBub2RlcywgbWFraW5nIHRoZSBlZGdlIGFwcGVhciBsYXJnZXIuXG4gICAgICAgICAgICAgIGVkZ2VMZW5ndGggPSBlZGdlLm9wdGlvbnMubGVuZ3RoID09PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuc3ByaW5nTGVuZ3RoICogMS41IDogZWRnZS5vcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlU3ByaW5nRm9yY2UoZWRnZS5mcm9tLCBlZGdlLnRvLCBlZGdlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBjb2RlIGFjdHVhbGx5IHBlcmZvcm1pbmcgdGhlIGNhbGN1bGF0aW9uIGZvciB0aGUgZnVuY3Rpb24gYWJvdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUxXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlMlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlZGdlTGVuZ3RoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY2FsY3VsYXRlU3ByaW5nRm9yY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZVNwcmluZ0ZvcmNlKG5vZGUxLCBub2RlMiwgZWRnZUxlbmd0aCkge1xuICAgICAgdmFyIGR4ID0gbm9kZTEueCAtIG5vZGUyLng7XG4gICAgICB2YXIgZHkgPSBub2RlMS55IC0gbm9kZTIueTtcbiAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGgubWF4KE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSksIDAuMDEpO1xuXG4gICAgICAvLyB0aGUgMS9kaXN0YW5jZSBpcyBzbyB0aGUgZnggYW5kIGZ5IGNhbiBiZSBjYWxjdWxhdGVkIHdpdGhvdXQgc2luZSBvciBjb3NpbmUuXG4gICAgICB2YXIgc3ByaW5nRm9yY2UgPSB0aGlzLm9wdGlvbnMuc3ByaW5nQ29uc3RhbnQgKiAoZWRnZUxlbmd0aCAtIGRpc3RhbmNlKSAvIGRpc3RhbmNlO1xuICAgICAgdmFyIGZ4ID0gZHggKiBzcHJpbmdGb3JjZTtcbiAgICAgIHZhciBmeSA9IGR5ICogc3ByaW5nRm9yY2U7XG5cbiAgICAgIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBvbmUgbm9kZSBpcyBub3QgcGFydCBvZiB0aGUgcGh5c2Npc1xuICAgICAgaWYgKHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUxLmlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUxLmlkXS54ICs9IGZ4O1xuICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlMS5pZF0ueSArPSBmeTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlMi5pZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlMi5pZF0ueCAtPSBmeDtcbiAgICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZTIuaWRdLnkgLT0gZnk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTcHJpbmdTb2x2ZXI7XG59KCk7XG5cbi8qKlxuICogSGllcmFyY2hpY2FsIFNwcmluZyBTb2x2ZXJcbiAqL1xudmFyIEhpZXJhcmNoaWNhbFNwcmluZ1NvbHZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge3twaHlzaWNzTm9kZUluZGljZXM6IEFycmF5LCBwaHlzaWNzRWRnZUluZGljZXM6IEFycmF5LCBmb3JjZXM6IHt9LCB2ZWxvY2l0aWVzOiB7fX19IHBoeXNpY3NCb2R5XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyKTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMucGh5c2ljc0JvZHkgPSBwaHlzaWNzQm9keTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgc3ByaW5nZm9yY2VzIG9uIHRoZSBub2RlcywgYWNjb3VudGluZyBmb3IgdGhlIHN1cHBvcnQgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvbHZlKCkge1xuICAgICAgdmFyIGVkZ2VMZW5ndGgsIGVkZ2U7XG4gICAgICB2YXIgZHgsIGR5LCBmeCwgZnksIHNwcmluZ0ZvcmNlLCBkaXN0YW5jZTtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgIHZhciBmYWN0b3IgPSAwLjU7XG4gICAgICB2YXIgZWRnZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NFZGdlSW5kaWNlcztcbiAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzO1xuICAgICAgdmFyIGZvcmNlcyA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzO1xuXG4gICAgICAvLyBpbml0aWFsaXplIHRoZSBzcHJpbmcgZm9yY2UgY291bnRlcnNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGVJbmRpY2VzW2ldO1xuICAgICAgICBmb3JjZXNbbm9kZUlkXS5zcHJpbmdGeCA9IDA7XG4gICAgICAgIGZvcmNlc1tub2RlSWRdLnNwcmluZ0Z5ID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gZm9yY2VzIGNhdXNlZCBieSB0aGUgZWRnZXMsIG1vZGVsbGVkIGFzIHNwcmluZ3NcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlZGdlSW5kaWNlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgZWRnZSA9IGVkZ2VzW2VkZ2VJbmRpY2VzW19pXV07XG4gICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGVkZ2VMZW5ndGggPSBlZGdlLm9wdGlvbnMubGVuZ3RoID09PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuc3ByaW5nTGVuZ3RoIDogZWRnZS5vcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICBkeCA9IGVkZ2UuZnJvbS54IC0gZWRnZS50by54O1xuICAgICAgICAgIGR5ID0gZWRnZS5mcm9tLnkgLSBlZGdlLnRvLnk7XG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgIGRpc3RhbmNlID0gZGlzdGFuY2UgPT09IDAgPyAwLjAxIDogZGlzdGFuY2U7XG5cbiAgICAgICAgICAvLyB0aGUgMS9kaXN0YW5jZSBpcyBzbyB0aGUgZnggYW5kIGZ5IGNhbiBiZSBjYWxjdWxhdGVkIHdpdGhvdXQgc2luZSBvciBjb3NpbmUuXG4gICAgICAgICAgc3ByaW5nRm9yY2UgPSB0aGlzLm9wdGlvbnMuc3ByaW5nQ29uc3RhbnQgKiAoZWRnZUxlbmd0aCAtIGRpc3RhbmNlKSAvIGRpc3RhbmNlO1xuICAgICAgICAgIGZ4ID0gZHggKiBzcHJpbmdGb3JjZTtcbiAgICAgICAgICBmeSA9IGR5ICogc3ByaW5nRm9yY2U7XG4gICAgICAgICAgaWYgKGVkZ2UudG8ubGV2ZWwgIT0gZWRnZS5mcm9tLmxldmVsKSB7XG4gICAgICAgICAgICBpZiAoZm9yY2VzW2VkZ2UudG9JZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBmb3JjZXNbZWRnZS50b0lkXS5zcHJpbmdGeCAtPSBmeDtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UudG9JZF0uc3ByaW5nRnkgLT0gZnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9yY2VzW2VkZ2UuZnJvbUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGZvcmNlc1tlZGdlLmZyb21JZF0uc3ByaW5nRnggKz0gZng7XG4gICAgICAgICAgICAgIGZvcmNlc1tlZGdlLmZyb21JZF0uc3ByaW5nRnkgKz0gZnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb3JjZXNbZWRnZS50b0lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGZvcmNlc1tlZGdlLnRvSWRdLnggLT0gZmFjdG9yICogZng7XG4gICAgICAgICAgICAgIGZvcmNlc1tlZGdlLnRvSWRdLnkgLT0gZmFjdG9yICogZnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9yY2VzW2VkZ2UuZnJvbUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGZvcmNlc1tlZGdlLmZyb21JZF0ueCArPSBmYWN0b3IgKiBmeDtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UuZnJvbUlkXS55ICs9IGZhY3RvciAqIGZ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBub3JtYWxpemUgc3ByaW5nIGZvcmNlc1xuICAgICAgc3ByaW5nRm9yY2UgPSAxO1xuICAgICAgdmFyIHNwcmluZ0Z4LCBzcHJpbmdGeTtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIF9ub2RlSWQgPSBub2RlSW5kaWNlc1tfaTJdO1xuICAgICAgICBzcHJpbmdGeCA9IE1hdGgubWluKHNwcmluZ0ZvcmNlLCBNYXRoLm1heCgtc3ByaW5nRm9yY2UsIGZvcmNlc1tfbm9kZUlkXS5zcHJpbmdGeCkpO1xuICAgICAgICBzcHJpbmdGeSA9IE1hdGgubWluKHNwcmluZ0ZvcmNlLCBNYXRoLm1heCgtc3ByaW5nRm9yY2UsIGZvcmNlc1tfbm9kZUlkXS5zcHJpbmdGeSkpO1xuICAgICAgICBmb3JjZXNbX25vZGVJZF0ueCArPSBzcHJpbmdGeDtcbiAgICAgICAgZm9yY2VzW19ub2RlSWRdLnkgKz0gc3ByaW5nRnk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJldGFpbiBlbmVyZ3kgYmFsYW5jZVxuICAgICAgdmFyIHRvdGFsRnggPSAwO1xuICAgICAgdmFyIHRvdGFsRnkgPSAwO1xuICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbm9kZUluZGljZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICB2YXIgX25vZGVJZDIgPSBub2RlSW5kaWNlc1tfaTNdO1xuICAgICAgICB0b3RhbEZ4ICs9IGZvcmNlc1tfbm9kZUlkMl0ueDtcbiAgICAgICAgdG90YWxGeSArPSBmb3JjZXNbX25vZGVJZDJdLnk7XG4gICAgICB9XG4gICAgICB2YXIgY29ycmVjdGlvbkZ4ID0gdG90YWxGeCAvIG5vZGVJbmRpY2VzLmxlbmd0aDtcbiAgICAgIHZhciBjb3JyZWN0aW9uRnkgPSB0b3RhbEZ5IC8gbm9kZUluZGljZXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbm9kZUluZGljZXMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICB2YXIgX25vZGVJZDMgPSBub2RlSW5kaWNlc1tfaTRdO1xuICAgICAgICBmb3JjZXNbX25vZGVJZDNdLnggLT0gY29ycmVjdGlvbkZ4O1xuICAgICAgICBmb3JjZXNbX25vZGVJZDNdLnkgLT0gY29ycmVjdGlvbkZ5O1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyO1xufSgpO1xuXG4vKipcbiAqIENlbnRyYWwgR3Jhdml0eSBTb2x2ZXJcbiAqL1xudmFyIENlbnRyYWxHcmF2aXR5U29sdmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIENlbnRyYWxHcmF2aXR5U29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENlbnRyYWxHcmF2aXR5U29sdmVyKTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMucGh5c2ljc0JvZHkgPSBwaHlzaWNzQm9keTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhDZW50cmFsR3Jhdml0eVNvbHZlciwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBmb3JjZXMgZm9yIGVhY2ggbm9kZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvbHZlKCkge1xuICAgICAgdmFyIGR4LCBkeSwgZGlzdGFuY2UsIG5vZGU7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcztcbiAgICAgIHZhciBmb3JjZXMgPSB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGVJbmRpY2VzW2ldO1xuICAgICAgICBub2RlID0gbm9kZXNbbm9kZUlkXTtcbiAgICAgICAgZHggPSAtbm9kZS54O1xuICAgICAgICBkeSA9IC1ub2RlLnk7XG4gICAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIGZvcmNlcywgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBmb3JjZXMgYmFzZWQgb24gdGhlIGRpc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR5XG4gICAgICogQHBhcmFtIHtPYmplY3Q8Tm9kZS5pZCwgdmlzLk5vZGU+fSBmb3JjZXNcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jYWxjdWxhdGVGb3JjZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBmb3JjZXMsIG5vZGUpIHtcbiAgICAgIHZhciBncmF2aXR5Rm9yY2UgPSBkaXN0YW5jZSA9PT0gMCA/IDAgOiB0aGlzLm9wdGlvbnMuY2VudHJhbEdyYXZpdHkgLyBkaXN0YW5jZTtcbiAgICAgIGZvcmNlc1tub2RlLmlkXS54ID0gZHggKiBncmF2aXR5Rm9yY2U7XG4gICAgICBmb3JjZXNbbm9kZS5pZF0ueSA9IGR5ICogZ3Jhdml0eUZvcmNlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ2VudHJhbEdyYXZpdHlTb2x2ZXI7XG59KCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciQzKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDMoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gX1JlZmxlY3QkY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMygpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFfUmVmbGVjdCRjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKF9SZWZsZWN0JGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChfUmVmbGVjdCRjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogQGF1Z21lbnRzIEJhcm5lc0h1dFNvbHZlclxuICovXG52YXIgRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhcm5lc0h1dFNvbHZlcikge1xuICBfaW5oZXJpdHMoRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlciwgX0Jhcm5lc0h1dFNvbHZlcik7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkMyhGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyKTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXIpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgIF90aGlzLl9ybmcgPSBBbGVhKFwiRk9SQ0UgQVRMQVMgMiBCQVNFRCBSRVBVTFNJT04gU09MVkVSXCIpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyBiYXNlZCBvbiB0aGUgZGlzdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICAgKiBAcGFyYW0ge251bWJlcn0gZHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR5XG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50QnJhbmNoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlciwgW3tcbiAgICBrZXk6IFwiX2NhbGN1bGF0ZUZvcmNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIG5vZGUsIHBhcmVudEJyYW5jaCkge1xuICAgICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAgIGRpc3RhbmNlID0gMC4xICogdGhpcy5fcm5nKCk7XG4gICAgICAgIGR4ID0gZGlzdGFuY2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yIDwgMSAmJiBub2RlLnNoYXBlLnJhZGl1cykge1xuICAgICAgICBkaXN0YW5jZSA9IE1hdGgubWF4KDAuMSArIHRoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvciAqIG5vZGUuc2hhcGUucmFkaXVzLCBkaXN0YW5jZSAtIG5vZGUuc2hhcGUucmFkaXVzKTtcbiAgICAgIH1cbiAgICAgIHZhciBkZWdyZWUgPSBub2RlLmVkZ2VzLmxlbmd0aCArIDE7XG4gICAgICAvLyB0aGUgZGl2aWRpbmcgYnkgdGhlIGRpc3RhbmNlIGN1YmVkIGluc3RlYWQgb2Ygc3F1YXJlZCBhbGxvd3MgdXMgdG8gZ2V0IHRoZSBmeCBhbmQgZnkgY29tcG9uZW50cyB3aXRob3V0IHNpbmVzIGFuZCBjb3NpbmVzXG4gICAgICAvLyBpdCBpcyBzaG9ydGhhbmQgZm9yIGdyYXZpdHlmb3JjZSB3aXRoIGRpc3RhbmNlIHNxdWFyZWQgYW5kIGZ4ID0gZHgvZGlzdGFuY2UgKiBncmF2aXR5Rm9yY2VcbiAgICAgIHZhciBncmF2aXR5Rm9yY2UgPSB0aGlzLm9wdGlvbnMuZ3Jhdml0YXRpb25hbENvbnN0YW50ICogcGFyZW50QnJhbmNoLm1hc3MgKiBub2RlLm9wdGlvbnMubWFzcyAqIGRlZ3JlZSAvIE1hdGgucG93KGRpc3RhbmNlLCAyKTtcbiAgICAgIHZhciBmeCA9IGR4ICogZ3Jhdml0eUZvcmNlO1xuICAgICAgdmFyIGZ5ID0gZHkgKiBncmF2aXR5Rm9yY2U7XG4gICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlLmlkXS54ICs9IGZ4O1xuICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZS5pZF0ueSArPSBmeTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXI7XG59KEJhcm5lc0h1dFNvbHZlcik7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciQyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDIoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gX1JlZmxlY3QkY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMigpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFfUmVmbGVjdCRjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKF9SZWZsZWN0JGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChfUmVmbGVjdCRjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogQGF1Z21lbnRzIENlbnRyYWxHcmF2aXR5U29sdmVyXG4gKi9cbnZhciBGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DZW50cmFsR3Jhdml0eVNvbHZlcikge1xuICBfaW5oZXJpdHMoRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyLCBfQ2VudHJhbEdyYXZpdHlTb2x2ZXIpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJDIoRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyKTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIpO1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBmb3JjZXMgYmFzZWQgb24gdGhlIGRpc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeVxuICAgKiBAcGFyYW0ge09iamVjdDxOb2RlLmlkLCBOb2RlPn0gZm9yY2VzXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlciwgW3tcbiAgICBrZXk6IFwiX2NhbGN1bGF0ZUZvcmNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIGZvcmNlcywgbm9kZSkge1xuICAgICAgaWYgKGRpc3RhbmNlID4gMCkge1xuICAgICAgICB2YXIgZGVncmVlID0gbm9kZS5lZGdlcy5sZW5ndGggKyAxO1xuICAgICAgICB2YXIgZ3Jhdml0eUZvcmNlID0gdGhpcy5vcHRpb25zLmNlbnRyYWxHcmF2aXR5ICogZGVncmVlICogbm9kZS5vcHRpb25zLm1hc3M7XG4gICAgICAgIGZvcmNlc1tub2RlLmlkXS54ID0gZHggKiBncmF2aXR5Rm9yY2U7XG4gICAgICAgIGZvcmNlc1tub2RlLmlkXS55ID0gZHkgKiBncmF2aXR5Rm9yY2U7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXI7XG59KENlbnRyYWxHcmF2aXR5U29sdmVyKTtcblxuLyoqXG4gKiBUaGUgcGh5c2ljcyBlbmdpbmVcbiAqL1xudmFyIFBoeXNpY3NFbmdpbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICovXG4gIGZ1bmN0aW9uIFBoeXNpY3NFbmdpbmUoYm9keSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQaHlzaWNzRW5naW5lKTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMucGh5c2ljc0JvZHkgPSB7XG4gICAgICBwaHlzaWNzTm9kZUluZGljZXM6IFtdLFxuICAgICAgcGh5c2ljc0VkZ2VJbmRpY2VzOiBbXSxcbiAgICAgIGZvcmNlczoge30sXG4gICAgICB2ZWxvY2l0aWVzOiB7fVxuICAgIH07XG4gICAgdGhpcy5waHlzaWNzRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5zaW11bGF0aW9uSW50ZXJ2YWwgPSAxMDAwIC8gNjA7XG4gICAgdGhpcy5yZXF1aXJlc1RpbWVvdXQgPSB0cnVlO1xuICAgIHRoaXMucHJldmlvdXNTdGF0ZXMgPSB7fTtcbiAgICB0aGlzLnJlZmVyZW5jZVN0YXRlID0ge307XG4gICAgdGhpcy5mcmVlemVDYWNoZSA9IHt9O1xuICAgIHRoaXMucmVuZGVyVGltZXIgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBwYXJhbWV0ZXJzIGZvciB0aGUgYWRhcHRpdmUgdGltZXN0ZXBcbiAgICB0aGlzLmFkYXB0aXZlVGltZXN0ZXAgPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0aXZlVGltZXN0ZXBFbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5hZGFwdGl2ZUNvdW50ZXIgPSAwO1xuICAgIHRoaXMuYWRhcHRpdmVJbnRlcnZhbCA9IDM7XG4gICAgdGhpcy5zdGFiaWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydGVkU3RhYmlsaXphdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMgPSAwO1xuICAgIHRoaXMucmVhZHkgPSBmYWxzZTsgLy8gd2lsbCBiZSBzZXQgdG8gdHJ1ZSBpZiB0aGUgc3RhYmlsaXplXG5cbiAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIGJhcm5lc0h1dDoge1xuICAgICAgICB0aGV0YTogMC41LFxuICAgICAgICBncmF2aXRhdGlvbmFsQ29uc3RhbnQ6IC0yMDAwLFxuICAgICAgICBjZW50cmFsR3Jhdml0eTogMC4zLFxuICAgICAgICBzcHJpbmdMZW5ndGg6IDk1LFxuICAgICAgICBzcHJpbmdDb25zdGFudDogMC4wNCxcbiAgICAgICAgZGFtcGluZzogMC4wOSxcbiAgICAgICAgYXZvaWRPdmVybGFwOiAwXG4gICAgICB9LFxuICAgICAgZm9yY2VBdGxhczJCYXNlZDoge1xuICAgICAgICB0aGV0YTogMC41LFxuICAgICAgICBncmF2aXRhdGlvbmFsQ29uc3RhbnQ6IC01MCxcbiAgICAgICAgY2VudHJhbEdyYXZpdHk6IDAuMDEsXG4gICAgICAgIHNwcmluZ0NvbnN0YW50OiAwLjA4LFxuICAgICAgICBzcHJpbmdMZW5ndGg6IDEwMCxcbiAgICAgICAgZGFtcGluZzogMC40LFxuICAgICAgICBhdm9pZE92ZXJsYXA6IDBcbiAgICAgIH0sXG4gICAgICByZXB1bHNpb246IHtcbiAgICAgICAgY2VudHJhbEdyYXZpdHk6IDAuMixcbiAgICAgICAgc3ByaW5nTGVuZ3RoOiAyMDAsXG4gICAgICAgIHNwcmluZ0NvbnN0YW50OiAwLjA1LFxuICAgICAgICBub2RlRGlzdGFuY2U6IDEwMCxcbiAgICAgICAgZGFtcGluZzogMC4wOSxcbiAgICAgICAgYXZvaWRPdmVybGFwOiAwXG4gICAgICB9LFxuICAgICAgaGllcmFyY2hpY2FsUmVwdWxzaW9uOiB7XG4gICAgICAgIGNlbnRyYWxHcmF2aXR5OiAwLjAsXG4gICAgICAgIHNwcmluZ0xlbmd0aDogMTAwLFxuICAgICAgICBzcHJpbmdDb25zdGFudDogMC4wMSxcbiAgICAgICAgbm9kZURpc3RhbmNlOiAxMjAsXG4gICAgICAgIGRhbXBpbmc6IDAuMDlcbiAgICAgIH0sXG4gICAgICBtYXhWZWxvY2l0eTogNTAsXG4gICAgICBtaW5WZWxvY2l0eTogMC43NSxcbiAgICAgIC8vIHB4L3NcbiAgICAgIHNvbHZlcjogXCJiYXJuZXNIdXRcIixcbiAgICAgIHN0YWJpbGl6YXRpb246IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgaXRlcmF0aW9uczogMTAwMCxcbiAgICAgICAgLy8gbWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9uIHRvIHN0YWJpbGl6ZVxuICAgICAgICB1cGRhdGVJbnRlcnZhbDogNTAsXG4gICAgICAgIG9ubHlEeW5hbWljRWRnZXM6IGZhbHNlLFxuICAgICAgICBmaXQ6IHRydWVcbiAgICAgIH0sXG4gICAgICB0aW1lc3RlcDogMC41LFxuICAgICAgYWRhcHRpdmVUaW1lc3RlcDogdHJ1ZSxcbiAgICAgIHdpbmQ6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfVxuICAgIH07XG4gICAgX09iamVjdCRhc3NpZ24odGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgICB0aGlzLnRpbWVzdGVwID0gMC41O1xuICAgIHRoaXMubGF5b3V0RmFpbGVkID0gZmFsc2U7XG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhQaHlzaWNzRW5naW5lLCBbe1xuICAgIGtleTogXCJiaW5kRXZlbnRMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiaW5pdFBoeXNpY3NcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5pbml0UGh5c2ljcygpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9sYXlvdXRGYWlsZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5sYXlvdXRGYWlsZWQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInJlc2V0UGh5c2ljc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnN0b3BTaW11bGF0aW9uKCk7XG4gICAgICAgIF90aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGlzYWJsZVBoeXNpY3NcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5waHlzaWNzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5zdG9wU2ltdWxhdGlvbigpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInJlc3RvcmVQaHlzaWNzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuc2V0T3B0aW9ucyhfdGhpcy5vcHRpb25zKTtcbiAgICAgICAgaWYgKF90aGlzLnJlYWR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgX3RoaXMuc3RhcnRTaW11bGF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJzdGFydFNpbXVsYXRpb25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMucmVhZHkgPT09IHRydWUpIHtcbiAgICAgICAgICBfdGhpcy5zdGFydFNpbXVsYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInN0b3BTaW11bGF0aW9uXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuc3RvcFNpbXVsYXRpb24oKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuc3RvcFNpbXVsYXRpb24oZmFsc2UpO1xuICAgICAgICBfdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFDaGFuZ2VkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gTm9kZXMgYW5kL29yIGVkZ2VzIGhhdmUgYmVlbiBhZGRlZCBvciByZW1vdmVkLCB1cGRhdGUgc2hvcnRjdXQgbGlzdHMuXG4gICAgICAgIF90aGlzLnVwZGF0ZVBoeXNpY3NEYXRhKCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gZGVidWc6IHNob3cgZm9yY2VzXG4gICAgICAvLyB0aGlzLmJvZHkuZW1pdHRlci5vbihcImFmdGVyRHJhd2luZ1wiLCAoY3R4KSA9PiB7dGhpcy5fZHJhd0ZvcmNlcyhjdHgpO30pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCB0aGUgcGh5c2ljcyBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5waHlzaWNzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuc3RvcFNpbXVsYXRpb24oKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMucGh5c2ljc0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuc3RhcnRTaW11bGF0aW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5waHlzaWNzRW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgc2VsZWN0aXZlTm90RGVlcEV4dGVuZChbXCJzdGFiaWxpemF0aW9uXCJdLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAgIG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsIFwic3RhYmlsaXphdGlvblwiKTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5lbmFibGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5waHlzaWNzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zdG9wU2ltdWxhdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgd2luZCA9IHRoaXMub3B0aW9ucy53aW5kO1xuICAgICAgICAgIGlmICh3aW5kKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmQueCAhPT0gXCJudW1iZXJcIiB8fCBfTnVtYmVyJGlzTmFOKHdpbmQueCkpIHtcbiAgICAgICAgICAgICAgd2luZC54ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZC55ICE9PSBcIm51bWJlclwiIHx8IF9OdW1iZXIkaXNOYU4od2luZC55KSkge1xuICAgICAgICAgICAgICB3aW5kLnkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHNldCB0aGUgdGltZXN0ZXBcbiAgICAgICAgICB0aGlzLnRpbWVzdGVwID0gdGhpcy5vcHRpb25zLnRpbWVzdGVwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb25maWd1cmUgdGhlIGVuZ2luZS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgb3B0aW9ucztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc29sdmVyID09PSBcImZvcmNlQXRsYXMyQmFzZWRcIikge1xuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLmZvcmNlQXRsYXMyQmFzZWQ7XG4gICAgICAgIHRoaXMubm9kZXNTb2x2ZXIgPSBuZXcgRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVkZ2VzU29sdmVyID0gbmV3IFNwcmluZ1NvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmdyYXZpdHlTb2x2ZXIgPSBuZXcgRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zb2x2ZXIgPT09IFwicmVwdWxzaW9uXCIpIHtcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5yZXB1bHNpb247XG4gICAgICAgIHRoaXMubm9kZXNTb2x2ZXIgPSBuZXcgUmVwdWxzaW9uU29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZWRnZXNTb2x2ZXIgPSBuZXcgU3ByaW5nU29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZ3Jhdml0eVNvbHZlciA9IG5ldyBDZW50cmFsR3Jhdml0eVNvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc29sdmVyID09PSBcImhpZXJhcmNoaWNhbFJlcHVsc2lvblwiKSB7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsUmVwdWxzaW9uO1xuICAgICAgICB0aGlzLm5vZGVzU29sdmVyID0gbmV3IEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVkZ2VzU29sdmVyID0gbmV3IEhpZXJhcmNoaWNhbFNwcmluZ1NvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmdyYXZpdHlTb2x2ZXIgPSBuZXcgQ2VudHJhbEdyYXZpdHlTb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGJhcm5lc0h1dFxuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLmJhcm5lc0h1dDtcbiAgICAgICAgdGhpcy5ub2Rlc1NvbHZlciA9IG5ldyBCYXJuZXNIdXRTb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5lZGdlc1NvbHZlciA9IG5ldyBTcHJpbmdTb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5ncmF2aXR5U29sdmVyID0gbmV3IENlbnRyYWxHcmF2aXR5U29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICB0aGlzLm1vZGVsT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5pdGlhbGl6ZSB0aGUgZW5naW5lXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFBoeXNpY3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFBoeXNpY3MoKSB7XG4gICAgICBpZiAodGhpcy5waHlzaWNzRW5hYmxlZCA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24uZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuc3RhYmlsaXplKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGFiaWxpemVkID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImZpdFwiLCB7fSwgdGhpcy5sYXlvdXRGYWlsZWQpOyAvLyBpZiB0aGUgbGF5b3V0IGZhaWxlZCwgd2UgdXNlIHRoZSBhcHByb3hpbWF0aW9uIGZvciB0aGUgem9vbVxuICAgICAgICAgIHRoaXMuc3RhcnRTaW11bGF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiZml0XCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHRoZSBzaW11bGF0aW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRTaW11bGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0U2ltdWxhdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnBoeXNpY3NFbmFibGVkID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc3RhYmlsaXplZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIHdoZW4gdmlzaWJsZSwgYWRhcHRpdml0eSBpcyBkaXNhYmxlZC5cbiAgICAgICAgdGhpcy5hZGFwdGl2ZVRpbWVzdGVwID0gZmFsc2U7XG5cbiAgICAgICAgLy8gdGhpcyBzZXRzIHRoZSB3aWR0aCBvZiBhbGwgbm9kZXMgaW5pdGlhbGx5IHdoaWNoIGNvdWxkIGJlIHJlcXVpcmVkIGZvciB0aGUgYXZvaWRPdmVybGFwXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVzaXplTm9kZXNcIik7XG4gICAgICAgIGlmICh0aGlzLnZpZXdGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0O1xuICAgICAgICAgIHRoaXMudmlld0Z1bmN0aW9uID0gX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQgPSB0aGlzLnNpbXVsYXRpb25TdGVwKS5jYWxsKF9jb250ZXh0LCB0aGlzKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImluaXRSZWRyYXdcIiwgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfc3RhcnRSZW5kZXJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIHNpbXVsYXRpb24sIGZvcmNlIHN0YWJpbGl6YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtlbWl0PXRydWVdXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcFNpbXVsYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcFNpbXVsYXRpb24oKSB7XG4gICAgICB2YXIgZW1pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICAgIHRoaXMuc3RhYmlsaXplZCA9IHRydWU7XG4gICAgICBpZiAoZW1pdCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9lbWl0U3RhYmlsaXplZCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudmlld0Z1bmN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKFwiaW5pdFJlZHJhd1wiLCB0aGlzLnZpZXdGdW5jdGlvbik7XG4gICAgICAgIHRoaXMudmlld0Z1bmN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZW1pdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfc3RvcFJlbmRlcmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB2aWV3RnVuY3Rpb24gaW5zZXJ0cyB0aGlzIHN0ZXAgaW50byBlYWNoIHJlbmRlciBsb29wLiBJdCBjYWxscyB0aGUgcGh5c2ljcyB0aWNrIGFuZCBoYW5kbGVzIHRoZSBjbGVhbnVwIGF0IHN0YWJpbGl6ZWQuXG4gICAgICpcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzaW11bGF0aW9uU3RlcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaW11bGF0aW9uU3RlcCgpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBwaHlzaWNzIGhhdmUgc2V0dGxlZFxuICAgICAgdmFyIHN0YXJ0VGltZSA9IF9EYXRlJG5vdygpO1xuICAgICAgdGhpcy5waHlzaWNzVGljaygpO1xuICAgICAgdmFyIHBoeXNpY3NUaW1lID0gX0RhdGUkbm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICAgIC8vIHJ1biBkb3VibGUgc3BlZWQgaWYgaXQgaXMgYSBsaXR0bGUgZ3JhcGhcbiAgICAgIGlmICgocGh5c2ljc1RpbWUgPCAwLjQgKiB0aGlzLnNpbXVsYXRpb25JbnRlcnZhbCB8fCB0aGlzLnJ1bkRvdWJsZVNwZWVkID09PSB0cnVlKSAmJiB0aGlzLnN0YWJpbGl6ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucGh5c2ljc1RpY2soKTtcblxuICAgICAgICAvLyB0aGlzIG1ha2VzIHN1cmUgdGhlcmUgaXMgbm8gaml0dGVyLiBUaGUgZGVjaXNpb24gaXMgdGFrZW4gb25jZSB0byBydW4gaXQgYXQgZG91YmxlIHNwZWVkLlxuICAgICAgICB0aGlzLnJ1bkRvdWJsZVNwZWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YWJpbGl6ZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zdG9wU2ltdWxhdGlvbigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRyaWdnZXIgdGhlIHN0YWJpbGl6ZWQgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Ftb3VudE9mSXRlcmF0aW9ucz10aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2VtaXRTdGFiaWxpemVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbWl0U3RhYmlsaXplZCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIGFtb3VudE9mSXRlcmF0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucztcbiAgICAgIGlmICh0aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zID4gMSB8fCB0aGlzLnN0YXJ0ZWRTdGFiaWxpemF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgIF9zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFiaWxpemVkXCIsIHtcbiAgICAgICAgICAgIGl0ZXJhdGlvbnM6IGFtb3VudE9mSXRlcmF0aW9uc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIF90aGlzMi5zdGFydGVkU3RhYmlsaXphdGlvbiA9IGZhbHNlO1xuICAgICAgICAgIF90aGlzMi5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA9IDA7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZm9yY2VzIGZvciBvbmUgcGh5c2ljcyBpdGVyYXRpb24gYW5kIG1vdmUgdGhlIG5vZGVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwaHlzaWNzU3RlcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwaHlzaWNzU3RlcCgpIHtcbiAgICAgIHRoaXMuZ3Jhdml0eVNvbHZlci5zb2x2ZSgpO1xuICAgICAgdGhpcy5ub2Rlc1NvbHZlci5zb2x2ZSgpO1xuICAgICAgdGhpcy5lZGdlc1NvbHZlci5zb2x2ZSgpO1xuICAgICAgdGhpcy5tb3ZlTm9kZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGR5bmFtaWMgYWRqdXN0bWVudHMgdG8gdGhlIHRpbWVzdGVwLCBiYXNlZCBvbiBjdXJyZW50IHN0YXRlLlxuICAgICAqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBwaHlzaWNzVGljaygpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhZGp1c3RUaW1lU3RlcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGp1c3RUaW1lU3RlcCgpIHtcbiAgICAgIHZhciBmYWN0b3IgPSAxLjI7IC8vIEZhY3RvciBmb3IgaW5jcmVhc2luZyB0aGUgdGltZXN0ZXAgb24gc3VjY2Vzcy5cblxuICAgICAgLy8gd2UgY29tcGFyZSB0aGUgdHdvIHN0ZXBzLiBpZiBpdCBpcyBhY2NlcHRhYmxlIHdlIGRvdWJsZSB0aGUgc3RlcC5cbiAgICAgIGlmICh0aGlzLl9ldmFsdWF0ZVN0ZXBRdWFsaXR5KCkgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy50aW1lc3RlcCA9IGZhY3RvciAqIHRoaXMudGltZXN0ZXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBub3QsIHdlIGRlY3JlYXNlIHRoZSBzdGVwIHRvIGEgbWluaW11bSBvZiB0aGUgb3B0aW9ucyB0aW1lc3RlcC5cbiAgICAgICAgLy8gaWYgdGhlIGRlY3JlYXNlZCB0aW1lc3RlcCBpcyBzbWFsbGVyIHRoYW4gdGhlIG9wdGlvbnMgc3RlcCwgd2UgZG8gbm90IHJlc2V0IHRoZSBjb3VudGVyXG4gICAgICAgIC8vIHdlIGFzc3VtZSB0aGF0IHRoZSBvcHRpb25zIHRpbWVzdGVwIGlzIHN0YWJsZSBlbm91Z2guXG4gICAgICAgIGlmICh0aGlzLnRpbWVzdGVwIC8gZmFjdG9yIDwgdGhpcy5vcHRpb25zLnRpbWVzdGVwKSB7XG4gICAgICAgICAgdGhpcy50aW1lc3RlcCA9IHRoaXMub3B0aW9ucy50aW1lc3RlcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiB0aGUgdGltZXN0ZXAgd2FzIGxhcmdlciB0aGFuIDIgdGltZXMgdGhlIG9wdGlvbiBvbmUgd2UgY2hlY2sgdGhlIGFkYXB0aXZpdHkgYWdhaW4gdG8gZW5zdXJlXG4gICAgICAgICAgLy8gdGhhdCBsYXJnZSBpbnN0YWJpbGl0aWVzIGRvIG5vdCBmb3JtLlxuICAgICAgICAgIHRoaXMuYWRhcHRpdmVDb3VudGVyID0gLTE7IC8vIGNoZWNrIGFnYWluIG5leHQgaXRlcmF0aW9uXG4gICAgICAgICAgdGhpcy50aW1lc3RlcCA9IE1hdGgubWF4KHRoaXMub3B0aW9ucy50aW1lc3RlcCwgdGhpcy50aW1lc3RlcCAvIGZhY3Rvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNpbmdsZSBzaW11bGF0aW9uIHN0ZXAgKG9yICd0aWNrJykgaW4gdGhlIHBoeXNpY3Mgc2ltdWxhdGlvblxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwaHlzaWNzVGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwaHlzaWNzVGljaygpIHtcbiAgICAgIHRoaXMuX3N0YXJ0U3RhYmlsaXppbmcoKTsgLy8gdGhpcyBlbnN1cmVzIHRoYXQgdGhlcmUgaXMgbm8gc3RhcnQgZXZlbnQgd2hlbiB0aGUgbmV0d29yayBpcyBhbHJlYWR5IHN0YWJsZS5cbiAgICAgIGlmICh0aGlzLnN0YWJpbGl6ZWQgPT09IHRydWUpIHJldHVybjtcblxuICAgICAgLy8gYWRhcHRpdml0eSBtZWFucyB0aGUgdGltZXN0ZXAgYWRhcHRzIHRvIHRoZSBzaXR1YXRpb24sIG9ubHkgYXBwbGljYWJsZSBmb3Igc3RhYmlsaXphdGlvblxuICAgICAgaWYgKHRoaXMuYWRhcHRpdmVUaW1lc3RlcCA9PT0gdHJ1ZSAmJiB0aGlzLmFkYXB0aXZlVGltZXN0ZXBFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIC8vIHRpbWVzdGVwIHJlbWFpbnMgc3RhYmxlIGZvciBcImludGVydmFsXCIgaXRlcmF0aW9ucy5cbiAgICAgICAgdmFyIGRvQWRhcHRpdmUgPSB0aGlzLmFkYXB0aXZlQ291bnRlciAlIHRoaXMuYWRhcHRpdmVJbnRlcnZhbCA9PT0gMDtcbiAgICAgICAgaWYgKGRvQWRhcHRpdmUpIHtcbiAgICAgICAgICAvLyBmaXJzdCB0aGUgYmlnIHN0ZXAgYW5kIHJldmVydC5cbiAgICAgICAgICB0aGlzLnRpbWVzdGVwID0gMiAqIHRoaXMudGltZXN0ZXA7XG4gICAgICAgICAgdGhpcy5waHlzaWNzU3RlcCgpO1xuICAgICAgICAgIHRoaXMucmV2ZXJ0KCk7IC8vIHNhdmVzIHRoZSByZWZlcmVuY2Ugc3RhdGVcblxuICAgICAgICAgIC8vIG5vdyB0aGUgbm9ybWFsIHN0ZXAuIFNpbmNlIHRoaXMgaXMgdGhlIGxhc3Qgc3RlcCwgaXQgaXMgdGhlIG1vcmUgc3RhYmxlIG9uZSBhbmQgd2Ugd2lsbCB0YWtlIHRoaXMuXG4gICAgICAgICAgdGhpcy50aW1lc3RlcCA9IDAuNSAqIHRoaXMudGltZXN0ZXA7XG5cbiAgICAgICAgICAvLyBzaW5jZSBpdCdzIGhhbGYgdGhlIHN0ZXAsIHdlIGRvIGl0IHR3aWNlLlxuICAgICAgICAgIHRoaXMucGh5c2ljc1N0ZXAoKTtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NTdGVwKCk7XG4gICAgICAgICAgdGhpcy5hZGp1c3RUaW1lU3RlcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGh5c2ljc1N0ZXAoKTsgLy8gbm9ybWFsIHN0ZXAsIGtlZXBpbmcgdGltZXN0ZXAgY29uc3RhbnRcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRhcHRpdmVDb3VudGVyICs9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjYXNlIGZvciB0aGUgc3RhdGljIHRpbWVzdGVwLCB3ZSByZXNldCBpdCB0byB0aGUgb25lIGluIG9wdGlvbnMgYW5kIHRha2UgYSBub3JtYWwgc3RlcC5cbiAgICAgICAgdGhpcy50aW1lc3RlcCA9IHRoaXMub3B0aW9ucy50aW1lc3RlcDtcbiAgICAgICAgdGhpcy5waHlzaWNzU3RlcCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhYmlsaXplZCA9PT0gdHJ1ZSkgdGhpcy5yZXZlcnQoKTtcbiAgICAgIHRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMrKztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb2RlcyBhbmQgZWRnZXMgY2FuIGhhdmUgdGhlIHBoeXNpY3MgdG9nZ2xlcyBvbiBvciBvZmYuIEEgY29sbGVjdGlvbiBvZiBpbmRpY2VzIGlzIGNyZWF0ZWQgaGVyZSBzbyB3ZSBjYW4gc2tpcCB0aGUgY2hlY2sgYWxsIHRoZSB0aW1lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVQaHlzaWNzRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVQaHlzaWNzRGF0YSgpIHtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzID0ge307XG4gICAgICB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcyA9IFtdO1xuICAgICAgdGhpcy5waHlzaWNzQm9keS5waHlzaWNzRWRnZUluZGljZXMgPSBbXTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcblxuICAgICAgLy8gZ2V0IG5vZGUgaW5kaWNlcyBmb3IgcGh5c2ljc1xuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIG5vZGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICBpZiAobm9kZXNbbm9kZUlkXS5vcHRpb25zLnBoeXNpY3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLnB1c2gobm9kZXNbbm9kZUlkXS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGdldCBlZGdlIGluZGljZXMgZm9yIHBoeXNpY3NcbiAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiBlZGdlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVkZ2VzLCBlZGdlSWQpKSB7XG4gICAgICAgICAgaWYgKGVkZ2VzW2VkZ2VJZF0ub3B0aW9ucy5waHlzaWNzID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NFZGdlSW5kaWNlcy5wdXNoKGVkZ2VzW2VkZ2VJZF0uaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBnZXQgdGhlIHZlbG9jaXR5IGFuZCB0aGUgZm9yY2VzIHZlY3RvclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX25vZGVJZCA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzW2ldO1xuICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tfbm9kZUlkXSA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBmb3JjZXMgY2FuIGJlIHJlc2V0IGJlY2F1c2UgdGhleSBhcmUgcmVjYWxjdWxhdGVkLiBWZWxvY2l0aWVzIGhhdmUgdG8gcGVyc2lzdC5cbiAgICAgICAgaWYgKHRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllc1tfbm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzW19ub2RlSWRdID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNsZWFuIGRlbGV0ZWQgbm9kZXMgZnJvbSB0aGUgdmVsb2NpdHkgdmVjdG9yXG4gICAgICBmb3IgKHZhciBfbm9kZUlkMiBpbiB0aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXMpIHtcbiAgICAgICAgaWYgKG5vZGVzW19ub2RlSWQyXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllc1tfbm9kZUlkMl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnQgdGhlIHNpbXVsYXRpb24gb25lIHN0ZXAuIFRoaXMgaXMgZG9uZSBzbyBhZnRlciBzdGFiaWxpemF0aW9uLCBldmVyeSBuZXcgc3RhcnQgb2YgdGhlIHNpbXVsYXRpb24gd2lsbCBhbHNvIHNheSBzdGFiaWxpemVkLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJldmVydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXZlcnQoKSB7XG4gICAgICB2YXIgbm9kZUlkcyA9IF9PYmplY3Qka2V5cyh0aGlzLnByZXZpb3VzU3RhdGVzKTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciB2ZWxvY2l0aWVzID0gdGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzO1xuICAgICAgdGhpcy5yZWZlcmVuY2VTdGF0ZSA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlSWQgPSBub2RlSWRzW2ldO1xuICAgICAgICBpZiAobm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG5vZGVzW25vZGVJZF0ub3B0aW9ucy5waHlzaWNzID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnJlZmVyZW5jZVN0YXRlW25vZGVJZF0gPSB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uczoge1xuICAgICAgICAgICAgICAgIHg6IG5vZGVzW25vZGVJZF0ueCxcbiAgICAgICAgICAgICAgICB5OiBub2Rlc1tub2RlSWRdLnlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZlbG9jaXRpZXNbbm9kZUlkXS54ID0gdGhpcy5wcmV2aW91c1N0YXRlc1tub2RlSWRdLnZ4O1xuICAgICAgICAgICAgdmVsb2NpdGllc1tub2RlSWRdLnkgPSB0aGlzLnByZXZpb3VzU3RhdGVzW25vZGVJZF0udnk7XG4gICAgICAgICAgICBub2Rlc1tub2RlSWRdLnggPSB0aGlzLnByZXZpb3VzU3RhdGVzW25vZGVJZF0ueDtcbiAgICAgICAgICAgIG5vZGVzW25vZGVJZF0ueSA9IHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXS55O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5wcmV2aW91c1N0YXRlc1tub2RlSWRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBjb21wYXJlcyB0aGUgcmVmZXJlbmNlIHN0YXRlIHRvIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9ldmFsdWF0ZVN0ZXBRdWFsaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmFsdWF0ZVN0ZXBRdWFsaXR5KCkge1xuICAgICAgdmFyIGR4LCBkeSwgZHBvcztcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciByZWZlcmVuY2UgPSB0aGlzLnJlZmVyZW5jZVN0YXRlO1xuICAgICAgdmFyIHBvc1RocmVzaG9sZCA9IDAuMztcbiAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLnJlZmVyZW5jZVN0YXRlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5yZWZlcmVuY2VTdGF0ZSwgbm9kZUlkKSAmJiBub2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkeCA9IG5vZGVzW25vZGVJZF0ueCAtIHJlZmVyZW5jZVtub2RlSWRdLnBvc2l0aW9ucy54O1xuICAgICAgICAgIGR5ID0gbm9kZXNbbm9kZUlkXS55IC0gcmVmZXJlbmNlW25vZGVJZF0ucG9zaXRpb25zLnk7XG4gICAgICAgICAgZHBvcyA9IE1hdGguc3FydChNYXRoLnBvdyhkeCwgMikgKyBNYXRoLnBvdyhkeSwgMikpO1xuICAgICAgICAgIGlmIChkcG9zID4gcG9zVGhyZXNob2xkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtb3ZlIHRoZSBub2RlcyBvbmUgdGltZXN0ZXAgYW5kIGNoZWNrIGlmIHRoZXkgYXJlIHN0YWJpbGl6ZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJtb3ZlTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZU5vZGVzKCkge1xuICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICB2YXIgbWF4Tm9kZVZlbG9jaXR5ID0gMDtcbiAgICAgIHZhciBhdmVyYWdlTm9kZVZlbG9jaXR5ID0gMDtcblxuICAgICAgLy8gdGhlIHZlbG9jaXR5IHRocmVzaG9sZCAoZW5lcmd5IGluIHRoZSBzeXN0ZW0pIGZvciB0aGUgYWRhcHRpdml0eSB0b2dnbGVcbiAgICAgIHZhciB2ZWxvY2l0eUFkYXB0aXZlVGhyZXNob2xkID0gNTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGVJbmRpY2VzW2ldO1xuICAgICAgICB2YXIgbm9kZVZlbG9jaXR5ID0gdGhpcy5fcGVyZm9ybVN0ZXAobm9kZUlkKTtcbiAgICAgICAgLy8gc3RhYmlsaXplZCBpcyB0cnVlIGlmIHN0YWJpbGl6ZWQgaXMgdHJ1ZSBhbmQgdmVsb2NpdHkgaXMgc21hbGxlciB0aGFuIHZtaW4gLS0+IGFsbCBub2RlcyBtdXN0IGJlIHN0YWJpbGl6ZWRcbiAgICAgICAgbWF4Tm9kZVZlbG9jaXR5ID0gTWF0aC5tYXgobWF4Tm9kZVZlbG9jaXR5LCBub2RlVmVsb2NpdHkpO1xuICAgICAgICBhdmVyYWdlTm9kZVZlbG9jaXR5ICs9IG5vZGVWZWxvY2l0eTtcbiAgICAgIH1cblxuICAgICAgLy8gZXZhbHVhdGluZyB0aGUgc3RhYmlsaXplZCBhbmQgYWRhcHRpdmVUaW1lc3RlcEVuYWJsZWQgY29uZGl0aW9uc1xuICAgICAgdGhpcy5hZGFwdGl2ZVRpbWVzdGVwRW5hYmxlZCA9IGF2ZXJhZ2VOb2RlVmVsb2NpdHkgLyBub2RlSW5kaWNlcy5sZW5ndGggPCB2ZWxvY2l0eUFkYXB0aXZlVGhyZXNob2xkO1xuICAgICAgdGhpcy5zdGFiaWxpemVkID0gbWF4Tm9kZVZlbG9jaXR5IDwgdGhpcy5vcHRpb25zLm1pblZlbG9jaXR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBuZXcgdmVsb2NpdHkgZm9yIGEgY29vcmRpbmF0ZSBkaXJlY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2ICB2ZWxvY2l0eSBmb3IgY3VycmVudCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGYgIHJlZ3VsYXIgZm9yY2UgZm9yIGN1cnJlbnQgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtICBtYXNzIG9mIGN1cnJlbnQgbm9kZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG5ldyB2ZWxvY2l0eSBmb3IgY3VycmVudCBjb29yZGluYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxhdGVDb21wb25lbnRWZWxvY2l0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVDb21wb25lbnRWZWxvY2l0eSh2LCBmLCBtKSB7XG4gICAgICB2YXIgZGYgPSB0aGlzLm1vZGVsT3B0aW9ucy5kYW1waW5nICogdjsgLy8gZGFtcGluZyBmb3JjZVxuICAgICAgdmFyIGEgPSAoZiAtIGRmKSAvIG07IC8vIGFjY2VsZXJhdGlvblxuXG4gICAgICB2ICs9IGEgKiB0aGlzLnRpbWVzdGVwO1xuXG4gICAgICAvLyBQdXQgYSBsaW1pdCBvbiB0aGUgdmVsb2NpdGllcyBpZiBpdCBpcyByZWFsbHkgaGlnaFxuICAgICAgdmFyIG1heFYgPSB0aGlzLm9wdGlvbnMubWF4VmVsb2NpdHkgfHwgMWU5O1xuICAgICAgaWYgKE1hdGguYWJzKHYpID4gbWF4Vikge1xuICAgICAgICB2ID0gdiA+IDAgPyBtYXhWIDogLW1heFY7XG4gICAgICB9XG4gICAgICByZXR1cm4gdjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIHRoZSBhY3R1YWwgc3RlcFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgbmV3IHZlbG9jaXR5IG9mIGdpdmVuIG5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9wZXJmb3JtU3RlcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGVyZm9ybVN0ZXAobm9kZUlkKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgdmFyIGZvcmNlID0gdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZUlkXTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMud2luZCkge1xuICAgICAgICBmb3JjZS54ICs9IHRoaXMub3B0aW9ucy53aW5kLng7XG4gICAgICAgIGZvcmNlLnkgKz0gdGhpcy5vcHRpb25zLndpbmQueTtcbiAgICAgIH1cbiAgICAgIHZhciB2ZWxvY2l0eSA9IHRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllc1tub2RlSWRdO1xuXG4gICAgICAvLyBzdG9yZSB0aGUgc3RhdGUgc28gd2UgY2FuIHJldmVydFxuICAgICAgdGhpcy5wcmV2aW91c1N0YXRlc1tub2RlSWRdID0ge1xuICAgICAgICB4OiBub2RlLngsXG4gICAgICAgIHk6IG5vZGUueSxcbiAgICAgICAgdng6IHZlbG9jaXR5LngsXG4gICAgICAgIHZ5OiB2ZWxvY2l0eS55XG4gICAgICB9O1xuICAgICAgaWYgKG5vZGUub3B0aW9ucy5maXhlZC54ID09PSBmYWxzZSkge1xuICAgICAgICB2ZWxvY2l0eS54ID0gdGhpcy5jYWxjdWxhdGVDb21wb25lbnRWZWxvY2l0eSh2ZWxvY2l0eS54LCBmb3JjZS54LCBub2RlLm9wdGlvbnMubWFzcyk7XG4gICAgICAgIG5vZGUueCArPSB2ZWxvY2l0eS54ICogdGhpcy50aW1lc3RlcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcmNlLnggPSAwO1xuICAgICAgICB2ZWxvY2l0eS54ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLm9wdGlvbnMuZml4ZWQueSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmVsb2NpdHkueSA9IHRoaXMuY2FsY3VsYXRlQ29tcG9uZW50VmVsb2NpdHkodmVsb2NpdHkueSwgZm9yY2UueSwgbm9kZS5vcHRpb25zLm1hc3MpO1xuICAgICAgICBub2RlLnkgKz0gdmVsb2NpdHkueSAqIHRoaXMudGltZXN0ZXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JjZS55ID0gMDtcbiAgICAgICAgdmVsb2NpdHkueSA9IDA7XG4gICAgICB9XG4gICAgICB2YXIgdG90YWxWZWxvY2l0eSA9IE1hdGguc3FydChNYXRoLnBvdyh2ZWxvY2l0eS54LCAyKSArIE1hdGgucG93KHZlbG9jaXR5LnksIDIpKTtcbiAgICAgIHJldHVybiB0b3RhbFZlbG9jaXR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gaW5pdGlhbGl6aW5nIGFuZCBzdGFiaWxpemluZywgd2UgY2FuIGZyZWV6ZSBub2RlcyB3aXRoIGEgcHJlZGVmaW5lZCBwb3NpdGlvbi5cbiAgICAgKiBUaGlzIGdyZWF0bHkgc3BlZWRzIHVwIHN0YWJpbGl6YXRpb24gYmVjYXVzZSBvbmx5IHRoZSBzdXBwb3J0bm9kZXMgZm9yIHRoZSBzbW9vdGhDdXJ2ZXMgaGF2ZSB0byBzZXR0bGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9mcmVlemVOb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZnJlZXplTm9kZXMoKSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICBmb3IgKHZhciBpZCBpbiBub2Rlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGVzLCBpZCkpIHtcbiAgICAgICAgICBpZiAobm9kZXNbaWRdLnggJiYgbm9kZXNbaWRdLnkpIHtcbiAgICAgICAgICAgIHZhciBmaXhlZCA9IG5vZGVzW2lkXS5vcHRpb25zLmZpeGVkO1xuICAgICAgICAgICAgdGhpcy5mcmVlemVDYWNoZVtpZF0gPSB7XG4gICAgICAgICAgICAgIHg6IGZpeGVkLngsXG4gICAgICAgICAgICAgIHk6IGZpeGVkLnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmaXhlZC54ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZpeGVkLnkgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVuZnJlZXplcyB0aGUgbm9kZXMgdGhhdCBoYXZlIGJlZW4gZnJvemVuIGJ5IF9mcmVlemVEZWZpbmVkTm9kZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9yZXN0b3JlRnJvemVuTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc3RvcmVGcm96ZW5Ob2RlcygpIHtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIGZvciAodmFyIGlkIGluIG5vZGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZXMsIGlkKSkge1xuICAgICAgICAgIGlmICh0aGlzLmZyZWV6ZUNhY2hlW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub2Rlc1tpZF0ub3B0aW9ucy5maXhlZC54ID0gdGhpcy5mcmVlemVDYWNoZVtpZF0ueDtcbiAgICAgICAgICAgIG5vZGVzW2lkXS5vcHRpb25zLmZpeGVkLnkgPSB0aGlzLmZyZWV6ZUNhY2hlW2lkXS55O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5mcmVlemVDYWNoZSA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgYSBzdGFibGUgcG9zaXRpb24gZm9yIGFsbCBub2Rlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtpdGVyYXRpb25zPXRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLml0ZXJhdGlvbnNdXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic3RhYmlsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YWJpbGl6ZSgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLml0ZXJhdGlvbnM7XG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdGlvbnMgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaXRlcmF0aW9ucyA9IHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLml0ZXJhdGlvbnM7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUaGUgc3RhYmlsaXplIG1ldGhvZCBuZWVkcyBhIG51bWVyaWMgYW1vdW50IG9mIGl0ZXJhdGlvbnMuIFN3aXRjaGluZyB0byBkZWZhdWx0OiBcIiwgaXRlcmF0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGVuYWJsZSBhZGFwdGl2ZSB0aW1lc3RlcHNcbiAgICAgIHRoaXMuYWRhcHRpdmVUaW1lc3RlcCA9IHRoaXMub3B0aW9ucy5hZGFwdGl2ZVRpbWVzdGVwO1xuXG4gICAgICAvLyB0aGlzIHNldHMgdGhlIHdpZHRoIG9mIGFsbCBub2RlcyBpbml0aWFsbHkgd2hpY2ggY291bGQgYmUgcmVxdWlyZWQgZm9yIHRoZSBhdm9pZE92ZXJsYXBcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVzaXplTm9kZXNcIik7XG4gICAgICB0aGlzLnN0b3BTaW11bGF0aW9uKCk7IC8vIHN0b3AgdGhlIHJlbmRlciBsb29wXG4gICAgICB0aGlzLnN0YWJpbGl6ZWQgPSBmYWxzZTtcblxuICAgICAgLy8gYmxvY2sgcmVkcmF3IHJlcXVlc3RzXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2Jsb2NrUmVkcmF3XCIpO1xuICAgICAgdGhpcy50YXJnZXRJdGVyYXRpb25zID0gaXRlcmF0aW9ucztcblxuICAgICAgLy8gc3RhcnQgdGhlIHN0YWJpbGl6YXRpb25cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5vbmx5RHluYW1pY0VkZ2VzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX2ZyZWV6ZU5vZGVzKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zID0gMDtcbiAgICAgIF9zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5fc3RhYmlsaXphdGlvbkJhdGNoKCk7XG4gICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiBub3QgYWxyZWFkeSBzdGFiaWxpemluZywgc3RhcnQgaXQgYW5kIGVtaXQgYSBzdGFydCBldmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHN0YWJpbGl6YXRpb24gc3RhcnRlZCB3aXRoIHRoaXMgY2FsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3N0YXJ0U3RhYmlsaXppbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0YXJ0U3RhYmlsaXppbmcoKSB7XG4gICAgICBpZiAodGhpcy5zdGFydGVkU3RhYmlsaXphdGlvbiA9PT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U3RhYmlsaXppbmdcIik7XG4gICAgICB0aGlzLnN0YXJ0ZWRTdGFiaWxpemF0aW9uID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9uZSBiYXRjaCBvZiBzdGFiaWxpemF0aW9uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9zdGFiaWxpemF0aW9uQmF0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0YWJpbGl6YXRpb25CYXRjaCgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgdmFyIHJ1bm5pbmcgPSBmdW5jdGlvbiBydW5uaW5nKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM0LnN0YWJpbGl6ZWQgPT09IGZhbHNlICYmIF90aGlzNC5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA8IF90aGlzNC50YXJnZXRJdGVyYXRpb25zO1xuICAgICAgfTtcbiAgICAgIHZhciBzZW5kUHJvZ3Jlc3MgPSBmdW5jdGlvbiBzZW5kUHJvZ3Jlc3MoKSB7XG4gICAgICAgIF90aGlzNC5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YWJpbGl6YXRpb25Qcm9ncmVzc1wiLCB7XG4gICAgICAgICAgaXRlcmF0aW9uczogX3RoaXM0LnN0YWJpbGl6YXRpb25JdGVyYXRpb25zLFxuICAgICAgICAgIHRvdGFsOiBfdGhpczQudGFyZ2V0SXRlcmF0aW9uc1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5fc3RhcnRTdGFiaWxpemluZygpKSB7XG4gICAgICAgIHNlbmRQcm9ncmVzcygpOyAvLyBFbnN1cmUgdGhhdCB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgc3RhcnQgZXZlbnQuXG4gICAgICB9XG5cbiAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICB3aGlsZSAocnVubmluZygpICYmIGNvdW50IDwgdGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24udXBkYXRlSW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5waHlzaWNzVGljaygpO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgICAgc2VuZFByb2dyZXNzKCk7XG4gICAgICBpZiAocnVubmluZygpKSB7XG4gICAgICAgIHZhciBfY29udGV4dDI7XG4gICAgICAgIF9zZXRUaW1lb3V0KF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MiA9IHRoaXMuX3N0YWJpbGl6YXRpb25CYXRjaCkuY2FsbChfY29udGV4dDIsIHRoaXMpLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2ZpbmFsaXplU3RhYmlsaXphdGlvbigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdyYXAgdXAgdGhlIHN0YWJpbGl6YXRpb24sIGZpdCBhbmQgZW1pdCB0aGUgZXZlbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZmluYWxpemVTdGFiaWxpemF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5hbGl6ZVN0YWJpbGl6YXRpb24oKSB7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2FsbG93UmVkcmF3XCIpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLmZpdCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiZml0XCIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLm9ubHlEeW5hbWljRWRnZXMgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fcmVzdG9yZUZyb3plbk5vZGVzKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhYmlsaXphdGlvbkl0ZXJhdGlvbnNEb25lXCIpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgaWYgKHRoaXMuc3RhYmlsaXplZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9lbWl0U3RhYmlsaXplZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGFydFNpbXVsYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICBERUJVR0dJTkcgQkVMT1cgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAvKipcbiAgICAgKiBEZWJ1ZyBmdW5jdGlvbiB0aGF0IGRpc3BsYXkgYXJyb3dzIGZvciB0aGUgZm9yY2VzIGN1cnJlbnRseSBhY3RpdmUgaW4gdGhlIG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyB3aGVuIGRlYnVnZ2luZyBvbmx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdGb3JjZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdGb3JjZXMoY3R4KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzW2ldO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tpbmRleF07XG4gICAgICAgIHZhciBmb3JjZSA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW2luZGV4XTtcbiAgICAgICAgdmFyIGZhY3RvciA9IDIwO1xuICAgICAgICB2YXIgY29sb3JGYWN0b3IgPSAwLjAzO1xuICAgICAgICB2YXIgZm9yY2VTaXplID0gTWF0aC5zcXJ0KE1hdGgucG93KGZvcmNlLngsIDIpICsgTWF0aC5wb3coZm9yY2UueCwgMikpO1xuICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKE1hdGgubWF4KDUsIGZvcmNlU2l6ZSksIDE1KTtcbiAgICAgICAgdmFyIGFycm93U2l6ZSA9IDMgKiBzaXplO1xuICAgICAgICB2YXIgY29sb3IgPSBIU1ZUb0hleCgoMTgwIC0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgY29sb3JGYWN0b3IgKiBmb3JjZVNpemUpKSAqIDE4MCkgLyAzNjAsIDEsIDEpO1xuICAgICAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgICAgeDogbm9kZS54ICsgZmFjdG9yICogZm9yY2UueCxcbiAgICAgICAgICB5OiBub2RlLnkgKyBmYWN0b3IgKiBmb3JjZS55XG4gICAgICAgIH07XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBzaXplO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKG5vZGUueCwgbm9kZS55KTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKGZvcmNlLnksIGZvcmNlLngpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIEVuZFBvaW50cy5kcmF3KGN0eCwge1xuICAgICAgICAgIHR5cGU6IFwiYXJyb3dcIixcbiAgICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgICAgYW5nbGU6IGFuZ2xlLFxuICAgICAgICAgIGxlbmd0aDogYXJyb3dTaXplXG4gICAgICAgIH0pO1xuICAgICAgICBfZmlsbEluc3RhbmNlUHJvcGVydHkoY3R4KS5jYWxsKGN0eCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBQaHlzaWNzRW5naW5lO1xufSgpO1xuXG4vLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiBJbiB0aGUgYnJvd3NlciB3ZSB0aGVyZWZvcmVcbi8vIHJlcXVpcmUgdGhlIGNyeXB0byBBUEkgYW5kIGRvIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGZhbGxiYWNrIHRvIGxvd2VyIHF1YWxpdHkgcmFuZG9tIG51bWJlclxuLy8gZ2VuZXJhdG9ycyAobGlrZSBNYXRoLnJhbmRvbSgpKS5cbmxldCBnZXRSYW5kb21WYWx1ZXM7XG5jb25zdCBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbmZ1bmN0aW9uIHJuZygpIHtcbiAgLy8gbGF6eSBsb2FkIHNvIHRoYXQgZW52aXJvbm1lbnRzIHRoYXQgbmVlZCB0byBwb2x5ZmlsbCBoYXZlIGEgY2hhbmNlIHRvIGRvIHNvXG4gIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvIGltcGxlbWVudGF0aW9uLlxuICAgIGdldFJhbmRvbVZhbHVlcyA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0byk7XG5cbiAgICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCkgbm90IHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCNnZXRyYW5kb212YWx1ZXMtbm90LXN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cblxuY29uc3QgYnl0ZVRvSGV4ID0gW107XG5cbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnNsaWNlKDEpKTtcbn1cblxuZnVuY3Rpb24gdW5zYWZlU3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xuICAvLyBOb3RlOiBCZSBjYXJlZnVsIGVkaXRpbmcgdGhpcyBjb2RlISAgSXQncyBiZWVuIHR1bmVkIGZvciBwZXJmb3JtYW5jZVxuICAvLyBhbmQgd29ya3MgaW4gd2F5cyB5b3UgbWF5IG5vdCBleHBlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC80MzRcbiAgcmV0dXJuIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgM11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDVdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA3XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDhdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxM11dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNV1dO1xufVxuXG5jb25zdCByYW5kb21VVUlEID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLnJhbmRvbVVVSUQgJiYgY3J5cHRvLnJhbmRvbVVVSUQuYmluZChjcnlwdG8pO1xudmFyIG5hdGl2ZSA9IHtcbiAgcmFuZG9tVVVJRFxufTtcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgaWYgKG5hdGl2ZS5yYW5kb21VVUlEICYmICFidWYgJiYgIW9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmF0aXZlLnJhbmRvbVVVSUQoKTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTsgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgcmV0dXJuIHVuc2FmZVN0cmluZ2lmeShybmRzKTtcbn1cblxuLyoqXG4gKiBVdGlsaXR5IENsYXNzXG4gKi9cbnZhciBOZXR3b3JrVXRpbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBOZXR3b3JrVXRpbCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTmV0d29ya1V0aWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIGNlbnRlciBwb3NpdGlvbiBvZiB0aGUgbmV0d29yayBjb25zaWRlcmluZyB0aGUgYm91bmRpbmcgYm94ZXNcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IGFsbE5vZGVzXG4gICAqIEBwYXJhbSB7QXJyYXkuPE5vZGU+fSBbc3BlY2lmaWNOb2Rlcz1bXV1cbiAgICogQHJldHVybnMge3ttaW5YOiBudW1iZXIsIG1heFg6IG51bWJlciwgbWluWTogbnVtYmVyLCBtYXhZOiBudW1iZXJ9fVxuICAgKiBAc3RhdGljXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoTmV0d29ya1V0aWwsIG51bGwsIFt7XG4gICAga2V5OiBcImdldFJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJhbmdlKGFsbE5vZGVzKSB7XG4gICAgICB2YXIgc3BlY2lmaWNOb2RlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgICB2YXIgbWluWSA9IDFlOSxcbiAgICAgICAgbWF4WSA9IC0xZTksXG4gICAgICAgIG1pblggPSAxZTksXG4gICAgICAgIG1heFggPSAtMWU5LFxuICAgICAgICBub2RlO1xuICAgICAgaWYgKHNwZWNpZmljTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwZWNpZmljTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlID0gYWxsTm9kZXNbc3BlY2lmaWNOb2Rlc1tpXV07XG4gICAgICAgICAgaWYgKG1pblggPiBub2RlLnNoYXBlLmJvdW5kaW5nQm94LmxlZnQpIHtcbiAgICAgICAgICAgIG1pblggPSBub2RlLnNoYXBlLmJvdW5kaW5nQm94LmxlZnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXhYIDwgbm9kZS5zaGFwZS5ib3VuZGluZ0JveC5yaWdodCkge1xuICAgICAgICAgICAgbWF4WCA9IG5vZGUuc2hhcGUuYm91bmRpbmdCb3gucmlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtaW5ZID4gbm9kZS5zaGFwZS5ib3VuZGluZ0JveC50b3ApIHtcbiAgICAgICAgICAgIG1pblkgPSBub2RlLnNoYXBlLmJvdW5kaW5nQm94LnRvcDtcbiAgICAgICAgICB9IC8vIHRvcCBpcyBuZWdhdGl2ZSwgYm90dG9tIGlzIHBvc2l0aXZlXG4gICAgICAgICAgaWYgKG1heFkgPCBub2RlLnNoYXBlLmJvdW5kaW5nQm94LmJvdHRvbSkge1xuICAgICAgICAgICAgbWF4WSA9IG5vZGUuc2hhcGUuYm91bmRpbmdCb3guYm90dG9tO1xuICAgICAgICAgIH0gLy8gdG9wIGlzIG5lZ2F0aXZlLCBib3R0b20gaXMgcG9zaXRpdmVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWluWCA9PT0gMWU5ICYmIG1heFggPT09IC0xZTkgJiYgbWluWSA9PT0gMWU5ICYmIG1heFkgPT09IC0xZTkpIHtcbiAgICAgICAgbWluWSA9IDAsIG1heFkgPSAwLCBtaW5YID0gMCwgbWF4WCA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW5YOiBtaW5YLFxuICAgICAgICBtYXhYOiBtYXhYLFxuICAgICAgICBtaW5ZOiBtaW5ZLFxuICAgICAgICBtYXhZOiBtYXhZXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGNlbnRlciBwb3NpdGlvbiBvZiB0aGUgbmV0d29ya1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IGFsbE5vZGVzXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IFtzcGVjaWZpY05vZGVzPVtdXVxuICAgICAqIEByZXR1cm5zIHt7bWluWDogbnVtYmVyLCBtYXhYOiBudW1iZXIsIG1pblk6IG51bWJlciwgbWF4WTogbnVtYmVyfX1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmFuZ2VDb3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJhbmdlQ29yZShhbGxOb2Rlcykge1xuICAgICAgdmFyIHNwZWNpZmljTm9kZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICAgICAgdmFyIG1pblkgPSAxZTksXG4gICAgICAgIG1heFkgPSAtMWU5LFxuICAgICAgICBtaW5YID0gMWU5LFxuICAgICAgICBtYXhYID0gLTFlOSxcbiAgICAgICAgbm9kZTtcbiAgICAgIGlmIChzcGVjaWZpY05vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGVjaWZpY05vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9kZSA9IGFsbE5vZGVzW3NwZWNpZmljTm9kZXNbaV1dO1xuICAgICAgICAgIGlmIChtaW5YID4gbm9kZS54KSB7XG4gICAgICAgICAgICBtaW5YID0gbm9kZS54O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWF4WCA8IG5vZGUueCkge1xuICAgICAgICAgICAgbWF4WCA9IG5vZGUueDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1pblkgPiBub2RlLnkpIHtcbiAgICAgICAgICAgIG1pblkgPSBub2RlLnk7XG4gICAgICAgICAgfSAvLyB0b3AgaXMgbmVnYXRpdmUsIGJvdHRvbSBpcyBwb3NpdGl2ZVxuICAgICAgICAgIGlmIChtYXhZIDwgbm9kZS55KSB7XG4gICAgICAgICAgICBtYXhZID0gbm9kZS55O1xuICAgICAgICAgIH0gLy8gdG9wIGlzIG5lZ2F0aXZlLCBib3R0b20gaXMgcG9zaXRpdmVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWluWCA9PT0gMWU5ICYmIG1heFggPT09IC0xZTkgJiYgbWluWSA9PT0gMWU5ICYmIG1heFkgPT09IC0xZTkpIHtcbiAgICAgICAgbWluWSA9IDAsIG1heFkgPSAwLCBtaW5YID0gMCwgbWF4WCA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW5YOiBtaW5YLFxuICAgICAgICBtYXhYOiBtYXhYLFxuICAgICAgICBtaW5ZOiBtaW5ZLFxuICAgICAgICBtYXhZOiBtYXhZXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByYW5nZSA9IHttaW5YOiBtaW5YLCBtYXhYOiBtYXhYLCBtaW5ZOiBtaW5ZLCBtYXhZOiBtYXhZfTtcbiAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZENlbnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQ2VudGVyKHJhbmdlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAwLjUgKiAocmFuZ2UubWF4WCArIHJhbmdlLm1pblgpLFxuICAgICAgICB5OiAwLjUgKiAocmFuZ2UubWF4WSArIHJhbmdlLm1pblkpXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgcmV0dXJucyBhIGNsb25lIG9mIHRoZSBvcHRpb25zIG9yIG9wdGlvbnMgb2YgdGhlIGVkZ2Ugb3Igbm9kZSB0byBiZSB1c2VkIGZvciBjb25zdHJ1Y3Rpb24gb2YgbmV3IGVkZ2VzIG9yIGNoZWNrIGZ1bmN0aW9ucyBmb3IgbmV3IG5vZGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuSXRlbX0gaXRlbVxuICAgICAqIEBwYXJhbSB7J25vZGUnfHVuZGVmaW5lZH0gdHlwZVxuICAgICAqIEByZXR1cm5zIHt7fX1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvbmVPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lT3B0aW9ucyhpdGVtLCB0eXBlKSB7XG4gICAgICB2YXIgY2xvbmVkT3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcIm5vZGVcIikge1xuICAgICAgICBkZWVwRXh0ZW5kKGNsb25lZE9wdGlvbnMsIGl0ZW0ub3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIGNsb25lZE9wdGlvbnMueCA9IGl0ZW0ueDtcbiAgICAgICAgY2xvbmVkT3B0aW9ucy55ID0gaXRlbS55O1xuICAgICAgICBjbG9uZWRPcHRpb25zLmFtb3VudE9mQ29ubmVjdGlvbnMgPSBpdGVtLmVkZ2VzLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZXBFeHRlbmQoY2xvbmVkT3B0aW9ucywgaXRlbS5vcHRpb25zLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9uZWRPcHRpb25zO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTmV0d29ya1V0aWw7XG59KCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciQxKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDEoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gX1JlZmxlY3QkY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMSgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFfUmVmbGVjdCRjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKF9SZWZsZWN0JGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChfUmVmbGVjdCRjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogQSBDbHVzdGVyIGlzIGEgc3BlY2lhbCBOb2RlIHRoYXQgYWxsb3dzIGEgZ3JvdXAgb2YgTm9kZXMgcG9zaXRpb25lZCBjbG9zZWx5IHRvZ2V0aGVyXG4gKiB0byBiZSByZXByZXNlbnRlZCBieSBhIHNpbmdsZSBDbHVzdGVyIE5vZGUuXG4gKlxuICogQGF1Z21lbnRzIE5vZGVcbiAqL1xudmFyIENsdXN0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG4gIF9pbmhlcml0cyhDbHVzdGVyLCBfTm9kZSk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkMShDbHVzdGVyKTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7QXJyYXkuPEhUTUxJbWFnZUVsZW1lbnQ+fWltYWdlbGlzdFxuICAgKiBAcGFyYW0ge0FycmF5fSBncm91cGxpc3RcbiAgICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbE9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGRlZmF1bHRPcHRpb25zICAgICBHbG9iYWwgZGVmYXVsdCBvcHRpb25zIGZvciBub2Rlc1xuICAgKi9cbiAgZnVuY3Rpb24gQ2x1c3RlcihvcHRpb25zLCBib2R5LCBpbWFnZWxpc3QsIGdyb3VwbGlzdCwgZ2xvYmFsT3B0aW9ucywgZGVmYXVsdE9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsdXN0ZXIpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgaW1hZ2VsaXN0LCBncm91cGxpc3QsIGdsb2JhbE9wdGlvbnMsIGRlZmF1bHRPcHRpb25zKTtcbiAgICBfdGhpcy5pc0NsdXN0ZXIgPSB0cnVlO1xuICAgIF90aGlzLmNvbnRhaW5lZE5vZGVzID0ge307XG4gICAgX3RoaXMuY29udGFpbmVkRWRnZXMgPSB7fTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmZXIgY2hpbGQgY2x1c3RlciBkYXRhIHRvIGN1cnJlbnQgYW5kIGRpc2Nvbm5lY3QgdGhlIGNoaWxkIGNsdXN0ZXIuXG4gICAqXG4gICAqIFBsZWFzZSBjb25zdWx0IHRoZSBoZWFkZXIgY29tbWVudCBpbiAnQ2x1c3RlcmluZy5qcycgZm9yIHRoZSBmaWVsZHMgc2V0IGhlcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gY2hpbGRDbHVzdGVySWQgIGlkIG9mIGNoaWxkIGNsdXN0ZXIgdG8gb3BlblxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKENsdXN0ZXIsIFt7XG4gICAga2V5OiBcIl9vcGVuQ2hpbGRDbHVzdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vcGVuQ2hpbGRDbHVzdGVyKGNoaWxkQ2x1c3RlcklkKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBjaGlsZENsdXN0ZXIgPSB0aGlzLmJvZHkubm9kZXNbY2hpbGRDbHVzdGVySWRdO1xuICAgICAgaWYgKHRoaXMuY29udGFpbmVkTm9kZXNbY2hpbGRDbHVzdGVySWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9kZSB3aXRoIGlkOiBcIiArIGNoaWxkQ2x1c3RlcklkICsgXCIgbm90IGluIGN1cnJlbnQgY2x1c3RlclwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghY2hpbGRDbHVzdGVyLmlzQ2x1c3Rlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub2RlIHdpdGggaWQ6IFwiICsgY2hpbGRDbHVzdGVySWQgKyBcIiBpcyBub3QgYSBjbHVzdGVyXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBEaXNjb25uZWN0IGNoaWxkIGNsdXN0ZXIgZnJvbSBjdXJyZW50IGNsdXN0ZXJcbiAgICAgIGRlbGV0ZSB0aGlzLmNvbnRhaW5lZE5vZGVzW2NoaWxkQ2x1c3RlcklkXTtcbiAgICAgIGZvckVhY2gkMShjaGlsZENsdXN0ZXIuZWRnZXMsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIuY29udGFpbmVkRWRnZXNbZWRnZS5pZF07XG4gICAgICB9KTtcblxuICAgICAgLy8gVHJhbnNmZXIgbm9kZXMgYW5kIGVkZ2VzXG4gICAgICBmb3JFYWNoJDEoY2hpbGRDbHVzdGVyLmNvbnRhaW5lZE5vZGVzLCBmdW5jdGlvbiAobm9kZSwgbm9kZUlkKSB7XG4gICAgICAgIF90aGlzMi5jb250YWluZWROb2Rlc1tub2RlSWRdID0gbm9kZTtcbiAgICAgIH0pO1xuICAgICAgY2hpbGRDbHVzdGVyLmNvbnRhaW5lZE5vZGVzID0ge307XG4gICAgICBmb3JFYWNoJDEoY2hpbGRDbHVzdGVyLmNvbnRhaW5lZEVkZ2VzLCBmdW5jdGlvbiAoZWRnZSwgZWRnZUlkKSB7XG4gICAgICAgIF90aGlzMi5jb250YWluZWRFZGdlc1tlZGdlSWRdID0gZWRnZTtcbiAgICAgIH0pO1xuICAgICAgY2hpbGRDbHVzdGVyLmNvbnRhaW5lZEVkZ2VzID0ge307XG5cbiAgICAgIC8vIFRyYW5zZmVyIGVkZ2VzIHdpdGhpbiBjbHVzdGVyIGVkZ2VzIHdoaWNoIGFyZSBjbHVzdGVyZWRcbiAgICAgIGZvckVhY2gkMShjaGlsZENsdXN0ZXIuZWRnZXMsIGZ1bmN0aW9uIChjbHVzdGVyRWRnZSkge1xuICAgICAgICBmb3JFYWNoJDEoX3RoaXMyLmVkZ2VzLCBmdW5jdGlvbiAocGFyZW50Q2x1c3RlckVkZ2UpIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQsIF9jb250ZXh0MjtcbiAgICAgICAgICAvLyBBc3N1bXB0aW9uOiBhIGNsdXN0ZXJlZCBlZGdlIGNhbiBvbmx5IGJlIHByZXNlbnQgaW4gYSBzaW5nbGUgY2x1c3RlcmluZyBlZGdlXG4gICAgICAgICAgLy8gTm90IHRlc3RlZCBoZXJlXG4gICAgICAgICAgdmFyIGluZGV4ID0gX2luZGV4T2ZJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0ID0gcGFyZW50Q2x1c3RlckVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMpLmNhbGwoX2NvbnRleHQsIGNsdXN0ZXJFZGdlLmlkKTtcbiAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm47XG4gICAgICAgICAgZm9yRWFjaCQxKGNsdXN0ZXJFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzLCBmdW5jdGlvbiAoc3JjSWQpIHtcbiAgICAgICAgICAgIHBhcmVudENsdXN0ZXJFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzLnB1c2goc3JjSWQpO1xuXG4gICAgICAgICAgICAvLyBNYWludGFpbiBjb3JyZWN0IGJvb2trZWVwaW5nIGZvciB0cmFuc2ZlcnJlZCBlZGdlXG4gICAgICAgICAgICBfdGhpczIuYm9keS5lZGdlc1tzcmNJZF0uZWRnZVJlcGxhY2VkQnlJZCA9IHBhcmVudENsdXN0ZXJFZGdlLmlkO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gUmVtb3ZlIGNsdXN0ZXIgZWRnZSBmcm9tIHBhcmVudCBjbHVzdGVyIGVkZ2VcbiAgICAgICAgICBfc3BsaWNlSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDIgPSBwYXJlbnRDbHVzdGVyRWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcykuY2FsbChfY29udGV4dDIsIGluZGV4LCAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGNoaWxkQ2x1c3Rlci5lZGdlcyA9IFtdO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ2x1c3Rlcjtcbn0oTm9kZSk7XG5cbi8qKlxuICogVGhlIGNsdXN0ZXJpbmcgZW5naW5lXG4gKi9cbnZhciBDbHVzdGVyRW5naW5lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqL1xuICBmdW5jdGlvbiBDbHVzdGVyRW5naW5lKGJvZHkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbHVzdGVyRW5naW5lKTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2x1c3RlcmVkTm9kZXMgPSB7fTsgLy8ga2V5OiBub2RlIGlkLCB2YWx1ZTogeyBjbHVzdGVySWQ6IDxpZCBvZiBjbHVzdGVyPiwgbm9kZTogPG5vZGUgaW5zdGFuY2U+fVxuICAgIHRoaXMuY2x1c3RlcmVkRWRnZXMgPSB7fTsgLy8ga2V5OiBlZGdlIGlkLCB2YWx1ZTogcmVzdG9yZSBpbmZvcm1hdGlvbiBmb3IgZ2l2ZW4gZWRnZVxuXG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHt9O1xuICAgIF9PYmplY3QkYXNzaWduKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfcmVzZXREYXRhXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmNsdXN0ZXJlZE5vZGVzID0ge307XG4gICAgICBfdGhpcy5jbHVzdGVyZWRFZGdlcyA9IHt9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBodWJzaXplXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoQ2x1c3RlckVuZ2luZSwgW3tcbiAgICBrZXk6IFwiY2x1c3RlckJ5SHVic2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyQnlIdWJzaXplKGh1YnNpemUsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChodWJzaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaHVic2l6ZSA9IHRoaXMuX2dldEh1YlNpemUoKTtcbiAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihodWJzaXplKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBvcHRpb25zID0gdGhpcy5fY2hlY2tPcHRpb25zKGh1YnNpemUpO1xuICAgICAgICBodWJzaXplID0gdGhpcy5fZ2V0SHViU2l6ZSgpO1xuICAgICAgfVxuICAgICAgdmFyIG5vZGVzVG9DbHVzdGVyID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbaV1dO1xuICAgICAgICBpZiAobm9kZS5lZGdlcy5sZW5ndGggPj0gaHVic2l6ZSkge1xuICAgICAgICAgIG5vZGVzVG9DbHVzdGVyLnB1c2gobm9kZS5pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2Rlc1RvQ2x1c3Rlci5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdGhpcy5jbHVzdGVyQnlDb25uZWN0aW9uKG5vZGVzVG9DbHVzdGVyW19pXSwgb3B0aW9ucywgdHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGxvb3Agb3ZlciBhbGwgbm9kZXMsIGNoZWNrIGlmIHRoZXkgYWRoZXJlIHRvIHRoZSBjb25kaXRpb24gYW5kIGNsdXN0ZXIgaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWZyZXNoRGF0YT10cnVlXVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNsdXN0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2x1c3RlcigpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgaWYgKG9wdGlvbnMuam9pbkNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGNsdXN0ZXJCeU5vZGVEYXRhIHdpdGhvdXQgYSBqb2luQ29uZGl0aW9uIGZ1bmN0aW9uIGluIHRoZSBvcHRpb25zLlwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgaWYgdGhlIG9wdGlvbnMgb2JqZWN0IGlzIGZpbmUsIGFwcGVuZCBpZiBuZWVkZWRcbiAgICAgIG9wdGlvbnMgPSB0aGlzLl9jaGVja09wdGlvbnMob3B0aW9ucyk7XG4gICAgICB2YXIgY2hpbGROb2Rlc09iaiA9IHt9O1xuICAgICAgdmFyIGNoaWxkRWRnZXNPYmogPSB7fTtcblxuICAgICAgLy8gY29sbGVjdCB0aGUgbm9kZXMgdGhhdCB3aWxsIGJlIGluIHRoZSBjbHVzdGVyXG4gICAgICBmb3JFYWNoJDEodGhpcy5ib2R5Lm5vZGVzLCBmdW5jdGlvbiAobm9kZSwgbm9kZUlkKSB7XG4gICAgICAgIGlmIChub2RlLm9wdGlvbnMgJiYgb3B0aW9ucy5qb2luQ29uZGl0aW9uKG5vZGUub3B0aW9ucykgPT09IHRydWUpIHtcbiAgICAgICAgICBjaGlsZE5vZGVzT2JqW25vZGVJZF0gPSBub2RlO1xuXG4gICAgICAgICAgLy8gY29sbGVjdCB0aGUgZWRnZXMgdGhhdCB3aWxsIGJlIGluIHRoZSBjbHVzdGVyXG4gICAgICAgICAgZm9yRWFjaCQxKG5vZGUuZWRnZXMsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMyLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY2hpbGRFZGdlc09ialtlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5fY2x1c3RlcihjaGlsZE5vZGVzT2JqLCBjaGlsZEVkZ2VzT2JqLCBvcHRpb25zLCByZWZyZXNoRGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2x1c3RlciBhbGwgbm9kZXMgaW4gdGhlIG5ldHdvcmsgdGhhdCBoYXZlIG9ubHkgWCBlZGdlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVkZ2VDb3VudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVmcmVzaERhdGE9dHJ1ZV1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjbHVzdGVyQnlFZGdlQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2x1c3RlckJ5RWRnZUNvdW50KGVkZ2VDb3VudCwgb3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgcmVmcmVzaERhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgICBvcHRpb25zID0gdGhpcy5fY2hlY2tPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdmFyIGNsdXN0ZXJzID0gW107XG4gICAgICB2YXIgdXNlZE5vZGVzID0ge307XG4gICAgICB2YXIgZWRnZSwgZWRnZXMsIHJlbGV2YW50RWRnZUNvdW50O1xuICAgICAgLy8gY29sbGVjdCB0aGUgbm9kZXMgdGhhdCB3aWxsIGJlIGluIHRoZSBjbHVzdGVyXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZXNPYmogPSB7fTtcbiAgICAgICAgdmFyIGNoaWxkRWRnZXNPYmogPSB7fTtcbiAgICAgICAgdmFyIG5vZGVJZCA9IF90aGlzMy5ib2R5Lm5vZGVJbmRpY2VzW2ldO1xuICAgICAgICB2YXIgbm9kZSA9IF90aGlzMy5ib2R5Lm5vZGVzW25vZGVJZF07XG5cbiAgICAgICAgLy8gaWYgdGhpcyBub2RlIGlzIGFscmVhZHkgdXNlZCBpbiBhbm90aGVyIGNsdXN0ZXIgdGhpcyBzZXNzaW9uLCB3ZSBkbyBub3QgaGF2ZSB0byByZS1ldmFsdWF0ZSBpdC5cbiAgICAgICAgaWYgKHVzZWROb2Rlc1tub2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZWxldmFudEVkZ2VDb3VudCA9IDA7XG4gICAgICAgICAgZWRnZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGUuZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGVkZ2UgPSBub2RlLmVkZ2VzW2pdO1xuICAgICAgICAgICAgaWYgKF90aGlzMy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGlmIChlZGdlLnRvSWQgIT09IGVkZ2UuZnJvbUlkKSB7XG4gICAgICAgICAgICAgICAgcmVsZXZhbnRFZGdlQ291bnQrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHRoaXMgbm9kZSBxdWFsaWZpZXMsIHdlIGNvbGxlY3QgaXRzIG5laWdoYm91cnMgdG8gc3RhcnQgdGhlIGNsdXN0ZXJpbmcgcHJvY2Vzcy5cbiAgICAgICAgICBpZiAocmVsZXZhbnRFZGdlQ291bnQgPT09IGVkZ2VDb3VudCkge1xuICAgICAgICAgICAgdmFyIGNoZWNrSm9pbkNvbmRpdGlvbiA9IGZ1bmN0aW9uIGNoZWNrSm9pbkNvbmRpdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmpvaW5Db25kaXRpb24gPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmpvaW5Db25kaXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgY2xvbmVkT3B0aW9ucyA9IE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyhub2RlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuam9pbkNvbmRpdGlvbihjbG9uZWRPcHRpb25zKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZ2F0aGVyaW5nU3VjY2Vzc2Z1bCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgZWRnZXMubGVuZ3RoOyBfaisrKSB7XG4gICAgICAgICAgICAgIGVkZ2UgPSBlZGdlc1tfal07XG4gICAgICAgICAgICAgIHZhciBjaGlsZE5vZGVJZCA9IF90aGlzMy5fZ2V0Q29ubmVjdGVkSWQoZWRnZSwgbm9kZUlkKTtcbiAgICAgICAgICAgICAgLy8gYWRkIHRoZSBub2RlcyB0byB0aGUgbGlzdCBieSB0aGUgam9pbiBjb25kaXRpb24uXG4gICAgICAgICAgICAgIGlmIChjaGVja0pvaW5Db25kaXRpb24obm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzT2JqW25vZGVJZF0gPSBub2RlO1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXNPYmpbY2hpbGROb2RlSWRdID0gX3RoaXMzLmJvZHkubm9kZXNbY2hpbGROb2RlSWRdO1xuICAgICAgICAgICAgICAgIHVzZWROb2Rlc1tub2RlSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIG5vZGUgZG9lcyBub3QgcXVhbGlmeSBhZnRlciBhbGwuXG4gICAgICAgICAgICAgICAgZ2F0aGVyaW5nU3VjY2Vzc2Z1bCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFkZCB0byB0aGUgY2x1c3RlciBxdWV1ZVxuICAgICAgICAgICAgaWYgKF9PYmplY3Qka2V5cyhjaGlsZE5vZGVzT2JqKS5sZW5ndGggPiAwICYmIF9PYmplY3Qka2V5cyhjaGlsZEVkZ2VzT2JqKS5sZW5ndGggPiAwICYmIGdhdGhlcmluZ1N1Y2Nlc3NmdWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFNlYXJjaCBmb3IgY2x1c3RlciBkYXRhIHRoYXQgY29udGFpbnMgYW55IG9mIHRoZSBub2RlIGlkJ3NcbiAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgbm8gam9pbkNvbmRpdGlvbiwgb3RoZXJ3aXNlIHJldHVybiB2YWx1ZSBvZiBqb2luQ29uZGl0aW9uXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICB2YXIgZmluZENsdXN0ZXJEYXRhID0gZnVuY3Rpb24gZmluZENsdXN0ZXJEYXRhKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgY2x1c3RlcnMubGVuZ3RoOyArK24pIHtcbiAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBmb3IgYSBjbHVzdGVyIGNvbnRhaW5pbmcgYW55IG9mIHRoZSBub2RlIGlkJ3NcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIG0gaW4gY2hpbGROb2Rlc09iaikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2x1c3RlcnNbbl0ubm9kZXNbbV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbHVzdGVyc1tuXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIC8vIElmIGFueSBvZiB0aGUgZm91bmQgbm9kZXMgaXMgcGFydCBvZiBhIGNsdXN0ZXIgZm91bmQgaW4gdGhpcyBtZXRob2QsXG4gICAgICAgICAgICAgIC8vIGFkZCB0aGUgY3VycmVudCB2YWx1ZXMgdG8gdGhhdCBjbHVzdGVyXG4gICAgICAgICAgICAgIHZhciBmb3VuZENsdXN0ZXIgPSBmaW5kQ2x1c3RlckRhdGEoKTtcbiAgICAgICAgICAgICAgaWYgKGZvdW5kQ2x1c3RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIG5vZGVzIHRvIGZvdW5kIGNsdXN0ZXIgaWYgbm90IHByZXNlbnRcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBtIGluIGNoaWxkTm9kZXNPYmopIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmb3VuZENsdXN0ZXIubm9kZXNbbV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZENsdXN0ZXIubm9kZXNbbV0gPSBjaGlsZE5vZGVzT2JqW21dO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBlZGdlcyB0byBmb3VuZCBjbHVzdGVyLCBpZiBub3QgcHJlc2VudFxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9tIGluIGNoaWxkRWRnZXNPYmopIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmb3VuZENsdXN0ZXIuZWRnZXNbX21dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRDbHVzdGVyLmVkZ2VzW19tXSA9IGNoaWxkRWRnZXNPYmpbX21dO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgY2x1c3RlciBncm91cFxuICAgICAgICAgICAgICAgIGNsdXN0ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgbm9kZXM6IGNoaWxkTm9kZXNPYmosXG4gICAgICAgICAgICAgICAgICBlZGdlczogY2hpbGRFZGdlc09ialxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgX2xvb3AoKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGNsdXN0ZXJzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdGhpcy5fY2x1c3RlcihjbHVzdGVyc1tfaTJdLm5vZGVzLCBjbHVzdGVyc1tfaTJdLmVkZ2VzLCBvcHRpb25zLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBpZiAocmVmcmVzaERhdGEgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbHVzdGVyIGFsbCBub2RlcyBpbiB0aGUgbmV0d29yayB0aGF0IGhhdmUgb25seSAxIGVkZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVmcmVzaERhdGE9dHJ1ZV1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjbHVzdGVyT3V0bGllcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2x1c3Rlck91dGxpZXJzKG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHRoaXMuY2x1c3RlckJ5RWRnZUNvdW50KDEsIG9wdGlvbnMsIHJlZnJlc2hEYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbHVzdGVyIGFsbCBub2RlcyBpbiB0aGUgbmV0d29yayB0aGF0IGhhdmUgb25seSAyIGVkZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVmcmVzaERhdGE9dHJ1ZV1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjbHVzdGVyQnJpZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyQnJpZGdlcyhvcHRpb25zKSB7XG4gICAgICB2YXIgcmVmcmVzaERhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICB0aGlzLmNsdXN0ZXJCeUVkZ2VDb3VudCgyLCBvcHRpb25zLCByZWZyZXNoRGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc3VjayBhbGwgY29ubmVjdGVkIG5vZGVzIG9mIGEgbm9kZSBpbnRvIHRoZSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlZnJlc2hEYXRhPXRydWVdXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2x1c3RlckJ5Q29ubmVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyQnlDb25uZWN0aW9uKG5vZGVJZCwgb3B0aW9ucykge1xuICAgICAgdmFyIF9jb250ZXh0O1xuICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICAgICAgLy8ga2lsbCBjb25kaXRpb25zXG4gICAgICBpZiAobm9kZUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbm9kZUlkIHN1cHBsaWVkIHRvIGNsdXN0ZXJCeUNvbm5lY3Rpb24hXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIG5vZGVJZCBnaXZlbiB0byBjbHVzdGVyQnlDb25uZWN0aW9uIGRvZXMgbm90IGV4aXN0IVwiKTtcbiAgICAgIH1cbiAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICBvcHRpb25zID0gdGhpcy5fY2hlY2tPcHRpb25zKG9wdGlvbnMsIG5vZGUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy54ID0gbm9kZS54O1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy55ID0gbm9kZS55O1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmZpeGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMuZml4ZWQgPSB7fTtcbiAgICAgICAgb3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMuZml4ZWQueCA9IG5vZGUub3B0aW9ucy5maXhlZC54O1xuICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy5maXhlZC55ID0gbm9kZS5vcHRpb25zLmZpeGVkLnk7XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGROb2Rlc09iaiA9IHt9O1xuICAgICAgdmFyIGNoaWxkRWRnZXNPYmogPSB7fTtcbiAgICAgIHZhciBwYXJlbnROb2RlSWQgPSBub2RlLmlkO1xuICAgICAgdmFyIHBhcmVudENsb25lZE9wdGlvbnMgPSBOZXR3b3JrVXRpbC5jbG9uZU9wdGlvbnMobm9kZSk7XG4gICAgICBjaGlsZE5vZGVzT2JqW3BhcmVudE5vZGVJZF0gPSBub2RlO1xuXG4gICAgICAvLyBjb2xsZWN0IHRoZSBub2RlcyB0aGF0IHdpbGwgYmUgaW4gdGhlIGNsdXN0ZXJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IG5vZGUuZWRnZXNbaV07XG4gICAgICAgIGlmICh0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgY2hpbGROb2RlSWQgPSB0aGlzLl9nZXRDb25uZWN0ZWRJZChlZGdlLCBwYXJlbnROb2RlSWQpO1xuXG4gICAgICAgICAgLy8gaWYgdGhlIGNoaWxkIG5vZGUgaXMgbm90IGluIGEgY2x1c3RlclxuICAgICAgICAgIGlmICh0aGlzLmNsdXN0ZXJlZE5vZGVzW2NoaWxkTm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlSWQgIT09IHBhcmVudE5vZGVJZCkge1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5qb2luQ29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzT2JqW2NoaWxkTm9kZUlkXSA9IHRoaXMuYm9keS5ub2Rlc1tjaGlsZE5vZGVJZF07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY2xvbmUgdGhlIG9wdGlvbnMgYW5kIGluc2VydCBzb21lIGFkZGl0aW9uYWwgcGFyYW1ldGVycyB0aGF0IGNvdWxkIGJlIGludGVyZXN0aW5nLlxuICAgICAgICAgICAgICAgIHZhciBjaGlsZENsb25lZE9wdGlvbnMgPSBOZXR3b3JrVXRpbC5jbG9uZU9wdGlvbnModGhpcy5ib2R5Lm5vZGVzW2NoaWxkTm9kZUlkXSk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuam9pbkNvbmRpdGlvbihwYXJlbnRDbG9uZWRPcHRpb25zLCBjaGlsZENsb25lZE9wdGlvbnMpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXNPYmpbY2hpbGROb2RlSWRdID0gdGhpcy5ib2R5Lm5vZGVzW2NoaWxkTm9kZUlkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHN3YWxsb3cgdGhlIGVkZ2UgaWYgaXQgaXMgc2VsZi1yZWZlcmVuY2luZy5cbiAgICAgICAgICAgICAgY2hpbGRFZGdlc09ialtlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGROb2RlSURzID0gX21hcEluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQgPSBfT2JqZWN0JGtleXMoY2hpbGROb2Rlc09iaikpLmNhbGwoX2NvbnRleHQsIGZ1bmN0aW9uIChjaGlsZE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkTm9kZXNPYmpbY2hpbGROb2RlXS5pZDtcbiAgICAgIH0pO1xuICAgICAgZm9yICh2YXIgY2hpbGROb2RlS2V5IGluIGNoaWxkTm9kZXNPYmopIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2hpbGROb2Rlc09iaiwgY2hpbGROb2RlS2V5KSkgY29udGludWU7XG4gICAgICAgIHZhciBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzT2JqW2NoaWxkTm9kZUtleV07XG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgY2hpbGROb2RlLmVkZ2VzLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgdmFyIGNoaWxkRWRnZSA9IGNoaWxkTm9kZS5lZGdlc1t5XTtcbiAgICAgICAgICBpZiAoX2luZGV4T2ZJbnN0YW5jZVByb3BlcnR5KGNoaWxkTm9kZUlEcykuY2FsbChjaGlsZE5vZGVJRHMsIHRoaXMuX2dldENvbm5lY3RlZElkKGNoaWxkRWRnZSwgY2hpbGROb2RlLmlkKSkgPiAtMSkge1xuICAgICAgICAgICAgY2hpbGRFZGdlc09ialtjaGlsZEVkZ2UuaWRdID0gY2hpbGRFZGdlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fY2x1c3RlcihjaGlsZE5vZGVzT2JqLCBjaGlsZEVkZ2VzT2JqLCBvcHRpb25zLCByZWZyZXNoRGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjcmVhdGVzIHRoZSBlZGdlcyB0aGF0IHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlIGNsdXN0ZXJcbiAgICAgKiBJdCBsb29rcyBmb3IgZWRnZXMgdGhhdCBhcmUgY29ubmVjdGVkIHRvIHRoZSBub2RlcyBmcm9tIHRoZSBcIm91dHNpZGUnIG9mIHRoZSBjbHVzdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt7Tm9kZS5pZDogdmlzLk5vZGV9fSBjaGlsZE5vZGVzT2JqXG4gICAgICogQHBhcmFtIHt7dmlzLkVkZ2UuaWQ6IHZpcy5FZGdlfX0gY2hpbGRFZGdlc09ialxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjbHVzdGVyTm9kZVByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2x1c3RlckVkZ2VQcm9wZXJ0aWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlQ2x1c3RlckVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVDbHVzdGVyRWRnZXMoY2hpbGROb2Rlc09iaiwgY2hpbGRFZGdlc09iaiwgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLCBjbHVzdGVyRWRnZVByb3BlcnRpZXMpIHtcbiAgICAgIHZhciBlZGdlLCBjaGlsZE5vZGVJZCwgY2hpbGROb2RlLCB0b0lkLCBmcm9tSWQsIG90aGVyTm9kZUlkO1xuXG4gICAgICAvLyBsb29wIG92ZXIgYWxsIGNoaWxkIG5vZGVzIGFuZCB0aGVpciBlZGdlcyB0byBmaW5kIGVkZ2VzIGdvaW5nIG91dCBvZiB0aGUgY2x1c3RlclxuICAgICAgLy8gdGhlc2UgZWRnZXMgd2lsbCBiZSByZXBsYWNlZCBieSBjbHVzdGVyRWRnZXMuXG4gICAgICB2YXIgY2hpbGRLZXlzID0gX09iamVjdCRrZXlzKGNoaWxkTm9kZXNPYmopO1xuICAgICAgdmFyIGNyZWF0ZUVkZ2VzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZE5vZGVJZCA9IGNoaWxkS2V5c1tpXTtcbiAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlc09ialtjaGlsZE5vZGVJZF07XG5cbiAgICAgICAgLy8gY29uc3RydWN0IG5ldyBlZGdlcyBmcm9tIHRoZSBjbHVzdGVyIHRvIG90aGVyc1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoaWxkTm9kZS5lZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGVkZ2UgPSBjaGlsZE5vZGUuZWRnZXNbal07XG4gICAgICAgICAgLy8gd2Ugb25seSBoYW5kbGUgZWRnZXMgdGhhdCBhcmUgdmlzaWJsZSB0byB0aGUgc3lzdGVtLCBub3QgdGhlIGRpc2FibGVkIG9uZXMgZnJvbSB0aGUgY2x1c3RlcmluZyBwcm9jZXNzLlxuICAgICAgICAgIGlmICh0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHNlbGYtcmVmZXJlbmNpbmcgZWRnZXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgXCJoaWRkZW5cIiBsaXN0XG4gICAgICAgICAgICBpZiAoZWRnZS50b0lkID09IGVkZ2UuZnJvbUlkKSB7XG4gICAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gc2V0IHVwIHRoZSBmcm9tIGFuZCB0by5cbiAgICAgICAgICAgICAgaWYgKGVkZ2UudG9JZCA9PSBjaGlsZE5vZGVJZCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBkb3VibGUgZXF1YWxzIGJlY2F1c2UgaW50cyBhbmQgc3RyaW5ncyBjYW4gYmUgaW50ZXJjaGFuZ2VkIGhlcmUuXG4gICAgICAgICAgICAgICAgdG9JZCA9IGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZDtcbiAgICAgICAgICAgICAgICBmcm9tSWQgPSBlZGdlLmZyb21JZDtcbiAgICAgICAgICAgICAgICBvdGhlck5vZGVJZCA9IGZyb21JZDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b0lkID0gZWRnZS50b0lkO1xuICAgICAgICAgICAgICAgIGZyb21JZCA9IGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZDtcbiAgICAgICAgICAgICAgICBvdGhlck5vZGVJZCA9IHRvSWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT25seSBlZGdlcyBmcm9tIHRoZSBjbHVzdGVyIG91dHdhcmRzIGFyZSBiZWluZyByZXBsYWNlZC5cbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzT2JqW290aGVyTm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNyZWF0ZUVkZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIGVkZ2U6IGVkZ2UsXG4gICAgICAgICAgICAgICAgZnJvbUlkOiBmcm9tSWQsXG4gICAgICAgICAgICAgICAgdG9JZDogdG9JZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9cbiAgICAgIC8vIEhlcmUgd2UgYWN0dWFsbHkgY3JlYXRlIHRoZSByZXBsYWNlbWVudCBlZGdlcy5cbiAgICAgIC8vXG4gICAgICAvLyBXZSBjb3VsZCBub3QgZG8gdGhpcyBpbiB0aGUgbG9vcCBhYm92ZSBhcyB0aGUgY3JlYXRpb24gcHJvY2Vzc1xuICAgICAgLy8gd291bGQgYWRkIGFuIGVkZ2UgdG8gdGhlIGVkZ2VzIGFycmF5IHdlIGFyZSBpdGVyYXRpbmcgb3Zlci5cbiAgICAgIC8vXG4gICAgICAvLyBOT1RFOiBhIGNsdXN0ZXJlZCBlZGdlIGNhbiBoYXZlIG11bHRpcGxlIGJhc2UgZWRnZXMhXG4gICAgICAvL1xuICAgICAgdmFyIG5ld0VkZ2VzID0gW107XG5cbiAgICAgIC8qKlxuICAgICAgICogRmluZCBhIGNsdXN0ZXIgZWRnZSB3aGljaCBtYXRjaGVzIHRoZSBnaXZlbiBjcmVhdGVkIGVkZ2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHt2aXMuRWRnZX0gY3JlYXRlZEVkZ2VcbiAgICAgICAqIEByZXR1cm5zIHt2aXMuRWRnZX1cbiAgICAgICAqL1xuICAgICAgdmFyIGdldE5ld0VkZ2UgPSBmdW5jdGlvbiBnZXROZXdFZGdlKGNyZWF0ZWRFZGdlKSB7XG4gICAgICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IG5ld0VkZ2VzLmxlbmd0aDsgX2oyKyspIHtcbiAgICAgICAgICB2YXIgbmV3RWRnZSA9IG5ld0VkZ2VzW19qMl07XG5cbiAgICAgICAgICAvLyBXZSByZXBsYWNlIGJvdGggdG8gYW5kIGZyb20gZWRnZXMgd2l0aCBhIHNpbmdsZSBjbHVzdGVyIGVkZ2VcbiAgICAgICAgICB2YXIgbWF0Y2hUb0RpcmVjdGlvbiA9IGNyZWF0ZWRFZGdlLmZyb21JZCA9PT0gbmV3RWRnZS5mcm9tSWQgJiYgY3JlYXRlZEVkZ2UudG9JZCA9PT0gbmV3RWRnZS50b0lkO1xuICAgICAgICAgIHZhciBtYXRjaEZyb21EaXJlY3Rpb24gPSBjcmVhdGVkRWRnZS5mcm9tSWQgPT09IG5ld0VkZ2UudG9JZCAmJiBjcmVhdGVkRWRnZS50b0lkID09PSBuZXdFZGdlLmZyb21JZDtcbiAgICAgICAgICBpZiAobWF0Y2hUb0RpcmVjdGlvbiB8fCBtYXRjaEZyb21EaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXdFZGdlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBfajMgPSAwOyBfajMgPCBjcmVhdGVFZGdlcy5sZW5ndGg7IF9qMysrKSB7XG4gICAgICAgIHZhciBjcmVhdGVkRWRnZSA9IGNyZWF0ZUVkZ2VzW19qM107XG4gICAgICAgIHZhciBfZWRnZSA9IGNyZWF0ZWRFZGdlLmVkZ2U7XG4gICAgICAgIHZhciBuZXdFZGdlID0gZ2V0TmV3RWRnZShjcmVhdGVkRWRnZSk7XG4gICAgICAgIGlmIChuZXdFZGdlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gQ3JlYXRlIGEgY2x1c3RlcmVkIGVkZ2UgZm9yIHRoaXMgY29ubmVjdGlvblxuICAgICAgICAgIG5ld0VkZ2UgPSB0aGlzLl9jcmVhdGVDbHVzdGVyZWRFZGdlKGNyZWF0ZWRFZGdlLmZyb21JZCwgY3JlYXRlZEVkZ2UudG9JZCwgX2VkZ2UsIGNsdXN0ZXJFZGdlUHJvcGVydGllcyk7XG4gICAgICAgICAgbmV3RWRnZXMucHVzaChuZXdFZGdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzLnB1c2goX2VkZ2UuaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWxzbyByZWZlcmVuY2UgdGhlIG5ldyBlZGdlIGluIHRoZSBvbGQgZWRnZVxuICAgICAgICB0aGlzLmJvZHkuZWRnZXNbX2VkZ2UuaWRdLmVkZ2VSZXBsYWNlZEJ5SWQgPSBuZXdFZGdlLmlkO1xuXG4gICAgICAgIC8vIGhpZGUgdGhlIHJlcGxhY2VkIGVkZ2VcbiAgICAgICAgdGhpcy5fYmFja3VwRWRnZU9wdGlvbnMoX2VkZ2UpO1xuICAgICAgICBfZWRnZS5zZXRPcHRpb25zKHtcbiAgICAgICAgICBwaHlzaWNzOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNoZWNrcyB0aGUgb3B0aW9ucyB0aGF0IGNhbiBiZSBzdXBwbGllZCB0byB0aGUgZGlmZmVyZW50IGNsdXN0ZXIgZnVuY3Rpb25zXG4gICAgICogZm9yIGNlcnRhaW4gZmllbGRzIGFuZCBpbnNlcnRzIGRlZmF1bHRzIGlmIG5lZWRlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jaGVja09wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrT3B0aW9ucygpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIGlmIChvcHRpb25zLmNsdXN0ZXJFZGdlUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzID0ge307XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcyA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gICAgY2hpbGROb2Rlc09iaiAgICAgICAgIHwgb2JqZWN0IHdpdGggbm9kZSBvYmplY3RzLCBpZCBhcyBrZXlzLCBzYW1lIGFzIGNoaWxkTm9kZXMgZXhjZXB0IGl0IGFsc28gY29udGFpbnMgYSBzb3VyY2Ugbm9kZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgICBjaGlsZEVkZ2VzT2JqICAgICAgICAgfCBvYmplY3Qgd2l0aCBlZGdlIG9iamVjdHMsIGlkIGFzIGtleXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgICAgb3B0aW9ucyAgICAgICAgICAgICAgIHwgb2JqZWN0IHdpdGgge2NsdXN0ZXJOb2RlUHJvcGVydGllcywgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzLCBwcm9jZXNzUHJvcGVydGllc31cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgcmVmcmVzaERhdGEgfCB3aGVuIHRydWUsIGRvIG5vdCB3cmFwIHVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY2x1c3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2x1c3RlcihjaGlsZE5vZGVzT2JqLCBjaGlsZEVkZ2VzT2JqLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcmVmcmVzaERhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG4gICAgICAvLyBSZW1vdmUgbm9kZXMgd2hpY2ggYXJlIGFscmVhZHkgY2x1c3RlcmVkXG4gICAgICB2YXIgdG1wTm9kZXNUb1JlbW92ZSA9IFtdO1xuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIGNoaWxkTm9kZXNPYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjaGlsZE5vZGVzT2JqLCBub2RlSWQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0bXBOb2Rlc1RvUmVtb3ZlLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdG1wTm9kZXNUb1JlbW92ZS5sZW5ndGg7ICsrbikge1xuICAgICAgICBkZWxldGUgY2hpbGROb2Rlc09ialt0bXBOb2Rlc1RvUmVtb3ZlW25dXTtcbiAgICAgIH1cblxuICAgICAgLy8ga2lsbCBjb25kaXRpb246IG5vIG5vZGVzIGRvbid0IGJvdGhlclxuICAgICAgaWYgKF9PYmplY3Qka2V5cyhjaGlsZE5vZGVzT2JqKS5sZW5ndGggPT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGFsbG93IGNsdXN0ZXJzIG9mIDEgaWYgb3B0aW9ucyBhbGxvd1xuICAgICAgaWYgKF9PYmplY3Qka2V5cyhjaGlsZE5vZGVzT2JqKS5sZW5ndGggPT0gMSAmJiBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy5hbGxvd1NpbmdsZU5vZGVDbHVzdGVyICE9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGNsdXN0ZXJOb2RlUHJvcGVydGllcyA9IGRlZXBFeHRlbmQoe30sIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzKTtcblxuICAgICAgLy8gY29uc3RydWN0IHRoZSBjbHVzdGVyTm9kZVByb3BlcnRpZXNcbiAgICAgIGlmIChvcHRpb25zLnByb2Nlc3NQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZ2V0IHRoZSBjaGlsZE5vZGUgb3B0aW9uc1xuICAgICAgICB2YXIgY2hpbGROb2Rlc09wdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX25vZGVJZCBpbiBjaGlsZE5vZGVzT2JqKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjaGlsZE5vZGVzT2JqLCBfbm9kZUlkKSkge1xuICAgICAgICAgICAgdmFyIGNsb25lZE9wdGlvbnMgPSBOZXR3b3JrVXRpbC5jbG9uZU9wdGlvbnMoY2hpbGROb2Rlc09ialtfbm9kZUlkXSk7XG4gICAgICAgICAgICBjaGlsZE5vZGVzT3B0aW9ucy5wdXNoKGNsb25lZE9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBjbHVzdGVyIHByb3BlcnRpZXMgYmFzZWQgb24gY2hpbGROb2Rlc1xuICAgICAgICB2YXIgY2hpbGRFZGdlc09wdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgZWRnZUlkIGluIGNoaWxkRWRnZXNPYmopIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNoaWxkRWRnZXNPYmosIGVkZ2VJZCkpIHtcbiAgICAgICAgICAgIC8vIHRoZXNlIGNsdXN0ZXIgZWRnZXMgd2lsbCBiZSByZW1vdmVkIG9uIGNyZWF0aW9uIG9mIHRoZSBjbHVzdGVyLlxuICAgICAgICAgICAgaWYgKGVkZ2VJZC5zdWJzdHIoMCwgMTIpICE9PSBcImNsdXN0ZXJFZGdlOlwiKSB7XG4gICAgICAgICAgICAgIHZhciBfY2xvbmVkT3B0aW9ucyA9IE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyhjaGlsZEVkZ2VzT2JqW2VkZ2VJZF0sIFwiZWRnZVwiKTtcbiAgICAgICAgICAgICAgY2hpbGRFZGdlc09wdGlvbnMucHVzaChfY2xvbmVkT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcyA9IG9wdGlvbnMucHJvY2Vzc1Byb3BlcnRpZXMoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLCBjaGlsZE5vZGVzT3B0aW9ucywgY2hpbGRFZGdlc09wdGlvbnMpO1xuICAgICAgICBpZiAoIWNsdXN0ZXJOb2RlUHJvcGVydGllcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBwcm9jZXNzUHJvcGVydGllcyBmdW5jdGlvbiBkb2VzIG5vdCByZXR1cm4gcHJvcGVydGllcyFcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSBhbiB1bmlxdWUgaWQ7XG4gICAgICBpZiAoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmlkID0gXCJjbHVzdGVyOlwiICsgdjQoKTtcbiAgICAgIH1cbiAgICAgIHZhciBjbHVzdGVySWQgPSBjbHVzdGVyTm9kZVByb3BlcnRpZXMuaWQ7XG4gICAgICBpZiAoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmxhYmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmxhYmVsID0gXCJjbHVzdGVyXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIGdpdmUgdGhlIGNsdXN0ZXJOb2RlIGEgcG9zaXRpb24gaWYgaXQgZG9lcyBub3QgaGF2ZSBvbmUuXG4gICAgICB2YXIgcG9zID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGNsdXN0ZXJOb2RlUHJvcGVydGllcy54ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcG9zID0gdGhpcy5fZ2V0Q2x1c3RlclBvc2l0aW9uKGNoaWxkTm9kZXNPYmopO1xuICAgICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXMueCA9IHBvcy54O1xuICAgICAgfVxuICAgICAgaWYgKGNsdXN0ZXJOb2RlUHJvcGVydGllcy55ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHBvcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcG9zID0gdGhpcy5fZ2V0Q2x1c3RlclBvc2l0aW9uKGNoaWxkTm9kZXNPYmopO1xuICAgICAgICB9XG4gICAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy55ID0gcG9zLnk7XG4gICAgICB9XG5cbiAgICAgIC8vIGZvcmNlIHRoZSBJRCB0byByZW1haW4gdGhlIHNhbWVcbiAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZCA9IGNsdXN0ZXJJZDtcblxuICAgICAgLy8gY3JlYXRlIHRoZSBjbHVzdGVyIE5vZGVcbiAgICAgIC8vIE5vdGUgdGhhdCBhbGxvd1NpbmdsZU5vZGVDbHVzdGVyLCBpZiBwcmVzZW50LCBpcyBzdG9yZWQgaW4gdGhlIG9wdGlvbnMgYXMgd2VsbFxuICAgICAgdmFyIGNsdXN0ZXJOb2RlID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVOb2RlKGNsdXN0ZXJOb2RlUHJvcGVydGllcywgQ2x1c3Rlcik7XG4gICAgICBjbHVzdGVyTm9kZS5jb250YWluZWROb2RlcyA9IGNoaWxkTm9kZXNPYmo7XG4gICAgICBjbHVzdGVyTm9kZS5jb250YWluZWRFZGdlcyA9IGNoaWxkRWRnZXNPYmo7XG4gICAgICAvLyBjYWNoZSBhIGNvcHkgZnJvbSB0aGUgY2x1c3RlciBlZGdlIHByb3BlcnRpZXMgaWYgd2UgaGF2ZSB0byByZWNvbm5lY3Qgb3RoZXJzIGxhdGVyIG9uXG4gICAgICBjbHVzdGVyTm9kZS5jbHVzdGVyRWRnZVByb3BlcnRpZXMgPSBvcHRpb25zLmNsdXN0ZXJFZGdlUHJvcGVydGllcztcblxuICAgICAgLy8gZmluYWxseSBwdXQgdGhlIGNsdXN0ZXIgbm9kZSBpbnRvIGdsb2JhbFxuICAgICAgdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJOb2RlUHJvcGVydGllcy5pZF0gPSBjbHVzdGVyTm9kZTtcbiAgICAgIHRoaXMuX2NsdXN0ZXJFZGdlcyhjaGlsZE5vZGVzT2JqLCBjaGlsZEVkZ2VzT2JqLCBjbHVzdGVyTm9kZVByb3BlcnRpZXMsIG9wdGlvbnMuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzKTtcblxuICAgICAgLy8gc2V0IElEIHRvIHVuZGVmaW5lZCBzbyBubyBkdXBsaWNhdGVzIGFyaXNlXG4gICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXMuaWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIC8vIHdyYXAgdXBcbiAgICAgIGlmIChyZWZyZXNoRGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFZGdlfSBlZGdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfYmFja3VwRWRnZU9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JhY2t1cEVkZ2VPcHRpb25zKGVkZ2UpIHtcbiAgICAgIGlmICh0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXSA9IHtcbiAgICAgICAgICBwaHlzaWNzOiBlZGdlLm9wdGlvbnMucGh5c2ljc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFZGdlfSBlZGdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfcmVzdG9yZUVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc3RvcmVFZGdlKGVkZ2UpIHtcbiAgICAgIHZhciBvcmlnaW5hbE9wdGlvbnMgPSB0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdO1xuICAgICAgaWYgKG9yaWdpbmFsT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVkZ2Uuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgcGh5c2ljczogb3JpZ2luYWxPcHRpb25zLnBoeXNpY3NcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgbm9kZSBpcyBhIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImlzQ2x1c3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0NsdXN0ZXIobm9kZUlkKSB7XG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0uaXNDbHVzdGVyID09PSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk5vZGUgZG9lcyBub3QgZXhpc3QuXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgY2x1c3RlciBub2RlIGJhc2VkIG9uIHdoYXQncyBpbnNpZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjaGlsZE5vZGVzT2JqICAgIHwgb2JqZWN0IHdpdGggbm9kZSBvYmplY3RzLCBpZCBhcyBrZXlzXG4gICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q2x1c3RlclBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDbHVzdGVyUG9zaXRpb24oY2hpbGROb2Rlc09iaikge1xuICAgICAgdmFyIGNoaWxkS2V5cyA9IF9PYmplY3Qka2V5cyhjaGlsZE5vZGVzT2JqKTtcbiAgICAgIHZhciBtaW5YID0gY2hpbGROb2Rlc09ialtjaGlsZEtleXNbMF1dLng7XG4gICAgICB2YXIgbWF4WCA9IGNoaWxkTm9kZXNPYmpbY2hpbGRLZXlzWzBdXS54O1xuICAgICAgdmFyIG1pblkgPSBjaGlsZE5vZGVzT2JqW2NoaWxkS2V5c1swXV0ueTtcbiAgICAgIHZhciBtYXhZID0gY2hpbGROb2Rlc09ialtjaGlsZEtleXNbMF1dLnk7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY2hpbGRLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vZGUgPSBjaGlsZE5vZGVzT2JqW2NoaWxkS2V5c1tpXV07XG4gICAgICAgIG1pblggPSBub2RlLnggPCBtaW5YID8gbm9kZS54IDogbWluWDtcbiAgICAgICAgbWF4WCA9IG5vZGUueCA+IG1heFggPyBub2RlLnggOiBtYXhYO1xuICAgICAgICBtaW5ZID0gbm9kZS55IDwgbWluWSA/IG5vZGUueSA6IG1pblk7XG4gICAgICAgIG1heFkgPSBub2RlLnkgPiBtYXhZID8gbm9kZS55IDogbWF4WTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IDAuNSAqIChtaW5YICsgbWF4WCksXG4gICAgICAgIHk6IDAuNSAqIChtaW5ZICsgbWF4WSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbiBhIGNsdXN0ZXIgYnkgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuRWRnZS5pZH0gIGNsdXN0ZXJOb2RlSWQgfCB0aGUgSUQgb2YgdGhlIGNsdXN0ZXIgbm9kZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSByZWZyZXNoRGF0YSB8IHdyYXAgdXAgYWZ0ZXJ3YXJkcyBpZiBub3QgdHJ1ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm9wZW5DbHVzdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW5DbHVzdGVyKGNsdXN0ZXJOb2RlSWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgICAgIC8vIGtpbGwgY29uZGl0aW9uc1xuICAgICAgaWYgKGNsdXN0ZXJOb2RlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjbHVzdGVyTm9kZUlkIHN1cHBsaWVkIHRvIG9wZW5DbHVzdGVyLlwiKTtcbiAgICAgIH1cbiAgICAgIHZhciBjbHVzdGVyTm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tjbHVzdGVyTm9kZUlkXTtcbiAgICAgIGlmIChjbHVzdGVyTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjbHVzdGVyTm9kZUlkIHN1cHBsaWVkIHRvIG9wZW5DbHVzdGVyIGRvZXMgbm90IGV4aXN0LlwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChjbHVzdGVyTm9kZS5pc0NsdXN0ZXIgIT09IHRydWUgfHwgY2x1c3Rlck5vZGUuY29udGFpbmVkTm9kZXMgPT09IHVuZGVmaW5lZCB8fCBjbHVzdGVyTm9kZS5jb250YWluZWRFZGdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBub2RlOlwiICsgY2x1c3Rlck5vZGVJZCArIFwiIGlzIG5vdCBhIHZhbGlkIGNsdXN0ZXIuXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiBjdXJyZW50IGNsdXN0ZXIgaXMgY2x1c3RlcmVkIGl0c2VsZlxuICAgICAgdmFyIHN0YWNrID0gdGhpcy5maW5kTm9kZShjbHVzdGVyTm9kZUlkKTtcbiAgICAgIHZhciBwYXJlbnRJbmRleCA9IF9pbmRleE9mSW5zdGFuY2VQcm9wZXJ0eShzdGFjaykuY2FsbChzdGFjaywgY2x1c3Rlck5vZGVJZCkgLSAxO1xuICAgICAgaWYgKHBhcmVudEluZGV4ID49IDApIHtcbiAgICAgICAgLy8gQ3VycmVudCBjbHVzdGVyIGlzIGNsdXN0ZXJlZDsgdHJhbnNmZXIgY29udGFpbmVkIG5vZGVzIGFuZCBlZGdlcyB0byBwYXJlbnRcbiAgICAgICAgdmFyIHBhcmVudENsdXN0ZXJOb2RlSWQgPSBzdGFja1twYXJlbnRJbmRleF07XG4gICAgICAgIHZhciBwYXJlbnRDbHVzdGVyTm9kZSA9IHRoaXMuYm9keS5ub2Rlc1twYXJlbnRDbHVzdGVyTm9kZUlkXTtcblxuICAgICAgICAvLyBjbHVzdGVyaW5nLmNsdXN0ZXJlZE5vZGVzIGFuZCBjbHVzdGVyaW5nLmNsdXN0ZXJlZEVkZ2VzIHJlbWFpbiB1bmNoYW5nZWRcbiAgICAgICAgcGFyZW50Q2x1c3Rlck5vZGUuX29wZW5DaGlsZENsdXN0ZXIoY2x1c3Rlck5vZGVJZCk7XG5cbiAgICAgICAgLy8gQWxsIGNvbXBvbmVudHMgb2YgY2hpbGQgY2x1c3RlciBub2RlIGhhdmUgYmVlbiB0cmFuc2ZlcnJlZC4gSXQgY2FuIGRpZSBub3cuXG4gICAgICAgIGRlbGV0ZSB0aGlzLmJvZHkubm9kZXNbY2x1c3Rlck5vZGVJZF07XG4gICAgICAgIGlmIChyZWZyZXNoRGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBtYWluIGJvZHlcbiAgICAgIHZhciBjb250YWluZWROb2RlcyA9IGNsdXN0ZXJOb2RlLmNvbnRhaW5lZE5vZGVzO1xuICAgICAgdmFyIGNvbnRhaW5lZEVkZ2VzID0gY2x1c3Rlck5vZGUuY29udGFpbmVkRWRnZXM7XG5cbiAgICAgIC8vIGFsbG93IHRoZSB1c2VyIHRvIHBvc2l0aW9uIHRoZSBub2RlcyBhZnRlciByZWxlYXNlLlxuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlbGVhc2VGdW5jdGlvbiAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zLnJlbGVhc2VGdW5jdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSB7fTtcbiAgICAgICAgdmFyIGNsdXN0ZXJQb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiBjbHVzdGVyTm9kZS54LFxuICAgICAgICAgIHk6IGNsdXN0ZXJOb2RlLnlcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIGNvbnRhaW5lZE5vZGVzKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb250YWluZWROb2Rlcywgbm9kZUlkKSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lZE5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgIHBvc2l0aW9uc1tub2RlSWRdID0ge1xuICAgICAgICAgICAgICB4OiBjb250YWluZWROb2RlLngsXG4gICAgICAgICAgICAgIHk6IGNvbnRhaW5lZE5vZGUueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld1Bvc2l0aW9ucyA9IG9wdGlvbnMucmVsZWFzZUZ1bmN0aW9uKGNsdXN0ZXJQb3NpdGlvbiwgcG9zaXRpb25zKTtcbiAgICAgICAgZm9yICh2YXIgX25vZGVJZDIgaW4gY29udGFpbmVkTm9kZXMpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnRhaW5lZE5vZGVzLCBfbm9kZUlkMikpIHtcbiAgICAgICAgICAgIHZhciBfY29udGFpbmVkTm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkMl07XG4gICAgICAgICAgICBpZiAobmV3UG9zaXRpb25zW19ub2RlSWQyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIF9jb250YWluZWROb2RlLnggPSBuZXdQb3NpdGlvbnNbX25vZGVJZDJdLnggPT09IHVuZGVmaW5lZCA/IGNsdXN0ZXJOb2RlLnggOiBuZXdQb3NpdGlvbnNbX25vZGVJZDJdLng7XG4gICAgICAgICAgICAgIF9jb250YWluZWROb2RlLnkgPSBuZXdQb3NpdGlvbnNbX25vZGVJZDJdLnkgPT09IHVuZGVmaW5lZCA/IGNsdXN0ZXJOb2RlLnkgOiBuZXdQb3NpdGlvbnNbX25vZGVJZDJdLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb3B5IHRoZSBwb3NpdGlvbiBmcm9tIHRoZSBjbHVzdGVyXG4gICAgICAgIGZvckVhY2gkMShjb250YWluZWROb2RlcywgZnVuY3Rpb24gKGNvbnRhaW5lZE5vZGUpIHtcbiAgICAgICAgICAvLyBpbmhlcml0IHBvc2l0aW9uXG4gICAgICAgICAgaWYgKGNvbnRhaW5lZE5vZGUub3B0aW9ucy5maXhlZC54ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGFpbmVkTm9kZS54ID0gY2x1c3Rlck5vZGUueDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbnRhaW5lZE5vZGUub3B0aW9ucy5maXhlZC55ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGFpbmVkTm9kZS55ID0gY2x1c3Rlck5vZGUueTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyByZWxlYXNlIG5vZGVzXG4gICAgICBmb3IgKHZhciBfbm9kZUlkMyBpbiBjb250YWluZWROb2Rlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnRhaW5lZE5vZGVzLCBfbm9kZUlkMykpIHtcbiAgICAgICAgICB2YXIgX2NvbnRhaW5lZE5vZGUyID0gdGhpcy5ib2R5Lm5vZGVzW19ub2RlSWQzXTtcblxuICAgICAgICAgIC8vIGluaGVyaXQgc3BlZWRcbiAgICAgICAgICBfY29udGFpbmVkTm9kZTIudnggPSBjbHVzdGVyTm9kZS52eDtcbiAgICAgICAgICBfY29udGFpbmVkTm9kZTIudnkgPSBjbHVzdGVyTm9kZS52eTtcbiAgICAgICAgICBfY29udGFpbmVkTm9kZTIuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICBwaHlzaWNzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuY2x1c3RlcmVkTm9kZXNbX25vZGVJZDNdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNvcHkgdGhlIGNsdXN0ZXJOb2RlIGVkZ2VzIGJlY2F1c2Ugd2UgY2Fubm90IGl0ZXJhdGUgb3ZlciBhbiBvYmplY3QgdGhhdCB3ZSBhZGQgb3IgcmVtb3ZlIGZyb20uXG4gICAgICB2YXIgZWRnZXNUb0JlRGVsZXRlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHVzdGVyTm9kZS5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlZGdlc1RvQmVEZWxldGVkLnB1c2goY2x1c3Rlck5vZGUuZWRnZXNbaV0pO1xuICAgICAgfVxuXG4gICAgICAvLyBhY3R1YWxseSBoYW5kbGluZyB0aGUgZGVsZXRpbmcuXG4gICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBlZGdlc1RvQmVEZWxldGVkLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1RvQmVEZWxldGVkW19pM107XG4gICAgICAgIHZhciBvdGhlck5vZGVJZCA9IHRoaXMuX2dldENvbm5lY3RlZElkKGVkZ2UsIGNsdXN0ZXJOb2RlSWQpO1xuICAgICAgICB2YXIgb3RoZXJOb2RlID0gdGhpcy5jbHVzdGVyZWROb2Rlc1tvdGhlck5vZGVJZF07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciB0cmFuc2ZlcklkID0gZWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkc1tqXTtcbiAgICAgICAgICB2YXIgdHJhbnNmZXJFZGdlID0gdGhpcy5ib2R5LmVkZ2VzW3RyYW5zZmVySWRdO1xuICAgICAgICAgIGlmICh0cmFuc2ZlckVkZ2UgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG5cbiAgICAgICAgICAvLyBpZiB0aGUgb3RoZXIgbm9kZSBpcyBpbiBhbm90aGVyIGNsdXN0ZXIsIHdlIHRyYW5zZmVyIG93bmVyc2hpcCBvZiB0aGlzIGVkZ2UgdG8gdGhlIG90aGVyIGNsdXN0ZXJcbiAgICAgICAgICBpZiAob3RoZXJOb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHRyYW5zZmVyIG93bmVyc2hpcDpcbiAgICAgICAgICAgIHZhciBvdGhlckNsdXN0ZXIgPSB0aGlzLmJvZHkubm9kZXNbb3RoZXJOb2RlLmNsdXN0ZXJJZF07XG4gICAgICAgICAgICBvdGhlckNsdXN0ZXIuY29udGFpbmVkRWRnZXNbdHJhbnNmZXJFZGdlLmlkXSA9IHRyYW5zZmVyRWRnZTtcblxuICAgICAgICAgICAgLy8gZGVsZXRlIGxvY2FsIHJlZmVyZW5jZVxuICAgICAgICAgICAgZGVsZXRlIGNvbnRhaW5lZEVkZ2VzW3RyYW5zZmVyRWRnZS5pZF07XG5cbiAgICAgICAgICAgIC8vIGdldCB0byBhbmQgZnJvbVxuICAgICAgICAgICAgdmFyIGZyb21JZCA9IHRyYW5zZmVyRWRnZS5mcm9tSWQ7XG4gICAgICAgICAgICB2YXIgdG9JZCA9IHRyYW5zZmVyRWRnZS50b0lkO1xuICAgICAgICAgICAgaWYgKHRyYW5zZmVyRWRnZS50b0lkID09IG90aGVyTm9kZUlkKSB7XG4gICAgICAgICAgICAgIHRvSWQgPSBvdGhlck5vZGUuY2x1c3RlcklkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZnJvbUlkID0gb3RoZXJOb2RlLmNsdXN0ZXJJZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY3JlYXRlIG5ldyBjbHVzdGVyIGVkZ2UgZnJvbSB0aGUgb3RoZXJDbHVzdGVyXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVDbHVzdGVyZWRFZGdlKGZyb21JZCwgdG9JZCwgdHJhbnNmZXJFZGdlLCBvdGhlckNsdXN0ZXIuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICAgICAgICAgIHBoeXNpY3M6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXN0b3JlRWRnZSh0cmFuc2ZlckVkZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlZGdlLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgdGhlIHJlbGVhc2luZyBvZiB0aGUgZWRnZXNcbiAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiBjb250YWluZWRFZGdlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnRhaW5lZEVkZ2VzLCBlZGdlSWQpKSB7XG4gICAgICAgICAgdGhpcy5fcmVzdG9yZUVkZ2UoY29udGFpbmVkRWRnZXNbZWRnZUlkXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIGNsdXN0ZXJOb2RlXG4gICAgICBkZWxldGUgdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJOb2RlSWRdO1xuICAgICAgaWYgKHJlZnJlc2hEYXRhID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NsdXN0ZXIuaWR9IGNsdXN0ZXJJZFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48Tm9kZS5pZD59XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Tm9kZXNJbkNsdXN0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Tm9kZXNJbkNsdXN0ZXIoY2x1c3RlcklkKSB7XG4gICAgICB2YXIgbm9kZXNBcnJheSA9IFtdO1xuICAgICAgaWYgKHRoaXMuaXNDbHVzdGVyKGNsdXN0ZXJJZCkgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lZE5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJJZF0uY29udGFpbmVkTm9kZXM7XG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBjb250YWluZWROb2Rlcykge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29udGFpbmVkTm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICAgIG5vZGVzQXJyYXkucHVzaCh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZXNBcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN0YWNrIGNsdXN0ZXJJZCdzIHRoYXQgYSBjZXJ0YWluIG5vZGUgcmVzaWRlcyBpbi4gY2x1c3RlciBBIC0+IGNsdXN0ZXIgQiAtPiBjbHVzdGVyIEMgLT4gbm9kZVxuICAgICAqXG4gICAgICogSWYgYSBub2RlIGNhbid0IGJlIGZvdW5kIGluIHRoZSBjaGFpbiwgcmV0dXJuIGFuIGVtcHR5IGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZE5vZGUobm9kZUlkKSB7XG4gICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgIHZhciBtYXggPSAxMDA7XG4gICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIHdoaWxlICh0aGlzLmNsdXN0ZXJlZE5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCAmJiBjb3VudGVyIDwgbWF4KSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtdO1xuICAgICAgICBzdGFjay5wdXNoKG5vZGUuaWQpO1xuICAgICAgICBub2RlSWQgPSB0aGlzLmNsdXN0ZXJlZE5vZGVzW25vZGVJZF0uY2x1c3RlcklkO1xuICAgICAgICBjb3VudGVyKys7XG4gICAgICB9XG4gICAgICBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW107XG4gICAgICBzdGFjay5wdXNoKG5vZGUuaWQpO1xuICAgICAgX3JldmVyc2VJbnN0YW5jZVByb3BlcnR5KHN0YWNrKS5jYWxsKHN0YWNrKTtcbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2luZyBhIGNsdXN0ZXJlZCBub2RlSWQsIHVwZGF0ZSB3aXRoIHRoZSBuZXcgb3B0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBjbHVzdGVyZWROb2RlSWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV3T3B0aW9uc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUNsdXN0ZXJlZE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQ2x1c3RlcmVkTm9kZShjbHVzdGVyZWROb2RlSWQsIG5ld09wdGlvbnMpIHtcbiAgICAgIGlmIChjbHVzdGVyZWROb2RlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjbHVzdGVyZWROb2RlSWQgc3VwcGxpZWQgdG8gdXBkYXRlQ2x1c3RlcmVkTm9kZS5cIik7XG4gICAgICB9XG4gICAgICBpZiAobmV3T3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG5ld09wdGlvbnMgc3VwcGxpZWQgdG8gdXBkYXRlQ2x1c3RlcmVkTm9kZS5cIik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJlZE5vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY2x1c3RlcmVkTm9kZUlkIHN1cHBsaWVkIHRvIHVwZGF0ZUNsdXN0ZXJlZE5vZGUgZG9lcyBub3QgZXhpc3QuXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJlZE5vZGVJZF0uc2V0T3B0aW9ucyhuZXdPcHRpb25zKTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNpbmcgYSBiYXNlIGVkZ2VJZCwgdXBkYXRlIGFsbCByZWxhdGVkIGNsdXN0ZXJlZCBlZGdlcyB3aXRoIHRoZSBuZXcgb3B0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuRWRnZS5pZH0gc3RhcnRFZGdlSWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV3T3B0aW9uc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRWRnZShzdGFydEVkZ2VJZCwgbmV3T3B0aW9ucykge1xuICAgICAgaWYgKHN0YXJ0RWRnZUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3RhcnRFZGdlSWQgc3VwcGxpZWQgdG8gdXBkYXRlRWRnZS5cIik7XG4gICAgICB9XG4gICAgICBpZiAobmV3T3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG5ld09wdGlvbnMgc3VwcGxpZWQgdG8gdXBkYXRlRWRnZS5cIik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5ib2R5LmVkZ2VzW3N0YXJ0RWRnZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdGFydEVkZ2VJZCBzdXBwbGllZCB0byB1cGRhdGVFZGdlIGRvZXMgbm90IGV4aXN0LlwiKTtcbiAgICAgIH1cbiAgICAgIHZhciBhbGxFZGdlSWRzID0gdGhpcy5nZXRDbHVzdGVyZWRFZGdlcyhzdGFydEVkZ2VJZCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEVkZ2VJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbYWxsRWRnZUlkc1tpXV07XG4gICAgICAgIGVkZ2Uuc2V0T3B0aW9ucyhuZXdPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgc3RhY2sgb2YgY2x1c3RlckVkZ2VJZCdzICgrYmFzZSBlZGdlaWQpIHRoYXQgYSBiYXNlIGVkZ2UgaXMgdGhlIHNhbWUgYXMuIGNsdXN0ZXIgZWRnZSBDIC0+IGNsdXN0ZXIgZWRnZSBCIC0+IGNsdXN0ZXIgZWRnZSBBIC0+IGJhc2UgZWRnZShlZGdlSWQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3Zpcy5FZGdlLmlkfSBlZGdlSWRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHZpcy5FZGdlLmlkPn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRDbHVzdGVyZWRFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDbHVzdGVyZWRFZGdlcyhlZGdlSWQpIHtcbiAgICAgIHZhciBzdGFjayA9IFtdO1xuICAgICAgdmFyIG1heCA9IDEwMDtcbiAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgIHdoaWxlIChlZGdlSWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXSAhPT0gdW5kZWZpbmVkICYmIGNvdW50ZXIgPCBtYXgpIHtcbiAgICAgICAgc3RhY2sucHVzaCh0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXS5pZCk7XG4gICAgICAgIGVkZ2VJZCA9IHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdLmVkZ2VSZXBsYWNlZEJ5SWQ7XG4gICAgICAgIGNvdW50ZXIrKztcbiAgICAgIH1cbiAgICAgIF9yZXZlcnNlSW5zdGFuY2VQcm9wZXJ0eShzdGFjaykuY2FsbChzdGFjayk7XG4gICAgICByZXR1cm4gc3RhY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBiYXNlIGVkZ2UgaWQgb2YgY2x1c3RlckVkZ2VJZC4gY2x1c3RlciBlZGdlIChjbHVzdGVyZWRFZGdlSWQpIC0+IGNsdXN0ZXIgZWRnZSBCIC0+IGNsdXN0ZXIgZWRnZSBDIC0+IGJhc2UgZWRnZVxuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuRWRnZS5pZH0gY2x1c3RlcmVkRWRnZUlkXG4gICAgICogQHJldHVybnMge3Zpcy5FZGdlLmlkfSBiYXNlRWRnZUlkXG4gICAgICpcbiAgICAgKiBUT0RPOiBkZXByZWNhdGUgaW4gNS4wLjAuIE1ldGhvZCBnZXRCYXNlRWRnZXMoKSBpcyB0aGUgY29ycmVjdCBvbmUgdG8gdXNlLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEJhc2VFZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhc2VFZGdlKGNsdXN0ZXJlZEVkZ2VJZCkge1xuICAgICAgLy8gSnVzdCBrbHVkZ2UgdGhpcyBieSByZXR1cm5pbmcgdGhlIGZpcnN0IGJhc2UgZWRnZSBpZCBmb3VuZFxuICAgICAgcmV0dXJuIHRoaXMuZ2V0QmFzZUVkZ2VzKGNsdXN0ZXJlZEVkZ2VJZClbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCByZWd1bGFyIGVkZ2VzIGZvciB0aGlzIGNsdXN0ZXJlZCBlZGdlIGlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuRWRnZS5pZH0gY2x1c3RlcmVkRWRnZUlkXG4gICAgICogQHJldHVybnMge0FycmF5Ljx2aXMuRWRnZS5pZD59IGFsbCBiYXNlRWRnZUlkJ3MgdW5kZXIgdGhpcyBjbHVzdGVyZWQgZWRnZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEJhc2VFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCYXNlRWRnZXMoY2x1c3RlcmVkRWRnZUlkKSB7XG4gICAgICB2YXIgSWRzVG9IYW5kbGUgPSBbY2x1c3RlcmVkRWRnZUlkXTtcbiAgICAgIHZhciBkb25lSWRzID0gW107XG4gICAgICB2YXIgZm91bmRJZHMgPSBbXTtcbiAgICAgIHZhciBtYXggPSAxMDA7XG4gICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICB3aGlsZSAoSWRzVG9IYW5kbGUubGVuZ3RoID4gMCAmJiBjb3VudGVyIDwgbWF4KSB7XG4gICAgICAgIHZhciBuZXh0SWQgPSBJZHNUb0hhbmRsZS5wb3AoKTtcbiAgICAgICAgaWYgKG5leHRJZCA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTsgLy8gUGFyYW5vaWEgaGVyZSBhbmQgb253YXJkc1xuICAgICAgICB2YXIgbmV4dEVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbbmV4dElkXTtcbiAgICAgICAgaWYgKG5leHRFZGdlID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIHZhciByZXBsYWNpbmdJZHMgPSBuZXh0RWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcztcbiAgICAgICAgaWYgKHJlcGxhY2luZ0lkcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gbmV4dElkIGlzIGEgYmFzZSBpZFxuICAgICAgICAgIGZvdW5kSWRzLnB1c2gobmV4dElkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBbm90aGVyIGNsdXN0ZXIgZWRnZSwgdW5yYXZlbCB0aGlzIG9uZSBhcyB3ZWxsXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBsYWNpbmdJZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciByZXBsYWNpbmdJZCA9IHJlcGxhY2luZ0lkc1tpXTtcblxuICAgICAgICAgICAgLy8gRG9uJ3QgYWRkIGlmIGFscmVhZHkgaGFuZGxlZFxuICAgICAgICAgICAgLy8gVE9ETzogbmV2ZXIgdHJpZ2dlcnM7IGZpbmQgYSB0ZXN0LWNhc2Ugd2hpY2ggZG9lc1xuICAgICAgICAgICAgaWYgKF9pbmRleE9mSW5zdGFuY2VQcm9wZXJ0eShJZHNUb0hhbmRsZSkuY2FsbChJZHNUb0hhbmRsZSwgcmVwbGFjaW5nSWRzKSAhPT0gLTEgfHwgX2luZGV4T2ZJbnN0YW5jZVByb3BlcnR5KGRvbmVJZHMpLmNhbGwoZG9uZUlkcywgcmVwbGFjaW5nSWRzKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBJZHNUb0hhbmRsZS5wdXNoKHJlcGxhY2luZ0lkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZG9uZUlkcy5wdXNoKG5leHRJZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZm91bmRJZHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBJZCB0aGUgbm9kZSBpcyBjb25uZWN0ZWQgdG9cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2V9IGVkZ2VcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldENvbm5lY3RlZElkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDb25uZWN0ZWRJZChlZGdlLCBub2RlSWQpIHtcbiAgICAgIGlmIChlZGdlLnRvSWQgIT0gbm9kZUlkKSB7XG4gICAgICAgIHJldHVybiBlZGdlLnRvSWQ7XG4gICAgICB9IGVsc2UgaWYgKGVkZ2UuZnJvbUlkICE9IG5vZGVJZCkge1xuICAgICAgICByZXR1cm4gZWRnZS5mcm9tSWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZWRnZS5mcm9tSWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2UgZGV0ZXJtaW5lIGhvdyBtYW55IGNvbm5lY3Rpb25zIGRlbm90ZSBhbiBpbXBvcnRhbnQgaHViLlxuICAgICAqIFdlIHRha2UgdGhlIG1lYW4gKyAyKnN0ZCBhcyB0aGUgaW1wb3J0YW50IGh1YiBzaXplLiAoQXNzdW1pbmcgYSBub3JtYWwgZGlzdHJpYnV0aW9uIG9mIGRhdGEsIH4yLjIlKVxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXRIdWJTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRIdWJTaXplKCkge1xuICAgICAgdmFyIGF2ZXJhZ2UgPSAwO1xuICAgICAgdmFyIGF2ZXJhZ2VTcXVhcmVkID0gMDtcbiAgICAgIHZhciBodWJDb3VudGVyID0gMDtcbiAgICAgIHZhciBsYXJnZXN0SHViID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tpXV07XG4gICAgICAgIGlmIChub2RlLmVkZ2VzLmxlbmd0aCA+IGxhcmdlc3RIdWIpIHtcbiAgICAgICAgICBsYXJnZXN0SHViID0gbm9kZS5lZGdlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgYXZlcmFnZSArPSBub2RlLmVkZ2VzLmxlbmd0aDtcbiAgICAgICAgYXZlcmFnZVNxdWFyZWQgKz0gTWF0aC5wb3cobm9kZS5lZGdlcy5sZW5ndGgsIDIpO1xuICAgICAgICBodWJDb3VudGVyICs9IDE7XG4gICAgICB9XG4gICAgICBhdmVyYWdlID0gYXZlcmFnZSAvIGh1YkNvdW50ZXI7XG4gICAgICBhdmVyYWdlU3F1YXJlZCA9IGF2ZXJhZ2VTcXVhcmVkIC8gaHViQ291bnRlcjtcbiAgICAgIHZhciB2YXJpYW5jZSA9IGF2ZXJhZ2VTcXVhcmVkIC0gTWF0aC5wb3coYXZlcmFnZSwgMik7XG4gICAgICB2YXIgc3RhbmRhcmREZXZpYXRpb24gPSBNYXRoLnNxcnQodmFyaWFuY2UpO1xuICAgICAgdmFyIGh1YlRocmVzaG9sZCA9IE1hdGguZmxvb3IoYXZlcmFnZSArIDIgKiBzdGFuZGFyZERldmlhdGlvbik7XG5cbiAgICAgIC8vIGFsd2F5cyBoYXZlIGF0IGxlYXN0IG9uZSB0byBjbHVzdGVyXG4gICAgICBpZiAoaHViVGhyZXNob2xkID4gbGFyZ2VzdEh1Yikge1xuICAgICAgICBodWJUaHJlc2hvbGQgPSBsYXJnZXN0SHViO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGh1YlRocmVzaG9sZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gZWRnZSBmb3IgdGhlIGNsdXN0ZXIgcmVwcmVzZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IGZyb21JZFxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gdG9JZFxuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2V9IGJhc2VFZGdlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNsdXN0ZXJFZGdlUHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBleHRyYU9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7RWRnZX0gbmV3bHkgY3JlYXRlZCBjbHVzdGVyZWQgZWRnZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUNsdXN0ZXJlZEVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUNsdXN0ZXJlZEVkZ2UoZnJvbUlkLCB0b0lkLCBiYXNlRWRnZSwgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzLCBleHRyYU9wdGlvbnMpIHtcbiAgICAgIC8vIGNvcHkgdGhlIG9wdGlvbnMgb2YgdGhlIGVkZ2Ugd2Ugd2lsbCByZXBsYWNlXG4gICAgICB2YXIgY2xvbmVkT3B0aW9ucyA9IE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyhiYXNlRWRnZSwgXCJlZGdlXCIpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRoZSBwcm9wZXJ0aWVzIG9mIGNsdXN0ZXJFZGdlcyBhcmUgc3VwZXJpbXBvc2VkIG9uIGl0XG4gICAgICBkZWVwRXh0ZW5kKGNsb25lZE9wdGlvbnMsIGNsdXN0ZXJFZGdlUHJvcGVydGllcyk7XG5cbiAgICAgIC8vIHNldCB1cCB0aGUgZWRnZVxuICAgICAgY2xvbmVkT3B0aW9ucy5mcm9tID0gZnJvbUlkO1xuICAgICAgY2xvbmVkT3B0aW9ucy50byA9IHRvSWQ7XG4gICAgICBjbG9uZWRPcHRpb25zLmlkID0gXCJjbHVzdGVyRWRnZTpcIiArIHY0KCk7XG5cbiAgICAgIC8vIGFwcGx5IHRoZSBlZGdlIHNwZWNpZmljIG9wdGlvbnMgdG8gaXQgaWYgc3BlY2lmaWVkXG4gICAgICBpZiAoZXh0cmFPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVlcEV4dGVuZChjbG9uZWRPcHRpb25zLCBleHRyYU9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0VkZ2UgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZUVkZ2UoY2xvbmVkT3B0aW9ucyk7XG4gICAgICBuZXdFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzID0gW2Jhc2VFZGdlLmlkXTtcbiAgICAgIG5ld0VkZ2UuY29ubmVjdCgpO1xuXG4gICAgICAvLyBSZWdpc3RlciB0aGUgbmV3IGVkZ2VcbiAgICAgIHRoaXMuYm9keS5lZGdlc1tuZXdFZGdlLmlkXSA9IG5ld0VkZ2U7XG4gICAgICByZXR1cm4gbmV3RWRnZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIHBhc3NlZCBjaGlsZCBub2RlcyBhbmQgZWRnZXMgdG8gdGhlIGdpdmVuIGNsdXN0ZXIgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0IHwgTm9kZX0gY2hpbGROb2RlcyAgaGFzaCBvZiBub2RlcyBvciBzaW5nbGUgbm9kZSB0byBhZGQgaW4gY2x1c3RlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0IHwgRWRnZX0gY2hpbGRFZGdlcyAgaGFzaCBvZiBlZGdlcyBvciBzaW5nbGUgZWRnZSB0byB0YWtlIGludG8gYWNjb3VudCB3aGVuIGNsdXN0ZXJpbmdcbiAgICAgKiBAcGFyYW0ge05vZGV9IGNsdXN0ZXJOb2RlICBjbHVzdGVyIG5vZGUgdG8gYWRkIG5vZGVzIGFuZCBlZGdlcyB0b1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY2x1c3RlckVkZ2VQcm9wZXJ0aWVzXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NsdXN0ZXJFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2x1c3RlckVkZ2VzKGNoaWxkTm9kZXMsIGNoaWxkRWRnZXMsIGNsdXN0ZXJOb2RlLCBjbHVzdGVyRWRnZVByb3BlcnRpZXMpIHtcbiAgICAgIGlmIChjaGlsZEVkZ2VzIGluc3RhbmNlb2YgRWRnZSkge1xuICAgICAgICB2YXIgZWRnZSA9IGNoaWxkRWRnZXM7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgb2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgY2hpbGRFZGdlcyA9IG9iajtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZE5vZGVzIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICB2YXIgbm9kZSA9IGNoaWxkTm9kZXM7XG4gICAgICAgIHZhciBfb2JqID0ge307XG4gICAgICAgIF9vYmpbbm9kZS5pZF0gPSBub2RlO1xuICAgICAgICBjaGlsZE5vZGVzID0gX29iajtcbiAgICAgIH1cbiAgICAgIGlmIChjbHVzdGVyTm9kZSA9PT0gdW5kZWZpbmVkIHx8IGNsdXN0ZXJOb2RlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIl9jbHVzdGVyRWRnZXM6IHBhcmFtZXRlciBjbHVzdGVyTm9kZSByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChjbHVzdGVyRWRnZVByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBUYWtlIHRoZSByZXF1aXJlZCBwcm9wZXJ0aWVzIGZyb20gdGhlIGNsdXN0ZXIgbm9kZVxuICAgICAgICBjbHVzdGVyRWRnZVByb3BlcnRpZXMgPSBjbHVzdGVyTm9kZS5jbHVzdGVyRWRnZVByb3BlcnRpZXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGNyZWF0ZSB0aGUgbmV3IGVkZ2VzIHRoYXQgd2lsbCBjb25uZWN0IHRvIHRoZSBjbHVzdGVyLlxuICAgICAgLy8gQWxsIHNlbGYtcmVmZXJlbmNpbmcgZWRnZXMgd2lsbCBiZSBhZGRlZCB0byBjaGlsZEVkZ2VzIGhlcmUuXG4gICAgICB0aGlzLl9jcmVhdGVDbHVzdGVyRWRnZXMoY2hpbGROb2RlcywgY2hpbGRFZGdlcywgY2x1c3Rlck5vZGUsIGNsdXN0ZXJFZGdlUHJvcGVydGllcyk7XG5cbiAgICAgIC8vIGRpc2FibGUgdGhlIGNoaWxkRWRnZXNcbiAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiBjaGlsZEVkZ2VzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2hpbGRFZGdlcywgZWRnZUlkKSkge1xuICAgICAgICAgIGlmICh0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgX2VkZ2UyID0gdGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF07XG4gICAgICAgICAgICAvLyBjYWNoZSB0aGUgb3B0aW9ucyBiZWZvcmUgY2hhbmdpbmdcbiAgICAgICAgICAgIHRoaXMuX2JhY2t1cEVkZ2VPcHRpb25zKF9lZGdlMik7XG4gICAgICAgICAgICAvLyBkaXNhYmxlIHBoeXNpY3MgYW5kIGhpZGUgdGhlIGVkZ2VcbiAgICAgICAgICAgIF9lZGdlMi5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgICAgcGh5c2ljczogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBkaXNhYmxlIHRoZSBjaGlsZE5vZGVzXG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gY2hpbGROb2Rlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNoaWxkTm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICB0aGlzLmNsdXN0ZXJlZE5vZGVzW25vZGVJZF0gPSB7XG4gICAgICAgICAgICBjbHVzdGVySWQ6IGNsdXN0ZXJOb2RlLmlkLFxuICAgICAgICAgICAgbm9kZTogdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgcGh5c2ljczogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpbiB3aGljaCBjbHVzdGVyIGdpdmVuIG5vZGVJZCByZXNpZGVzLlxuICAgICAqXG4gICAgICogSWYgbm90IGluIGNsdXN0ZXIsIHJldHVybiB1bmRlZmluZWQuXG4gICAgICpcbiAgICAgKiBOT1RFOiBJZiB5b3Uga25vdyBhIGNsZWFuZXIgd2F5IHRvIGRvIHRoaXMsIHBsZWFzZSBlbmxpZ2h0ZW4gbWUgKHdpbXJpam5kZXJzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHJldHVybnMge05vZGV8dW5kZWZpbmVkfSBOb2RlIGluc3RhbmNlIGZvciBjbHVzdGVyLCBpZiBwcmVzZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q2x1c3Rlck5vZGVGb3JOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDbHVzdGVyTm9kZUZvck5vZGUobm9kZUlkKSB7XG4gICAgICBpZiAobm9kZUlkID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB2YXIgY2x1c3RlcmVkTm9kZSA9IHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXTtcblxuICAgICAgLy8gTk9URTogSWYgbm8gY2x1c3RlciBpbmZvIGZvdW5kLCBpdCBzaG91bGQgYWN0dWFsbHkgYmUgYW4gZXJyb3JcbiAgICAgIGlmIChjbHVzdGVyZWROb2RlID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB2YXIgY2x1c3RlcklkID0gY2x1c3RlcmVkTm9kZS5jbHVzdGVySWQ7XG4gICAgICBpZiAoY2x1c3RlcklkID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJJZF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIGZvciBjb25kaXRpb25hbGx5IHJlbW92aW5nIGl0ZW1zIGluIGFycmF5XG4gICAgICpcbiAgICAgKiBEb25lIGxpa2UgdGhpcyBiZWNhdXNlIEFycmF5LmZpbHRlcigpIGlzIG5vdCBmdWxseSBzdXBwb3J0ZWQgYnkgYWxsIElFJ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9maWx0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbHRlcihhcnIsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgcmV0ID0gW107XG4gICAgICBmb3JFYWNoJDEoYXJyLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoY2FsbGJhY2soaXRlbSkpIHtcbiAgICAgICAgICByZXQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjYW4gYWxsIGVkZ2VzIGZvciBjaGFuZ2VzIGluIGNsdXN0ZXJpbmcgYW5kIGFkanVzdCB0aGlzIGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIENhbGwgdGhpcyAoaW50ZXJuYWxseSkgYWZ0ZXIgdGhlcmUgaGFzIGJlZW4gYSBjaGFuZ2UgaW4gbm9kZSBvciBlZGdlIGRhdGEuXG4gICAgICpcbiAgICAgKiBQcmU6IFN0YXRlcyBvZiB0aGlzLmJvZHkubm9kZXMgYW5kIHRoaXMuYm9keS5lZGdlcyBjb25zaXN0ZW50XG4gICAgICogUHJlOiB0aGlzLmNsdXN0ZXJlZE5vZGVzIGFuZCB0aGlzLmNsdXN0ZXJlZEVkZ2UgY29uc2lzdGVudCB3aXRoIGNvbnRhaW5lZE5vZGVzIGFuZCBjb250YWluZWRFZGdlc1xuICAgICAqICAgICAgb2YgY2x1c3RlciBub2Rlcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVN0YXRlKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICB2YXIgbm9kZUlkO1xuICAgICAgdmFyIGRlbGV0ZWROb2RlSWRzID0gW107XG4gICAgICB2YXIgZGVsZXRlZEVkZ2VJZHMgPSB7fTtcblxuICAgICAgLyoqXG4gICAgICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBjbHVzdGVyaW5nIG5vZGVzIG9ubHlcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBjbHVzdGVyIG5vZGVcbiAgICAgICAqL1xuICAgICAgdmFyIGVhY2hDbHVzdGVyTm9kZSA9IGZ1bmN0aW9uIGVhY2hDbHVzdGVyTm9kZShjYWxsYmFjaykge1xuICAgICAgICBmb3JFYWNoJDEoX3RoaXM0LmJvZHkubm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgaWYgKG5vZGUuaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgLy9cbiAgICAgIC8vIFJlbW92ZSBkZWxldGVkIHJlZ3VsYXIgbm9kZXMgZnJvbSBjbHVzdGVyaW5nXG4gICAgICAvL1xuXG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIGRlbGV0ZWQgbm9kZXNcbiAgICAgIGZvciAobm9kZUlkIGluIHRoaXMuY2x1c3RlcmVkTm9kZXMpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jbHVzdGVyZWROb2Rlcywgbm9kZUlkKSkgY29udGludWU7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGVkTm9kZUlkcy5wdXNoKG5vZGVJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIG5vZGVzIGZyb20gY2x1c3RlciBub2Rlc1xuICAgICAgZWFjaENsdXN0ZXJOb2RlKGZ1bmN0aW9uIChjbHVzdGVyTm9kZSkge1xuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGRlbGV0ZWROb2RlSWRzLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgZGVsZXRlIGNsdXN0ZXJOb2RlLmNvbnRhaW5lZE5vZGVzW2RlbGV0ZWROb2RlSWRzW25dXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlbW92ZSBub2RlcyBmcm9tIGNsdXN0ZXIgbGlzdFxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBkZWxldGVkTm9kZUlkcy5sZW5ndGg7IG4rKykge1xuICAgICAgICBkZWxldGUgdGhpcy5jbHVzdGVyZWROb2Rlc1tkZWxldGVkTm9kZUlkc1tuXV07XG4gICAgICB9XG5cbiAgICAgIC8vXG4gICAgICAvLyBSZW1vdmUgZGVsZXRlZCBlZGdlcyBmcm9tIGNsdXN0ZXJpbmdcbiAgICAgIC8vXG5cbiAgICAgIC8vIEFkZCB0aGUgZGVsZXRlZCBjbHVzdGVyZWQgZWRnZXMgdG8gdGhlIGxpc3RcbiAgICAgIGZvckVhY2gkMSh0aGlzLmNsdXN0ZXJlZEVkZ2VzLCBmdW5jdGlvbiAoZWRnZUlkKSB7XG4gICAgICAgIHZhciBlZGdlID0gX3RoaXM0LmJvZHkuZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgaWYgKGVkZ2UgPT09IHVuZGVmaW5lZCB8fCAhZWRnZS5lbmRQb2ludHNWYWxpZCgpKSB7XG4gICAgICAgICAgZGVsZXRlZEVkZ2VJZHNbZWRnZUlkXSA9IGVkZ2VJZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIENsdXN0ZXIgbm9kZXMgY2FuIGFsc28gY29udGFpbiBlZGdlcyB3aGljaCBhcmUgbm90IGNsdXN0ZXJlZCxcbiAgICAgIC8vIGkuZS4gbm9kZXMgMS0yIHdpdGhpbiBjbHVzdGVyIHdpdGggYW4gZWRnZSBpbiBiZXR3ZWVuLlxuICAgICAgLy8gU28gdGhlIGNsdXN0ZXIgbm9kZXMgYWxzbyBuZWVkIHRvIGJlIHNjYW5uZWQgZm9yIGludmFsaWQgZWRnZXNcbiAgICAgIGVhY2hDbHVzdGVyTm9kZShmdW5jdGlvbiAoY2x1c3Rlck5vZGUpIHtcbiAgICAgICAgZm9yRWFjaCQxKGNsdXN0ZXJOb2RlLmNvbnRhaW5lZEVkZ2VzLCBmdW5jdGlvbiAoZWRnZSwgZWRnZUlkKSB7XG4gICAgICAgICAgaWYgKCFlZGdlLmVuZFBvaW50c1ZhbGlkKCkgJiYgIWRlbGV0ZWRFZGdlSWRzW2VkZ2VJZF0pIHtcbiAgICAgICAgICAgIGRlbGV0ZWRFZGdlSWRzW2VkZ2VJZF0gPSBlZGdlSWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBbHNvIHNjYW4gZm9yIGNsdXN0ZXIgZWRnZXMgd2hpY2ggbmVlZCB0byBiZSByZW1vdmVkIGluIHRoZSBhY3RpdmUgbGlzdC5cbiAgICAgIC8vIFJlZ3VsYXIgZWRnZXMgaGF2ZSBiZWVuIHJlbW92ZWQgYmVmb3JlaGFuZCwgc28gdGhpcyBvbmx5IHBpY2tzIHVwIHRoZSBjbHVzdGVyIGVkZ2VzLlxuICAgICAgZm9yRWFjaCQxKHRoaXMuYm9keS5lZGdlcywgZnVuY3Rpb24gKGVkZ2UsIGVkZ2VJZCkge1xuICAgICAgICAvLyBFeHBsaWNpdGx5IHNjYW4gdGhlIGNvbnRhaW5lZCBlZGdlcyBmb3IgdmFsaWRpdHlcbiAgICAgICAgdmFyIGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICB2YXIgcmVwbGFjZWRJZHMgPSBlZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzO1xuICAgICAgICBpZiAocmVwbGFjZWRJZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBudW1WYWxpZCA9IDA7XG4gICAgICAgICAgZm9yRWFjaCQxKHJlcGxhY2VkSWRzLCBmdW5jdGlvbiAoY29udGFpbmVkRWRnZUlkKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVkRWRnZSA9IF90aGlzNC5ib2R5LmVkZ2VzW2NvbnRhaW5lZEVkZ2VJZF07XG4gICAgICAgICAgICBpZiAoY29udGFpbmVkRWRnZSAhPT0gdW5kZWZpbmVkICYmIGNvbnRhaW5lZEVkZ2UuZW5kUG9pbnRzVmFsaWQoKSkge1xuICAgICAgICAgICAgICBudW1WYWxpZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlzVmFsaWQgPSBudW1WYWxpZCA+IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlZGdlLmVuZFBvaW50c1ZhbGlkKCkgfHwgIWlzVmFsaWQpIHtcbiAgICAgICAgICBkZWxldGVkRWRnZUlkc1tlZGdlSWRdID0gZWRnZUlkO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gUmVtb3ZlIGVkZ2VzIGZyb20gY2x1c3RlciBub2Rlc1xuICAgICAgZWFjaENsdXN0ZXJOb2RlKGZ1bmN0aW9uIChjbHVzdGVyTm9kZSkge1xuICAgICAgICBmb3JFYWNoJDEoZGVsZXRlZEVkZ2VJZHMsIGZ1bmN0aW9uIChkZWxldGVkRWRnZUlkKSB7XG4gICAgICAgICAgZGVsZXRlIGNsdXN0ZXJOb2RlLmNvbnRhaW5lZEVkZ2VzW2RlbGV0ZWRFZGdlSWRdO1xuICAgICAgICAgIGZvckVhY2gkMShjbHVzdGVyTm9kZS5lZGdlcywgZnVuY3Rpb24gKGVkZ2UsIG0pIHtcbiAgICAgICAgICAgIGlmIChlZGdlLmlkID09PSBkZWxldGVkRWRnZUlkKSB7XG4gICAgICAgICAgICAgIGNsdXN0ZXJOb2RlLmVkZ2VzW21dID0gbnVsbDsgLy8gRG9uJ3Qgd2FudCB0byBkaXJlY3RseSBkZWxldGUgaGVyZSwgYmVjYXVzZSBpbiB0aGUgbG9vcFxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzID0gX3RoaXM0Ll9maWx0ZXIoZWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcywgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhZGVsZXRlZEVkZ2VJZHNbaWRdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgbnVsbHNcbiAgICAgICAgICBjbHVzdGVyTm9kZS5lZGdlcyA9IF90aGlzNC5fZmlsdGVyKGNsdXN0ZXJOb2RlLmVkZ2VzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0gIT09IG51bGw7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlbW92ZSBmcm9tIGNsdXN0ZXIgbGlzdFxuICAgICAgZm9yRWFjaCQxKGRlbGV0ZWRFZGdlSWRzLCBmdW5jdGlvbiAoZWRnZUlkKSB7XG4gICAgICAgIGRlbGV0ZSBfdGhpczQuY2x1c3RlcmVkRWRnZXNbZWRnZUlkXTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZW1vdmUgY2x1c3RlciBlZGdlcyBmcm9tIGFjdGl2ZSBsaXN0ICh0aGlzLmJvZHkuZWRnZXMpLlxuICAgICAgLy8gZGVsZXRlZEVkZ2VJZHMgc3RpbGwgY29udGFpbnMgaWQgb2YgcmVndWxhciBlZGdlcywgYnV0IHRoZXNlIHNob3VsZCBhbGxcbiAgICAgIC8vIGJlIGdvbmUgd2hlbiB5b3UgcmVhY2ggaGVyZS5cbiAgICAgIGZvckVhY2gkMShkZWxldGVkRWRnZUlkcywgZnVuY3Rpb24gKGVkZ2VJZCkge1xuICAgICAgICBkZWxldGUgX3RoaXM0LmJvZHkuZWRnZXNbZWRnZUlkXTtcbiAgICAgIH0pO1xuXG4gICAgICAvL1xuICAgICAgLy8gQ2hlY2sgY2hhbmdlZCBjbHVzdGVyIHN0YXRlIG9mIGVkZ2VzXG4gICAgICAvL1xuXG4gICAgICAvLyBJdGVyYXRpbmcgb3ZlciBrZXlzIGhlcmUsIGJlY2F1c2UgZWRnZXMgbWF5IGJlIHJlbW92ZWQgaW4gdGhlIGxvb3BcbiAgICAgIHZhciBpZHMgPSBfT2JqZWN0JGtleXModGhpcy5ib2R5LmVkZ2VzKTtcbiAgICAgIGZvckVhY2gkMShpZHMsIGZ1bmN0aW9uIChlZGdlSWQpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBfdGhpczQuYm9keS5lZGdlc1tlZGdlSWRdO1xuICAgICAgICB2YXIgc2hvdWxkQmVDbHVzdGVyZWQgPSBfdGhpczQuX2lzQ2x1c3RlcmVkTm9kZShlZGdlLmZyb21JZCkgfHwgX3RoaXM0Ll9pc0NsdXN0ZXJlZE5vZGUoZWRnZS50b0lkKTtcbiAgICAgICAgaWYgKHNob3VsZEJlQ2x1c3RlcmVkID09PSBfdGhpczQuX2lzQ2x1c3RlcmVkRWRnZShlZGdlLmlkKSkge1xuICAgICAgICAgIHJldHVybjsgLy8gYWxsIGlzIHdlbGxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG91bGRCZUNsdXN0ZXJlZCkge1xuICAgICAgICAgIC8vIGFkZCBlZGdlIHRvIGNsdXN0ZXJpbmdcbiAgICAgICAgICB2YXIgY2x1c3RlckZyb20gPSBfdGhpczQuX2dldENsdXN0ZXJOb2RlRm9yTm9kZShlZGdlLmZyb21JZCk7XG4gICAgICAgICAgaWYgKGNsdXN0ZXJGcm9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF90aGlzNC5fY2x1c3RlckVkZ2VzKF90aGlzNC5ib2R5Lm5vZGVzW2VkZ2UuZnJvbUlkXSwgZWRnZSwgY2x1c3RlckZyb20pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2x1c3RlclRvID0gX3RoaXM0Ll9nZXRDbHVzdGVyTm9kZUZvck5vZGUoZWRnZS50b0lkKTtcbiAgICAgICAgICBpZiAoY2x1c3RlclRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF90aGlzNC5fY2x1c3RlckVkZ2VzKF90aGlzNC5ib2R5Lm5vZGVzW2VkZ2UudG9JZF0sIGVkZ2UsIGNsdXN0ZXJUbyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVE9ETzogY2hlY2sgdGhhdCBpdCB3b3JrcyBmb3IgYm90aCBlZGdlcyBjbHVzdGVyZWRcbiAgICAgICAgICAvLyAgICAgICAoVGhpcyBtaWdodCBiZSBwYXJhbm9pYSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgX3RoaXM0Ll9jbHVzdGVyRWRnZXNbZWRnZUlkXTtcbiAgICAgICAgICBfdGhpczQuX3Jlc3RvcmVFZGdlKGVkZ2UpO1xuICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBiZSBoYXBwZW5pbmcsIHRoZSBzdGF0ZSBzaG91bGRcbiAgICAgICAgICAvLyBiZSBwcm9wZXJseSB1cGRhdGVkIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBJZiBpdCAqaXMqIHJlYWNoZWQgZHVyaW5nIG5vcm1hbCBvcGVyYXRpb24sIHRoZW4gd2UgaGF2ZSB0byBpbXBsZW1lbnRcbiAgICAgICAgICAvLyB1bmRvIGNsdXN0ZXJpbmcgZm9yIHRoaXMgZWRnZSBoZXJlLlxuICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcigncmVtb3ZlIGVkZ2UgZnJvbSBjbHVzdGVyaW5nIG5vdCBpbXBsZW1lbnRlZCEnKVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQ2x1c3RlcnMgbWF5IGJlIG5lc3RlZCB0byBhbnkgbGV2ZWwuIEtlZXAgb24gb3BlbmluZyB1bnRpbCBub3RoaW5nIHRvIG9wZW5cbiAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICB2YXIgY29udGludWVMb29wID0gdHJ1ZTtcbiAgICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoKSB7XG4gICAgICAgIHZhciBjbHVzdGVyc1RvT3BlbiA9IFtdO1xuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgaWQncyBvZiBjbHVzdGVycyB0aGF0IG5lZWQgb3BlbmluZ1xuICAgICAgICBlYWNoQ2x1c3Rlck5vZGUoZnVuY3Rpb24gKGNsdXN0ZXJOb2RlKSB7XG4gICAgICAgICAgdmFyIG51bU5vZGVzID0gX09iamVjdCRrZXlzKGNsdXN0ZXJOb2RlLmNvbnRhaW5lZE5vZGVzKS5sZW5ndGg7XG4gICAgICAgICAgdmFyIGFsbG93U2luZ2xlID0gY2x1c3Rlck5vZGUub3B0aW9ucy5hbGxvd1NpbmdsZU5vZGVDbHVzdGVyID09PSB0cnVlO1xuICAgICAgICAgIGlmIChhbGxvd1NpbmdsZSAmJiBudW1Ob2RlcyA8IDEgfHwgIWFsbG93U2luZ2xlICYmIG51bU5vZGVzIDwgMikge1xuICAgICAgICAgICAgY2x1c3RlcnNUb09wZW4ucHVzaChjbHVzdGVyTm9kZS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBPcGVuIHRoZW1cbiAgICAgICAgZm9yICh2YXIgX24gPSAwOyBfbiA8IGNsdXN0ZXJzVG9PcGVuLmxlbmd0aDsgKytfbikge1xuICAgICAgICAgIF90aGlzNC5vcGVuQ2x1c3RlcihjbHVzdGVyc1RvT3Blbltfbl0sIHt9LCBmYWxzZSAvKiBEb24ndCByZWZyZXNoLCB3ZSdyZSBpbiBhbiByZWZyZXNoL3VwZGF0ZSBhbHJlYWR5ICovKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRpbnVlTG9vcCA9IGNsdXN0ZXJzVG9PcGVuLmxlbmd0aCA+IDA7XG4gICAgICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IGNvbnRpbnVlTG9vcDtcbiAgICAgIH07XG4gICAgICB3aGlsZSAoY29udGludWVMb29wKSB7XG4gICAgICAgIF9sb29wMigpO1xuICAgICAgfVxuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlU3RhdGUoKTsgLy8gUmVkbyB0aGlzIG1ldGhvZCAocmVjdXJzaW9uIHBvc3NpYmxlISBzaG91bGQgYmUgc2FmZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgbm9kZSB3aXRoIGdpdmVuIGlkIGlzIHBhcnQgb2YgYSBjbHVzdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBwYXJ0IG9mIGEgY2x1c3Rlci5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfaXNDbHVzdGVyZWROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc0NsdXN0ZXJlZE5vZGUobm9kZUlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbHVzdGVyZWROb2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIGVkZ2Ugd2l0aCBnaXZlbiBpZCBpcyBub3QgdmlzaWJsZSBkdWUgdG8gY2x1c3RlcmluZy5cbiAgICAgKlxuICAgICAqIEFuIGVkZ2UgaXMgY29uc2lkZXJlZCBjbHVzdGVyZWQgaWY6XG4gICAgICogLSBpdCBpcyBkaXJlY3RseSByZXBsYWNlZCBieSBhIGNsdXN0ZXJpbmcgZWRnZVxuICAgICAqIC0gYW55IG9mIGl0cyBjb25uZWN0aW5nIG5vZGVzIGlzIGluIGEgY2x1c3RlclxuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuRWRnZS5pZH0gZWRnZUlkXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgcGFydCBvZiBhIGNsdXN0ZXIuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzQ2x1c3RlcmVkRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNDbHVzdGVyZWRFZGdlKGVkZ2VJZCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2x1c3RlcmVkRWRnZXNbZWRnZUlkXSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ2x1c3RlckVuZ2luZTtcbn0oKTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkgdG8gYSB1c2FibGUgZm9ybS5cbiAqXG4gKiBTcGVjaWZpY2FsbHksIHNldCB1cCB0aGlzIG1ldGhvZCBmb3IgdGhlIGNhc2Ugb2YgcnVubmluZyBvbiBub2RlLmpzIHdpdGgganNkb20gZW5hYmxlZC5cbiAqXG4gKiBOT1RFUzpcbiAqXG4gKiBPbiBub2RlLmpzLCB3aGVuIGNhbGxpbmcgdGhpcyBkaXJlY3RseSBvdXRzaWRlIG9mIHRoaXMgY2xhc3MsIGB3aW5kb3dgIGlzIG5vdCBkZWZpbmVkLlxuICogICBUaGlzIGhhcHBlbnMgZXZlbiBpZiBqc2RvbSBpcyB1c2VkLlxuICogRm9yIG5vZGUuanMgKyBqc2RvbSwgYHdpbmRvd2AgaXMgYXZhaWxhYmxlIGF0IHRoZSBtb21lbnQgdGhlIGNvbnN0cnVjdG9yIGlzIGNhbGxlZC5cbiAqICAgRm9yIHRoaXMgcmVhc29uLCB0aGUgY2FsbGVkIGlzIHBsYWNlZCB3aXRoaW4gdGhlIGNvbnN0cnVjdG9yLlxuICogRXZlbiB0aGVuLCBgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgpYCBpcyBub3QgZGVmaW5lZCwgc28gaXQgc3RpbGwgbmVlZHMgdG8gYmUgYWRkZWQuXG4gKiBEdXJpbmcgdW5pdCB0ZXN0aW5nLCBpdCBoYXBwZW5zIHRoYXQgdGhlIHdpbmRvdyBvYmplY3QgaXMgcmVzZXQgZHVyaW5nIGV4ZWN1dGlvbiwgY2F1c2luZ1xuICogICBhIHJ1bnRpbWUgZXJyb3IgZHVlIHRvIG1pc3NpbmcgYHJlcXVlc3RBbmltYXRpb25GcmFtZSgpYC4gVGhpcyBuZWVkcyB0byBiZSBjb21wZW5zYXRlZCBmb3IsXG4gKiAgIHNlZSBgX3JlcXVlc3ROZXh0RnJhbWUoKWAuXG4gKiBTaW5jZSB0aGlzIGlzIGEgZ2xvYmFsIG9iamVjdCwgaXQgbWF5IGFmZmVjdCBvdGhlciBtb2R1bGVzIGJlc2lkZXMgYE5ldHdvcmtgLiBXaXRoIG5vcm1hbFxuICogICB1c2FnZSwgdGhpcyBkb2VzIG5vdCBjYXVzZSBhbnkgcHJvYmxlbXMuIER1cmluZyB1bml0IHRlc3RpbmcsIGVycm9ycyBtYXkgb2NjdXIuIFRoZXNlIGhhdmVcbiAqICAgYmVlbiBjb21wZW5zYXRlZCBmb3IsIHNlZSBjb21tZW50IGJsb2NrIGluIF9yZXF1ZXN0TmV4dEZyYW1lKCkuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2luaXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSB7XG4gIHZhciBmdW5jO1xuICBpZiAod2luZG93ICE9PSB1bmRlZmluZWQpIHtcbiAgICBmdW5jID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICB9XG4gIGlmIChmdW5jID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyB3aW5kb3cgb3IgbWV0aG9kIG5vdCBwcmVzZW50LCBzZXR0aW5nIG1vY2sgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIkNhbGxlZCBtb2NrIHJlcXVlc3RBbmltYXRpb25GcmFtZVwiKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuYztcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBjYW52YXMgcmVuZGVyZXJcbiAqL1xudmFyIENhbnZhc1JlbmRlcmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICovXG4gIGZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKGJvZHksIGNhbnZhcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYW52YXNSZW5kZXJlcik7XG4gICAgX2luaXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMucmVkcmF3UmVxdWVzdGVkID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IHRydWU7XG4gICAgdGhpcy5yZW5kZXJpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlclJlcXVlc3RzID0gMDtcbiAgICB0aGlzLmFsbG93UmVkcmF3ID0gdHJ1ZTtcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgdGhpcy56b29taW5nID0gZmFsc2U7XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGhpZGVFZGdlc09uRHJhZzogZmFsc2UsXG4gICAgICBoaWRlRWRnZXNPblpvb206IGZhbHNlLFxuICAgICAgaGlkZU5vZGVzT25EcmFnOiBmYWxzZVxuICAgIH07XG4gICAgX09iamVjdCRhc3NpZ24odGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgICB0aGlzLl9kZXRlcm1pbmVCcm93c2VyTWV0aG9kKCk7XG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhDYW52YXNSZW5kZXJlciwgW3tcbiAgICBrZXk6IFwiYmluZEV2ZW50TGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIF9jb250ZXh0MjtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZHJhZ1N0YXJ0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRyYWdFbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInpvb21cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy56b29taW5nID0gdHJ1ZTtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChfdGhpcy56b29tVGltZW91dElkKTtcbiAgICAgICAgX3RoaXMuem9vbVRpbWVvdXRJZCA9IF9zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQ7XG4gICAgICAgICAgX3RoaXMuem9vbWluZyA9IGZhbHNlO1xuICAgICAgICAgIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0ID0gX3RoaXMuX3JlcXVlc3RSZWRyYXcpLmNhbGwoX2NvbnRleHQsIF90aGlzKSgpO1xuICAgICAgICB9LCAyNTApO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9yZXNpemVOb2Rlc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLl9yZXNpemVOb2RlcygpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9yZWRyYXdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMucmVuZGVyaW5nQWN0aXZlID09PSBmYWxzZSkge1xuICAgICAgICAgIF90aGlzLl9yZWRyYXcoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9ibG9ja1JlZHJhd1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmFsbG93UmVkcmF3ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2FsbG93UmVkcmF3XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuYWxsb3dSZWRyYXcgPSB0cnVlO1xuICAgICAgICBfdGhpcy5yZWRyYXdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfcmVxdWVzdFJlZHJhd1wiLCBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDIgPSB0aGlzLl9yZXF1ZXN0UmVkcmF3KS5jYWxsKF9jb250ZXh0MiwgdGhpcykpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfc3RhcnRSZW5kZXJpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5yZW5kZXJSZXF1ZXN0cyArPSAxO1xuICAgICAgICBfdGhpcy5yZW5kZXJpbmdBY3RpdmUgPSB0cnVlO1xuICAgICAgICBfdGhpcy5fc3RhcnRSZW5kZXJpbmcoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfc3RvcFJlbmRlcmluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnJlbmRlclJlcXVlc3RzIC09IDE7XG4gICAgICAgIF90aGlzLnJlbmRlcmluZ0FjdGl2ZSA9IF90aGlzLnJlbmRlclJlcXVlc3RzID4gMDtcbiAgICAgICAgX3RoaXMucmVuZGVyVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVzdHJveVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnJlbmRlclJlcXVlc3RzID0gMDtcbiAgICAgICAgX3RoaXMuYWxsb3dSZWRyYXcgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMucmVuZGVyaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGlmIChfdGhpcy5yZXF1aXJlc1RpbWVvdXQgPT09IHRydWUpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMucmVuZGVyVGltZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShfdGhpcy5yZW5kZXJUaW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuYm9keS5lbWl0dGVyLm9mZigpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBmaWVsZHMgPSBbXCJoaWRlRWRnZXNPbkRyYWdcIiwgXCJoaWRlRWRnZXNPblpvb21cIiwgXCJoaWRlTm9kZXNPbkRyYWdcIl07XG4gICAgICAgIHNlbGVjdGl2ZURlZXBFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIGRyYXdpbmcgb2YgdGhlIG5leHQgZnJhbWUuXG4gICAgICpcbiAgICAgKiBDYWxscyB0aGUgY2FsbGJhY2sgd2hlbiB0aGUgbmV4dCBmcmFtZSBjYW4gb3Igd2lsbCBiZSBkcmF3bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IC0gdGltZW91dCBjYXNlIG9ubHksIHdhaXQgdGhpcyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9uIHwgdW5kZWZpbmVkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlcXVlc3ROZXh0RnJhbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlcXVlc3ROZXh0RnJhbWUoY2FsbGJhY2ssIGRlbGF5KSB7XG4gICAgICAvLyBEdXJpbmcgdW5pdCB0ZXN0aW5nLCBpdCBoYXBwZW5zIHRoYXQgdGhlIG1vY2sgd2luZG93IG9iamVjdCBpcyByZXNldCB3aGlsZVxuICAgICAgLy8gdGhlIG5leHQgZnJhbWUgaXMgc3RpbGwgcGVuZGluZy4gVGhlbiwgZWl0aGVyICd3aW5kb3cnIGlzIG5vdCBwcmVzZW50LCBvclxuICAgICAgLy8gJ3JlcXVlc3RBbmltYXRpb25GcmFtZSgpJyBpcyBub3QgcHJlc2VudCBiZWNhdXNlIGl0IGlzIG5vdCBkZWZpbmVkIG9uIHRoZVxuICAgICAgLy8gbW9jayB3aW5kb3cgb2JqZWN0LlxuICAgICAgLy9cbiAgICAgIC8vIEFzIGEgY29uc2VxdWVuY2UsIHVucmVsYXRlZCB1bml0IHRlc3RzIG1heSBhcHBlYXIgdG8gZmFpbCwgZXZlbiBpZiB0aGUgcHJvYmxlbVxuICAgICAgLy8gZGVzY3JpYmVkIGhhcHBlbnMgaW4gdGhlIGN1cnJlbnQgdW5pdCB0ZXN0LlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgaXMgbm90IHNvbWV0aGluZyB0aGF0IHdpbGwgaGFwcGVuIGluIG5vcm1hbCBvcGVyYXRpb24sIGJ1dCB3ZSBzdGlsbCBuZWVkXG4gICAgICAvLyB0byB0YWtlIGl0IGludG8gYWNjb3VudC5cbiAgICAgIC8vXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuOyAvLyBEb2luZyBgaWYgKHdpbmRvdyA9PT0gdW5kZWZpbmVkKWAgZG9lcyBub3Qgd29yayBoZXJlIVxuXG4gICAgICB2YXIgdGltZXI7XG4gICAgICB2YXIgbXlXaW5kb3cgPSB3aW5kb3c7IC8vIEdyYWIgYSByZWZlcmVuY2UgdG8gcmVkdWNlIHRoZSBwb3NzaWJpbGl0eSB0aGF0ICd3aW5kb3cnIGlzIHJlc2V0XG4gICAgICAvLyB3aGlsZSBydW5uaW5nIHRoaXMgbWV0aG9kLlxuXG4gICAgICBpZiAodGhpcy5yZXF1aXJlc1RpbWVvdXQgPT09IHRydWUpIHtcbiAgICAgICAgLy8gd2FpdCBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGFuZCBwZXJmb3JtIHRoZSBhbmltYXRpb24gc3RlcCBmdW5jdGlvblxuICAgICAgICB0aW1lciA9IF9zZXRUaW1lb3V0KGNhbGxiYWNrLCBkZWxheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobXlXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgdGltZXIgPSBteVdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGltZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9zdGFydFJlbmRlcmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RhcnRSZW5kZXJpbmcoKSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJpbmdBY3RpdmUgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyVGltZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBfY29udGV4dDM7XG4gICAgICAgICAgdGhpcy5yZW5kZXJUaW1lciA9IHRoaXMuX3JlcXVlc3ROZXh0RnJhbWUoX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQzID0gdGhpcy5fcmVuZGVyU3RlcCkuY2FsbChfY29udGV4dDMsIHRoaXMpLCB0aGlzLnNpbXVsYXRpb25JbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbmRlclN0ZXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlclN0ZXAoKSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJpbmdBY3RpdmUgPT09IHRydWUpIHtcbiAgICAgICAgLy8gcmVzZXQgdGhlIHJlbmRlclRpbWVyIHNvIGEgbmV3IHNjaGVkdWxlZCBhbmltYXRpb24gc3RlcCBjYW4gYmUgc2V0XG4gICAgICAgIHRoaXMucmVuZGVyVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLnJlcXVpcmVzVGltZW91dCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIHRoaXMgc2NoZWR1bGVzIGEgbmV3IHNpbXVsYXRpb24gc3RlcFxuICAgICAgICAgIHRoaXMuX3N0YXJ0UmVuZGVyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVkcmF3KCk7XG4gICAgICAgIGlmICh0aGlzLnJlcXVpcmVzVGltZW91dCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAvLyB0aGlzIHNjaGVkdWxlcyBhIG5ldyBzaW11bGF0aW9uIHN0ZXBcbiAgICAgICAgICB0aGlzLl9zdGFydFJlbmRlcmluZygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVkcmF3IHRoZSBuZXR3b3JrIHdpdGggdGhlIGN1cnJlbnQgZGF0YVxuICAgICAqIGNoYXJ0IHdpbGwgYmUgcmVzaXplZCB0b28uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZHJhdygpIHtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJzZXRTaXplXCIpO1xuICAgICAgdGhpcy5fcmVkcmF3KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVkcmF3IHRoZSBuZXR3b3JrIHdpdGggdGhlIGN1cnJlbnQgZGF0YVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfcmVxdWVzdFJlZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVxdWVzdFJlZHJhdygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMucmVkcmF3UmVxdWVzdGVkICE9PSB0cnVlICYmIHRoaXMucmVuZGVyaW5nQWN0aXZlID09PSBmYWxzZSAmJiB0aGlzLmFsbG93UmVkcmF3ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMucmVkcmF3UmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdE5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLl9yZWRyYXcoZmFsc2UpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgdGhlIG5ldHdvcmsgd2l0aCB0aGUgY3VycmVudCBkYXRhXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtoaWRkZW49ZmFsc2VdIHwgVXNlZCB0byBnZXQgdGhlIGZpcnN0IGVzdGltYXRlIG9mIHRoZSBub2RlIHNpemVzLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IHRoZSBub2RlcyBhcmUgZHJhd24gYWZ0ZXIgd2hpY2ggdGhleSBhcmUgcXVpY2tseSBkcmF3biBvdmVyLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVkcmF3KCkge1xuICAgICAgdmFyIGhpZGRlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgICBpZiAodGhpcy5hbGxvd1JlZHJhdyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiaW5pdFJlZHJhd1wiKTtcbiAgICAgICAgdGhpcy5yZWRyYXdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRyYXdMYXRlciA9IHtcbiAgICAgICAgICBkcmF3RXh0ZXJuYWxMYWJlbHM6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyB3aGVuIHRoZSBjb250YWluZXIgZGl2IHdhcyBoaWRkZW4sIHRoaXMgZml4ZXMgaXQgYmFjayB1cCFcbiAgICAgICAgaWYgKHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy53aWR0aCA9PT0gMCB8fCB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5jYW52YXMuc2V0U2l6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FudmFzLnNldFRyYW5zZm9ybSgpO1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgpO1xuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBjYW52YXNcbiAgICAgICAgdmFyIHcgPSB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciBoID0gdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodDtcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3LCBoKTtcblxuICAgICAgICAvLyBpZiB0aGUgZGl2IGlzIGhpZGRlbiwgd2Ugc3RvcCB0aGUgcmVkcmF3IGhlcmUgZm9yIHBlcmZvcm1hbmNlLlxuICAgICAgICBpZiAodGhpcy5jYW52YXMuZnJhbWUuY2xpZW50V2lkdGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgc2NhbGluZyBhbmQgdHJhbnNsYXRpb25cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55KTtcbiAgICAgICAgY3R4LnNjYWxlKHRoaXMuYm9keS52aWV3LnNjYWxlLCB0aGlzLmJvZHkudmlldy5zY2FsZSk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImJlZm9yZURyYXdpbmdcIiwgY3R4KTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBpZiAoaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICAgIGlmICgodGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UgfHwgdGhpcy5kcmFnZ2luZyA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuaGlkZUVkZ2VzT25EcmFnID09PSBmYWxzZSkgJiYgKHRoaXMuem9vbWluZyA9PT0gZmFsc2UgfHwgdGhpcy56b29taW5nID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5oaWRlRWRnZXNPblpvb20gPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgdGhpcy5fZHJhd0VkZ2VzKGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nID09PSBmYWxzZSB8fCB0aGlzLmRyYWdnaW5nID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5oaWRlTm9kZXNPbkRyYWcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIF90aGlzJF9kcmF3Tm9kZXMgPSB0aGlzLl9kcmF3Tm9kZXMoY3R4LCBoaWRkZW4pLFxuICAgICAgICAgICAgZHJhd0V4dGVybmFsTGFiZWxzID0gX3RoaXMkX2RyYXdOb2Rlcy5kcmF3RXh0ZXJuYWxMYWJlbHM7XG4gICAgICAgICAgZHJhd0xhdGVyLmRyYXdFeHRlcm5hbExhYmVscyA9IGRyYXdFeHRlcm5hbExhYmVscztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRyYXcgdGhlIGFycm93cyBsYXN0IHNvIHRoZXkgd2lsbCBiZSBhdCB0aGUgdG9wXG4gICAgICAgIGlmIChoaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKCh0aGlzLmRyYWdnaW5nID09PSBmYWxzZSB8fCB0aGlzLmRyYWdnaW5nID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5oaWRlRWRnZXNPbkRyYWcgPT09IGZhbHNlKSAmJiAodGhpcy56b29taW5nID09PSBmYWxzZSB8fCB0aGlzLnpvb21pbmcgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmhpZGVFZGdlc09uWm9vbSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3QXJyb3dzKGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkcmF3TGF0ZXIuZHJhd0V4dGVybmFsTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgICBkcmF3TGF0ZXIuZHJhd0V4dGVybmFsTGFiZWxzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhpZGRlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLl9kcmF3U2VsZWN0aW9uQm94KGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYWZ0ZXJEcmF3aW5nXCIsIGN0eCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIHNjYWxpbmcgYW5kIHRyYW5zbGF0aW9uXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIGlmIChoaWRkZW4gPT09IHRydWUpIHtcbiAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVkcmF3IGFsbCBub2Rlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYWx3YXlzU2hvd11cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9yZXNpemVOb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplTm9kZXMoKSB7XG4gICAgICB0aGlzLmNhbnZhcy5zZXRUcmFuc2Zvcm0oKTtcbiAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55KTtcbiAgICAgIGN0eC5zY2FsZSh0aGlzLmJvZHkudmlldy5zY2FsZSwgdGhpcy5ib2R5LnZpZXcuc2NhbGUpO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIG5vZGU7XG5cbiAgICAgIC8vIHJlc2l6ZSBhbGwgbm9kZXNcbiAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBub2Rlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGVzLCBub2RlSWQpKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGVzW25vZGVJZF07XG4gICAgICAgICAgbm9kZS5yZXNpemUoY3R4KTtcbiAgICAgICAgICBub2RlLnVwZGF0ZUJvdW5kaW5nQm94KGN0eCwgbm9kZS5zZWxlY3RlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCBzY2FsaW5nIGFuZCB0cmFuc2xhdGlvblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgYWxsIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4ICAyRCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthbHdheXNTaG93XVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge29iamVjdH0gQ2FsbGJhY2tzIHRvIGRyYXcgbGF0ZXIgb24gaGlnaGVyIGxheWVycy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd05vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3Tm9kZXMoY3R4KSB7XG4gICAgICB2YXIgYWx3YXlzU2hvdyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIHZhciBzZWxlY3RlZCA9IFtdO1xuICAgICAgdmFyIGhvdmVyZWQgPSBbXTtcbiAgICAgIHZhciBtYXJnaW4gPSAyMDtcbiAgICAgIHZhciB0b3BMZWZ0ID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMoe1xuICAgICAgICB4OiAtbWFyZ2luLFxuICAgICAgICB5OiAtbWFyZ2luXG4gICAgICB9KTtcbiAgICAgIHZhciBib3R0b21SaWdodCA9IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHtcbiAgICAgICAgeDogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoICsgbWFyZ2luLFxuICAgICAgICB5OiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0ICsgbWFyZ2luXG4gICAgICB9KTtcbiAgICAgIHZhciB2aWV3YWJsZUFyZWEgPSB7XG4gICAgICAgIHRvcDogdG9wTGVmdC55LFxuICAgICAgICBsZWZ0OiB0b3BMZWZ0LngsXG4gICAgICAgIGJvdHRvbTogYm90dG9tUmlnaHQueSxcbiAgICAgICAgcmlnaHQ6IGJvdHRvbVJpZ2h0LnhcbiAgICAgIH07XG4gICAgICB2YXIgX2RyYXdFeHRlcm5hbExhYmVscyA9IFtdO1xuXG4gICAgICAvLyBkcmF3IHVuc2VsZWN0ZWQgbm9kZXM7XG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbm9kZUluZGljZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tub2RlSW5kaWNlc1tfaV1dO1xuICAgICAgICAvLyBzZXQgc2VsZWN0ZWQgYW5kIGhvdmVyZWQgbm9kZXMgYXNpZGVcbiAgICAgICAgaWYgKG5vZGUuaG92ZXIpIHtcbiAgICAgICAgICBob3ZlcmVkLnB1c2gobm9kZUluZGljZXNbX2ldKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLmlzU2VsZWN0ZWQoKSkge1xuICAgICAgICAgIHNlbGVjdGVkLnB1c2gobm9kZUluZGljZXNbX2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoYWx3YXlzU2hvdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGRyYXdMYXRlciA9IG5vZGUuZHJhdyhjdHgpO1xuICAgICAgICAgICAgaWYgKGRyYXdMYXRlci5kcmF3RXh0ZXJuYWxMYWJlbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIF9kcmF3RXh0ZXJuYWxMYWJlbHMucHVzaChkcmF3TGF0ZXIuZHJhd0V4dGVybmFsTGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5pc0JvdW5kaW5nQm94T3ZlcmxhcHBpbmdXaXRoKHZpZXdhYmxlQXJlYSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBfZHJhd0xhdGVyID0gbm9kZS5kcmF3KGN0eCk7XG4gICAgICAgICAgICBpZiAoX2RyYXdMYXRlci5kcmF3RXh0ZXJuYWxMYWJlbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIF9kcmF3RXh0ZXJuYWxMYWJlbHMucHVzaChfZHJhd0xhdGVyLmRyYXdFeHRlcm5hbExhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZS51cGRhdGVCb3VuZGluZ0JveChjdHgsIG5vZGUuc2VsZWN0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgc2VsZWN0ZWRMZW5ndGggPSBzZWxlY3RlZC5sZW5ndGg7XG4gICAgICB2YXIgaG92ZXJlZExlbmd0aCA9IGhvdmVyZWQubGVuZ3RoO1xuXG4gICAgICAvLyBkcmF3IHRoZSBzZWxlY3RlZCBub2RlcyBvbiB0b3BcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxlY3RlZExlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tzZWxlY3RlZFtpXV07XG4gICAgICAgIHZhciBfZHJhd0xhdGVyMiA9IG5vZGUuZHJhdyhjdHgpO1xuICAgICAgICBpZiAoX2RyYXdMYXRlcjIuZHJhd0V4dGVybmFsTGFiZWwgIT0gbnVsbCkge1xuICAgICAgICAgIF9kcmF3RXh0ZXJuYWxMYWJlbHMucHVzaChfZHJhd0xhdGVyMi5kcmF3RXh0ZXJuYWxMYWJlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZHJhdyBob3ZlcmVkIG5vZGVzIGFib3ZlIGV2ZXJ5dGhpbmcgZWxzZTogZml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL3Zpc2pzL3Zpcy1uZXR3b3JrL2lzc3Vlcy8yMjZcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBob3ZlcmVkTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW2hvdmVyZWRbaV1dO1xuICAgICAgICB2YXIgX2RyYXdMYXRlcjMgPSBub2RlLmRyYXcoY3R4KTtcbiAgICAgICAgaWYgKF9kcmF3TGF0ZXIzLmRyYXdFeHRlcm5hbExhYmVsICE9IG51bGwpIHtcbiAgICAgICAgICBfZHJhd0V4dGVybmFsTGFiZWxzLnB1c2goX2RyYXdMYXRlcjMuZHJhd0V4dGVybmFsTGFiZWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkcmF3RXh0ZXJuYWxMYWJlbHM6IGZ1bmN0aW9uIGRyYXdFeHRlcm5hbExhYmVscygpIHtcbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwLCBfZHJhd0V4dGVybmFsTGFiZWxzMiA9IF9kcmF3RXh0ZXJuYWxMYWJlbHM7IF9pMiA8IF9kcmF3RXh0ZXJuYWxMYWJlbHMyLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgIHZhciBkcmF3ID0gX2RyYXdFeHRlcm5hbExhYmVsczJbX2kyXTtcbiAgICAgICAgICAgIGRyYXcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVkcmF3IGFsbCBlZGdlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAgMkQgY29udGV4dCBvZiBhIEhUTUwgY2FudmFzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd0VkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3RWRnZXMoY3R4KSB7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICB2YXIgZWRnZUluZGljZXMgPSB0aGlzLmJvZHkuZWRnZUluZGljZXM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbZWRnZUluZGljZXNbaV1dO1xuICAgICAgICBpZiAoZWRnZS5jb25uZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBlZGdlLmRyYXcoY3R4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZHJhdyBhbGwgYXJyb3dzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4ICAyRCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3QXJyb3dzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3QXJyb3dzKGN0eCkge1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgdmFyIGVkZ2VJbmRpY2VzID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VkZ2VJbmRpY2VzW2ldXTtcbiAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgZWRnZS5kcmF3QXJyb3dzKGN0eCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgdGhlIGJyb3dzZXIgcmVxdWlyZXMgYSBzZXRUaW1lb3V0IG9yIGEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLiBUaGlzIHdhcyByZXF1aXJlZCBiZWNhdXNlXG4gICAgICogc29tZSBpbXBsZW1lbnRhdGlvbnMgKHNhZmFyaSBhbmQgSUU5KSBkaWQgbm90IHN1cHBvcnQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9kZXRlcm1pbmVCcm93c2VyTWV0aG9kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRlcm1pbmVCcm93c2VyTWV0aG9kKCkge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFyIGJyb3dzZXJUeXBlID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IGZhbHNlO1xuICAgICAgICBpZiAoX2luZGV4T2ZJbnN0YW5jZVByb3BlcnR5KGJyb3dzZXJUeXBlKS5jYWxsKGJyb3dzZXJUeXBlLCBcIm1zaWUgOS4wXCIpICE9IC0xKSB7XG4gICAgICAgICAgLy8gSUUgOVxuICAgICAgICAgIHRoaXMucmVxdWlyZXNUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkoYnJvd3NlclR5cGUpLmNhbGwoYnJvd3NlclR5cGUsIFwic2FmYXJpXCIpICE9IC0xKSB7XG4gICAgICAgICAgLy8gc2FmYXJpXG4gICAgICAgICAgaWYgKF9pbmRleE9mSW5zdGFuY2VQcm9wZXJ0eShicm93c2VyVHlwZSkuY2FsbChicm93c2VyVHlwZSwgXCJjaHJvbWVcIikgPD0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWlyZXNUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVxdWlyZXNUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgc2VsZWN0aW9uIGJveFxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAgMkQgY29udGV4dCBvZiBhIEhUTUwgY2FudmFzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd1NlbGVjdGlvbkJveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd1NlbGVjdGlvbkJveChjdHgpIHtcbiAgICAgIGlmICh0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnNob3cpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLmVuZC54IC0gdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5zdGFydC54O1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5lbmQueSAtIHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uc3RhcnQueTtcbiAgICAgICAgY3R4LnJlY3QodGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5zdGFydC54LCB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLnN0YXJ0LnksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2JhKDE1MSwgMTk0LCAyNTIsIDAuMilcIjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uc3RhcnQueCwgdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5zdGFydC55LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJyZ2JhKDE1MSwgMTk0LCAyNTIsIDEpXCI7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENhbnZhc1JlbmRlcmVyO1xufSgpO1xuXG52YXIgcGF0aCQyID0gcGF0aCR3O1xuXG52YXIgc2V0SW50ZXJ2YWwkMSA9IHBhdGgkMi5zZXRJbnRlcnZhbDtcblxudmFyIHNldEludGVydmFsID0gc2V0SW50ZXJ2YWwkMTtcblxudmFyIF9zZXRJbnRlcnZhbCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhzZXRJbnRlcnZhbCk7XG5cbi8qKlxuICogUmVnaXN0ZXIgYSB0b3VjaCBldmVudCwgdGFraW5nIHBsYWNlIGJlZm9yZSBhIGdlc3R1cmVcbiAqXG4gKiBAcGFyYW0ge0hhbW1lcn0gaGFtbWVyICAgICAgIEEgaGFtbWVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAgIENhbGxiYWNrLCBjYWxsZWQgYXMgY2FsbGJhY2soZXZlbnQpXG4gKi9cbmZ1bmN0aW9uIG9uVG91Y2goaGFtbWVyLCBjYWxsYmFjaykge1xuICBjYWxsYmFjay5pbnB1dEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuaXNGaXJzdCkge1xuICAgICAgY2FsbGJhY2soZXZlbnQpO1xuICAgIH1cbiAgfTtcbiAgaGFtbWVyLm9uKFwiaGFtbWVyLmlucHV0XCIsIGNhbGxiYWNrLmlucHV0SGFuZGxlcik7XG59XG5cbi8qKlxuICogUmVnaXN0ZXIgYSByZWxlYXNlIGV2ZW50LCB0YWtpbmcgcGxhY2UgYWZ0ZXIgYSBnZXN0dXJlXG4gKlxuICogQHBhcmFtIHtIYW1tZXJ9IGhhbW1lciAgICAgICBBIGhhbW1lciBpbnN0YW5jZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgICBDYWxsYmFjaywgY2FsbGVkIGFzIGNhbGxiYWNrKGV2ZW50KVxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIG9uUmVsZWFzZShoYW1tZXIsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrLmlucHV0SGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5pc0ZpbmFsKSB7XG4gICAgICBjYWxsYmFjayhldmVudCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGFtbWVyLm9uKFwiaGFtbWVyLmlucHV0XCIsIGNhbGxiYWNrLmlucHV0SGFuZGxlcik7XG59XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBtYWluIGZyYW1lIGZvciB0aGUgTmV0d29yay5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgb25jZSB3aGVuIGEgTmV0d29yayBvYmplY3QgaXMgY3JlYXRlZC4gVGhlIGZyYW1lXG4gKiBjb250YWlucyBhIGNhbnZhcywgYW5kIHRoaXMgY2FudmFzIGNvbnRhaW5zIGFsbCBvYmplY3RzIGxpa2UgdGhlIGF4aXMgYW5kXG4gKiBub2Rlcy5cbiAqL1xudmFyIENhbnZhcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKi9cbiAgZnVuY3Rpb24gQ2FudmFzKGJvZHkpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FudmFzKTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMucGl4ZWxSYXRpbyA9IDE7XG4gICAgdGhpcy5jYW1lcmFTdGF0ZSA9IHt9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhbnZhc1ZpZXdDZW50ZXIgPSB7fTtcbiAgICB0aGlzLl9jbGVhbnVwQ2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGF1dG9SZXNpemU6IHRydWUsXG4gICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgd2lkdGg6IFwiMTAwJVwiXG4gICAgfTtcbiAgICBfT2JqZWN0JGFzc2lnbih0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogQmluZHMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoQ2FudmFzLCBbe1xuICAgIGtleTogXCJiaW5kRXZlbnRMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgX2NvbnRleHQ7XG4gICAgICAvLyBiaW5kIHRoZSBldmVudHNcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uY2UoXCJyZXNpemVcIiwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAob2JqLndpZHRoICE9PSAwKSB7XG4gICAgICAgICAgX3RoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnggPSBvYmoud2lkdGggKiAwLjU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai5oZWlnaHQgIT09IDApIHtcbiAgICAgICAgICBfdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSA9IG9iai5oZWlnaHQgKiAwLjU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJzZXRTaXplXCIsIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0ID0gdGhpcy5zZXRTaXplKS5jYWxsKF9jb250ZXh0LCB0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5oYW1tZXJGcmFtZS5kZXN0cm95KCk7XG4gICAgICAgIF90aGlzLmhhbW1lci5kZXN0cm95KCk7XG4gICAgICAgIF90aGlzLl9jbGVhblVwKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGZpZWxkcyA9IFtcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwiYXV0b1Jlc2l6ZVwiXTtcbiAgICAgICAgc2VsZWN0aXZlRGVlcEV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgYWRhcHQgdG8gY2hhbmdpbmcgc2l6ZSBvZiB0aGUgY29udGFpbmVyIGVsZW1lbnQuXG4gICAgICB0aGlzLl9jbGVhblVwKCk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9SZXNpemUgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MjtcbiAgICAgICAgaWYgKHdpbmRvdy5SZXNpemVPYnNlcnZlcikge1xuICAgICAgICAgIC8vIGRlY2VudCBicm93c2VycywgaW1tZWRpYXRlIHJlYWN0aW9uc1xuICAgICAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlZCA9IF90aGlzMi5zZXRTaXplKCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBfdGhpczIuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgZnJhbWUgPSB0aGlzLmZyYW1lO1xuICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoZnJhbWUpO1xuICAgICAgICAgIHRoaXMuX2NsZWFudXBDYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoZnJhbWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElFMTEsIGNvbnRpbm91cyBwb2xsaW5nXG4gICAgICAgICAgdmFyIHJlc2l6ZVRpbWVyID0gX3NldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VkID0gX3RoaXMyLnNldFNpemUoKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIF90aGlzMi5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICAgIHRoaXMuX2NsZWFudXBDYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHJlc2l6ZVRpbWVyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF1dG9tYXRpY2FsbHkgYWRhcHQgdG8gY2hhbmdpbmcgc2l6ZSBvZiB0aGUgYnJvd3Nlci5cbiAgICAgICAgdmFyIHJlc2l6ZUZ1bmN0aW9uID0gX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQyID0gdGhpcy5fb25SZXNpemUpLmNhbGwoX2NvbnRleHQyLCB0aGlzKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcmVzaXplRnVuY3Rpb24pO1xuICAgICAgICB0aGlzLl9jbGVhbnVwQ2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHJlc2l6ZUZ1bmN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY2xlYW5VcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xlYW5VcCgpIHtcbiAgICAgIHZhciBfY29udGV4dDMsIF9jb250ZXh0NCwgX2NvbnRleHQ1O1xuICAgICAgX2ZvckVhY2hJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0MyA9IF9yZXZlcnNlSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDQgPSBfc3BsaWNlSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDUgPSB0aGlzLl9jbGVhbnVwQ2FsbGJhY2tzKS5jYWxsKF9jb250ZXh0NSwgMCkpLmNhbGwoX2NvbnRleHQ0KSkuY2FsbChfY29udGV4dDMsIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX29uUmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblJlc2l6ZSgpIHtcbiAgICAgIHRoaXMuc2V0U2l6ZSgpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFuZCBzdG9yZSB0aGUgY2FtZXJhU3RhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGl4ZWxSYXRpbz10aGlzLnBpeGVsUmF0aW9dXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q2FtZXJhU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENhbWVyYVN0YXRlKCkge1xuICAgICAgdmFyIHBpeGVsUmF0aW8gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMucGl4ZWxSYXRpbztcbiAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNXaWR0aCA9IHRoaXMuZnJhbWUuY2FudmFzLndpZHRoIC8gcGl4ZWxSYXRpbztcbiAgICAgICAgdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c0hlaWdodCA9IHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCAvIHBpeGVsUmF0aW87XG4gICAgICAgIHRoaXMuY2FtZXJhU3RhdGUuc2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgdGhpcy5jYW1lcmFTdGF0ZS5wb3NpdGlvbiA9IHRoaXMuRE9NdG9DYW52YXMoe1xuICAgICAgICAgIHg6IDAuNSAqIHRoaXMuZnJhbWUuY2FudmFzLndpZHRoIC8gcGl4ZWxSYXRpbyxcbiAgICAgICAgICB5OiAwLjUgKiB0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgLyBwaXhlbFJhdGlvXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY2FtZXJhU3RhdGVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldENhbWVyYVN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRDYW1lcmFTdGF0ZSgpIHtcbiAgICAgIGlmICh0aGlzLmNhbWVyYVN0YXRlLnNjYWxlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGggIT09IDAgJiYgdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0ICE9PSAwICYmIHRoaXMucGl4ZWxSYXRpbyAhPT0gMCAmJiB0aGlzLmNhbWVyYVN0YXRlLnByZXZpb3VzV2lkdGggPiAwICYmIHRoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNIZWlnaHQgPiAwKSB7XG4gICAgICAgIHZhciB3aWR0aFJhdGlvID0gdGhpcy5mcmFtZS5jYW52YXMud2lkdGggLyB0aGlzLnBpeGVsUmF0aW8gLyB0aGlzLmNhbWVyYVN0YXRlLnByZXZpb3VzV2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHRSYXRpbyA9IHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCAvIHRoaXMucGl4ZWxSYXRpbyAvIHRoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNIZWlnaHQ7XG4gICAgICAgIHZhciBuZXdTY2FsZSA9IHRoaXMuY2FtZXJhU3RhdGUuc2NhbGU7XG4gICAgICAgIGlmICh3aWR0aFJhdGlvICE9IDEgJiYgaGVpZ2h0UmF0aW8gIT0gMSkge1xuICAgICAgICAgIG5ld1NjYWxlID0gdGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSAqIDAuNSAqICh3aWR0aFJhdGlvICsgaGVpZ2h0UmF0aW8pO1xuICAgICAgICB9IGVsc2UgaWYgKHdpZHRoUmF0aW8gIT0gMSkge1xuICAgICAgICAgIG5ld1NjYWxlID0gdGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSAqIHdpZHRoUmF0aW87XG4gICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0UmF0aW8gIT0gMSkge1xuICAgICAgICAgIG5ld1NjYWxlID0gdGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSAqIGhlaWdodFJhdGlvO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gbmV3U2NhbGU7XG4gICAgICAgIC8vIHRoaXMgY29tZXMgZnJvbSB0aGUgdmlldyBtb2R1bGUuXG4gICAgICAgIHZhciBjdXJyZW50Vmlld0NlbnRlciA9IHRoaXMuRE9NdG9DYW52YXMoe1xuICAgICAgICAgIHg6IDAuNSAqIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoLFxuICAgICAgICAgIHk6IDAuNSAqIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRpc3RhbmNlRnJvbUNlbnRlciA9IHtcbiAgICAgICAgICAvLyBvZmZzZXQgZnJvbSB2aWV3LCBkaXN0YW5jZSB2aWV3IGhhcyB0byBjaGFuZ2UgYnkgdGhlc2UgeCBhbmQgeSB0byBjZW50ZXIgdGhlIG5vZGVcbiAgICAgICAgICB4OiBjdXJyZW50Vmlld0NlbnRlci54IC0gdGhpcy5jYW1lcmFTdGF0ZS5wb3NpdGlvbi54LFxuICAgICAgICAgIHk6IGN1cnJlbnRWaWV3Q2VudGVyLnkgLSB0aGlzLmNhbWVyYVN0YXRlLnBvc2l0aW9uLnlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCArPSBkaXN0YW5jZUZyb21DZW50ZXIueCAqIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55ICs9IGRpc3RhbmNlRnJvbUNlbnRlci55ICogdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9wcmVwYXJlVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ByZXBhcmVWYWx1ZSh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gdmFsdWUgKyBcInB4XCI7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoX2luZGV4T2ZJbnN0YW5jZVByb3BlcnR5KHZhbHVlKS5jYWxsKHZhbHVlLCBcIiVcIikgIT09IC0xIHx8IF9pbmRleE9mSW5zdGFuY2VQcm9wZXJ0eSh2YWx1ZSkuY2FsbCh2YWx1ZSwgXCJweFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoX2luZGV4T2ZJbnN0YW5jZVByb3BlcnR5KHZhbHVlKS5jYWxsKHZhbHVlLCBcIiVcIikgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgdXNlIHRoZSB2YWx1ZSBzdXBwbGllZCBmb3Igd2lkdGggb3IgaGVpZ2h0OlwiICsgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgSFRNTFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcbiAgICAgIC8vIHJlbW92ZSBhbGwgZWxlbWVudHMgZnJvbSB0aGUgY29udGFpbmVyIGVsZW1lbnQuXG4gICAgICB3aGlsZSAodGhpcy5ib2R5LmNvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgdGhpcy5ib2R5LmNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmJvZHkuY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLmZyYW1lLmNsYXNzTmFtZSA9IFwidmlzLW5ldHdvcmtcIjtcbiAgICAgIHRoaXMuZnJhbWUuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICAgIHRoaXMuZnJhbWUudGFiSW5kZXggPSAwOyAvLyB0YWIgaW5kZXggaXMgcmVxdWlyZWQgZm9yIGtleWNoYXJtIHRvIGJpbmQga2V5c3Ryb2tlcyB0byB0aGUgZGl2IGluc3RlYWQgb2YgdGhlIHdpbmRvd1xuXG4gICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgdGhpcy5mcmFtZS5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgdGhpcy5mcmFtZS5jYW52YXMuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuZnJhbWUuY2FudmFzKTtcbiAgICAgIGlmICghdGhpcy5mcmFtZS5jYW52YXMuZ2V0Q29udGV4dCkge1xuICAgICAgICB2YXIgbm9DYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO1xuICAgICAgICBub0NhbnZhcy5zdHlsZS5jb2xvciA9IFwicmVkXCI7XG4gICAgICAgIG5vQ2FudmFzLnN0eWxlLmZvbnRXZWlnaHQgPSBcImJvbGRcIjtcbiAgICAgICAgbm9DYW52YXMuc3R5bGUucGFkZGluZyA9IFwiMTBweFwiO1xuICAgICAgICBub0NhbnZhcy5pbm5lclRleHQgPSBcIkVycm9yOiB5b3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBIVE1MIGNhbnZhc1wiO1xuICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy5hcHBlbmRDaGlsZChub0NhbnZhcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZXRQaXhlbFJhdGlvKCk7XG4gICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCB0aGUgZnJhbWUgdG8gdGhlIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICB0aGlzLmJvZHkuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZnJhbWUpO1xuICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSAxO1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IDAuNSAqIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoLFxuICAgICAgICB5OiAwLjUgKiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHRcbiAgICAgIH07XG4gICAgICB0aGlzLl9iaW5kSGFtbWVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBiaW5kcyBoYW1tZXIsIGl0IGNhbiBiZSByZXBlYXRlZCBvdmVyIGFuZCBvdmVyIGR1ZSB0byB0aGUgdW5pcXVlbmVzcyBjaGVjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2JpbmRIYW1tZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRIYW1tZXIoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIGlmICh0aGlzLmhhbW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaGFtbWVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZHJhZyA9IHt9O1xuICAgICAgdGhpcy5waW5jaCA9IHt9O1xuXG4gICAgICAvLyBpbml0IGhhbW1lclxuICAgICAgdGhpcy5oYW1tZXIgPSBuZXcgSGFtbWVyKHRoaXMuZnJhbWUuY2FudmFzKTtcbiAgICAgIHRoaXMuaGFtbWVyLmdldChcInBpbmNoXCIpLnNldCh7XG4gICAgICAgIGVuYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICAvLyBlbmFibGUgdG8gZ2V0IGJldHRlciByZXNwb25zZSwgdG9kbzogdGVzdCBvbiBtb2JpbGUuXG4gICAgICB0aGlzLmhhbW1lci5nZXQoXCJwYW5cIikuc2V0KHtcbiAgICAgICAgdGhyZXNob2xkOiA1LFxuICAgICAgICBkaXJlY3Rpb246IEhhbW1lci5ESVJFQ1RJT05fQUxMXG4gICAgICB9KTtcbiAgICAgIG9uVG91Y2godGhpcy5oYW1tZXIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vblRvdWNoKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oXCJ0YXBcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uVGFwKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oXCJkb3VibGV0YXBcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRG91YmxlVGFwKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oXCJwcmVzc1wiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Ib2xkKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oXCJwYW5zdGFydFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnU3RhcnQoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcInBhbm1vdmVcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZyhldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwicGFuZW5kXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbkRyYWdFbmQoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcInBpbmNoXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vblBpbmNoKGV2ZW50KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUT0RPOiBuZWF0bHkgY2xlYW51cCB0aGVzZSBoYW5kbGVycyB3aGVuIHJlLWNyZWF0aW5nIHRoZSBDYW52YXMsIElGIHRoZXNlIGFyZSBkb25lIHdpdGggaGFtbWVyLCBldmVudC5zdG9wUHJvcGFnYXRpb24gd2lsbCBub3Qgd29yaz9cbiAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Nb3VzZVdoZWVsKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5mcmFtZS5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Nb3VzZU1vdmUoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmZyYW1lLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uQ29udGV4dChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyRnJhbWUgPSBuZXcgSGFtbWVyKHRoaXMuZnJhbWUpO1xuICAgICAgb25SZWxlYXNlKHRoaXMuaGFtbWVyRnJhbWUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vblJlbGVhc2UoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGEgbmV3IHNpemUgZm9yIHRoZSBuZXR3b3JrXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2lkdGggICBXaWR0aCBpbiBwaXhlbHMgb3IgcGVyY2VudGFnZSAoZm9yIGV4YW1wbGUgJzgwMHB4J1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIG9yICc1MCUnKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZWlnaHQgIEhlaWdodCBpbiBwaXhlbHMgb3IgcGVyY2VudGFnZSAgKGZvciBleGFtcGxlICc0MDBweCdcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBvciAnMzAlJylcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNpemUoKSB7XG4gICAgICB2YXIgd2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMub3B0aW9ucy53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMub3B0aW9ucy5oZWlnaHQ7XG4gICAgICB3aWR0aCA9IHRoaXMuX3ByZXBhcmVWYWx1ZSh3aWR0aCk7XG4gICAgICBoZWlnaHQgPSB0aGlzLl9wcmVwYXJlVmFsdWUoaGVpZ2h0KTtcbiAgICAgIHZhciBlbWl0RXZlbnQgPSBmYWxzZTtcbiAgICAgIHZhciBvbGRXaWR0aCA9IHRoaXMuZnJhbWUuY2FudmFzLndpZHRoO1xuICAgICAgdmFyIG9sZEhlaWdodCA9IHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodDtcblxuICAgICAgLy8gdXBkYXRlIHRoZSBwaXhlbCByYXRpb1xuICAgICAgLy9cbiAgICAgIC8vIE5PVEU6IENvbW1lbnQgaW4gZm9sbG93aW5nIGlzIHJhdGhlciBpbmNvbnNpc3RlbnQ7IHRoaXMgaXMgdGhlIE9OTFkgcGxhY2UgaW4gdGhlIGNvZGVcbiAgICAgIC8vICAgICAgIHdoZXJlIGl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgcGl4ZWwgcmF0aW8gY291bGQgY2hhbmdlIGF0IHJ1bnRpbWUuXG4gICAgICAvLyAgICAgICBUaGUgb25seSB3YXkgSSBjYW4gdGhpbmsgb2YgdGhpcyBoYXBwZW5pbmcgaXMgYSByb3RhdGluZyBzY3JlZW4gb3IgdGFibGV0OyBidXQgdGhlblxuICAgICAgLy8gICAgICAgdGhlcmUgc2hvdWxkIGJlIGEgbWVjaGFuaXNtIGZvciByZWxvYWRpbmcgdGhlIGRhdGEgKFRPRE86IGNoZWNrIGlmIHRoaXMgaXMgcHJlc2VudCkuXG4gICAgICAvL1xuICAgICAgLy8gICAgICAgSWYgdGhlIGFzc3VtcHRpb24gaXMgdHJ1ZSAoaS5lLiBwaXhlbCByYXRpbyBjYW4gY2hhbmdlIGF0IHJ1bnRpbWUpLCB0aGVuICphbGwqIHVzYWdlXG4gICAgICAvLyAgICAgICBvZiBwaXhlbCByYXRpbyBtdXN0IGJlIG92ZXJoYXVsZWQgZm9yIHRoaXMuXG4gICAgICAvL1xuICAgICAgLy8gICAgICAgRm9yIHRoZSB0aW1lIGJlaW5nLCBJIHdpbGwgaHVtb3IgdGhlIGFzc3VtcHRpb24gaGVyZSwgYW5kIGluIHRoZSByZXN0IG9mIHRoZSBjb2RlIGFzc3VtZSBpdCBpc1xuICAgICAgLy8gICAgICAgY29uc3RhbnQuXG4gICAgICB2YXIgcHJldmlvdXNSYXRpbyA9IHRoaXMucGl4ZWxSYXRpbzsgLy8gd2UgY2FjaGUgdGhpcyBiZWNhdXNlIHRoZSBjYW1lcmEgc3RhdGUgc3RvcmFnZSBuZWVkcyB0aGUgb2xkIHZhbHVlXG4gICAgICB0aGlzLl9zZXRQaXhlbFJhdGlvKCk7XG4gICAgICBpZiAod2lkdGggIT0gdGhpcy5vcHRpb25zLndpZHRoIHx8IGhlaWdodCAhPSB0aGlzLm9wdGlvbnMuaGVpZ2h0IHx8IHRoaXMuZnJhbWUuc3R5bGUud2lkdGggIT0gd2lkdGggfHwgdGhpcy5mcmFtZS5zdHlsZS5oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuX2dldENhbWVyYVN0YXRlKHByZXZpb3VzUmF0aW8pO1xuICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuZnJhbWUuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcbiAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMud2lkdGggPSBNYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoICogdGhpcy5waXhlbFJhdGlvKTtcbiAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8pO1xuICAgICAgICB0aGlzLm9wdGlvbnMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5jYW52YXNWaWV3Q2VudGVyID0ge1xuICAgICAgICAgIHg6IDAuNSAqIHRoaXMuZnJhbWUuY2xpZW50V2lkdGgsXG4gICAgICAgICAgeTogMC41ICogdGhpcy5mcmFtZS5jbGllbnRIZWlnaHRcbiAgICAgICAgfTtcbiAgICAgICAgZW1pdEV2ZW50ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoaXMgd291bGQgYWRhcHQgdGhlIHdpZHRoIG9mIHRoZSBjYW52YXMgdG8gdGhlIHdpZHRoIGZyb20gMTAwJSBpZiBhbmQgb25seSBpZlxuICAgICAgICAvLyB0aGVyZSBpcyBhIGNoYW5nZS5cblxuICAgICAgICB2YXIgbmV3V2lkdGggPSBNYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoICogdGhpcy5waXhlbFJhdGlvKTtcbiAgICAgICAgdmFyIG5ld0hlaWdodCA9IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvKTtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgY2FtZXJhIGlmIHRoZXJlIGlzIGEgY2hhbmdlIGluIHNpemUuXG4gICAgICAgIGlmICh0aGlzLmZyYW1lLmNhbnZhcy53aWR0aCAhPT0gbmV3V2lkdGggfHwgdGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0ICE9PSBuZXdIZWlnaHQpIHtcbiAgICAgICAgICB0aGlzLl9nZXRDYW1lcmFTdGF0ZShwcmV2aW91c1JhdGlvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mcmFtZS5jYW52YXMud2lkdGggIT09IG5ld1dpZHRoKSB7XG4gICAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMud2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgICBlbWl0RXZlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgIT09IG5ld0hlaWdodCkge1xuICAgICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgICBlbWl0RXZlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZW1pdEV2ZW50ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJyZXNpemVcIiwge1xuICAgICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLndpZHRoIC8gdGhpcy5waXhlbFJhdGlvKSxcbiAgICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0IC8gdGhpcy5waXhlbFJhdGlvKSxcbiAgICAgICAgICBvbGRXaWR0aDogTWF0aC5yb3VuZChvbGRXaWR0aCAvIHRoaXMucGl4ZWxSYXRpbyksXG4gICAgICAgICAgb2xkSGVpZ2h0OiBNYXRoLnJvdW5kKG9sZEhlaWdodCAvIHRoaXMucGl4ZWxSYXRpbylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcmVzdG9yZSB0aGUgY2FtZXJhIG9uIGNoYW5nZS5cbiAgICAgICAgdGhpcy5fc2V0Q2FtZXJhU3RhdGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IGluaXRpYWxpemVkIHNvIHRoZSBnZXQgYW5kIHNldCBjYW1lcmEgd2lsbCB3b3JrIGZyb20gbm93IG9uLlxuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICByZXR1cm4gZW1pdEV2ZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mcmFtZS5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgcGl4ZWwgcmF0aW8gZm9yIHZhcmlvdXMgYnJvd3NlcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RldGVybWluZVBpeGVsUmF0aW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZVBpeGVsUmF0aW8oKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5nZXRDb250ZXh0KCk7XG4gICAgICBpZiAoY3R4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGdldCBjYW52YXggY29udGV4dFwiKTtcbiAgICAgIH1cbiAgICAgIHZhciBudW1lcmF0b3IgPSAxO1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gKHdpbmRvdyAhPT0gdW5kZWZpbmVkKSBkb2Vzbid0IHdvcmsgaGVyZSFcbiAgICAgICAgLy8gUHJvdGVjdGlvbiBkdXJpbmcgdW5pdCB0ZXN0cywgd2hlcmUgJ3dpbmRvdycgY2FuIGJlIG1pc3NpbmdcbiAgICAgICAgbnVtZXJhdG9yID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgIH1cbiAgICAgIHZhciBkZW5vbWluYXRvciA9IGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG4gICAgICByZXR1cm4gbnVtZXJhdG9yIC8gZGVub21pbmF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGF6eSBkZXRlcm1pbmF0aW9uIG9mIHBpeGVsIHJhdGlvLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfc2V0UGl4ZWxSYXRpb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0UGl4ZWxSYXRpbygpIHtcbiAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IHRoaXMuX2RldGVybWluZVBpeGVsUmF0aW8oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHRyYW5zZm9ybSBpbiB0aGUgY29udGFpbmVkIGNvbnRleHQsIGJhc2VkIG9uIGl0cyBwaXhlbFJhdGlvXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VHJhbnNmb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRyYW5zZm9ybSgpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmdldENvbnRleHQoKTtcbiAgICAgIGlmIChjdHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZ2V0IGNhbnZheCBjb250ZXh0XCIpO1xuICAgICAgfVxuICAgICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgWCBjb29yZGluYXRlIGluIERPTS1zcGFjZSAoY29vcmRpbmF0ZSBwb2ludCBpbiBicm93c2VyIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIgZGl2KSB0b1xuICAgICAqIHRoZSBYIGNvb3JkaW5hdGUgaW4gY2FudmFzLXNwYWNlICh0aGUgc2ltdWxhdGlvbiBzYW5kYm94LCB3aGljaCB0aGUgY2FtZXJhIGxvb2tzIHVwb24pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfWGNvbnZlcnRET010b0NhbnZhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfWGNvbnZlcnRET010b0NhbnZhcyh4KSB7XG4gICAgICByZXR1cm4gKHggLSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54KSAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIFggY29vcmRpbmF0ZSBpbiBjYW52YXMtc3BhY2UgKHRoZSBzaW11bGF0aW9uIHNhbmRib3gsIHdoaWNoIHRoZSBjYW1lcmEgbG9va3MgdXBvbikgdG9cbiAgICAgKiB0aGUgWCBjb29yZGluYXRlIGluIERPTS1zcGFjZSAoY29vcmRpbmF0ZSBwb2ludCBpbiBicm93c2VyIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIgZGl2KVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX1hjb252ZXJ0Q2FudmFzVG9ET01cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX1hjb252ZXJ0Q2FudmFzVG9ET00oeCkge1xuICAgICAgcmV0dXJuIHggKiB0aGlzLmJvZHkudmlldy5zY2FsZSArIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLng7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgWSBjb29yZGluYXRlIGluIERPTS1zcGFjZSAoY29vcmRpbmF0ZSBwb2ludCBpbiBicm93c2VyIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIgZGl2KSB0b1xuICAgICAqIHRoZSBZIGNvb3JkaW5hdGUgaW4gY2FudmFzLXNwYWNlICh0aGUgc2ltdWxhdGlvbiBzYW5kYm94LCB3aGljaCB0aGUgY2FtZXJhIGxvb2tzIHVwb24pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfWWNvbnZlcnRET010b0NhbnZhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfWWNvbnZlcnRET010b0NhbnZhcyh5KSB7XG4gICAgICByZXR1cm4gKHkgLSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55KSAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIFkgY29vcmRpbmF0ZSBpbiBjYW52YXMtc3BhY2UgKHRoZSBzaW11bGF0aW9uIHNhbmRib3gsIHdoaWNoIHRoZSBjYW1lcmEgbG9va3MgdXBvbikgdG9cbiAgICAgKiB0aGUgWSBjb29yZGluYXRlIGluIERPTS1zcGFjZSAoY29vcmRpbmF0ZSBwb2ludCBpbiBicm93c2VyIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIgZGl2KVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX1ljb252ZXJ0Q2FudmFzVG9ET01cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX1ljb252ZXJ0Q2FudmFzVG9ET00oeSkge1xuICAgICAgcmV0dXJuIHkgKiB0aGlzLmJvZHkudmlldy5zY2FsZSArIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtwb2ludH0gcG9zXG4gICAgICogQHJldHVybnMge3BvaW50fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNhbnZhc1RvRE9NXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbnZhc1RvRE9NKHBvcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogdGhpcy5fWGNvbnZlcnRDYW52YXNUb0RPTShwb3MueCksXG4gICAgICAgIHk6IHRoaXMuX1ljb252ZXJ0Q2FudmFzVG9ET00ocG9zLnkpXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtwb2ludH0gcG9zXG4gICAgICogQHJldHVybnMge3BvaW50fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIkRPTXRvQ2FudmFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIERPTXRvQ2FudmFzKHBvcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogdGhpcy5fWGNvbnZlcnRET010b0NhbnZhcyhwb3MueCksXG4gICAgICAgIHk6IHRoaXMuX1ljb252ZXJ0RE9NdG9DYW52YXMocG9zLnkpXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ2FudmFzO1xufSgpO1xuXG4vKipcclxuICogVmFsaWRhdGUgdGhlIGZpdCBvcHRpb25zLCByZXBsYWNlIG1pc3Npbmcgb3B0aW9uYWwgdmFsdWVzIGJ5IGRlZmF1bHRzIGV0Yy5cclxuICpcclxuICogQHBhcmFtIHJhd09wdGlvbnMgLSBUaGUgcmF3IG9wdGlvbnMuXHJcbiAqIEBwYXJhbSBhbGxOb2RlSWRzIC0gQWxsIG5vZGUgaWRzIHRoYXQgd2lsbCBiZSB1c2VkIGlmIG5vZGVzIGFyZSBvbWl0dGVkIGluXHJcbiAqIHRoZSByYXcgb3B0aW9ucy5cclxuICogQHJldHVybnMgT3B0aW9ucyB3aXRoIGV2ZXJ5dGhpbmcgZmlsbGVkIGluIGFuZCB2YWxpZGF0ZWQuXHJcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRml0T3B0aW9ucyhyYXdPcHRpb25zLCBhbGxOb2RlSWRzKSB7XG4gIHZhciBvcHRpb25zID0gX09iamVjdCRhc3NpZ24oe1xuICAgIG5vZGVzOiBhbGxOb2RlSWRzLFxuICAgIG1pblpvb21MZXZlbDogTnVtYmVyLk1JTl9WQUxVRSxcbiAgICBtYXhab29tTGV2ZWw6IDFcbiAgfSwgcmF3T3B0aW9ucyAhPT0gbnVsbCAmJiByYXdPcHRpb25zICE9PSB2b2lkIDAgPyByYXdPcHRpb25zIDoge30pO1xuICBpZiAoIV9BcnJheSRpc0FycmF5KG9wdGlvbnMubm9kZXMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vZGVzIGhhcyB0byBiZSBhbiBhcnJheSBvZiBpZHMuXCIpO1xuICB9XG4gIGlmIChvcHRpb25zLm5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIG9wdGlvbnMubm9kZXMgPSBhbGxOb2RlSWRzO1xuICB9XG4gIGlmICghKHR5cGVvZiBvcHRpb25zLm1pblpvb21MZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBvcHRpb25zLm1pblpvb21MZXZlbCA+IDApKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1pbiB6b29tIGxldmVsIGhhcyB0byBiZSBhIG51bWJlciBoaWdoZXIgdGhhbiB6ZXJvLlwiKTtcbiAgfVxuICBpZiAoISh0eXBlb2Ygb3B0aW9ucy5tYXhab29tTGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgb3B0aW9ucy5taW5ab29tTGV2ZWwgPD0gb3B0aW9ucy5tYXhab29tTGV2ZWwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1heCB6b29tIGxldmVsIGhhcyB0byBiZSBhIG51bWJlciBoaWdoZXIgdGhhbiBtaW4gem9vbSBsZXZlbC5cIik7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8qKlxuICogVGhlIHZpZXdcbiAqL1xudmFyIFZpZXcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICAgKi9cbiAgZnVuY3Rpb24gVmlldyhib2R5LCBjYW52YXMpIHtcbiAgICB2YXIgX2NvbnRleHQsXG4gICAgICBfdGhpcyA9IHRoaXMsXG4gICAgICBfY29udGV4dDI7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZpZXcpO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5hbmltYXRpb25TcGVlZCA9IDEgLyB0aGlzLnJlbmRlclJlZnJlc2hSYXRlO1xuICAgIHRoaXMuYW5pbWF0aW9uRWFzaW5nRnVuY3Rpb24gPSBcImVhc2VJbk91dFF1aW50XCI7XG4gICAgdGhpcy5lYXNpbmdUaW1lID0gMDtcbiAgICB0aGlzLnNvdXJjZVNjYWxlID0gMDtcbiAgICB0aGlzLnRhcmdldFNjYWxlID0gMDtcbiAgICB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uID0gMDtcbiAgICB0aGlzLnRhcmdldFRyYW5zbGF0aW9uID0gMDtcbiAgICB0aGlzLmxvY2tlZE9uTm9kZUlkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubG9ja2VkT25Ob2RlT2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudG91Y2hUaW1lID0gMDtcbiAgICB0aGlzLnZpZXdGdW5jdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImZpdFwiLCBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dCA9IHRoaXMuZml0KS5jYWxsKF9jb250ZXh0LCB0aGlzKSk7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJhbmltYXRpb25GaW5pc2hlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9zdG9wUmVuZGVyaW5nXCIpO1xuICAgIH0pO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwidW5sb2NrTm9kZVwiLCBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDIgPSB0aGlzLnJlbGVhc2VOb2RlKS5jYWxsKF9jb250ZXh0MiwgdGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICovXG4gIF9jcmVhdGVDbGFzcyhWaWV3LCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gem9vbXMgb3V0IHRvIGZpdCBhbGwgZGF0YSBvbiBzY3JlZW4gYmFzZWQgb24gYW1vdW50IG9mIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e3tub2Rlcz1BcnJheX19XVxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdGlhbFpvb209ZmFsc2VdICB8IHpvb20gYmFzZWQgb24gZml0dGVkIGZvcm11bGEgb3IgcmFuZ2UsIHRydWUgPSBmaXR0ZWQsIGRlZmF1bHQgPSBmYWxzZTtcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJmaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZml0KG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbml0aWFsWm9vbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICBvcHRpb25zID0gbm9ybWFsaXplRml0T3B0aW9ucyhvcHRpb25zLCB0aGlzLmJvZHkubm9kZUluZGljZXMpO1xuICAgICAgdmFyIGNhbnZhc1dpZHRoID0gdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgdmFyIGNhbnZhc0hlaWdodCA9IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgICB2YXIgcmFuZ2U7XG4gICAgICB2YXIgem9vbUxldmVsO1xuICAgICAgaWYgKGNhbnZhc1dpZHRoID09PSAwIHx8IGNhbnZhc0hlaWdodCA9PT0gMCkge1xuICAgICAgICAvLyBUaGVyZSdzIG5vIHBvaW50IGluIHRyeWluZyB0byBmaXQgaW50byB6ZXJvIHNpemVkIGNhbnZhcy4gVGhpcyBjb3VsZFxuICAgICAgICAvLyBwb3RlbnRpYWxseSBldmVuIHJlc3VsdCBpbiBpbnZhbGlkIHZhbHVlcyBiZWluZyBjb21wdXRlZC4gRm9yIGV4YW1wbGVcbiAgICAgICAgLy8gZm9yIG5ldHdvcmsgd2l0aG91dCBub2RlcyBhbmQgemVybyBzaXplZCBjYW52YXMgdGhlIHpvb20gbGV2ZWwgd291bGRcbiAgICAgICAgLy8gZW5kIHVwIGJlaW5nIGNvbXB1dGVkIGFzIDAvMCB3aGljaCByZXN1bHRzIGluIE5hTi4gSW4gYW55IG90aGVyIGNhc2VcbiAgICAgICAgLy8gdGhpcyB3b3VsZCBiZSAwL3NvbWV0aGluZyB3aGljaCBpcyBhZ2FpbiBwb2ludGxlc3MgdG8gY29tcHV0ZS5cbiAgICAgICAgem9vbUxldmVsID0gMTtcbiAgICAgICAgcmFuZ2UgPSBOZXR3b3JrVXRpbC5nZXRSYW5nZSh0aGlzLmJvZHkubm9kZXMsIG9wdGlvbnMubm9kZXMpO1xuICAgICAgfSBlbHNlIGlmIChpbml0aWFsWm9vbSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBjaGVjayBpZiBtb3JlIHRoYW4gaGFsZiBvZiB0aGUgbm9kZXMgaGF2ZSBhIHByZWRlZmluZWQgcG9zaXRpb24uIElmIHNvLCB3ZSB1c2UgdGhlIHJhbmdlLCBub3QgdGhlIGFwcHJveGltYXRpb24uXG4gICAgICAgIHZhciBwb3NpdGlvbkRlZmluZWQgPSAwO1xuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkubm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgICBpZiAobm9kZS5wcmVkZWZpbmVkUG9zaXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgcG9zaXRpb25EZWZpbmVkICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbkRlZmluZWQgPiAwLjUgKiB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5maXQob3B0aW9ucywgZmFsc2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByYW5nZSA9IE5ldHdvcmtVdGlsLmdldFJhbmdlKHRoaXMuYm9keS5ub2Rlcywgb3B0aW9ucy5ub2Rlcyk7XG4gICAgICAgIHZhciBudW1iZXJPZk5vZGVzID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgem9vbUxldmVsID0gMTIuNjYyIC8gKG51bWJlck9mTm9kZXMgKyA3LjQxNDcpICsgMC4wOTY0ODIyOyAvLyB0aGlzIGlzIG9idGFpbmVkIGZyb20gZml0dGluZyBhIGRhdGFzZXQgZnJvbSA1IHBvaW50cyB3aXRoIHNjYWxlIGxldmVscyB0aGF0IGxvb2tlZCBnb29kLlxuXG4gICAgICAgIC8vIGNvcnJlY3QgZm9yIGxhcmdlciBjYW52YXNzZXMuXG4gICAgICAgIHZhciBmYWN0b3IgPSBNYXRoLm1pbihjYW52YXNXaWR0aCAvIDYwMCwgY2FudmFzSGVpZ2h0IC8gNjAwKTtcbiAgICAgICAgem9vbUxldmVsICo9IGZhY3RvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVzaXplTm9kZXNcIik7XG4gICAgICAgIHJhbmdlID0gTmV0d29ya1V0aWwuZ2V0UmFuZ2UodGhpcy5ib2R5Lm5vZGVzLCBvcHRpb25zLm5vZGVzKTtcbiAgICAgICAgdmFyIHhEaXN0YW5jZSA9IE1hdGguYWJzKHJhbmdlLm1heFggLSByYW5nZS5taW5YKSAqIDEuMTtcbiAgICAgICAgdmFyIHlEaXN0YW5jZSA9IE1hdGguYWJzKHJhbmdlLm1heFkgLSByYW5nZS5taW5ZKSAqIDEuMTtcbiAgICAgICAgdmFyIHhab29tTGV2ZWwgPSBjYW52YXNXaWR0aCAvIHhEaXN0YW5jZTtcbiAgICAgICAgdmFyIHlab29tTGV2ZWwgPSBjYW52YXNIZWlnaHQgLyB5RGlzdGFuY2U7XG4gICAgICAgIHpvb21MZXZlbCA9IHhab29tTGV2ZWwgPD0geVpvb21MZXZlbCA/IHhab29tTGV2ZWwgOiB5Wm9vbUxldmVsO1xuICAgICAgfVxuICAgICAgaWYgKHpvb21MZXZlbCA+IG9wdGlvbnMubWF4Wm9vbUxldmVsKSB7XG4gICAgICAgIHpvb21MZXZlbCA9IG9wdGlvbnMubWF4Wm9vbUxldmVsO1xuICAgICAgfSBlbHNlIGlmICh6b29tTGV2ZWwgPCBvcHRpb25zLm1pblpvb21MZXZlbCkge1xuICAgICAgICB6b29tTGV2ZWwgPSBvcHRpb25zLm1pblpvb21MZXZlbDtcbiAgICAgIH1cbiAgICAgIHZhciBjZW50ZXIgPSBOZXR3b3JrVXRpbC5maW5kQ2VudGVyKHJhbmdlKTtcbiAgICAgIHZhciBhbmltYXRpb25PcHRpb25zID0ge1xuICAgICAgICBwb3NpdGlvbjogY2VudGVyLFxuICAgICAgICBzY2FsZTogem9vbUxldmVsLFxuICAgICAgICBhbmltYXRpb246IG9wdGlvbnMuYW5pbWF0aW9uXG4gICAgICB9O1xuICAgICAgdGhpcy5tb3ZlVG8oYW5pbWF0aW9uT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gYW5pbWF0aW9uXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXIgYSBub2RlIGluIHZpZXcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbm9kZUlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zXVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImZvY3VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvY3VzKG5vZGVJZCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG5vZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS54LFxuICAgICAgICAgIHk6IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLnlcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucy5wb3NpdGlvbiA9IG5vZGVQb3NpdGlvbjtcbiAgICAgICAgb3B0aW9ucy5sb2NrZWRPbk5vZGUgPSBub2RlSWQ7XG4gICAgICAgIHRoaXMubW92ZVRvKG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk5vZGU6IFwiICsgbm9kZUlkICsgXCIgY2Fubm90IGJlIGZvdW5kLlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICB8ICBvcHRpb25zLm9mZnNldCAgID0ge3g6bnVtYmVyLCB5Om51bWJlcn0gICAvLyBvZmZzZXQgZnJvbSB0aGUgY2VudGVyIGluIERPTSBwaXhlbHNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb3B0aW9ucy5zY2FsZSAgICA9IG51bWJlciAgICAgICAgICAgICAgICAgLy8gc2NhbGUgdG8gbW92ZSB0b1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLnBvc2l0aW9uID0ge3g6bnVtYmVyLCB5Om51bWJlcn0gICAvLyBwb3NpdGlvbiB0byBtb3ZlIHRvXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMuYW5pbWF0aW9uID0ge2R1cmF0aW9uOm51bWJlciwgZWFzaW5nRnVuY3Rpb246U3RyaW5nfSB8fCBCb29sZWFuICAgLy8gcG9zaXRpb24gdG8gbW92ZSB0b1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm1vdmVUb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlVG8ob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLm9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm9mZnNldC54ICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDb2VyY2UgYW5kIHZlcmlmeSB0aGF0IHggaXMgdmFsaWQuXG4gICAgICAgICAgb3B0aW9ucy5vZmZzZXQueCA9ICtvcHRpb25zLm9mZnNldC54O1xuICAgICAgICAgIGlmICghX051bWJlciRpc0Zpbml0ZShvcHRpb25zLm9mZnNldC54KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIG9wdGlvbiBcIm9mZnNldC54XCIgaGFzIHRvIGJlIGEgZmluaXRlIG51bWJlci4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5vZmZzZXQueCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0LnkgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvZXJjZSBhbmQgdmVyaWZ5IHRoYXQgeSBpcyB2YWxpZC5cbiAgICAgICAgICBvcHRpb25zLm9mZnNldC55ID0gK29wdGlvbnMub2Zmc2V0Lnk7XG4gICAgICAgICAgaWYgKCFfTnVtYmVyJGlzRmluaXRlKG9wdGlvbnMub2Zmc2V0LnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgb3B0aW9uIFwib2Zmc2V0LnlcIiBoYXMgdG8gYmUgYSBmaW5pdGUgbnVtYmVyLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLm9mZnNldC54ID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5vZmZzZXQgPSB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uLnggIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvZXJjZSBhbmQgdmVyaWZ5IHRoYXQgeCBpcyB2YWxpZC5cbiAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uLnggPSArb3B0aW9ucy5wb3NpdGlvbi54O1xuICAgICAgICAgIGlmICghX051bWJlciRpc0Zpbml0ZShvcHRpb25zLnBvc2l0aW9uLngpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgb3B0aW9uIFwicG9zaXRpb24ueFwiIGhhcyB0byBiZSBhIGZpbml0ZSBudW1iZXIuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMucG9zaXRpb24ueCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24ueSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29lcmNlIGFuZCB2ZXJpZnkgdGhhdCB5IGlzIHZhbGlkLlxuICAgICAgICAgIG9wdGlvbnMucG9zaXRpb24ueSA9ICtvcHRpb25zLnBvc2l0aW9uLnk7XG4gICAgICAgICAgaWYgKCFfTnVtYmVyJGlzRmluaXRlKG9wdGlvbnMucG9zaXRpb24ueSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBvcHRpb24gXCJwb3NpdGlvbi55XCIgaGFzIHRvIGJlIGEgZmluaXRlIG51bWJlci4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5wb3NpdGlvbi54ID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5wb3NpdGlvbiA9IHRoaXMuZ2V0Vmlld1Bvc2l0aW9uKCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5zY2FsZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIENvZXJjZSBhbmQgdmVyaWZ5IHRoYXQgdGhlIHNjYWxlIGlzIHZhbGlkLlxuICAgICAgICBvcHRpb25zLnNjYWxlID0gK29wdGlvbnMuc2NhbGU7XG4gICAgICAgIGlmICghKG9wdGlvbnMuc2NhbGUgPiAwKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBvcHRpb24gXCJzY2FsZVwiIGhhcyB0byBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gemVyby4nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5zY2FsZSA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb24gPSB7XG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb24gPSB7XG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICBvcHRpb25zLmFuaW1hdGlvbiA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uLmR1cmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb24uZHVyYXRpb24gPSAxMDAwO1xuICAgICAgfSAvLyBkZWZhdWx0IGR1cmF0aW9uXG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24uZWFzaW5nRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmFuaW1hdGlvbi5lYXNpbmdGdW5jdGlvbiA9IFwiZWFzZUluT3V0UXVhZFwiO1xuICAgICAgfSAvLyBkZWZhdWx0IGVhc2luZyBmdW5jdGlvblxuXG4gICAgICB0aGlzLmFuaW1hdGVWaWV3KG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgIHwgIG9wdGlvbnMub2Zmc2V0ICAgPSB7eDpudW1iZXIsIHk6bnVtYmVyfSAgIC8vIG9mZnNldCBmcm9tIHRoZSBjZW50ZXIgaW4gRE9NIHBpeGVsc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLnRpbWUgICAgID0gbnVtYmVyICAgICAgICAgICAgICAgICAvLyBhbmltYXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb3B0aW9ucy5zY2FsZSAgICA9IG51bWJlciAgICAgICAgICAgICAgICAgLy8gc2NhbGUgdG8gYW5pbWF0ZSB0b1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLnBvc2l0aW9uID0ge3g6bnVtYmVyLCB5Om51bWJlcn0gICAvLyBwb3NpdGlvbiB0byBhbmltYXRlIHRvXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMuZWFzaW5nRnVuY3Rpb24gPSBTdHJpbmcgICAgICAgICAgIC8vIGxpbmVhciwgZWFzZUluUXVhZCwgZWFzZU91dFF1YWQsIGVhc2VJbk91dFF1YWQsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVhc2VJbkN1YmljLCBlYXNlT3V0Q3ViaWMsIGVhc2VJbk91dEN1YmljLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlYXNlSW5RdWFydCwgZWFzZU91dFF1YXJ0LCBlYXNlSW5PdXRRdWFydCxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWFzZUluUXVpbnQsIGVhc2VPdXRRdWludCwgZWFzZUluT3V0UXVpbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhbmltYXRlVmlld1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlVmlldyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYW5pbWF0aW9uRWFzaW5nRnVuY3Rpb24gPSBvcHRpb25zLmFuaW1hdGlvbi5lYXNpbmdGdW5jdGlvbjtcbiAgICAgIC8vIHJlbGVhc2UgaWYgc29tZXRoaW5nIGZvY3Vzc2VkIG9uIHRoZSBub2RlXG4gICAgICB0aGlzLnJlbGVhc2VOb2RlKCk7XG4gICAgICBpZiAob3B0aW9ucy5sb2NrZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5sb2NrZWRPbk5vZGVJZCA9IG9wdGlvbnMubG9ja2VkT25Ob2RlO1xuICAgICAgICB0aGlzLmxvY2tlZE9uTm9kZU9mZnNldCA9IG9wdGlvbnMub2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICAvLyBmb3JjZWZ1bGx5IGNvbXBsZXRlIHRoZSBvbGQgYW5pbWF0aW9uIGlmIGl0IHdhcyBzdGlsbCBydW5uaW5nXG4gICAgICBpZiAodGhpcy5lYXNpbmdUaW1lICE9IDApIHtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvblJlZHJhdyh0cnVlKTsgLy8gYnkgc2V0dGluZyBlYXNpbmd0aW1lIHRvIDEsIHdlIGZpbmlzaCB0aGUgYW5pbWF0aW9uLlxuICAgICAgfVxuXG4gICAgICB0aGlzLnNvdXJjZVNjYWxlID0gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uID0gdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb247XG4gICAgICB0aGlzLnRhcmdldFNjYWxlID0gb3B0aW9ucy5zY2FsZTtcblxuICAgICAgLy8gc2V0IHRoZSBzY2FsZSBzbyB0aGUgdmlld0NlbnRlciBpcyBiYXNlZCBvbiB0aGUgY29ycmVjdCB6b29tIGxldmVsLiBUaGlzIGlzIG92ZXJyaWRkZW4gaW4gdGhlIHRyYW5zaXRpb25SZWRyYXdcbiAgICAgIC8vIGJ1dCBhdCBsZWFzdCB0aGVuIHdlJ2xsIGhhdmUgdGhlIHRhcmdldCB0cmFuc2l0aW9uXG4gICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IHRoaXMudGFyZ2V0U2NhbGU7XG4gICAgICB2YXIgdmlld0NlbnRlciA9IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHtcbiAgICAgICAgeDogMC41ICogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoLFxuICAgICAgICB5OiAwLjUgKiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIHZhciBkaXN0YW5jZUZyb21DZW50ZXIgPSB7XG4gICAgICAgIC8vIG9mZnNldCBmcm9tIHZpZXcsIGRpc3RhbmNlIHZpZXcgaGFzIHRvIGNoYW5nZSBieSB0aGVzZSB4IGFuZCB5IHRvIGNlbnRlciB0aGUgbm9kZVxuICAgICAgICB4OiB2aWV3Q2VudGVyLnggLSBvcHRpb25zLnBvc2l0aW9uLngsXG4gICAgICAgIHk6IHZpZXdDZW50ZXIueSAtIG9wdGlvbnMucG9zaXRpb24ueVxuICAgICAgfTtcbiAgICAgIHRoaXMudGFyZ2V0VHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IHRoaXMuc291cmNlVHJhbnNsYXRpb24ueCArIGRpc3RhbmNlRnJvbUNlbnRlci54ICogdGhpcy50YXJnZXRTY2FsZSArIG9wdGlvbnMub2Zmc2V0LngsXG4gICAgICAgIHk6IHRoaXMuc291cmNlVHJhbnNsYXRpb24ueSArIGRpc3RhbmNlRnJvbUNlbnRlci55ICogdGhpcy50YXJnZXRTY2FsZSArIG9wdGlvbnMub2Zmc2V0LnlcbiAgICAgIH07XG5cbiAgICAgIC8vIGlmIHRoZSB0aW1lIGlzIHNldCB0byAwLCBkb24ndCBkbyBhbiBhbmltYXRpb25cbiAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbi5kdXJhdGlvbiA9PT0gMCkge1xuICAgICAgICBpZiAodGhpcy5sb2NrZWRPbk5vZGVJZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQzO1xuICAgICAgICAgIHRoaXMudmlld0Z1bmN0aW9uID0gX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQzID0gdGhpcy5fbG9ja2VkUmVkcmF3KS5jYWxsKF9jb250ZXh0MywgdGhpcyk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJpbml0UmVkcmF3XCIsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IHRoaXMudGFyZ2V0U2NhbGU7XG4gICAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB0aGlzLnRhcmdldFRyYW5zbGF0aW9uO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9jb250ZXh0NDtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TcGVlZCA9IDEgLyAoNjAgKiBvcHRpb25zLmFuaW1hdGlvbi5kdXJhdGlvbiAqIDAuMDAxKSB8fCAxIC8gNjA7IC8vIDYwIGZvciA2MCBzZWNvbmRzLCAwLjAwMSBmb3IgbWlsbGknc1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkVhc2luZ0Z1bmN0aW9uID0gb3B0aW9ucy5hbmltYXRpb24uZWFzaW5nRnVuY3Rpb247XG4gICAgICAgIHRoaXMudmlld0Z1bmN0aW9uID0gX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQ0ID0gdGhpcy5fdHJhbnNpdGlvblJlZHJhdykuY2FsbChfY29udGV4dDQsIHRoaXMpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImluaXRSZWRyYXdcIiwgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0YXJ0UmVuZGVyaW5nXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHVzZWQgdG8gYW5pbWF0ZSBzbW9vdGhseSBieSBoaWphY2tpbmcgdGhlIHJlZHJhdyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2xvY2tlZFJlZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9ja2VkUmVkcmF3KCkge1xuICAgICAgdmFyIG5vZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogdGhpcy5ib2R5Lm5vZGVzW3RoaXMubG9ja2VkT25Ob2RlSWRdLngsXG4gICAgICAgIHk6IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmxvY2tlZE9uTm9kZUlkXS55XG4gICAgICB9O1xuICAgICAgdmFyIHZpZXdDZW50ZXIgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7XG4gICAgICAgIHg6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCxcbiAgICAgICAgeTogMC41ICogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodFxuICAgICAgfSk7XG4gICAgICB2YXIgZGlzdGFuY2VGcm9tQ2VudGVyID0ge1xuICAgICAgICAvLyBvZmZzZXQgZnJvbSB2aWV3LCBkaXN0YW5jZSB2aWV3IGhhcyB0byBjaGFuZ2UgYnkgdGhlc2UgeCBhbmQgeSB0byBjZW50ZXIgdGhlIG5vZGVcbiAgICAgICAgeDogdmlld0NlbnRlci54IC0gbm9kZVBvc2l0aW9uLngsXG4gICAgICAgIHk6IHZpZXdDZW50ZXIueSAtIG5vZGVQb3NpdGlvbi55XG4gICAgICB9O1xuICAgICAgdmFyIHNvdXJjZVRyYW5zbGF0aW9uID0gdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb247XG4gICAgICB2YXIgdGFyZ2V0VHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IHNvdXJjZVRyYW5zbGF0aW9uLnggKyBkaXN0YW5jZUZyb21DZW50ZXIueCAqIHRoaXMuYm9keS52aWV3LnNjYWxlICsgdGhpcy5sb2NrZWRPbk5vZGVPZmZzZXQueCxcbiAgICAgICAgeTogc291cmNlVHJhbnNsYXRpb24ueSArIGRpc3RhbmNlRnJvbUNlbnRlci55ICogdGhpcy5ib2R5LnZpZXcuc2NhbGUgKyB0aGlzLmxvY2tlZE9uTm9kZU9mZnNldC55XG4gICAgICB9O1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB0YXJnZXRUcmFuc2xhdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgc3RhdGUgb2YgYSBsb2NrZWQgb24gTm9kZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlbGVhc2VOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbGVhc2VOb2RlKCkge1xuICAgICAgaWYgKHRoaXMubG9ja2VkT25Ob2RlSWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZpZXdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZihcImluaXRSZWRyYXdcIiwgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICB0aGlzLmxvY2tlZE9uTm9kZUlkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmxvY2tlZE9uTm9kZU9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmaW5pc2hlZD1mYWxzZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl90cmFuc2l0aW9uUmVkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90cmFuc2l0aW9uUmVkcmF3KCkge1xuICAgICAgdmFyIGZpbmlzaGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICAgIHRoaXMuZWFzaW5nVGltZSArPSB0aGlzLmFuaW1hdGlvblNwZWVkO1xuICAgICAgdGhpcy5lYXNpbmdUaW1lID0gZmluaXNoZWQgPT09IHRydWUgPyAxLjAgOiB0aGlzLmVhc2luZ1RpbWU7XG4gICAgICB2YXIgcHJvZ3Jlc3MgPSBlYXNpbmdGdW5jdGlvbnNbdGhpcy5hbmltYXRpb25FYXNpbmdGdW5jdGlvbl0odGhpcy5lYXNpbmdUaW1lKTtcbiAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gdGhpcy5zb3VyY2VTY2FsZSArICh0aGlzLnRhcmdldFNjYWxlIC0gdGhpcy5zb3VyY2VTY2FsZSkgKiBwcm9ncmVzcztcbiAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0ge1xuICAgICAgICB4OiB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnggKyAodGhpcy50YXJnZXRUcmFuc2xhdGlvbi54IC0gdGhpcy5zb3VyY2VUcmFuc2xhdGlvbi54KSAqIHByb2dyZXNzLFxuICAgICAgICB5OiB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnkgKyAodGhpcy50YXJnZXRUcmFuc2xhdGlvbi55IC0gdGhpcy5zb3VyY2VUcmFuc2xhdGlvbi55KSAqIHByb2dyZXNzXG4gICAgICB9O1xuXG4gICAgICAvLyBjbGVhbnVwXG4gICAgICBpZiAodGhpcy5lYXNpbmdUaW1lID49IDEuMCkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vZmYoXCJpbml0UmVkcmF3XCIsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgdGhpcy5lYXNpbmdUaW1lID0gMDtcbiAgICAgICAgaWYgKHRoaXMubG9ja2VkT25Ob2RlSWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0NTtcbiAgICAgICAgICB0aGlzLnZpZXdGdW5jdGlvbiA9IF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0NSA9IHRoaXMuX2xvY2tlZFJlZHJhdykuY2FsbChfY29udGV4dDUsIHRoaXMpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiaW5pdFJlZHJhd1wiLCB0aGlzLnZpZXdGdW5jdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImFuaW1hdGlvbkZpbmlzaGVkXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRTY2FsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTY2FsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFZpZXdQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWV3UG9zaXRpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMoe1xuICAgICAgICB4OiAwLjUgKiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgsXG4gICAgICAgIHk6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHRcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVmlldztcbn0oKTtcblxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgQWxleCBvbiAxMS82LzIwMTQuXHJcbiAqL1xyXG5mdW5jdGlvbiBrZXljaGFybShvcHRpb25zKSB7XHJcbiAgdmFyIHByZXZlbnREZWZhdWx0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnByZXZlbnREZWZhdWx0IHx8IGZhbHNlO1xyXG5cclxuICB2YXIgY29udGFpbmVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbnRhaW5lciB8fCB3aW5kb3c7XHJcblxyXG4gIHZhciBfZXhwb3J0RnVuY3Rpb25zID0ge307XHJcbiAgdmFyIF9ib3VuZCA9IHtrZXlkb3duOnt9LCBrZXl1cDp7fX07XHJcbiAgdmFyIF9rZXlzID0ge307XHJcbiAgdmFyIGk7XHJcblxyXG4gIC8vIGEgLSB6XHJcbiAgZm9yIChpID0gOTc7IGkgPD0gMTIyOyBpKyspIHtfa2V5c1tTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IHtjb2RlOjY1ICsgKGkgLSA5NyksIHNoaWZ0OiBmYWxzZX07fVxyXG4gIC8vIEEgLSBaXHJcbiAgZm9yIChpID0gNjU7IGkgPD0gOTA7IGkrKykge19rZXlzW1N0cmluZy5mcm9tQ2hhckNvZGUoaSldID0ge2NvZGU6aSwgc2hpZnQ6IHRydWV9O31cclxuICAvLyAwIC0gOVxyXG4gIGZvciAoaSA9IDA7ICBpIDw9IDk7ICAgaSsrKSB7X2tleXNbJycgKyBpXSA9IHtjb2RlOjQ4ICsgaSwgc2hpZnQ6IGZhbHNlfTt9XHJcbiAgLy8gRjEgLSBGMTJcclxuICBmb3IgKGkgPSAxOyAgaSA8PSAxMjsgICBpKyspIHtfa2V5c1snRicgKyBpXSA9IHtjb2RlOjExMSArIGksIHNoaWZ0OiBmYWxzZX07fVxyXG4gIC8vIG51bTAgLSBudW05XHJcbiAgZm9yIChpID0gMDsgIGkgPD0gOTsgICBpKyspIHtfa2V5c1snbnVtJyArIGldID0ge2NvZGU6OTYgKyBpLCBzaGlmdDogZmFsc2V9O31cclxuXHJcbiAgLy8gbnVtcGFkIG1pc2NcclxuICBfa2V5c1snbnVtKiddID0ge2NvZGU6MTA2LCBzaGlmdDogZmFsc2V9O1xyXG4gIF9rZXlzWydudW0rJ10gPSB7Y29kZToxMDcsIHNoaWZ0OiBmYWxzZX07XHJcbiAgX2tleXNbJ251bS0nXSA9IHtjb2RlOjEwOSwgc2hpZnQ6IGZhbHNlfTtcclxuICBfa2V5c1snbnVtLyddID0ge2NvZGU6MTExLCBzaGlmdDogZmFsc2V9O1xyXG4gIF9rZXlzWydudW0uJ10gPSB7Y29kZToxMTAsIHNoaWZ0OiBmYWxzZX07XHJcbiAgLy8gYXJyb3dzXHJcbiAgX2tleXNbJ2xlZnQnXSAgPSB7Y29kZTozNywgc2hpZnQ6IGZhbHNlfTtcclxuICBfa2V5c1sndXAnXSAgICA9IHtjb2RlOjM4LCBzaGlmdDogZmFsc2V9O1xyXG4gIF9rZXlzWydyaWdodCddID0ge2NvZGU6MzksIHNoaWZ0OiBmYWxzZX07XHJcbiAgX2tleXNbJ2Rvd24nXSAgPSB7Y29kZTo0MCwgc2hpZnQ6IGZhbHNlfTtcclxuICAvLyBleHRyYSBrZXlzXHJcbiAgX2tleXNbJ3NwYWNlJ10gPSB7Y29kZTozMiwgc2hpZnQ6IGZhbHNlfTtcclxuICBfa2V5c1snZW50ZXInXSA9IHtjb2RlOjEzLCBzaGlmdDogZmFsc2V9O1xyXG4gIF9rZXlzWydzaGlmdCddID0ge2NvZGU6MTYsIHNoaWZ0OiB1bmRlZmluZWR9O1xyXG4gIF9rZXlzWydlc2MnXSAgID0ge2NvZGU6MjcsIHNoaWZ0OiBmYWxzZX07XHJcbiAgX2tleXNbJ2JhY2tzcGFjZSddID0ge2NvZGU6OCwgc2hpZnQ6IGZhbHNlfTtcclxuICBfa2V5c1sndGFiJ10gICAgICAgPSB7Y29kZTo5LCBzaGlmdDogZmFsc2V9O1xyXG4gIF9rZXlzWydjdHJsJ10gICAgICA9IHtjb2RlOjE3LCBzaGlmdDogZmFsc2V9O1xyXG4gIF9rZXlzWydhbHQnXSAgICAgICA9IHtjb2RlOjE4LCBzaGlmdDogZmFsc2V9O1xyXG4gIF9rZXlzWydkZWxldGUnXSAgICA9IHtjb2RlOjQ2LCBzaGlmdDogZmFsc2V9O1xyXG4gIF9rZXlzWydwYWdldXAnXSAgICA9IHtjb2RlOjMzLCBzaGlmdDogZmFsc2V9O1xyXG4gIF9rZXlzWydwYWdlZG93biddICA9IHtjb2RlOjM0LCBzaGlmdDogZmFsc2V9O1xyXG4gIC8vIHN5bWJvbHNcclxuICBfa2V5c1snPSddICAgICA9IHtjb2RlOjE4Nywgc2hpZnQ6IGZhbHNlfTtcclxuICBfa2V5c1snLSddICAgICA9IHtjb2RlOjE4OSwgc2hpZnQ6IGZhbHNlfTtcclxuICBfa2V5c1snXSddICAgICA9IHtjb2RlOjIyMSwgc2hpZnQ6IGZhbHNlfTtcclxuICBfa2V5c1snWyddICAgICA9IHtjb2RlOjIxOSwgc2hpZnQ6IGZhbHNlfTtcclxuXHJcblxyXG5cclxuICB2YXIgZG93biA9IGZ1bmN0aW9uKGV2ZW50KSB7aGFuZGxlRXZlbnQoZXZlbnQsJ2tleWRvd24nKTt9O1xyXG4gIHZhciB1cCA9IGZ1bmN0aW9uKGV2ZW50KSB7aGFuZGxlRXZlbnQoZXZlbnQsJ2tleXVwJyk7fTtcclxuXHJcbiAgLy8gaGFuZGxlIHRoZSBhY3R1YWx5IGJvdW5kIGtleSB3aXRoIHRoZSBldmVudFxyXG4gIHZhciBoYW5kbGVFdmVudCA9IGZ1bmN0aW9uKGV2ZW50LHR5cGUpIHtcclxuICAgIGlmIChfYm91bmRbdHlwZV1bZXZlbnQua2V5Q29kZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB2YXIgYm91bmQgPSBfYm91bmRbdHlwZV1bZXZlbnQua2V5Q29kZV07XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoYm91bmRbaV0uc2hpZnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgYm91bmRbaV0uZm4oZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChib3VuZFtpXS5zaGlmdCA9PSB0cnVlICYmIGV2ZW50LnNoaWZ0S2V5ID09IHRydWUpIHtcclxuICAgICAgICAgIGJvdW5kW2ldLmZuKGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYm91bmRbaV0uc2hpZnQgPT0gZmFsc2UgJiYgZXZlbnQuc2hpZnRLZXkgPT0gZmFsc2UpIHtcclxuICAgICAgICAgIGJvdW5kW2ldLmZuKGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCA9PSB0cnVlKSB7XHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIGJpbmQgYSBrZXkgdG8gYSBjYWxsYmFja1xyXG4gIF9leHBvcnRGdW5jdGlvbnMuYmluZCA9IGZ1bmN0aW9uKGtleSwgY2FsbGJhY2ssIHR5cGUpIHtcclxuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdHlwZSA9ICdrZXlkb3duJztcclxuICAgIH1cclxuICAgIGlmIChfa2V5c1trZXldID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQga2V5OiBcIiArIGtleSk7XHJcbiAgICB9XHJcbiAgICBpZiAoX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXSA9IFtdO1xyXG4gICAgfVxyXG4gICAgX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV0ucHVzaCh7Zm46Y2FsbGJhY2ssIHNoaWZ0Ol9rZXlzW2tleV0uc2hpZnR9KTtcclxuICB9O1xyXG5cclxuXHJcbiAgLy8gYmluZCBhbGwga2V5cyB0byBhIGNhbGwgYmFjayAoZGVtbyBwdXJwb3NlcylcclxuICBfZXhwb3J0RnVuY3Rpb25zLmJpbmRBbGwgPSBmdW5jdGlvbihjYWxsYmFjaywgdHlwZSkge1xyXG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0eXBlID0gJ2tleWRvd24nO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIga2V5IGluIF9rZXlzKSB7XHJcbiAgICAgIGlmIChfa2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgX2V4cG9ydEZ1bmN0aW9ucy5iaW5kKGtleSxjYWxsYmFjayx0eXBlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIGdldCB0aGUga2V5IGxhYmVsIGZyb20gYW4gZXZlbnRcclxuICBfZXhwb3J0RnVuY3Rpb25zLmdldEtleSA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gX2tleXMpIHtcclxuICAgICAgaWYgKF9rZXlzLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkgPT0gdHJ1ZSAmJiBfa2V5c1trZXldLnNoaWZ0ID09IHRydWUgJiYgZXZlbnQua2V5Q29kZSA9PSBfa2V5c1trZXldLmNvZGUpIHtcclxuICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LnNoaWZ0S2V5ID09IGZhbHNlICYmIF9rZXlzW2tleV0uc2hpZnQgPT0gZmFsc2UgJiYgZXZlbnQua2V5Q29kZSA9PSBfa2V5c1trZXldLmNvZGUpIHtcclxuICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gX2tleXNba2V5XS5jb2RlICYmIGtleSA9PSAnc2hpZnQnKSB7XHJcbiAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwidW5rbm93biBrZXksIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkXCI7XHJcbiAgfTtcclxuXHJcbiAgLy8gdW5iaW5kIGVpdGhlciBhIHNwZWNpZmljIGNhbGxiYWNrIGZyb20gYSBrZXkgb3IgYWxsIG9mIHRoZW0gKGJ5IGxlYXZpbmcgY2FsbGJhY2sgdW5kZWZpbmVkKVxyXG4gIF9leHBvcnRGdW5jdGlvbnMudW5iaW5kID0gZnVuY3Rpb24oa2V5LCBjYWxsYmFjaywgdHlwZSkge1xyXG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0eXBlID0gJ2tleWRvd24nO1xyXG4gICAgfVxyXG4gICAgaWYgKF9rZXlzW2tleV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBrZXk6IFwiICsga2V5KTtcclxuICAgIH1cclxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHZhciBuZXdCaW5kaW5ncyA9IFtdO1xyXG4gICAgICB2YXIgYm91bmQgPSBfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXTtcclxuICAgICAgaWYgKGJvdW5kICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAoIShib3VuZFtpXS5mbiA9PSBjYWxsYmFjayAmJiBib3VuZFtpXS5zaGlmdCA9PSBfa2V5c1trZXldLnNoaWZ0KSkge1xyXG4gICAgICAgICAgICBuZXdCaW5kaW5ncy5wdXNoKF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdW2ldKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV0gPSBuZXdCaW5kaW5ncztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXSA9IFtdO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIHJlc2V0IGFsbCBib3VuZCB2YXJpYWJsZXMuXHJcbiAgX2V4cG9ydEZ1bmN0aW9ucy5yZXNldCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX2JvdW5kID0ge2tleWRvd246e30sIGtleXVwOnt9fTtcclxuICB9O1xyXG5cclxuICAvLyB1bmJpbmQgYWxsIGxpc3RlbmVycyBhbmQgcmVzZXQgYWxsIHZhcmlhYmxlcy5cclxuICBfZXhwb3J0RnVuY3Rpb25zLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcclxuICAgIF9ib3VuZCA9IHtrZXlkb3duOnt9LCBrZXl1cDp7fX07XHJcbiAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGRvd24sIHRydWUpO1xyXG4gICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdXAsIHRydWUpO1xyXG4gIH07XHJcblxyXG4gIC8vIGNyZWF0ZSBsaXN0ZW5lcnMuXHJcbiAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLGRvd24sdHJ1ZSk7XHJcbiAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJyx1cCx0cnVlKTtcclxuXHJcbiAgLy8gcmV0dXJuIHRoZSBwdWJsaWMgZnVuY3Rpb25zLlxyXG4gIHJldHVybiBfZXhwb3J0RnVuY3Rpb25zO1xyXG59XG5cbi8qKlxuICogTmF2aWdhdGlvbiBIYW5kbGVyXG4gKi9cbnZhciBOYXZpZ2F0aW9uSGFuZGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gICAqL1xuICBmdW5jdGlvbiBOYXZpZ2F0aW9uSGFuZGxlcihib2R5LCBjYW52YXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOYXZpZ2F0aW9uSGFuZGxlcik7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLmljb25zQ3JlYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMubmF2aWdhdGlvbkhhbW1lcnMgPSBbXTtcbiAgICB0aGlzLmJvdW5kRnVuY3Rpb25zID0ge307XG4gICAgdGhpcy50b3VjaFRpbWUgPSAwO1xuICAgIHRoaXMuYWN0aXZhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJhY3RpdmF0ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5hY3RpdmF0ZWQgPSB0cnVlO1xuICAgICAgX3RoaXMuY29uZmlndXJlS2V5Ym9hcmRCaW5kaW5ncygpO1xuICAgIH0pO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVhY3RpdmF0ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5hY3RpdmF0ZWQgPSBmYWxzZTtcbiAgICAgIF90aGlzLmNvbmZpZ3VyZUtleWJvYXJkQmluZGluZ3MoKTtcbiAgICB9KTtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLmtleWNoYXJtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX3RoaXMua2V5Y2hhcm0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoTmF2aWdhdGlvbkhhbmRsZXIsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY3JlYXRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBvciByZWZyZXNoZXMgbmF2aWdhdGlvbiBhbmQgc2V0cyBrZXkgYmluZGluZ3NcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5uYXZpZ2F0aW9uQnV0dG9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5pY29uc0NyZWF0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5sb2FkTmF2aWdhdGlvbkVsZW1lbnRzKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pY29uc0NyZWF0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5jbGVhbk5hdmlnYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29uZmlndXJlS2V5Ym9hcmRCaW5kaW5ncygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFucyB1cCBwcmV2aW91cyBuYXZpZ2F0aW9uIGl0ZW1zXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYW5OYXZpZ2F0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFuTmF2aWdhdGlvbigpIHtcbiAgICAgIC8vIGNsZWFuIGhhbW1lciBiaW5kaW5nc1xuICAgICAgaWYgKHRoaXMubmF2aWdhdGlvbkhhbW1lcnMubGVuZ3RoICE9IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5hdmlnYXRpb25IYW1tZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uSGFtbWVyc1tpXS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uSGFtbWVycyA9IFtdO1xuICAgICAgfVxuXG4gICAgICAvLyBjbGVhbiB1cCBwcmV2aW91cyBuYXZpZ2F0aW9uIGl0ZW1zXG4gICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uRE9NICYmIHRoaXMubmF2aWdhdGlvbkRPTVtcIndyYXBwZXJcIl0gJiYgdGhpcy5uYXZpZ2F0aW9uRE9NW1wid3JhcHBlclwiXS5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkRPTVtcIndyYXBwZXJcIl0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5hdmlnYXRpb25ET01bXCJ3cmFwcGVyXCJdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaWNvbnNDcmVhdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRpb24gb2YgdGhlIG5hdmlnYXRpb24gY29udHJvbHMgbm9kZXMuIFRoZXkgYXJlIGRyYXduIG92ZXIgdGhlIHJlc3Qgb2YgdGhlIG5vZGVzIGFuZCBhcmUgbm90IGFmZmVjdGVkIGJ5IHNjYWxlIGFuZCB0cmFuc2xhdGlvblxuICAgICAqIHRoZXkgaGF2ZSBhIHRyaWdnZXJGdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgb24gY2xpY2suIElmIHRoZSBwb3NpdGlvbiBvZiB0aGUgbmF2aWdhdGlvbiBjb250cm9scyBpcyBkZXBlbmRlbnRcbiAgICAgKiBvbiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCBvciB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQsIHdlIGZsYWcgaG9yaXpvbnRhbEFsaWduTGVmdCBhbmQgdmVydGljYWxBbGlnblRvcCBmYWxzZS5cbiAgICAgKiBUaGlzIG1lYW5zIHRoYXQgdGhlIGxvY2F0aW9uIHdpbGwgYmUgY29ycmVjdGVkIGJ5IHRoZSBfcmVsb2NhdGVOYXZpZ2F0aW9uIGZ1bmN0aW9uIG9uIGEgc2l6ZSBjaGFuZ2Ugb2YgdGhlIGNhbnZhcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZE5hdmlnYXRpb25FbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkTmF2aWdhdGlvbkVsZW1lbnRzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB0aGlzLmNsZWFuTmF2aWdhdGlvbigpO1xuICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NID0ge307XG4gICAgICB2YXIgbmF2aWdhdGlvbkRpdnMgPSBbXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJ6b29tSW5cIiwgXCJ6b29tT3V0XCIsIFwiem9vbUV4dGVuZHNcIl07XG4gICAgICB2YXIgbmF2aWdhdGlvbkRpdkFjdGlvbnMgPSBbXCJfbW92ZVVwXCIsIFwiX21vdmVEb3duXCIsIFwiX21vdmVMZWZ0XCIsIFwiX21vdmVSaWdodFwiLCBcIl96b29tSW5cIiwgXCJfem9vbU91dFwiLCBcIl9maXRcIl07XG4gICAgICB0aGlzLm5hdmlnYXRpb25ET01bXCJ3cmFwcGVyXCJdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMubmF2aWdhdGlvbkRPTVtcIndyYXBwZXJcIl0uY2xhc3NOYW1lID0gXCJ2aXMtbmF2aWdhdGlvblwiO1xuICAgICAgdGhpcy5jYW52YXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5uYXZpZ2F0aW9uRE9NW1wid3JhcHBlclwiXSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hdmlnYXRpb25EaXZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkRPTVtuYXZpZ2F0aW9uRGl2c1tpXV0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25ET01bbmF2aWdhdGlvbkRpdnNbaV1dLmNsYXNzTmFtZSA9IFwidmlzLWJ1dHRvbiB2aXMtXCIgKyBuYXZpZ2F0aW9uRGl2c1tpXTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NW1wid3JhcHBlclwiXS5hcHBlbmRDaGlsZCh0aGlzLm5hdmlnYXRpb25ET01bbmF2aWdhdGlvbkRpdnNbaV1dKTtcbiAgICAgICAgdmFyIGhhbW1lciA9IG5ldyBIYW1tZXIodGhpcy5uYXZpZ2F0aW9uRE9NW25hdmlnYXRpb25EaXZzW2ldXSk7XG4gICAgICAgIGlmIChuYXZpZ2F0aW9uRGl2QWN0aW9uc1tpXSA9PT0gXCJfZml0XCIpIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQ7XG4gICAgICAgICAgb25Ub3VjaChoYW1tZXIsIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0ID0gdGhpcy5fZml0KS5jYWxsKF9jb250ZXh0LCB0aGlzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0MjtcbiAgICAgICAgICBvblRvdWNoKGhhbW1lciwgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQyID0gdGhpcy5iaW5kVG9SZWRyYXcpLmNhbGwoX2NvbnRleHQyLCB0aGlzLCBuYXZpZ2F0aW9uRGl2QWN0aW9uc1tpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkhhbW1lcnMucHVzaChoYW1tZXIpO1xuICAgICAgfVxuXG4gICAgICAvLyB1c2UgYSBoYW1tZXIgZm9yIHRoZSByZWxlYXNlIHNvIHdlIGRvIG5vdCByZXF1aXJlIHRoZSBvbmUgdXNlZCBpbiB0aGUgcmVzdCBvZiB0aGUgbmV0d29ya1xuICAgICAgLy8gdGhlIG9uZSB0aGUgcmVzdCB1c2VzIGNhbiBiZSBvdmVybG9hZGVkIGJ5IHRoZSBtYW5pcHVsYXRpb24gc3lzdGVtLlxuICAgICAgdmFyIGhhbW1lckZyYW1lID0gbmV3IEhhbW1lcih0aGlzLmNhbnZhcy5mcmFtZSk7XG4gICAgICBvblJlbGVhc2UoaGFtbWVyRnJhbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLl9zdG9wTW92ZW1lbnQoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5uYXZpZ2F0aW9uSGFtbWVycy5wdXNoKGhhbW1lckZyYW1lKTtcbiAgICAgIHRoaXMuaWNvbnNDcmVhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJiaW5kVG9SZWRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZFRvUmVkcmF3KGFjdGlvbikge1xuICAgICAgaWYgKHRoaXMuYm91bmRGdW5jdGlvbnNbYWN0aW9uXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBfY29udGV4dDM7XG4gICAgICAgIHRoaXMuYm91bmRGdW5jdGlvbnNbYWN0aW9uXSA9IF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MyA9IHRoaXNbYWN0aW9uXSkuY2FsbChfY29udGV4dDMsIHRoaXMpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImluaXRSZWRyYXdcIiwgdGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9zdGFydFJlbmRlcmluZ1wiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1bmJpbmRGcm9tUmVkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuYmluZEZyb21SZWRyYXcoYWN0aW9uKSB7XG4gICAgICBpZiAodGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKFwiaW5pdFJlZHJhd1wiLCB0aGlzLmJvdW5kRnVuY3Rpb25zW2FjdGlvbl0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0b3BSZW5kZXJpbmdcIik7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmJvdW5kRnVuY3Rpb25zW2FjdGlvbl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhpcyBzdG9wcyBhbGwgbW92ZW1lbnQgaW5kdWNlZCBieSB0aGUgbmF2aWdhdGlvbiBidXR0b25zXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9maXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpdCgpIHtcbiAgICAgIGlmIChuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHRoaXMudG91Y2hUaW1lID4gNzAwKSB7XG4gICAgICAgIC8vIFRPRE86IGZpeCB1Z2x5IGhhY2sgdG8gYXZvaWQgaGFtbWVyJ3MgZG91YmxlIGZpcmVpbmcgb2YgZXZlbnQgKGJlY2F1c2Ugd2UgdXNlIHJlbGVhc2U/KVxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiZml0XCIsIHtcbiAgICAgICAgICBkdXJhdGlvbjogNzAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvdWNoVGltZSA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRoaXMgc3RvcHMgYWxsIG1vdmVtZW50IGluZHVjZWQgYnkgdGhlIG5hdmlnYXRpb24gYnV0dG9uc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfc3RvcE1vdmVtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdG9wTW92ZW1lbnQoKSB7XG4gICAgICBmb3IgKHZhciBib3VuZEFjdGlvbiBpbiB0aGlzLmJvdW5kRnVuY3Rpb25zKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib3VuZEZ1bmN0aW9ucywgYm91bmRBY3Rpb24pKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKFwiaW5pdFJlZHJhd1wiLCB0aGlzLmJvdW5kRnVuY3Rpb25zW2JvdW5kQWN0aW9uXSk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9zdG9wUmVuZGVyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmJvdW5kRnVuY3Rpb25zID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfbW92ZVVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlVXAoKSB7XG4gICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55ICs9IHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC55O1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX21vdmVEb3duXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlRG93bigpIHtcbiAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkgLT0gdGhpcy5vcHRpb25zLmtleWJvYXJkLnNwZWVkLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfbW92ZUxlZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVMZWZ0KCkge1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCArPSB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQueDtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9tb3ZlUmlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVSaWdodCgpIHtcbiAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnggLT0gdGhpcy5vcHRpb25zLmtleWJvYXJkLnNwZWVkLng7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfem9vbUluXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF96b29tSW4oKSB7XG4gICAgICB2YXIgc2NhbGVPbGQgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIHZhciBzY2FsZSA9IHRoaXMuYm9keS52aWV3LnNjYWxlICogKDEgKyB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQuem9vbSk7XG4gICAgICB2YXIgdHJhbnNsYXRpb24gPSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbjtcbiAgICAgIHZhciBzY2FsZUZyYWMgPSBzY2FsZSAvIHNjYWxlT2xkO1xuICAgICAgdmFyIHR4ID0gKDEgLSBzY2FsZUZyYWMpICogdGhpcy5jYW52YXMuY2FudmFzVmlld0NlbnRlci54ICsgdHJhbnNsYXRpb24ueCAqIHNjYWxlRnJhYztcbiAgICAgIHZhciB0eSA9ICgxIC0gc2NhbGVGcmFjKSAqIHRoaXMuY2FudmFzLmNhbnZhc1ZpZXdDZW50ZXIueSArIHRyYW5zbGF0aW9uLnkgKiBzY2FsZUZyYWM7XG4gICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IHNjYWxlO1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IHR4LFxuICAgICAgICB5OiB0eVxuICAgICAgfTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJ6b29tXCIsIHtcbiAgICAgICAgZGlyZWN0aW9uOiBcIitcIixcbiAgICAgICAgc2NhbGU6IHRoaXMuYm9keS52aWV3LnNjYWxlLFxuICAgICAgICBwb2ludGVyOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3pvb21PdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3pvb21PdXQoKSB7XG4gICAgICB2YXIgc2NhbGVPbGQgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIHZhciBzY2FsZSA9IHRoaXMuYm9keS52aWV3LnNjYWxlIC8gKDEgKyB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQuem9vbSk7XG4gICAgICB2YXIgdHJhbnNsYXRpb24gPSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbjtcbiAgICAgIHZhciBzY2FsZUZyYWMgPSBzY2FsZSAvIHNjYWxlT2xkO1xuICAgICAgdmFyIHR4ID0gKDEgLSBzY2FsZUZyYWMpICogdGhpcy5jYW52YXMuY2FudmFzVmlld0NlbnRlci54ICsgdHJhbnNsYXRpb24ueCAqIHNjYWxlRnJhYztcbiAgICAgIHZhciB0eSA9ICgxIC0gc2NhbGVGcmFjKSAqIHRoaXMuY2FudmFzLmNhbnZhc1ZpZXdDZW50ZXIueSArIHRyYW5zbGF0aW9uLnkgKiBzY2FsZUZyYWM7XG4gICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IHNjYWxlO1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IHR4LFxuICAgICAgICB5OiB0eVxuICAgICAgfTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJ6b29tXCIsIHtcbiAgICAgICAgZGlyZWN0aW9uOiBcIi1cIixcbiAgICAgICAgc2NhbGU6IHRoaXMuYm9keS52aWV3LnNjYWxlLFxuICAgICAgICBwb2ludGVyOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBiaW5kIGFsbCBrZXlzIHVzaW5nIGtleWNoYXJtLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNvbmZpZ3VyZUtleWJvYXJkQmluZGluZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uZmlndXJlS2V5Ym9hcmRCaW5kaW5ncygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMua2V5Y2hhcm0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmtleWNoYXJtLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMua2V5Ym9hcmQuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmtleWJvYXJkLmJpbmRUb1dpbmRvdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMua2V5Y2hhcm0gPSBrZXljaGFybSh7XG4gICAgICAgICAgICBjb250YWluZXI6IHdpbmRvdyxcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5rZXljaGFybSA9IGtleWNoYXJtKHtcbiAgICAgICAgICAgIGNvbnRhaW5lcjogdGhpcy5jYW52YXMuZnJhbWUsXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMua2V5Y2hhcm0ucmVzZXQoKTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZhdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0NCwgX2NvbnRleHQ1LCBfY29udGV4dDYsIF9jb250ZXh0NywgX2NvbnRleHQ4LCBfY29udGV4dDksIF9jb250ZXh0MTAsIF9jb250ZXh0MTEsIF9jb250ZXh0MTIsIF9jb250ZXh0MTMsIF9jb250ZXh0MTQsIF9jb250ZXh0MTUsIF9jb250ZXh0MTYsIF9jb250ZXh0MTcsIF9jb250ZXh0MTgsIF9jb250ZXh0MTksIF9jb250ZXh0MjAsIF9jb250ZXh0MjEsIF9jb250ZXh0MjIsIF9jb250ZXh0MjMsIF9jb250ZXh0MjQsIF9jb250ZXh0MjUsIF9jb250ZXh0MjYsIF9jb250ZXh0Mjc7XG4gICAgICAgICAgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQ0ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDQsIFwidXBcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl9tb3ZlVXBcIik7XG4gICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuICAgICAgICAgIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0NSA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQ1LCBcImRvd25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl9tb3ZlRG93blwiKTtcbiAgICAgICAgICB9LCBcImtleWRvd25cIik7XG4gICAgICAgICAgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQ2ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDYsIFwibGVmdFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX21vdmVMZWZ0XCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcbiAgICAgICAgICBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDcgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0NywgXCJyaWdodFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX21vdmVSaWdodFwiKTtcbiAgICAgICAgICB9LCBcImtleWRvd25cIik7XG4gICAgICAgICAgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQ4ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDgsIFwiPVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX3pvb21JblwiKTtcbiAgICAgICAgICB9LCBcImtleWRvd25cIik7XG4gICAgICAgICAgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQ5ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDksIFwibnVtK1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX3pvb21JblwiKTtcbiAgICAgICAgICB9LCBcImtleWRvd25cIik7XG4gICAgICAgICAgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQxMCA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQxMCwgXCJudW0tXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbU91dFwiKTtcbiAgICAgICAgICB9LCBcImtleWRvd25cIik7XG4gICAgICAgICAgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQxMSA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQxMSwgXCItXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbU91dFwiKTtcbiAgICAgICAgICB9LCBcImtleWRvd25cIik7XG4gICAgICAgICAgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQxMiA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQxMiwgXCJbXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbU91dFwiKTtcbiAgICAgICAgICB9LCBcImtleWRvd25cIik7XG4gICAgICAgICAgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQxMyA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQxMywgXCJdXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcbiAgICAgICAgICBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDE0ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDE0LCBcInBhZ2V1cFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX3pvb21JblwiKTtcbiAgICAgICAgICB9LCBcImtleWRvd25cIik7XG4gICAgICAgICAgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQxNSA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQxNSwgXCJwYWdlZG93blwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX3pvb21PdXRcIik7XG4gICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuICAgICAgICAgIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MTYgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MTYsIFwidXBcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfbW92ZVVwXCIpO1xuICAgICAgICAgIH0sIFwia2V5dXBcIik7XG4gICAgICAgICAgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQxNyA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQxNywgXCJkb3duXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX21vdmVEb3duXCIpO1xuICAgICAgICAgIH0sIFwia2V5dXBcIik7XG4gICAgICAgICAgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQxOCA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQxOCwgXCJsZWZ0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX21vdmVMZWZ0XCIpO1xuICAgICAgICAgIH0sIFwia2V5dXBcIik7XG4gICAgICAgICAgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQxOSA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQxOSwgXCJyaWdodFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl9tb3ZlUmlnaHRcIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcbiAgICAgICAgICBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDIwID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDIwLCBcIj1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgIH0sIFwia2V5dXBcIik7XG4gICAgICAgICAgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQyMSA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQyMSwgXCJudW0rXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21JblwiKTtcbiAgICAgICAgICB9LCBcImtleXVwXCIpO1xuICAgICAgICAgIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MjIgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MjIsIFwibnVtLVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgIH0sIFwia2V5dXBcIik7XG4gICAgICAgICAgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQyMyA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQyMywgXCItXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21PdXRcIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcbiAgICAgICAgICBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDI0ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDI0LCBcIltcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbU91dFwiKTtcbiAgICAgICAgICB9LCBcImtleXVwXCIpO1xuICAgICAgICAgIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MjUgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MjUsIFwiXVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tSW5cIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcbiAgICAgICAgICBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDI2ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDI2LCBcInBhZ2V1cFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tSW5cIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcbiAgICAgICAgICBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDI3ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDI3LCBcInBhZ2Vkb3duXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21PdXRcIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTmF2aWdhdGlvbkhhbmRsZXI7XG59KCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDQobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIF9TeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgX2dldEl0ZXJhdG9yTWV0aG9kKG8pIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChfQXJyYXkkaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNChvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNChvLCBtaW5MZW4pIHsgdmFyIF9jb250ZXh0MTU7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ0KG8sIG1pbkxlbik7IHZhciBuID0gX3NsaWNlSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDE1ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pKS5jYWxsKF9jb250ZXh0MTUsIDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIF9BcnJheSRmcm9tJDEobyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNChvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQ0KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG5cbi8qKlxuICogSGFuZGxlciBmb3IgaW50ZXJhY3Rpb25zXG4gKi9cbnZhciBJbnRlcmFjdGlvbkhhbmRsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICAgKiBAcGFyYW0ge1NlbGVjdGlvbkhhbmRsZXJ9IHNlbGVjdGlvbkhhbmRsZXJcbiAgICovXG4gIGZ1bmN0aW9uIEludGVyYWN0aW9uSGFuZGxlcihib2R5LCBjYW52YXMsIHNlbGVjdGlvbkhhbmRsZXIpIHtcbiAgICB2YXIgX2NvbnRleHQsIF9jb250ZXh0MiwgX2NvbnRleHQzLCBfY29udGV4dDQsIF9jb250ZXh0NSwgX2NvbnRleHQ2LCBfY29udGV4dDcsIF9jb250ZXh0OCwgX2NvbnRleHQ5LCBfY29udGV4dDEwLCBfY29udGV4dDExLCBfY29udGV4dDEyLCBfY29udGV4dDEzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnRlcmFjdGlvbkhhbmRsZXIpO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyID0gc2VsZWN0aW9uSGFuZGxlcjtcbiAgICB0aGlzLm5hdmlnYXRpb25IYW5kbGVyID0gbmV3IE5hdmlnYXRpb25IYW5kbGVyKGJvZHksIGNhbnZhcyk7XG5cbiAgICAvLyBiaW5kIHRoZSBldmVudHMgZnJvbSBoYW1tZXIgdG8gZnVuY3Rpb25zIGluIHRoaXMgb2JqZWN0XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uVGFwID0gX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQgPSB0aGlzLm9uVGFwKS5jYWxsKF9jb250ZXh0LCB0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Ub3VjaCA9IF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MiA9IHRoaXMub25Ub3VjaCkuY2FsbChfY29udGV4dDIsIHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbkRvdWJsZVRhcCA9IF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MyA9IHRoaXMub25Eb3VibGVUYXApLmNhbGwoX2NvbnRleHQzLCB0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Ib2xkID0gX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQ0ID0gdGhpcy5vbkhvbGQpLmNhbGwoX2NvbnRleHQ0LCB0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnU3RhcnQgPSBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDUgPSB0aGlzLm9uRHJhZ1N0YXJ0KS5jYWxsKF9jb250ZXh0NSwgdGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZyA9IF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0NiA9IHRoaXMub25EcmFnKS5jYWxsKF9jb250ZXh0NiwgdGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZ0VuZCA9IF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0NyA9IHRoaXMub25EcmFnRW5kKS5jYWxsKF9jb250ZXh0NywgdGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uTW91c2VXaGVlbCA9IF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0OCA9IHRoaXMub25Nb3VzZVdoZWVsKS5jYWxsKF9jb250ZXh0OCwgdGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uUGluY2ggPSBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDkgPSB0aGlzLm9uUGluY2gpLmNhbGwoX2NvbnRleHQ5LCB0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Nb3VzZU1vdmUgPSBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDEwID0gdGhpcy5vbk1vdXNlTW92ZSkuY2FsbChfY29udGV4dDEwLCB0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25SZWxlYXNlID0gX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQxMSA9IHRoaXMub25SZWxlYXNlKS5jYWxsKF9jb250ZXh0MTEsIHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbkNvbnRleHQgPSBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDEyID0gdGhpcy5vbkNvbnRleHQpLmNhbGwoX2NvbnRleHQxMiwgdGhpcyk7XG4gICAgdGhpcy50b3VjaFRpbWUgPSAwO1xuICAgIHRoaXMuZHJhZyA9IHt9O1xuICAgIHRoaXMucGluY2ggPSB7fTtcbiAgICB0aGlzLnBvcHVwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9wdXBPYmogPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3B1cFRpbWVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlciA9IF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MTMgPSB0aGlzLmdldFBvaW50ZXIpLmNhbGwoX2NvbnRleHQxMywgdGhpcyk7XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGRyYWdOb2RlczogdHJ1ZSxcbiAgICAgIGRyYWdWaWV3OiB0cnVlLFxuICAgICAgaG92ZXI6IGZhbHNlLFxuICAgICAga2V5Ym9hcmQ6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHNwZWVkOiB7XG4gICAgICAgICAgeDogMTAsXG4gICAgICAgICAgeTogMTAsXG4gICAgICAgICAgem9vbTogMC4wMlxuICAgICAgICB9LFxuICAgICAgICBiaW5kVG9XaW5kb3c6IHRydWUsXG4gICAgICAgIGF1dG9Gb2N1czogdHJ1ZVxuICAgICAgfSxcbiAgICAgIG5hdmlnYXRpb25CdXR0b25zOiBmYWxzZSxcbiAgICAgIHRvb2x0aXBEZWxheTogMzAwLFxuICAgICAgem9vbVZpZXc6IHRydWUsXG4gICAgICB6b29tU3BlZWQ6IDFcbiAgICB9O1xuICAgIF9PYmplY3QkYXNzaWduKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhJbnRlcmFjdGlvbkhhbmRsZXIsIFt7XG4gICAga2V5OiBcImJpbmRFdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnBvcHVwVGltZXIpO1xuICAgICAgICBkZWxldGUgX3RoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcjtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBleHRlbmQgYWxsIGJ1dCB0aGUgdmFsdWVzIGluIGZpZWxkc1xuICAgICAgICB2YXIgZmllbGRzID0gW1wiaGlkZUVkZ2VzT25EcmFnXCIsIFwiaGlkZUVkZ2VzT25ab29tXCIsIFwiaGlkZU5vZGVzT25EcmFnXCIsIFwia2V5Ym9hcmRcIiwgXCJtdWx0aXNlbGVjdFwiLCBcInNlbGVjdGFibGVcIiwgXCJzZWxlY3RDb25uZWN0ZWRFZGdlc1wiXTtcbiAgICAgICAgc2VsZWN0aXZlTm90RGVlcEV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gbWVyZ2UgdGhlIGtleWJvYXJkIG9wdGlvbnMgaW4uXG4gICAgICAgIG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsIFwia2V5Ym9hcmRcIik7XG4gICAgICAgIGlmIChvcHRpb25zLnRvb2x0aXApIHtcbiAgICAgICAgICBfT2JqZWN0JGFzc2lnbih0aGlzLm9wdGlvbnMudG9vbHRpcCwgb3B0aW9ucy50b29sdGlwKTtcbiAgICAgICAgICBpZiAob3B0aW9ucy50b29sdGlwLmNvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMudG9vbHRpcC5jb2xvciA9IHBhcnNlQ29sb3Iob3B0aW9ucy50b29sdGlwLmNvbG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubmF2aWdhdGlvbkhhbmRsZXIuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcG9pbnRlciBsb2NhdGlvbiBmcm9tIGEgdG91Y2ggbG9jYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gdG91Y2hcbiAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9pbnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludGVyKHRvdWNoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB0b3VjaC54IC0gZ2V0QWJzb2x1dGVMZWZ0KHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcyksXG4gICAgICAgIHk6IHRvdWNoLnkgLSBnZXRBYnNvbHV0ZVRvcCh0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMpXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9uIHN0YXJ0IG9mIGEgdG91Y2ggZ2VzdHVyZSwgc3RvcmUgdGhlIHBvaW50ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwib25Ub3VjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblRvdWNoKGV2ZW50KSB7XG4gICAgICBpZiAobmV3IERhdGUoKS52YWx1ZU9mKCkgLSB0aGlzLnRvdWNoVGltZSA+IDUwKSB7XG4gICAgICAgIHRoaXMuZHJhZy5wb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgIHRoaXMuZHJhZy5waW5jaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGluY2guc2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgLy8gdG8gYXZvaWQgZG91YmxlIGZpcmVpbmcgb2YgdGhpcyBldmVudCBiZWNhdXNlIHdlIGhhdmUgdHdvIGhhbW1lciBpbnN0YW5jZXMuIChvbiBjYW52YXMgYW5kIG9uIGZyYW1lKVxuICAgICAgICB0aGlzLnRvdWNoVGltZSA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGhhbmRsZSB0YXAvY2xpY2sgZXZlbnQ6IHNlbGVjdC91bnNlbGVjdCBhIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJvblRhcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblRhcChldmVudCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgIHZhciBtdWx0aXNlbGVjdCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5vcHRpb25zLm11bHRpc2VsZWN0ICYmIChldmVudC5jaGFuZ2VkUG9pbnRlcnNbMF0uY3RybEtleSB8fCBldmVudC5jaGFuZ2VkUG9pbnRlcnNbMF0ubWV0YUtleSk7XG4gICAgICB0aGlzLmNoZWNrU2VsZWN0aW9uQ2hhbmdlcyhwb2ludGVyLCBtdWx0aXNlbGVjdCk7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuY29tbWl0QW5kRW1pdChwb2ludGVyLCBldmVudCk7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiY2xpY2tcIiwgZXZlbnQsIHBvaW50ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGhhbmRsZSBkb3VibGV0YXAgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJvbkRvdWJsZVRhcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRvdWJsZVRhcChldmVudCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkb3VibGVDbGlja1wiLCBldmVudCwgcG9pbnRlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGFuZGxlIGxvbmcgdGFwIGV2ZW50OiBtdWx0aSBzZWxlY3Qgbm9kZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJvbkhvbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Ib2xkKGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgdmFyIG11bHRpc2VsZWN0ID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLm9wdGlvbnMubXVsdGlzZWxlY3Q7XG4gICAgICB0aGlzLmNoZWNrU2VsZWN0aW9uQ2hhbmdlcyhwb2ludGVyLCBtdWx0aXNlbGVjdCk7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuY29tbWl0QW5kRW1pdChwb2ludGVyLCBldmVudCk7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiY2xpY2tcIiwgZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImhvbGRcIiwgZXZlbnQsIHBvaW50ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGhhbmRsZSB0aGUgcmVsZWFzZSBvZiB0aGUgc2NyZWVuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwib25SZWxlYXNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVsZWFzZShldmVudCkge1xuICAgICAgaWYgKG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdGhpcy50b3VjaFRpbWUgPiAxMCkge1xuICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwicmVsZWFzZVwiLCBldmVudCwgcG9pbnRlcik7XG4gICAgICAgIC8vIHRvIGF2b2lkIGRvdWJsZSBmaXJlaW5nIG9mIHRoaXMgZXZlbnQgYmVjYXVzZSB3ZSBoYXZlIHR3byBoYW1tZXIgaW5zdGFuY2VzLiAob24gY2FudmFzIGFuZCBvbiBmcmFtZSlcbiAgICAgICAgdGhpcy50b3VjaFRpbWUgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwib25Db250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ29udGV4dChldmVudCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoe1xuICAgICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJvbmNvbnRleHRcIiwgZXZlbnQsIHBvaW50ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBhbmQgZGVzZWxlY3Qgbm9kZXMgZGVwZW5kaW5nIGN1cnJlbnQgc2VsZWN0aW9uIGNoYW5nZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FkZD1mYWxzZV1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjaGVja1NlbGVjdGlvbkNoYW5nZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tTZWxlY3Rpb25DaGFuZ2VzKHBvaW50ZXIpIHtcbiAgICAgIHZhciBhZGQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgaWYgKGFkZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0QWRkaXRpb25hbE9uUG9pbnQocG9pbnRlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0T25Qb2ludChwb2ludGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIG5vZGUgYW5kIGVkZ2UgaWQncyBmcm9tIHRoZSBmaXJzdCBzZXQgdGhhdCBhcmUgcHJlc2VudCBpbiB0aGUgc2Vjb25kIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e25vZGVzOiBBcnJheS48Tm9kZT4sIGVkZ2VzOiBBcnJheS48dmlzLkVkZ2U+fX0gZmlyc3RTZXRcbiAgICAgKiBAcGFyYW0ge3tub2RlczogQXJyYXkuPE5vZGU+LCBlZGdlczogQXJyYXkuPHZpcy5FZGdlPn19IHNlY29uZFNldFxuICAgICAqIEByZXR1cm5zIHt7bm9kZXM6IEFycmF5LjxOb2RlPiwgZWRnZXM6IEFycmF5Ljx2aXMuRWRnZT59fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RldGVybWluZURpZmZlcmVuY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZURpZmZlcmVuY2UoZmlyc3RTZXQsIHNlY29uZFNldCkge1xuICAgICAgdmFyIGFycmF5RGlmZiA9IGZ1bmN0aW9uIGFycmF5RGlmZihmaXJzdEFyciwgc2Vjb25kQXJyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaXJzdEFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGZpcnN0QXJyW2ldO1xuICAgICAgICAgIGlmIChfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkoc2Vjb25kQXJyKS5jYWxsKHNlY29uZEFyciwgdmFsdWUpID09PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVzOiBhcnJheURpZmYoZmlyc3RTZXQubm9kZXMsIHNlY29uZFNldC5ub2RlcyksXG4gICAgICAgIGVkZ2VzOiBhcnJheURpZmYoZmlyc3RTZXQuZWRnZXMsIHNlY29uZFNldC5lZGdlcylcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgb25EcmFnU3RhcnQuXG4gICAgICogSXQgaXMgc2VwYXJhdGVkIG91dCBiZWNhdXNlIHdlIGNhbiB0aGVuIG92ZXJsb2FkIGl0IGZvciB0aGUgZGF0YW1hbmlwdWxhdGlvbiBzeXN0ZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwib25EcmFnU3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmFnU3RhcnQoZXZlbnQpIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZHJhZ2dpbmcsIGRvIG5vdCBzdGFydFxuICAgICAgLy8gdGhpcyBjYW4gaGFwcGVuIG9uIHRvdWNoIHNjcmVlbnMgd2l0aCBtdWx0aXBsZSBmaW5nZXJzXG4gICAgICBpZiAodGhpcy5kcmFnLmRyYWdnaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy9pbiBjYXNlIHRoZSB0b3VjaCBldmVudCB3YXMgdHJpZ2dlcmVkIG9uIGFuIGV4dGVybmFsIGRpdiwgZG8gdGhlIGluaXRpYWwgdG91Y2ggbm93LlxuICAgICAgaWYgKHRoaXMuZHJhZy5wb2ludGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5vblRvdWNoKGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gbm90ZTogZHJhZy5wb2ludGVyIGlzIHNldCBpbiBvblRvdWNoIHRvIGdldCB0aGUgaW5pdGlhbCB0b3VjaCBsb2NhdGlvblxuICAgICAgdmFyIG5vZGUgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0Tm9kZUF0KHRoaXMuZHJhZy5wb2ludGVyKTtcbiAgICAgIHRoaXMuZHJhZy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICB0aGlzLmRyYWcuc2VsZWN0aW9uID0gW107XG4gICAgICB0aGlzLmRyYWcudHJhbnNsYXRpb24gPSBfT2JqZWN0JGFzc2lnbih7fSwgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24pOyAvLyBjb3B5IHRoZSBvYmplY3RcbiAgICAgIHRoaXMuZHJhZy5ub2RlSWQgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoZXZlbnQuc3JjRXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5zaG93ID0gdHJ1ZTtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgICAgdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5zdGFydCA9IHtcbiAgICAgICAgICB4OiB0aGlzLmNhbnZhcy5fWGNvbnZlcnRET010b0NhbnZhcyhwb2ludGVyLngpLFxuICAgICAgICAgIHk6IHRoaXMuY2FudmFzLl9ZY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueSlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5lbmQgPSB7XG4gICAgICAgICAgeDogdGhpcy5jYW52YXMuX1hjb252ZXJ0RE9NdG9DYW52YXMocG9pbnRlci54KSxcbiAgICAgICAgICB5OiB0aGlzLmNhbnZhcy5fWWNvbnZlcnRET010b0NhbnZhcyhwb2ludGVyLnkpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuZHJhZ05vZGVzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZHJhZy5ub2RlSWQgPSBub2RlLmlkO1xuICAgICAgICAvLyBzZWxlY3QgdGhlIGNsaWNrZWQgbm9kZSBpZiBub3QgeWV0IHNlbGVjdGVkXG4gICAgICAgIGlmIChub2RlLmlzU2VsZWN0ZWQoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2V0U2VsZWN0aW9uKHtcbiAgICAgICAgICAgIG5vZGVzOiBbbm9kZS5pZF1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFmdGVyIHNlbGVjdCB0byBjb250YWluIHRoZSBub2RlXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnU3RhcnRcIiwgZXZlbnQsIHRoaXMuZHJhZy5wb2ludGVyKTtcblxuICAgICAgICAvLyBjcmVhdGUgYW4gYXJyYXkgd2l0aCB0aGUgc2VsZWN0ZWQgbm9kZXMgYW5kIHRoZWlyIG9yaWdpbmFsIGxvY2F0aW9uIGFuZCBzdGF0dXNcbiAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDQodGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkTm9kZXMoKSksXG4gICAgICAgICAgX3N0ZXA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBfbm9kZSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHMgPSB7XG4gICAgICAgICAgICAgIGlkOiBfbm9kZS5pZCxcbiAgICAgICAgICAgICAgbm9kZTogX25vZGUsXG4gICAgICAgICAgICAgIC8vIHN0b3JlIG9yaWdpbmFsIHgsIHksIHhGaXhlZCBhbmQgeUZpeGVkLCBtYWtlIHRoZSBub2RlIHRlbXBvcmFyaWx5IEZpeGVkXG4gICAgICAgICAgICAgIHg6IF9ub2RlLngsXG4gICAgICAgICAgICAgIHk6IF9ub2RlLnksXG4gICAgICAgICAgICAgIHhGaXhlZDogX25vZGUub3B0aW9ucy5maXhlZC54LFxuICAgICAgICAgICAgICB5Rml4ZWQ6IF9ub2RlLm9wdGlvbnMuZml4ZWQueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9ub2RlLm9wdGlvbnMuZml4ZWQueCA9IHRydWU7XG4gICAgICAgICAgICBfbm9kZS5vcHRpb25zLmZpeGVkLnkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kcmFnLnNlbGVjdGlvbi5wdXNoKHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmYWxsYmFjayBpZiBubyBub2RlIGlzIHNlbGVjdGVkIGFuZCB0aHVzIHRoZSB2aWV3IGlzIGRyYWdnZWQuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnU3RhcnRcIiwgZXZlbnQsIHRoaXMuZHJhZy5wb2ludGVyLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGhhbmRsZSBkcmFnIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwib25EcmFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRHJhZyhldmVudCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5kcmFnLnBpbmNoZWQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyByZW1vdmUgdGhlIGZvY3VzIG9uIG5vZGUgaWYgaXQgaXMgZm9jdXNzZWQgb24gYnkgdGhlIGZvY3VzT25Ob2RlXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwidW5sb2NrTm9kZVwiKTtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5kcmFnLnNlbGVjdGlvbjtcbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmxlbmd0aCAmJiB0aGlzLm9wdGlvbnMuZHJhZ05vZGVzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnZ2luZ1wiLCBldmVudCwgcG9pbnRlcik7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIGRlbHRhJ3MgYW5kIG5ldyBsb2NhdGlvblxuICAgICAgICB2YXIgZGVsdGFYID0gcG9pbnRlci54IC0gdGhpcy5kcmFnLnBvaW50ZXIueDtcbiAgICAgICAgdmFyIGRlbHRhWSA9IHBvaW50ZXIueSAtIHRoaXMuZHJhZy5wb2ludGVyLnk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHBvc2l0aW9uIG9mIGFsbCBzZWxlY3RlZCBub2Rlc1xuICAgICAgICBfZm9yRWFjaEluc3RhbmNlUHJvcGVydHkoc2VsZWN0aW9uKS5jYWxsKHNlbGVjdGlvbiwgZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICAgIHZhciBub2RlID0gc2VsZWN0aW9uLm5vZGU7XG4gICAgICAgICAgLy8gb25seSBtb3ZlIHRoZSBub2RlIGlmIGl0IHdhcyBub3QgZml4ZWQgaW5pdGlhbGx5XG4gICAgICAgICAgaWYgKHNlbGVjdGlvbi54Rml4ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBub2RlLnggPSBfdGhpczIuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKF90aGlzMi5jYW52YXMuX1hjb252ZXJ0Q2FudmFzVG9ET00oc2VsZWN0aW9uLngpICsgZGVsdGFYKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gb25seSBtb3ZlIHRoZSBub2RlIGlmIGl0IHdhcyBub3QgZml4ZWQgaW5pdGlhbGx5XG4gICAgICAgICAgaWYgKHNlbGVjdGlvbi55Rml4ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBub2RlLnkgPSBfdGhpczIuY2FudmFzLl9ZY29udmVydERPTXRvQ2FudmFzKF90aGlzMi5jYW52YXMuX1ljb252ZXJ0Q2FudmFzVG9ET00oc2VsZWN0aW9uLnkpICsgZGVsdGFZKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHN0YXJ0IHRoZSBzaW11bGF0aW9uIG9mIHRoZSBwaHlzaWNzXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFydFNpbXVsYXRpb25cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjcmVhdGUgc2VsZWN0aW9uIGJveFxuICAgICAgICBpZiAoZXZlbnQuc3JjRXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZHJhZ2dpbmdcIiwgZXZlbnQsIHBvaW50ZXIsIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgICAgICAvLyBpZiB0aGUgZHJhZyB3YXMgbm90IHN0YXJ0ZWQgcHJvcGVybHkgYmVjYXVzZSB0aGUgY2xpY2sgc3RhcnRlZCBvdXRzaWRlIHRoZSBuZXR3b3JrIGRpdiwgc3RhcnQgaXQgbm93LlxuICAgICAgICAgIGlmICh0aGlzLmRyYWcucG9pbnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uRHJhZ1N0YXJ0KGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5lbmQgPSB7XG4gICAgICAgICAgICB4OiB0aGlzLmNhbnZhcy5fWGNvbnZlcnRET010b0NhbnZhcyhwb2ludGVyLngpLFxuICAgICAgICAgICAgeTogdGhpcy5jYW52YXMuX1ljb252ZXJ0RE9NdG9DYW52YXMocG9pbnRlci55KVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW92ZSB0aGUgbmV0d29ya1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRyYWdWaWV3ID09PSB0cnVlICYmICFldmVudC5zcmNFdmVudC5zaGlmdEtleSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnZ2luZ1wiLCBldmVudCwgcG9pbnRlciwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgICAgIC8vIGlmIHRoZSBkcmFnIHdhcyBub3Qgc3RhcnRlZCBwcm9wZXJseSBiZWNhdXNlIHRoZSBjbGljayBzdGFydGVkIG91dHNpZGUgdGhlIG5ldHdvcmsgZGl2LCBzdGFydCBpdCBub3cuXG4gICAgICAgICAgaWYgKHRoaXMuZHJhZy5wb2ludGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25EcmFnU3RhcnQoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGlmZlggPSBwb2ludGVyLnggLSB0aGlzLmRyYWcucG9pbnRlci54O1xuICAgICAgICAgIHZhciBkaWZmWSA9IHBvaW50ZXIueSAtIHRoaXMuZHJhZy5wb2ludGVyLnk7XG4gICAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7XG4gICAgICAgICAgICB4OiB0aGlzLmRyYWcudHJhbnNsYXRpb24ueCArIGRpZmZYLFxuICAgICAgICAgICAgeTogdGhpcy5kcmFnLnRyYW5zbGF0aW9uLnkgKyBkaWZmWVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGFuZGxlIGRyYWcgc3RhcnQgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJvbkRyYWdFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmFnRW5kKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHRoaXMuZHJhZy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuYm9keS5zZWxlY3Rpb25Cb3guc2hvdykge1xuICAgICAgICB2YXIgX2NvbnRleHQxNDtcbiAgICAgICAgdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5zaG93ID0gZmFsc2U7XG4gICAgICAgIHZhciBzZWxlY3Rpb25Cb3hQb3NpdGlvbiA9IHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb247XG4gICAgICAgIHZhciBzZWxlY3Rpb25Cb3hQb3NpdGlvbk1pbk1heCA9IHtcbiAgICAgICAgICBtaW5YOiBNYXRoLm1pbihzZWxlY3Rpb25Cb3hQb3NpdGlvbi5zdGFydC54LCBzZWxlY3Rpb25Cb3hQb3NpdGlvbi5lbmQueCksXG4gICAgICAgICAgbWluWTogTWF0aC5taW4oc2VsZWN0aW9uQm94UG9zaXRpb24uc3RhcnQueSwgc2VsZWN0aW9uQm94UG9zaXRpb24uZW5kLnkpLFxuICAgICAgICAgIG1heFg6IE1hdGgubWF4KHNlbGVjdGlvbkJveFBvc2l0aW9uLnN0YXJ0LngsIHNlbGVjdGlvbkJveFBvc2l0aW9uLmVuZC54KSxcbiAgICAgICAgICBtYXhZOiBNYXRoLm1heChzZWxlY3Rpb25Cb3hQb3NpdGlvbi5zdGFydC55LCBzZWxlY3Rpb25Cb3hQb3NpdGlvbi5lbmQueSlcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRvQmVTZWxlY3RlZE5vZGVzID0gX2ZpbHRlckluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQxNCA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcykuY2FsbChfY29udGV4dDE0LCBmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBfdGhpczMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgIHJldHVybiBub2RlLnggPj0gc2VsZWN0aW9uQm94UG9zaXRpb25NaW5NYXgubWluWCAmJiBub2RlLnggPD0gc2VsZWN0aW9uQm94UG9zaXRpb25NaW5NYXgubWF4WCAmJiBub2RlLnkgPj0gc2VsZWN0aW9uQm94UG9zaXRpb25NaW5NYXgubWluWSAmJiBub2RlLnkgPD0gc2VsZWN0aW9uQm94UG9zaXRpb25NaW5NYXgubWF4WTtcbiAgICAgICAgfSk7XG4gICAgICAgIF9mb3JFYWNoSW5zdGFuY2VQcm9wZXJ0eSh0b0JlU2VsZWN0ZWROb2RlcykuY2FsbCh0b0JlU2VsZWN0ZWROb2RlcywgZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RPYmplY3QoX3RoaXMzLmJvZHkubm9kZXNbbm9kZUlkXSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuY29tbWl0QW5kRW1pdChwb2ludGVyLCBldmVudCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnRW5kXCIsIGV2ZW50LCB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZHJhZy5zZWxlY3Rpb247XG4gICAgICAgIGlmIChzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICAgIF9mb3JFYWNoSW5zdGFuY2VQcm9wZXJ0eShzZWxlY3Rpb24pLmNhbGwoc2VsZWN0aW9uLCBmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCB4Rml4ZWQgYW5kIHlGaXhlZFxuICAgICAgICAgICAgcy5ub2RlLm9wdGlvbnMuZml4ZWQueCA9IHMueEZpeGVkO1xuICAgICAgICAgICAgcy5ub2RlLm9wdGlvbnMuZml4ZWQueSA9IHMueUZpeGVkO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnRW5kXCIsIGV2ZW50LCB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKSk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZHJhZ0VuZFwiLCBldmVudCwgdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlciksIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIHBpbmNoIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm9uUGluY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25QaW5jaChldmVudCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgIHRoaXMuZHJhZy5waW5jaGVkID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLnBpbmNoW1wic2NhbGVcIl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnBpbmNoLnNjYWxlID0gMTtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogZW5hYmxlZCBtb3Zpbmcgd2hpbGUgcGluY2hpbmc/XG4gICAgICB2YXIgc2NhbGUgPSB0aGlzLnBpbmNoLnNjYWxlICogZXZlbnQuc2NhbGU7XG4gICAgICB0aGlzLnpvb20oc2NhbGUsIHBvaW50ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFpvb20gdGhlIG5ldHdvcmsgaW4gb3Igb3V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGUgYSBudW1iZXIgYXJvdW5kIDEsIGFuZCBiZXR3ZWVuIDAuMDEgYW5kIDEwXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyICAgIFBvc2l0aW9uIG9uIHNjcmVlblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiem9vbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB6b29tKHNjYWxlLCBwb2ludGVyKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnpvb21WaWV3ID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBzY2FsZU9sZCA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICBpZiAoc2NhbGUgPCAwLjAwMDAxKSB7XG4gICAgICAgICAgc2NhbGUgPSAwLjAwMDAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2FsZSA+IDEwKSB7XG4gICAgICAgICAgc2NhbGUgPSAxMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJlU2NhbGVEcmFnUG9pbnRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMuZHJhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZHJhZy5kcmFnZ2luZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcHJlU2NhbGVEcmFnUG9pbnRlciA9IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHRoaXMuZHJhZy5wb2ludGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gKyB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0IC8gMlxuICAgICAgICB2YXIgdHJhbnNsYXRpb24gPSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbjtcbiAgICAgICAgdmFyIHNjYWxlRnJhYyA9IHNjYWxlIC8gc2NhbGVPbGQ7XG4gICAgICAgIHZhciB0eCA9ICgxIC0gc2NhbGVGcmFjKSAqIHBvaW50ZXIueCArIHRyYW5zbGF0aW9uLnggKiBzY2FsZUZyYWM7XG4gICAgICAgIHZhciB0eSA9ICgxIC0gc2NhbGVGcmFjKSAqIHBvaW50ZXIueSArIHRyYW5zbGF0aW9uLnkgKiBzY2FsZUZyYWM7XG4gICAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gc2NhbGU7XG4gICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0ge1xuICAgICAgICAgIHg6IHR4LFxuICAgICAgICAgIHk6IHR5XG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcmVTY2FsZURyYWdQb2ludGVyICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBwb3N0U2NhbGVEcmFnUG9pbnRlciA9IHRoaXMuY2FudmFzLmNhbnZhc1RvRE9NKHByZVNjYWxlRHJhZ1BvaW50ZXIpO1xuICAgICAgICAgIHRoaXMuZHJhZy5wb2ludGVyLnggPSBwb3N0U2NhbGVEcmFnUG9pbnRlci54O1xuICAgICAgICAgIHRoaXMuZHJhZy5wb2ludGVyLnkgPSBwb3N0U2NhbGVEcmFnUG9pbnRlci55O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgICAgaWYgKHNjYWxlT2xkIDwgc2NhbGUpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiem9vbVwiLCB7XG4gICAgICAgICAgICBkaXJlY3Rpb246IFwiK1wiLFxuICAgICAgICAgICAgc2NhbGU6IHRoaXMuYm9keS52aWV3LnNjYWxlLFxuICAgICAgICAgICAgcG9pbnRlcjogcG9pbnRlclxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJ6b29tXCIsIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbjogXCItXCIsXG4gICAgICAgICAgICBzY2FsZTogdGhpcy5ib2R5LnZpZXcuc2NhbGUsXG4gICAgICAgICAgICBwb2ludGVyOiBwb2ludGVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBoYW5kbGVyIGZvciBtb3VzZSB3aGVlbCBldmVudCwgdXNlZCB0byB6b29tIHRoZSB0aW1lbGluZVxuICAgICAqIFNlZSBodHRwOi8vYWRvbWFzLm9yZy9qYXZhc2NyaXB0LW1vdXNlLXdoZWVsL1xuICAgICAqICAgICBodHRwczovL2dpdGh1Yi5jb20vRWlnaHRNZWRpYS9oYW1tZXIuanMvaXNzdWVzLzI1NlxuICAgICAqXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSAgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm9uTW91c2VXaGVlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1vdXNlV2hlZWwoZXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuem9vbVZpZXcgPT09IHRydWUpIHtcbiAgICAgICAgLy8gSWYgZGVsdGEgaXMgbm9uemVybywgaGFuZGxlIGl0LlxuICAgICAgICAvLyBCYXNpY2FsbHksIGRlbHRhIGlzIG5vdyBwb3NpdGl2ZSBpZiB3aGVlbCB3YXMgc2Nyb2xsZWQgdXAsXG4gICAgICAgIC8vIGFuZCBuZWdhdGl2ZSwgaWYgd2hlZWwgd2FzIHNjcm9sbGVkIGRvd24uXG4gICAgICAgIGlmIChldmVudC5kZWx0YVkgIT09IDApIHtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIG5ldyBzY2FsZVxuICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICAgIHNjYWxlICo9IDEgKyAoZXZlbnQuZGVsdGFZIDwgMCA/IDEgOiAtMSkgKiAodGhpcy5vcHRpb25zLnpvb21TcGVlZCAqIDAuMSk7XG5cbiAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHBvaW50ZXIgbG9jYXRpb25cbiAgICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcih7XG4gICAgICAgICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgICAgICAgeTogZXZlbnQuY2xpZW50WVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gYXBwbHkgdGhlIG5ldyBzY2FsZVxuICAgICAgICAgIHRoaXMuem9vbShzY2FsZSwgcG9pbnRlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgYWN0aW9ucyBjYXVzZWQgYnkgbW91c2Ugd2hlZWwuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW91c2UgbW92ZSBoYW5kbGVyIGZvciBjaGVja2luZyB3aGV0aGVyIHRoZSB0aXRsZSBtb3ZlcyBvdmVyIGEgbm9kZSB3aXRoIGEgdGl0bGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm9uTW91c2VNb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WVxuICAgICAgfSk7XG4gICAgICB2YXIgcG9wdXBWaXNpYmxlID0gZmFsc2U7XG5cbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBwcmV2aW91c2x5IHNlbGVjdGVkIG5vZGUgaXMgc3RpbGwgc2VsZWN0ZWRcbiAgICAgIGlmICh0aGlzLnBvcHVwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXAuaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuX2NoZWNrSGlkZVBvcHVwKHBvaW50ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIHBvcHVwIHdhcyBub3QgaGlkZGVuIGFib3ZlXG4gICAgICAgIGlmICh0aGlzLnBvcHVwLmhpZGRlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBwb3B1cFZpc2libGUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMucG9wdXAuc2V0UG9zaXRpb24ocG9pbnRlci54ICsgMywgcG9pbnRlci55IC0gNSk7XG4gICAgICAgICAgdGhpcy5wb3B1cC5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYgd2UgYmluZCB0aGUga2V5Ym9hcmQgdG8gdGhlIGRpdiwgd2UgaGF2ZSB0byBoaWdobGlnaHQgaXQgdG8gdXNlIGl0LiBUaGlzIGhpZ2hsaWdodHMgaXQgb24gbW91c2Ugb3Zlci5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMua2V5Ym9hcmQuYXV0b0ZvY3VzICYmIHRoaXMub3B0aW9ucy5rZXlib2FyZC5iaW5kVG9XaW5kb3cgPT09IGZhbHNlICYmIHRoaXMub3B0aW9ucy5rZXlib2FyZC5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLmZvY3VzKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHN0YXJ0IGEgdGltZW91dCB0aGF0IHdpbGwgY2hlY2sgaWYgdGhlIG1vdXNlIGlzIHBvc2l0aW9uZWQgYWJvdmUgYW4gZWxlbWVudFxuICAgICAgaWYgKHBvcHVwVmlzaWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXBUaW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnBvcHVwVGltZXIpOyAvLyBzdG9wIGFueSBydW5uaW5nIGNhbGN1bGF0aW9uVGltZXJcbiAgICAgICAgICB0aGlzLnBvcHVwVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmRyYWcuZHJhZ2dpbmcpIHtcbiAgICAgICAgICB0aGlzLnBvcHVwVGltZXIgPSBfc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM0Ll9jaGVja1Nob3dQb3B1cChwb2ludGVyKTtcbiAgICAgICAgICB9LCB0aGlzLm9wdGlvbnMudG9vbHRpcERlbGF5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBhZGRpbmcgaG92ZXIgaGlnaGxpZ2h0c1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ob3ZlciA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuaG92ZXJPYmplY3QoZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZXJlIGlzIGFuIGVsZW1lbnQgb24gdGhlIGdpdmVuIHBvc2l0aW9uIGluIHRoZSBuZXR3b3JrXG4gICAgICogKGEgbm9kZSBvciBlZGdlKS4gSWYgc28sIGFuZCBpZiB0aGlzIGVsZW1lbnQgaGFzIGEgdGl0bGUsXG4gICAgICogc2hvdyBhIHBvcHVwIHdpbmRvdyB3aXRoIGl0cyB0aXRsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6bnVtYmVyLCB5Om51bWJlcn19IHBvaW50ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jaGVja1Nob3dQb3B1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tTaG93UG9wdXAocG9pbnRlcikge1xuICAgICAgdmFyIHggPSB0aGlzLmNhbnZhcy5fWGNvbnZlcnRET010b0NhbnZhcyhwb2ludGVyLngpO1xuICAgICAgdmFyIHkgPSB0aGlzLmNhbnZhcy5fWWNvbnZlcnRET010b0NhbnZhcyhwb2ludGVyLnkpO1xuICAgICAgdmFyIHBvaW50ZXJPYmogPSB7XG4gICAgICAgIGxlZnQ6IHgsXG4gICAgICAgIHRvcDogeSxcbiAgICAgICAgcmlnaHQ6IHgsXG4gICAgICAgIGJvdHRvbTogeVxuICAgICAgfTtcbiAgICAgIHZhciBwcmV2aW91c1BvcHVwT2JqSWQgPSB0aGlzLnBvcHVwT2JqID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB0aGlzLnBvcHVwT2JqLmlkO1xuICAgICAgdmFyIG5vZGVVbmRlckN1cnNvciA9IGZhbHNlO1xuICAgICAgdmFyIHBvcHVwVHlwZSA9IFwibm9kZVwiO1xuXG4gICAgICAvLyBjaGVjayBpZiBhIG5vZGUgaXMgdW5kZXIgdGhlIGN1cnNvci5cbiAgICAgIGlmICh0aGlzLnBvcHVwT2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gc2VhcmNoIHRoZSBub2RlcyBmb3Igb3ZlcmxhcCwgc2VsZWN0IHRoZSB0b3Agb25lIGluIGNhc2Ugb2YgbXVsdGlwbGUgbm9kZXNcbiAgICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICB2YXIgb3ZlcmxhcHBpbmdOb2RlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGVzW25vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgICBpZiAobm9kZS5pc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbm9kZVVuZGVyQ3Vyc29yID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChub2RlLmdldFRpdGxlKCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBvdmVybGFwcGluZ05vZGVzLnB1c2gobm9kZUluZGljZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3ZlcmxhcHBpbmdOb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG92ZXJsYXBwaW5nIG5vZGVzLCBzZWxlY3QgdGhlIGxhc3Qgb25lLCB0aGlzIGlzIHRoZSBvbmUgd2hpY2ggaXMgZHJhd24gb24gdG9wIG9mIHRoZSBvdGhlcnNcbiAgICAgICAgICB0aGlzLnBvcHVwT2JqID0gbm9kZXNbb3ZlcmxhcHBpbmdOb2Rlc1tvdmVybGFwcGluZ05vZGVzLmxlbmd0aCAtIDFdXTtcbiAgICAgICAgICAvLyBpZiB5b3UgaG92ZXIgb3ZlciBhIG5vZGUsIHRoZSB0aXRsZSBvZiB0aGUgZWRnZSBpcyBub3Qgc3VwcG9zZWQgdG8gYmUgc2hvd24uXG4gICAgICAgICAgbm9kZVVuZGVyQ3Vyc29yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMucG9wdXBPYmogPT09IHVuZGVmaW5lZCAmJiBub2RlVW5kZXJDdXJzb3IgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIHNlYXJjaCB0aGUgZWRnZXMgZm9yIG92ZXJsYXBcbiAgICAgICAgdmFyIGVkZ2VJbmRpY2VzID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzO1xuICAgICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICAgIHZhciBlZGdlO1xuICAgICAgICB2YXIgb3ZlcmxhcHBpbmdFZGdlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWRnZUluZGljZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgZWRnZSA9IGVkZ2VzW2VkZ2VJbmRpY2VzW19pXV07XG4gICAgICAgICAgaWYgKGVkZ2UuaXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaikgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCA9PT0gdHJ1ZSAmJiBlZGdlLmdldFRpdGxlKCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBvdmVybGFwcGluZ0VkZ2VzLnB1c2goZWRnZUluZGljZXNbX2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG92ZXJsYXBwaW5nRWRnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMucG9wdXBPYmogPSBlZGdlc1tvdmVybGFwcGluZ0VkZ2VzW292ZXJsYXBwaW5nRWRnZXMubGVuZ3RoIC0gMV1dO1xuICAgICAgICAgIHBvcHVwVHlwZSA9IFwiZWRnZVwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wb3B1cE9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHNob3cgcG9wdXAgbWVzc2FnZSB3aW5kb3dcbiAgICAgICAgaWYgKHRoaXMucG9wdXBPYmouaWQgIT09IHByZXZpb3VzUG9wdXBPYmpJZCkge1xuICAgICAgICAgIGlmICh0aGlzLnBvcHVwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXAgPSBuZXcgUG9wdXAodGhpcy5jYW52YXMuZnJhbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0VHlwZSA9IHBvcHVwVHlwZTtcbiAgICAgICAgICB0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWQgPSB0aGlzLnBvcHVwT2JqLmlkO1xuXG4gICAgICAgICAgLy8gYWRqdXN0IGEgc21hbGwgb2Zmc2V0IHN1Y2ggdGhhdCB0aGUgbW91c2UgY3Vyc29yIGlzIGxvY2F0ZWQgaW4gdGhlXG4gICAgICAgICAgLy8gYm90dG9tIGxlZnQgbG9jYXRpb24gb2YgdGhlIHBvcHVwLCBhbmQgeW91IGNhbiBlYXNpbHkgbW92ZSBvdmVyIHRoZVxuICAgICAgICAgIC8vIHBvcHVwIGFyZWFcbiAgICAgICAgICB0aGlzLnBvcHVwLnNldFBvc2l0aW9uKHBvaW50ZXIueCArIDMsIHBvaW50ZXIueSAtIDUpO1xuICAgICAgICAgIHRoaXMucG9wdXAuc2V0VGV4dCh0aGlzLnBvcHVwT2JqLmdldFRpdGxlKCkpO1xuICAgICAgICAgIHRoaXMucG9wdXAuc2hvdygpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJzaG93UG9wdXBcIiwgdGhpcy5wb3B1cE9iai5pZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLnBvcHVwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnBvcHVwLmhpZGUoKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiaGlkZVBvcHVwXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHBvcHVwIG11c3QgYmUgaGlkZGVuLCB3aGljaCBpcyB0aGUgY2FzZSB3aGVuIHRoZSBtb3VzZSBpcyBub1xuICAgICAqIGxvbmdlciBob3ZlcmluZyBvbiB0aGUgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3t4Om51bWJlciwgeTpudW1iZXJ9fSBwb2ludGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY2hlY2tIaWRlUG9wdXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrSGlkZVBvcHVwKHBvaW50ZXIpIHtcbiAgICAgIHZhciBwb2ludGVyT2JqID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChwb2ludGVyKTtcbiAgICAgIHZhciBzdGlsbE9uT2JqID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5wb3B1cC5wb3B1cFRhcmdldFR5cGUgPT09IFwibm9kZVwiKSB7XG4gICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc3RpbGxPbk9iaiA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWRdLmlzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopO1xuXG4gICAgICAgICAgLy8gaWYgdGhlIG1vdXNlIGlzIHN0aWxsIG9uZSB0aGUgbm9kZSwgd2UgaGF2ZSB0byBjaGVjayBpZiBpdCBpcyBub3QgYWxzbyBvbiBvbmUgdGhhdCBpcyBkcmF3biBvbiB0b3Agb2YgaXQuXG4gICAgICAgICAgLy8gd2UgaW5pdGlhbGx5IG9ubHkgY2hlY2sgc3RpbGxPbk9iaiBiZWNhdXNlIHRoaXMgaXMgbXVjaCBmYXN0ZXIuXG4gICAgICAgICAgaWYgKHN0aWxsT25PYmogPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBvdmVyTm9kZSA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXROb2RlQXQocG9pbnRlcik7XG4gICAgICAgICAgICBzdGlsbE9uT2JqID0gb3Zlck5vZGUgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogb3Zlck5vZGUuaWQgPT09IHRoaXMucG9wdXAucG9wdXBUYXJnZXRJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0Tm9kZUF0KHBvaW50ZXIpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5LmVkZ2VzW3RoaXMucG9wdXAucG9wdXBUYXJnZXRJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RpbGxPbk9iaiA9IHRoaXMuYm9keS5lZGdlc1t0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWRdLmlzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0aWxsT25PYmogPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucG9wdXBPYmogPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucG9wdXAuaGlkZSgpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiaGlkZVBvcHVwXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSW50ZXJhY3Rpb25IYW5kbGVyO1xufSgpO1xuXG52YXIgY29sbGVjdGlvbiQxID0gY29sbGVjdGlvbiQzO1xudmFyIGNvbGxlY3Rpb25TdHJvbmcgPSBjb2xsZWN0aW9uU3Ryb25nJDI7XG5cbi8vIGBTZXRgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC1vYmplY3RzXG5jb2xsZWN0aW9uJDEoJ1NldCcsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKSB7IHJldHVybiBpbml0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwgY29sbGVjdGlvblN0cm9uZyk7XG5cbnZhciBwYXRoJDEgPSBwYXRoJHc7XG5cbnZhciBzZXQkMiA9IHBhdGgkMS5TZXQ7XG5cbnZhciBwYXJlbnQkNCA9IHNldCQyO1xuXG5cbnZhciBzZXQkMSA9IHBhcmVudCQ0O1xuXG52YXIgc2V0ID0gc2V0JDE7XG5cbnZhciBfU2V0ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHNldCk7XG5cbnZhciB1bmN1cnJ5VGhpcyQyID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBkZWZpbmVCdWlsdElucyQxID0gZGVmaW5lQnVpbHRJbnMkMztcbnZhciBnZXRXZWFrRGF0YSA9IGludGVybmFsTWV0YWRhdGFFeHBvcnRzLmdldFdlYWtEYXRhO1xudmFyIGFuSW5zdGFuY2UgPSBhbkluc3RhbmNlJDM7XG52YXIgYW5PYmplY3QgPSBhbk9iamVjdCRkO1xudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQkNjtcbnZhciBpc09iamVjdCQxID0gaXNPYmplY3QkajtcbnZhciBpdGVyYXRlID0gaXRlcmF0ZSQzO1xudmFyIEFycmF5SXRlcmF0aW9uTW9kdWxlID0gYXJyYXlJdGVyYXRpb247XG52YXIgaGFzT3duID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gaW50ZXJuYWxTdGF0ZTtcblxudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3I7XG52YXIgZmluZCA9IEFycmF5SXRlcmF0aW9uTW9kdWxlLmZpbmQ7XG52YXIgZmluZEluZGV4ID0gQXJyYXlJdGVyYXRpb25Nb2R1bGUuZmluZEluZGV4O1xudmFyIHNwbGljZSA9IHVuY3VycnlUaGlzJDIoW10uc3BsaWNlKTtcbnZhciBpZCA9IDA7XG5cbi8vIGZhbGxiYWNrIGZvciB1bmNhdWdodCBmcm96ZW4ga2V5c1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmZyb3plbiB8fCAoc3RhdGUuZnJvemVuID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUoKSk7XG59O1xuXG52YXIgVW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbnRyaWVzID0gW107XG59O1xuXG52YXIgZmluZFVuY2F1Z2h0RnJvemVuID0gZnVuY3Rpb24gKHN0b3JlLCBrZXkpIHtcbiAgcmV0dXJuIGZpbmQoc3RvcmUuZW50cmllcywgZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gIH0pO1xufTtcblxuVW5jYXVnaHRGcm96ZW5TdG9yZS5wcm90b3R5cGUgPSB7XG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgcmV0dXJuIGVudHJ5WzFdO1xuICB9LFxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gISFmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgZW50cnlbMV0gPSB2YWx1ZTtcbiAgICBlbHNlIHRoaXMuZW50cmllcy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0sXG4gICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGluZGV4ID0gZmluZEluZGV4KHRoaXMuZW50cmllcywgZnVuY3Rpb24gKGl0KSB7XG4gICAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgICB9KTtcbiAgICBpZiAofmluZGV4KSBzcGxpY2UodGhpcy5lbnRyaWVzLCBpbmRleCwgMSk7XG4gICAgcmV0dXJuICEhfmluZGV4O1xuICB9XG59O1xuXG52YXIgY29sbGVjdGlvbldlYWskMSA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgUHJvdG90eXBlKTtcbiAgICAgIHNldEludGVybmFsU3RhdGUodGhhdCwge1xuICAgICAgICB0eXBlOiBDT05TVFJVQ1RPUl9OQU1FLFxuICAgICAgICBpZDogaWQrKyxcbiAgICAgICAgZnJvemVuOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChpdGVyYWJsZSkpIGl0ZXJhdGUoaXRlcmFibGUsIHRoYXRbQURERVJdLCB7IHRoYXQ6IHRoYXQsIEFTX0VOVFJJRVM6IElTX01BUCB9KTtcbiAgICB9KTtcblxuICAgIHZhciBQcm90b3R5cGUgPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IoQ09OU1RSVUNUT1JfTkFNRSk7XG5cbiAgICB2YXIgZGVmaW5lID0gZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICB2YXIgZGF0YSA9IGdldFdlYWtEYXRhKGFuT2JqZWN0KGtleSksIHRydWUpO1xuICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHVuY2F1Z2h0RnJvemVuU3RvcmUoc3RhdGUpLnNldChrZXksIHZhbHVlKTtcbiAgICAgIGVsc2UgZGF0YVtzdGF0ZS5pZF0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBkZWZpbmVCdWlsdElucyQxKFByb3RvdHlwZSwge1xuICAgICAgLy8gYHsgV2Vha01hcCwgV2Vha1NldCB9LnByb3RvdHlwZS5kZWxldGUoa2V5KWAgbWV0aG9kc1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy13ZWFrbWFwLnByb3RvdHlwZS5kZWxldGVcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha3NldC5wcm90b3R5cGUuZGVsZXRlXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgICAgICBpZiAoIWlzT2JqZWN0JDEoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWtEYXRhKGtleSk7XG4gICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZShzdGF0ZSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmIGhhc093bihkYXRhLCBzdGF0ZS5pZCkgJiYgZGVsZXRlIGRhdGFbc3RhdGUuaWRdO1xuICAgICAgfSxcbiAgICAgIC8vIGB7IFdlYWtNYXAsIFdlYWtTZXQgfS5wcm90b3R5cGUuaGFzKGtleSlgIG1ldGhvZHNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha21hcC5wcm90b3R5cGUuaGFzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXdlYWtzZXQucHJvdG90eXBlLmhhc1xuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gICAgICAgIGlmICghaXNPYmplY3QkMShrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHN0YXRlKS5oYXMoa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgaGFzT3duKGRhdGEsIHN0YXRlLmlkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRlZmluZUJ1aWx0SW5zJDEoUHJvdG90eXBlLCBJU19NQVAgPyB7XG4gICAgICAvLyBgV2Vha01hcC5wcm90b3R5cGUuZ2V0KGtleSlgIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy13ZWFrbWFwLnByb3RvdHlwZS5nZXRcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgICAgICBpZiAoaXNPYmplY3QkMShrZXkpKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrRGF0YShrZXkpO1xuICAgICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZShzdGF0ZSkuZ2V0KGtleSk7XG4gICAgICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhW3N0YXRlLmlkXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIGBXZWFrTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlgIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy13ZWFrbWFwLnByb3RvdHlwZS5zZXRcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IDoge1xuICAgICAgLy8gYFdlYWtTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlgIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy13ZWFrc2V0LnByb3RvdHlwZS5hZGRcbiAgICAgIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUodGhpcywgdmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9XG59O1xuXG52YXIgRlJFRVpJTkcgPSBmcmVlemluZztcbnZhciBnbG9iYWwkMiA9IGdsb2JhbCRuO1xudmFyIHVuY3VycnlUaGlzJDEgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGRlZmluZUJ1aWx0SW5zID0gZGVmaW5lQnVpbHRJbnMkMztcbnZhciBJbnRlcm5hbE1ldGFkYXRhTW9kdWxlID0gaW50ZXJuYWxNZXRhZGF0YUV4cG9ydHM7XG52YXIgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb24kMztcbnZhciBjb2xsZWN0aW9uV2VhayA9IGNvbGxlY3Rpb25XZWFrJDE7XG52YXIgaXNPYmplY3QgPSBpc09iamVjdCRqO1xudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gaW50ZXJuYWxTdGF0ZS5lbmZvcmNlO1xudmFyIGZhaWxzJDEgPSBmYWlscyR3O1xudmFyIE5BVElWRV9XRUFLX01BUCA9IHdlYWtNYXBCYXNpY0RldGVjdGlvbjtcblxudmFyICRPYmplY3QgPSBPYmplY3Q7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktaXNhcnJheSAtLSBzYWZlXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWlzZXh0ZW5zaWJsZSAtLSBzYWZlXG52YXIgaXNFeHRlbnNpYmxlID0gJE9iamVjdC5pc0V4dGVuc2libGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWlzZnJvemVuIC0tIHNhZmVcbnZhciBpc0Zyb3plbiA9ICRPYmplY3QuaXNGcm96ZW47XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWlzc2VhbGVkIC0tIHNhZmVcbnZhciBpc1NlYWxlZCA9ICRPYmplY3QuaXNTZWFsZWQ7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWZyZWV6ZSAtLSBzYWZlXG52YXIgZnJlZXplID0gJE9iamVjdC5mcmVlemU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LXNlYWwgLS0gc2FmZVxudmFyIHNlYWwgPSAkT2JqZWN0LnNlYWw7XG5cbnZhciBGUk9aRU4gPSB7fTtcbnZhciBTRUFMRUQgPSB7fTtcbnZhciBJU19JRTExID0gIWdsb2JhbCQyLkFjdGl2ZVhPYmplY3QgJiYgJ0FjdGl2ZVhPYmplY3QnIGluIGdsb2JhbCQyO1xudmFyIEludGVybmFsV2Vha01hcDtcblxudmFyIHdyYXBwZXIgPSBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha01hcCgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn07XG5cbi8vIGBXZWFrTWFwYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy13ZWFrbWFwLWNvbnN0cnVjdG9yXG52YXIgJFdlYWtNYXAgPSBjb2xsZWN0aW9uKCdXZWFrTWFwJywgd3JhcHBlciwgY29sbGVjdGlvbldlYWspO1xudmFyIFdlYWtNYXBQcm90b3R5cGUgPSAkV2Vha01hcC5wcm90b3R5cGU7XG52YXIgbmF0aXZlU2V0ID0gdW5jdXJyeVRoaXMkMShXZWFrTWFwUHJvdG90eXBlLnNldCk7XG5cbi8vIENoYWtyYSBFZGdlIGJ1ZzogYWRkaW5nIGZyb3plbiBhcnJheXMgdG8gV2Vha01hcCB1bmZyZWV6ZSB0aGVtXG52YXIgaGFzTVNFZGdlRnJlZXppbmdCdWcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBGUkVFWklORyAmJiBmYWlscyQxKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZnJvemVuQXJyYXkgPSBmcmVlemUoW10pO1xuICAgIG5hdGl2ZVNldChuZXcgJFdlYWtNYXAoKSwgZnJvemVuQXJyYXksIDEpO1xuICAgIHJldHVybiAhaXNGcm96ZW4oZnJvemVuQXJyYXkpO1xuICB9KTtcbn07XG5cbi8vIElFMTEgV2Vha01hcCBmcm96ZW4ga2V5cyBmaXhcbi8vIFdlIGNhbid0IHVzZSBmZWF0dXJlIGRldGVjdGlvbiBiZWNhdXNlIGl0IGNyYXNoIHNvbWUgb2xkIElFIGJ1aWxkc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ4NVxuaWYgKE5BVElWRV9XRUFLX01BUCkgaWYgKElTX0lFMTEpIHtcbiAgSW50ZXJuYWxXZWFrTWFwID0gY29sbGVjdGlvbldlYWsuZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgJ1dlYWtNYXAnLCB0cnVlKTtcbiAgSW50ZXJuYWxNZXRhZGF0YU1vZHVsZS5lbmFibGUoKTtcbiAgdmFyIG5hdGl2ZURlbGV0ZSA9IHVuY3VycnlUaGlzJDEoV2Vha01hcFByb3RvdHlwZVsnZGVsZXRlJ10pO1xuICB2YXIgbmF0aXZlSGFzID0gdW5jdXJyeVRoaXMkMShXZWFrTWFwUHJvdG90eXBlLmhhcyk7XG4gIHZhciBuYXRpdmVHZXQgPSB1bmN1cnJ5VGhpcyQxKFdlYWtNYXBQcm90b3R5cGUuZ2V0KTtcbiAgZGVmaW5lQnVpbHRJbnMoV2Vha01hcFByb3RvdHlwZSwge1xuICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoaXNPYmplY3Qoa2V5KSAmJiAhaXNFeHRlbnNpYmxlKGtleSkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUodGhpcyk7XG4gICAgICAgIGlmICghc3RhdGUuZnJvemVuKSBzdGF0ZS5mcm96ZW4gPSBuZXcgSW50ZXJuYWxXZWFrTWFwKCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVEZWxldGUodGhpcywga2V5KSB8fCBzdGF0ZS5mcm96ZW5bJ2RlbGV0ZSddKGtleSk7XG4gICAgICB9IHJldHVybiBuYXRpdmVEZWxldGUodGhpcywga2V5KTtcbiAgICB9LFxuICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgaWYgKGlzT2JqZWN0KGtleSkgJiYgIWlzRXh0ZW5zaWJsZShrZXkpKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgICAgICBpZiAoIXN0YXRlLmZyb3plbikgc3RhdGUuZnJvemVuID0gbmV3IEludGVybmFsV2Vha01hcCgpO1xuICAgICAgICByZXR1cm4gbmF0aXZlSGFzKHRoaXMsIGtleSkgfHwgc3RhdGUuZnJvemVuLmhhcyhrZXkpO1xuICAgICAgfSByZXR1cm4gbmF0aXZlSGFzKHRoaXMsIGtleSk7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgIGlmIChpc09iamVjdChrZXkpICYmICFpc0V4dGVuc2libGUoa2V5KSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKCFzdGF0ZS5mcm96ZW4pIHN0YXRlLmZyb3plbiA9IG5ldyBJbnRlcm5hbFdlYWtNYXAoKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUhhcyh0aGlzLCBrZXkpID8gbmF0aXZlR2V0KHRoaXMsIGtleSkgOiBzdGF0ZS5mcm96ZW4uZ2V0KGtleSk7XG4gICAgICB9IHJldHVybiBuYXRpdmVHZXQodGhpcywga2V5KTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChpc09iamVjdChrZXkpICYmICFpc0V4dGVuc2libGUoa2V5KSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKCFzdGF0ZS5mcm96ZW4pIHN0YXRlLmZyb3plbiA9IG5ldyBJbnRlcm5hbFdlYWtNYXAoKTtcbiAgICAgICAgbmF0aXZlSGFzKHRoaXMsIGtleSkgPyBuYXRpdmVTZXQodGhpcywga2V5LCB2YWx1ZSkgOiBzdGF0ZS5mcm96ZW4uc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIG5hdGl2ZVNldCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG4vLyBDaGFrcmEgRWRnZSBmcm96ZW4ga2V5cyBmaXhcbn0gZWxzZSBpZiAoaGFzTVNFZGdlRnJlZXppbmdCdWcoKSkge1xuICBkZWZpbmVCdWlsdElucyhXZWFrTWFwUHJvdG90eXBlLCB7XG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGFycmF5SW50ZWdyaXR5TGV2ZWw7XG4gICAgICBpZiAoaXNBcnJheShrZXkpKSB7XG4gICAgICAgIGlmIChpc0Zyb3plbihrZXkpKSBhcnJheUludGVncml0eUxldmVsID0gRlJPWkVOO1xuICAgICAgICBlbHNlIGlmIChpc1NlYWxlZChrZXkpKSBhcnJheUludGVncml0eUxldmVsID0gU0VBTEVEO1xuICAgICAgfVxuICAgICAgbmF0aXZlU2V0KHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKGFycmF5SW50ZWdyaXR5TGV2ZWwgPT09IEZST1pFTikgZnJlZXplKGtleSk7XG4gICAgICBpZiAoYXJyYXlJbnRlZ3JpdHlMZXZlbCA9PT0gU0VBTEVEKSBzZWFsKGtleSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgcGF0aCA9IHBhdGgkdztcblxudmFyIHdlYWtNYXAkMiA9IHBhdGguV2Vha01hcDtcblxudmFyIHBhcmVudCQzID0gd2Vha01hcCQyO1xuXG5cbnZhciB3ZWFrTWFwJDEgPSBwYXJlbnQkMztcblxudmFyIHdlYWtNYXAgPSB3ZWFrTWFwJDE7XG5cbnZhciBfV2Vha01hcCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyh3ZWFrTWFwKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMyhvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgX1N5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBfZ2V0SXRlcmF0b3JNZXRob2QobykgfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKF9BcnJheSRpc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQzKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQzKG8sIG1pbkxlbikgeyB2YXIgX2NvbnRleHQyOyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMyhvLCBtaW5MZW4pOyB2YXIgbiA9IF9zbGljZUluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pKS5jYWxsKF9jb250ZXh0MiwgOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gX0FycmF5JGZyb20kMShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQzKG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDMoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbnZhciBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3ByZXZpb3VzU2VsZWN0aW9uLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3NlbGVjdGlvbiwgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX25vZGVzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3JfZWRnZXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9jb21taXRIYW5kbGVyO1xuLyoqXHJcbiAqIEBwYXJhbSBwcmV2XHJcbiAqIEBwYXJhbSBuZXh0XHJcbiAqL1xuZnVuY3Rpb24gZGlmZlNldHMocHJldiwgbmV4dCkge1xuICB2YXIgZGlmZiA9IG5ldyBfU2V0KCk7XG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQzKG5leHQpLFxuICAgIF9zdGVwO1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgaXRlbSA9IF9zdGVwLnZhbHVlO1xuICAgICAgaWYgKCFwcmV2LmhhcyhpdGVtKSkge1xuICAgICAgICBkaWZmLmFkZChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuICByZXR1cm4gZGlmZjtcbn1cbnZhciBTaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3IoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcik7XG4gICAgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9wcmV2aW91c1NlbGVjdGlvbi5zZXQodGhpcywgbmV3IF9TZXQoKSk7XG4gICAgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9zZWxlY3Rpb24uc2V0KHRoaXMsIG5ldyBfU2V0KCkpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhTaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3IsIFt7XG4gICAga2V5OiBcInNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3Jfc2VsZWN0aW9uLCBcImZcIikuc2l6ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZCgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBpdGVtcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgaXRlbXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfaSA9IDAsIF9pdGVtcyA9IGl0ZW1zOyBfaSA8IF9pdGVtcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBfaXRlbXNbX2ldO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3Jfc2VsZWN0aW9uLCBcImZcIikuYWRkKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgaXRlbXNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9pdGVtczIgPSBpdGVtczsgX2kyIDwgX2l0ZW1zMi5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBpdGVtID0gX2l0ZW1zMltfaTJdO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3Jfc2VsZWN0aW9uLCBcImZcIikuZGVsZXRlKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9zZWxlY3Rpb24sIFwiZlwiKS5jbGVhcigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZWxlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKCkge1xuICAgICAgcmV0dXJuIF90b0NvbnN1bWFibGVBcnJheShfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3Jfc2VsZWN0aW9uLCBcImZcIikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDaGFuZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENoYW5nZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRlZDogX3RvQ29uc3VtYWJsZUFycmF5KGRpZmZTZXRzKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9wcmV2aW91c1NlbGVjdGlvbiwgXCJmXCIpLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3Jfc2VsZWN0aW9uLCBcImZcIikpKSxcbiAgICAgICAgZGVsZXRlZDogX3RvQ29uc3VtYWJsZUFycmF5KGRpZmZTZXRzKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9zZWxlY3Rpb24sIFwiZlwiKSwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3ByZXZpb3VzU2VsZWN0aW9uLCBcImZcIikpKSxcbiAgICAgICAgcHJldmlvdXM6IF90b0NvbnN1bWFibGVBcnJheShuZXcgX1NldChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3JfcHJldmlvdXNTZWxlY3Rpb24sIFwiZlwiKSkpLFxuICAgICAgICBjdXJyZW50OiBfdG9Db25zdW1hYmxlQXJyYXkobmV3IF9TZXQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3NlbGVjdGlvbiwgXCJmXCIpKSlcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbW1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21taXQoKSB7XG4gICAgICB2YXIgY2hhbmdlcyA9IHRoaXMuZ2V0Q2hhbmdlcygpO1xuICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3ByZXZpb3VzU2VsZWN0aW9uLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3Jfc2VsZWN0aW9uLCBcImZcIiksIFwiZlwiKTtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9zZWxlY3Rpb24sIG5ldyBfU2V0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9wcmV2aW91c1NlbGVjdGlvbiwgXCJmXCIpKSwgXCJmXCIpO1xuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQzKGNoYW5nZXMuYWRkZWQpLFxuICAgICAgICBfc3RlcDI7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBpdGVtID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgIGl0ZW0uc2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQzKGNoYW5nZXMuZGVsZXRlZCksXG4gICAgICAgIF9zdGVwMztcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9pdGVtID0gX3N0ZXAzLnZhbHVlO1xuICAgICAgICAgIF9pdGVtLnVuc2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoYW5nZXM7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3I7XG59KCk7XG5fU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3ByZXZpb3VzU2VsZWN0aW9uID0gbmV3IF9XZWFrTWFwKCksIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3Jfc2VsZWN0aW9uID0gbmV3IF9XZWFrTWFwKCk7XG52YXIgU2VsZWN0aW9uQWNjdW11bGF0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTZWxlY3Rpb25BY2N1bXVsYXRvcigpIHtcbiAgICB2YXIgY29tbWl0SGFuZGxlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZnVuY3Rpb24gKCkge307XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlbGVjdGlvbkFjY3VtdWxhdG9yKTtcbiAgICBfU2VsZWN0aW9uQWNjdW11bGF0b3Jfbm9kZXMuc2V0KHRoaXMsIG5ldyBTaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3IoKSk7XG4gICAgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2VkZ2VzLnNldCh0aGlzLCBuZXcgU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yKCkpO1xuICAgIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9jb21taXRIYW5kbGVyLnNldCh0aGlzLCB2b2lkIDApO1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2NvbW1pdEhhbmRsZXIsIGNvbW1pdEhhbmRsZXIsIFwiZlwiKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoU2VsZWN0aW9uQWNjdW11bGF0b3IsIFt7XG4gICAga2V5OiBcInNpemVOb2Rlc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX25vZGVzLCBcImZcIikuc2l6ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2l6ZUVkZ2VzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3JfZWRnZXMsIFwiZlwiKS5zaXplO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXROb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROb2RlcygpIHtcbiAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9ub2RlcywgXCJmXCIpLmdldFNlbGVjdGlvbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFZGdlcygpIHtcbiAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9lZGdlcywgXCJmXCIpLmdldFNlbGVjdGlvbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGROb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGROb2RlcygpIHtcbiAgICAgIHZhciBfY2xhc3NQcml2YXRlRmllbGRHZTtcbiAgICAgIChfY2xhc3NQcml2YXRlRmllbGRHZSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX25vZGVzLCBcImZcIikpLmFkZC5hcHBseShfY2xhc3NQcml2YXRlRmllbGRHZSwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRWRnZXMoKSB7XG4gICAgICB2YXIgX2NsYXNzUHJpdmF0ZUZpZWxkR2UyO1xuICAgICAgKF9jbGFzc1ByaXZhdGVGaWVsZEdlMiA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2VkZ2VzLCBcImZcIikpLmFkZC5hcHBseShfY2xhc3NQcml2YXRlRmllbGRHZTIsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZU5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZU5vZGVzKG5vZGUpIHtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX25vZGVzLCBcImZcIikuZGVsZXRlKG5vZGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVFZGdlcyhlZGdlKSB7XG4gICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9lZGdlcywgXCJmXCIpLmRlbGV0ZShlZGdlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9ub2RlcywgXCJmXCIpLmNsZWFyKCk7XG4gICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9lZGdlcywgXCJmXCIpLmNsZWFyKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbW1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21taXQoKSB7XG4gICAgICB2YXIgX2NsYXNzUHJpdmF0ZUZpZWxkR2UzLCBfY29udGV4dDtcbiAgICAgIHZhciBzdW1tYXJ5ID0ge1xuICAgICAgICBub2RlczogX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3Jfbm9kZXMsIFwiZlwiKS5jb21taXQoKSxcbiAgICAgICAgZWRnZXM6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2VkZ2VzLCBcImZcIikuY29tbWl0KClcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgcmVzdFtfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuICAgICAgKF9jbGFzc1ByaXZhdGVGaWVsZEdlMyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2NvbW1pdEhhbmRsZXIsIFwiZlwiKSkuY2FsbC5hcHBseShfY2xhc3NQcml2YXRlRmllbGRHZTMsIF9jb25jYXRJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0ID0gW3RoaXMsIHN1bW1hcnldKS5jYWxsKF9jb250ZXh0LCByZXN0KSk7XG4gICAgICByZXR1cm4gc3VtbWFyeTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFNlbGVjdGlvbkFjY3VtdWxhdG9yO1xufSgpO1xuX1NlbGVjdGlvbkFjY3VtdWxhdG9yX25vZGVzID0gbmV3IF9XZWFrTWFwKCksIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9lZGdlcyA9IG5ldyBfV2Vha01hcCgpLCBfU2VsZWN0aW9uQWNjdW11bGF0b3JfY29tbWl0SGFuZGxlciA9IG5ldyBfV2Vha01hcCgpO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBfU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIF9nZXRJdGVyYXRvck1ldGhvZChvKSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoX0FycmF5JGlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDIobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDIobywgbWluTGVuKSB7IHZhciBfY29udGV4dDM7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQyKG8sIG1pbkxlbik7IHZhciBuID0gX3NsaWNlSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDMgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpLmNhbGwoX2NvbnRleHQzLCA4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBfQXJyYXkkZnJvbSQxKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDIobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkMihhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuXG4vKipcbiAqIFRoZSBoYW5kbGVyIGZvciBzZWxlY3Rpb25zXG4gKi9cbnZhciBTZWxlY3Rpb25IYW5kbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICovXG4gIGZ1bmN0aW9uIFNlbGVjdGlvbkhhbmRsZXIoYm9keSwgY2FudmFzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VsZWN0aW9uSGFuZGxlcik7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAvLyBUT0RPOiBDb25zaWRlciBmaXJpbmcgYW4gZXZlbnQgb24gYW55IGNoYW5nZSB0byB0aGUgc2VsZWN0aW9uLCBub3RcbiAgICAvLyBvbmx5IHRob3NlIGNhdXNlZCBieSBjbGlja3MgYW5kIHRhcHMuIEl0IHdvdWxkIGJlIGVhc3kgdG8gaW1wbGVtZW50XG4gICAgLy8gbm93IGFuZCAoYXQgbGVhc3QgdG8gbWUpIGl0IHNlZW1zIGxpa2Ugc29tZXRoaW5nIHRoYXQgY291bGQgYmVcbiAgICAvLyBxdWl0ZSB1c2VmdWwuXG4gICAgdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IgPSBuZXcgU2VsZWN0aW9uQWNjdW11bGF0b3IoKTtcbiAgICB0aGlzLmhvdmVyT2JqID0ge1xuICAgICAgbm9kZXM6IHt9LFxuICAgICAgZWRnZXM6IHt9XG4gICAgfTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgbXVsdGlzZWxlY3Q6IGZhbHNlLFxuICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICAgIHNlbGVjdENvbm5lY3RlZEVkZ2VzOiB0cnVlLFxuICAgICAgaG92ZXJDb25uZWN0ZWRFZGdlczogdHJ1ZVxuICAgIH07XG4gICAgX09iamVjdCRhc3NpZ24odGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhQ2hhbmdlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoU2VsZWN0aW9uSGFuZGxlciwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGZpZWxkcyA9IFtcIm11bHRpc2VsZWN0XCIsIFwiaG92ZXJDb25uZWN0ZWRFZGdlc1wiLCBcInNlbGVjdGFibGVcIiwgXCJzZWxlY3RDb25uZWN0ZWRFZGdlc1wiXTtcbiAgICAgICAgc2VsZWN0aXZlRGVlcEV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGFuZGxlcyB0aGUgc2VsZWN0aW9uIHBhcnQgb2YgdGhlIHRhcDtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdE9uUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0T25Qb2ludChwb2ludGVyKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2VsZWN0YWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgb2JqID0gdGhpcy5nZXROb2RlQXQocG9pbnRlcikgfHwgdGhpcy5nZXRFZGdlQXQocG9pbnRlcik7XG5cbiAgICAgICAgLy8gdW5zZWxlY3QgYWZ0ZXIgZ2V0dGluZyB0aGUgb2JqZWN0cyBpbiBvcmRlciB0byByZXN0b3JlIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICAgICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdE9iamVjdChvYmopO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdEFkZGl0aW9uYWxPblBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdEFkZGl0aW9uYWxPblBvaW50KHBvaW50ZXIpIHtcbiAgICAgIHZhciBzZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNlbGVjdGFibGUgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMuZ2V0Tm9kZUF0KHBvaW50ZXIpIHx8IHRoaXMuZ2V0RWRnZUF0KHBvaW50ZXIpO1xuICAgICAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAob2JqLmlzU2VsZWN0ZWQoKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5kZXNlbGVjdE9iamVjdChvYmopO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdE9iamVjdChvYmopO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3Rpb25DaGFuZ2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgc3RhbmRhcmQgZmllbGRzIGZvciBhbiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyIE9iamVjdCB3aXRoIHRoZSB4IGFuZCB5IHNjcmVlbiBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKiBAcmV0dXJucyB7e319XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfaW5pdEJhc2VFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdEJhc2VFdmVudChldmVudCwgcG9pbnRlcikge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgIHByb3BlcnRpZXNbXCJwb2ludGVyXCJdID0ge1xuICAgICAgICBET006IHtcbiAgICAgICAgICB4OiBwb2ludGVyLngsXG4gICAgICAgICAgeTogcG9pbnRlci55XG4gICAgICAgIH0sXG4gICAgICAgIGNhbnZhczogdGhpcy5jYW52YXMuRE9NdG9DYW52YXMocG9pbnRlcilcbiAgICAgIH07XG4gICAgICBwcm9wZXJ0aWVzW1wiZXZlbnRcIl0gPSBldmVudDtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGFuIGV2ZW50IHdoaWNoIHRoZSB1c2VyIGNhbiBjYXRjaC5cbiAgICAgKlxuICAgICAqIFRoaXMgYWRkcyBzb21lIGV4dHJhIGRhdGEgdG8gdGhlIGV2ZW50IHdpdGggcmVzcGVjdCB0byBjdXJzb3IgcG9zaXRpb24gYW5kXG4gICAgICogc2VsZWN0ZWQgbm9kZXMgYW5kIGVkZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSAgICAgICAgICAgICAgICAgICAgICAgICAgTmFtZSBvZiBldmVudCB0byBzZW5kXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50XG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyICAgICAgICAgICAgT2JqZWN0IHdpdGggdGhlIHggYW5kIHkgc2NyZWVuIGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0IHwgdW5kZWZpbmVkfSBvbGRTZWxlY3Rpb24gICAgICAgICAgICAgSWYgcHJlc2VudCwgc2VsZWN0aW9uIHN0YXRlIGJlZm9yZSBldmVudCBvY2N1cmVkXG4gICAgICogQHBhcmFtIHtib29sZWFufHVuZGVmaW5lZH0gW2VtcHR5U2VsZWN0aW9uPWZhbHNlXSAgSW5kaWNhdGUgaWYgc2VsZWN0aW9uIGRhdGEgc2hvdWxkIGJlIHBhc3NlZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdlbmVyYXRlQ2xpY2tFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZUNsaWNrRXZlbnQoZXZlbnRUeXBlLCBldmVudCwgcG9pbnRlciwgb2xkU2VsZWN0aW9uKSB7XG4gICAgICB2YXIgZW1wdHlTZWxlY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLl9pbml0QmFzZUV2ZW50KGV2ZW50LCBwb2ludGVyKTtcbiAgICAgIGlmIChlbXB0eVNlbGVjdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICBwcm9wZXJ0aWVzLm5vZGVzID0gW107XG4gICAgICAgIHByb3BlcnRpZXMuZWRnZXMgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0bXAgPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuICAgICAgICBwcm9wZXJ0aWVzLm5vZGVzID0gdG1wLm5vZGVzO1xuICAgICAgICBwcm9wZXJ0aWVzLmVkZ2VzID0gdG1wLmVkZ2VzO1xuICAgICAgfVxuICAgICAgaWYgKG9sZFNlbGVjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BlcnRpZXNbXCJwcmV2aW91c1NlbGVjdGlvblwiXSA9IG9sZFNlbGVjdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudFR5cGUgPT0gXCJjbGlja1wiKSB7XG4gICAgICAgIC8vIEZvciB0aGUgdGltZSBiZWluZywgcmVzdHJpY3QgdGhpcyBmdW5jdGlvbmFsaXR5IHRvXG4gICAgICAgIC8vIGp1c3QgdGhlIGNsaWNrIGV2ZW50LlxuICAgICAgICBwcm9wZXJ0aWVzLml0ZW1zID0gdGhpcy5nZXRDbGlja2VkSXRlbXMocG9pbnRlcik7XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQuY29udHJvbEVkZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wZXJ0aWVzLmNvbnRyb2xFZGdlID0gZXZlbnQuY29udHJvbEVkZ2U7XG4gICAgICB9XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KGV2ZW50VHlwZSwgcHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaGlnaGxpZ2h0RWRnZXM9dGhpcy5vcHRpb25zLnNlbGVjdENvbm5lY3RlZEVkZ2VzXVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdE9iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RPYmplY3Qob2JqKSB7XG4gICAgICB2YXIgaGlnaGxpZ2h0RWRnZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMub3B0aW9ucy5zZWxlY3RDb25uZWN0ZWRFZGdlcztcbiAgICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgIGlmIChoaWdobGlnaHRFZGdlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzJF9zZWxlY3Rpb25BY2N1bTtcbiAgICAgICAgICAgIChfdGhpcyRfc2VsZWN0aW9uQWNjdW0gPSB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvcikuYWRkRWRnZXMuYXBwbHkoX3RoaXMkX3NlbGVjdGlvbkFjY3VtLCBfdG9Db25zdW1hYmxlQXJyYXkob2JqLmVkZ2VzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmFkZE5vZGVzKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuYWRkRWRnZXMob2JqKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkZXNlbGVjdE9iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXNlbGVjdE9iamVjdChvYmopIHtcbiAgICAgIGlmIChvYmouaXNTZWxlY3RlZCgpID09PSB0cnVlKSB7XG4gICAgICAgIG9iai5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZW1vdmVGcm9tU2VsZWN0aW9uKG9iaik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0cmlldmUgYWxsIG5vZGVzIG92ZXJsYXBwaW5nIHdpdGggZ2l2ZW4gb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0ICBBbiBvYmplY3Qgd2l0aCBwYXJhbWV0ZXJzIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0gICBBbiBhcnJheSB3aXRoIGlkJ3Mgb2YgdGhlIG92ZXJsYXBwaW5nIG5vZGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QWxsTm9kZXNPdmVybGFwcGluZ1dpdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoKG9iamVjdCkge1xuICAgICAgdmFyIG92ZXJsYXBwaW5nTm9kZXMgPSBbXTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlSWQgPSB0aGlzLmJvZHkubm9kZUluZGljZXNbaV07XG4gICAgICAgIGlmIChub2Rlc1tub2RlSWRdLmlzT3ZlcmxhcHBpbmdXaXRoKG9iamVjdCkpIHtcbiAgICAgICAgICBvdmVybGFwcGluZ05vZGVzLnB1c2gobm9kZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG92ZXJsYXBwaW5nTm9kZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgcG9zaXRpb24gb2JqZWN0IGluIGNhbnZhc3NwYWNlIGZyb20gYSBzaW5nbGUgcG9pbnQgaW4gc2NyZWVuc3BhY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgcmlnaHQ6IG51bWJlciwgYm90dG9tOiBudW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChwb2ludGVyKSB7XG4gICAgICB2YXIgY2FudmFzUG9zID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMocG9pbnRlcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBjYW52YXNQb3MueCAtIDEsXG4gICAgICAgIHRvcDogY2FudmFzUG9zLnkgKyAxLFxuICAgICAgICByaWdodDogY2FudmFzUG9zLnggKyAxLFxuICAgICAgICBib3R0b206IGNhbnZhc1Bvcy55IC0gMVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRvcCBub2RlIGF0IHRoZSBwYXNzZWQgcG9pbnQgKGxpa2UgYSBjbGljaylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldHVybk5vZGU9dHJ1ZV1cbiAgICAgKiBAcmV0dXJucyB7Tm9kZSB8IHVuZGVmaW5lZH0gbm9kZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldE5vZGVBdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROb2RlQXQocG9pbnRlcikge1xuICAgICAgdmFyIHJldHVybk5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICAvLyB3ZSBmaXJzdCBjaGVjayBpZiB0aGlzIGlzIGFuIG5hdmlnYXRpb24gY29udHJvbHMgZWxlbWVudFxuICAgICAgdmFyIHBvc2l0aW9uT2JqZWN0ID0gdGhpcy5fcG9pbnRlclRvUG9zaXRpb25PYmplY3QocG9pbnRlcik7XG4gICAgICB2YXIgb3ZlcmxhcHBpbmdOb2RlcyA9IHRoaXMuX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoKHBvc2l0aW9uT2JqZWN0KTtcbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBvdmVybGFwcGluZyBub2Rlcywgc2VsZWN0IHRoZSBsYXN0IG9uZSwgdGhpcyBpcyB0aGVcbiAgICAgIC8vIG9uZSB3aGljaCBpcyBkcmF3biBvbiB0b3Agb2YgdGhlIG90aGVyc1xuICAgICAgaWYgKG92ZXJsYXBwaW5nTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAocmV0dXJuTm9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkubm9kZXNbb3ZlcmxhcHBpbmdOb2Rlc1tvdmVybGFwcGluZ05vZGVzLmxlbmd0aCAtIDFdXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gb3ZlcmxhcHBpbmdOb2Rlc1tvdmVybGFwcGluZ05vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHJpZXZlIGFsbCBlZGdlcyBvdmVybGFwcGluZyB3aXRoIGdpdmVuIG9iamVjdCwgc2VsZWN0b3IgaXMgYXJvdW5kIGNlbnRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCAgQW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBvdmVybGFwcGluZ0VkZ2VzIEFuIGFycmF5IHdpdGggaWQncyBvZiB0aGUgb3ZlcmxhcHBpbmcgbm9kZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXRFZGdlc092ZXJsYXBwaW5nV2l0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RWRnZXNPdmVybGFwcGluZ1dpdGgob2JqZWN0LCBvdmVybGFwcGluZ0VkZ2VzKSB7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5lZGdlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZUlkID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzW2ldO1xuICAgICAgICBpZiAoZWRnZXNbZWRnZUlkXS5pc092ZXJsYXBwaW5nV2l0aChvYmplY3QpKSB7XG4gICAgICAgICAgb3ZlcmxhcHBpbmdFZGdlcy5wdXNoKGVkZ2VJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXRyaWV2ZSBhbGwgbm9kZXMgb3ZlcmxhcHBpbmcgd2l0aCBnaXZlbiBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgIEFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tXG4gICAgICogQHJldHVybnMge251bWJlcltdfSAgIEFuIGFycmF5IHdpdGggaWQncyBvZiB0aGUgb3ZlcmxhcHBpbmcgbm9kZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXRBbGxFZGdlc092ZXJsYXBwaW5nV2l0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QWxsRWRnZXNPdmVybGFwcGluZ1dpdGgob2JqZWN0KSB7XG4gICAgICB2YXIgb3ZlcmxhcHBpbmdFZGdlcyA9IFtdO1xuICAgICAgdGhpcy5fZ2V0RWRnZXNPdmVybGFwcGluZ1dpdGgob2JqZWN0LCBvdmVybGFwcGluZ0VkZ2VzKTtcbiAgICAgIHJldHVybiBvdmVybGFwcGluZ0VkZ2VzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZWRnZXMgbmVhcmVzdCB0byB0aGUgcGFzc2VkIHBvaW50IChsaWtlIGEgY2xpY2spXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXR1cm5FZGdlPXRydWVdXG4gICAgICogQHJldHVybnMge0VkZ2UgfCB1bmRlZmluZWR9IG5vZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRFZGdlQXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWRnZUF0KHBvaW50ZXIpIHtcbiAgICAgIHZhciByZXR1cm5FZGdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgLy8gSXRlcmF0ZSBvdmVyIGVkZ2VzLCBwaWNrIGNsb3Nlc3Qgd2l0aGluIDEwXG4gICAgICB2YXIgY2FudmFzUG9zID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMocG9pbnRlcik7XG4gICAgICB2YXIgbWluZGlzdCA9IDEwO1xuICAgICAgdmFyIG92ZXJsYXBwaW5nRWRnZSA9IG51bGw7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5lZGdlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZUlkID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzW2ldO1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VkZ2VJZF07XG4gICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCkge1xuICAgICAgICAgIHZhciB4RnJvbSA9IGVkZ2UuZnJvbS54O1xuICAgICAgICAgIHZhciB5RnJvbSA9IGVkZ2UuZnJvbS55O1xuICAgICAgICAgIHZhciB4VG8gPSBlZGdlLnRvLng7XG4gICAgICAgICAgdmFyIHlUbyA9IGVkZ2UudG8ueTtcbiAgICAgICAgICB2YXIgZGlzdCA9IGVkZ2UuZWRnZVR5cGUuZ2V0RGlzdGFuY2VUb0VkZ2UoeEZyb20sIHlGcm9tLCB4VG8sIHlUbywgY2FudmFzUG9zLngsIGNhbnZhc1Bvcy55KTtcbiAgICAgICAgICBpZiAoZGlzdCA8IG1pbmRpc3QpIHtcbiAgICAgICAgICAgIG92ZXJsYXBwaW5nRWRnZSA9IGVkZ2VJZDtcbiAgICAgICAgICAgIG1pbmRpc3QgPSBkaXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG92ZXJsYXBwaW5nRWRnZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAocmV0dXJuRWRnZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkuZWRnZXNbb3ZlcmxhcHBpbmdFZGdlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gb3ZlcmxhcHBpbmdFZGdlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBvYmplY3QgdG8gdGhlIHNlbGVjdGlvbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9hZGRUb0hvdmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRUb0hvdmVyKG9iaikge1xuICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgdGhpcy5ob3Zlck9iai5ub2Rlc1tvYmouaWRdID0gb2JqO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ob3Zlck9iai5lZGdlc1tvYmouaWRdID0gb2JqO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHNpbmdsZSBvcHRpb24gZnJvbSBzZWxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfcmVtb3ZlRnJvbVNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlRnJvbVNlbGVjdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyRfc2VsZWN0aW9uQWNjdW0yO1xuICAgICAgICB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5kZWxldGVOb2RlcyhvYmopO1xuICAgICAgICAoX3RoaXMkX3NlbGVjdGlvbkFjY3VtMiA9IHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yKS5kZWxldGVFZGdlcy5hcHBseShfdGhpcyRfc2VsZWN0aW9uQWNjdW0yLCBfdG9Db25zdW1hYmxlQXJyYXkob2JqLmVkZ2VzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5kZWxldGVFZGdlcyhvYmopO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVuc2VsZWN0IGFsbCBub2RlcyBhbmQgZWRnZXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidW5zZWxlY3RBbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zZWxlY3RBbGwoKSB7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5jbGVhcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgbnVtYmVyIG9mIHNlbGVjdGVkIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFNlbGVjdGVkTm9kZUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGVkTm9kZUNvdW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLnNpemVOb2RlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIG51bWJlciBvZiBzZWxlY3RlZCBlZGdlc1xuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZWxlY3RlZEVkZ2VDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWxlY3RlZEVkZ2VDb3VudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5zaXplRWRnZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2VsZWN0IHRoZSBlZGdlcyBjb25uZWN0ZWQgdG8gdGhlIG5vZGUgdGhhdCBpcyBiZWluZyBzZWxlY3RlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfaG92ZXJDb25uZWN0ZWRFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaG92ZXJDb25uZWN0ZWRFZGdlcyhub2RlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBub2RlLmVkZ2VzW2ldO1xuICAgICAgICBlZGdlLmhvdmVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fYWRkVG9Ib3ZlcihlZGdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGhpZ2hsaWdodCBmcm9tIGEgbm9kZSBvciBlZGdlLCBpbiByZXNwb25zZSB0byBtb3VzZSBtb3ZlbWVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50XG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyIG9iamVjdCB3aXRoIHRoZSB4IGFuZCB5IHNjcmVlbiBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKiBAcGFyYW0ge05vZGV8dmlzLkVkZ2V9IG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZW1pdEJsdXJFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0Qmx1ckV2ZW50KGV2ZW50LCBwb2ludGVyLCBvYmplY3QpIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5faW5pdEJhc2VFdmVudChldmVudCwgcG9pbnRlcik7XG4gICAgICBpZiAob2JqZWN0LmhvdmVyID09PSB0cnVlKSB7XG4gICAgICAgIG9iamVjdC5ob3ZlciA9IGZhbHNlO1xuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgIHByb3BlcnRpZXMubm9kZSA9IG9iamVjdC5pZDtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYmx1ck5vZGVcIiwgcHJvcGVydGllcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcGVydGllcy5lZGdlID0gb2JqZWN0LmlkO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJibHVyRWRnZVwiLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgaGlnaGxpZ2h0IGZvciBhIG5vZGUgb3IgZWRnZSwgaW4gcmVzcG9uc2UgdG8gbW91c2UgbW92ZW1lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudFxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlciBvYmplY3Qgd2l0aCB0aGUgeCBhbmQgeSBzY3JlZW4gY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICogQHBhcmFtIHtOb2RlfHZpcy5FZGdlfSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gaG92ZXJDaGFuZ2VkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJlbWl0SG92ZXJFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0SG92ZXJFdmVudChldmVudCwgcG9pbnRlciwgb2JqZWN0KSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuX2luaXRCYXNlRXZlbnQoZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgdmFyIGhvdmVyQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgaWYgKG9iamVjdC5ob3ZlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgb2JqZWN0LmhvdmVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fYWRkVG9Ib3ZlcihvYmplY3QpO1xuICAgICAgICBob3ZlckNoYW5nZWQgPSB0cnVlO1xuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgIHByb3BlcnRpZXMubm9kZSA9IG9iamVjdC5pZDtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiaG92ZXJOb2RlXCIsIHByb3BlcnRpZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BlcnRpZXMuZWRnZSA9IG9iamVjdC5pZDtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiaG92ZXJFZGdlXCIsIHByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaG92ZXJDaGFuZ2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYWN0aW9ucyBpbiByZXNwb25zZSB0byBhIG1vdXNlIG1vdmVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50XG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyIHwgb2JqZWN0IHdpdGggdGhlIHggYW5kIHkgc2NyZWVuIGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImhvdmVyT2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhvdmVyT2JqZWN0KGV2ZW50LCBwb2ludGVyKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gdGhpcy5nZXROb2RlQXQocG9pbnRlcik7XG4gICAgICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5nZXRFZGdlQXQocG9pbnRlcik7XG4gICAgICB9XG4gICAgICB2YXIgaG92ZXJDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAvLyByZW1vdmUgYWxsIG5vZGUgaG92ZXIgaGlnaGxpZ2h0c1xuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuaG92ZXJPYmoubm9kZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmhvdmVyT2JqLm5vZGVzLCBub2RlSWQpKSB7XG4gICAgICAgICAgaWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkIHx8IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgJiYgb2JqZWN0LmlkICE9IG5vZGVJZCB8fCBvYmplY3QgaW5zdGFuY2VvZiBFZGdlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRCbHVyRXZlbnQoZXZlbnQsIHBvaW50ZXIsIHRoaXMuaG92ZXJPYmoubm9kZXNbbm9kZUlkXSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5ob3Zlck9iai5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgaG92ZXJDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZpbmcgYWxsIGVkZ2UgaG92ZXIgaGlnaGxpZ2h0c1xuICAgICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuaG92ZXJPYmouZWRnZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmhvdmVyT2JqLmVkZ2VzLCBlZGdlSWQpKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGhvdmVyIGhhcyBiZWVuIGNoYW5nZWQgaGVyZSBpdCBtZWFucyB0aGF0IHRoZSBub2RlIGhhcyBiZWVuIGhvdmVyZWQgb3ZlciBvciBvZmZcbiAgICAgICAgICAvLyB3ZSB0aGVuIGRvIG5vdCB1c2UgdGhlIGVtaXRCbHVyRXZlbnQgbWV0aG9kIGhlcmUuXG4gICAgICAgICAgaWYgKGhvdmVyQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5ob3Zlck9iai5lZGdlc1tlZGdlSWRdLmhvdmVyID0gZmFsc2U7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5ob3Zlck9iai5lZGdlc1tlZGdlSWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpZiB0aGUgYmx1ciByZW1haW5zIHRoZSBzYW1lIGFuZCB0aGUgb2JqZWN0IGlzIHVuZGVmaW5lZCAobW91c2Ugb2ZmKSBvciBhbm90aGVyXG4gICAgICAgICAgLy8gZWRnZSBoYXMgYmVlbiBob3ZlcmVkLCBvciBhbm90aGVyIG5vZGUgaGFzIGJlZW4gaG92ZXJlZCB3ZSBibHVyIHRoZSBlZGdlLlxuICAgICAgICAgIGVsc2UgaWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkIHx8IG9iamVjdCBpbnN0YW5jZW9mIEVkZ2UgJiYgb2JqZWN0LmlkICE9IGVkZ2VJZCB8fCBvYmplY3QgaW5zdGFuY2VvZiBOb2RlICYmICFvYmplY3QuaG92ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdEJsdXJFdmVudChldmVudCwgcG9pbnRlciwgdGhpcy5ob3Zlck9iai5lZGdlc1tlZGdlSWRdKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmhvdmVyT2JqLmVkZ2VzW2VkZ2VJZF07XG4gICAgICAgICAgICBob3ZlckNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9iamVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBob3ZlcmVkRWRnZXNDb3VudCA9IF9PYmplY3Qka2V5cyh0aGlzLmhvdmVyT2JqLmVkZ2VzKS5sZW5ndGg7XG4gICAgICAgIHZhciBob3ZlcmVkTm9kZXNDb3VudCA9IF9PYmplY3Qka2V5cyh0aGlzLmhvdmVyT2JqLm5vZGVzKS5sZW5ndGg7XG4gICAgICAgIHZhciBuZXdPbmx5SG92ZXJlZEVkZ2UgPSBvYmplY3QgaW5zdGFuY2VvZiBFZGdlICYmIGhvdmVyZWRFZGdlc0NvdW50ID09PSAwICYmIGhvdmVyZWROb2Rlc0NvdW50ID09PSAwO1xuICAgICAgICB2YXIgbmV3T25seUhvdmVyZWROb2RlID0gb2JqZWN0IGluc3RhbmNlb2YgTm9kZSAmJiBob3ZlcmVkRWRnZXNDb3VudCA9PT0gMCAmJiBob3ZlcmVkTm9kZXNDb3VudCA9PT0gMDtcbiAgICAgICAgaWYgKGhvdmVyQ2hhbmdlZCB8fCBuZXdPbmx5SG92ZXJlZEVkZ2UgfHwgbmV3T25seUhvdmVyZWROb2RlKSB7XG4gICAgICAgICAgaG92ZXJDaGFuZ2VkID0gdGhpcy5lbWl0SG92ZXJFdmVudChldmVudCwgcG9pbnRlciwgb2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTm9kZSAmJiB0aGlzLm9wdGlvbnMuaG92ZXJDb25uZWN0ZWRFZGdlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuX2hvdmVyQ29ubmVjdGVkRWRnZXMob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGhvdmVyQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tbWl0IHRoZSBzZWxlY3Rpb24gY2hhbmdlcyBidXQgZG9uJ3QgZW1pdCBhbnkgZXZlbnRzLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNvbW1pdFdpdGhvdXRFbWl0dGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21taXRXaXRob3V0RW1pdHRpbmcoKSB7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5jb21taXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgYW5kIGRlc2VsZWN0IG5vZGVzIGRlcGVuZGluZyBjdXJyZW50IHNlbGVjdGlvbiBjaGFuZ2UuXG4gICAgICpcbiAgICAgKiBGb3IgY2hhbmdpbmcgbm9kZXMsIHNlbGVjdC9kZXNlbGVjdCBldmVudHMgYXJlIGZpcmVkLlxuICAgICAqXG4gICAgICogTk9URTogRm9yIGEgZ2l2ZW4gZWRnZSwgaWYgb25lIGNvbm5lY3Rpbmcgbm9kZSBpcyBkZXNlbGVjdGVkIGFuZCB3aXRoIHRoZVxuICAgICAqIHNhbWUgY2xpY2sgdGhlIG90aGVyIG5vZGUgaXMgc2VsZWN0ZWQsIG5vIGV2ZW50cyBmb3IgdGhlIGVkZ2Ugd2lsbCBmaXJlLiBJdFxuICAgICAqIHdhcyBzZWxlY3RlZCBhbmQgaXQgd2lsbCByZW1haW4gc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXIgLSBUaGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGVcbiAgICAgKiBjbGljaywgdGFwLCBkcmFnZW5k4oCmIHRoYXQgdHJpZ2dlcmVkIHRoaXMuXG4gICAgICogQHBhcmFtIHtVSUV2ZW50fSBldmVudCAtIFRoZSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNvbW1pdEFuZEVtaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tbWl0QW5kRW1pdChwb2ludGVyLCBldmVudCkge1xuICAgICAgdmFyIHNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB2YXIgc2VsZWN0aW9uQ2hhbmdlcyA9IHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmNvbW1pdCgpO1xuICAgICAgdmFyIHByZXZpb3VzU2VsZWN0aW9uID0ge1xuICAgICAgICBub2Rlczogc2VsZWN0aW9uQ2hhbmdlcy5ub2Rlcy5wcmV2aW91cyxcbiAgICAgICAgZWRnZXM6IHNlbGVjdGlvbkNoYW5nZXMuZWRnZXMucHJldmlvdXNcbiAgICAgIH07XG4gICAgICBpZiAoc2VsZWN0aW9uQ2hhbmdlcy5lZGdlcy5kZWxldGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkZXNlbGVjdEVkZ2VcIiwgZXZlbnQsIHBvaW50ZXIsIHByZXZpb3VzU2VsZWN0aW9uKTtcbiAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGlvbkNoYW5nZXMubm9kZXMuZGVsZXRlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZGVzZWxlY3ROb2RlXCIsIGV2ZW50LCBwb2ludGVyLCBwcmV2aW91c1NlbGVjdGlvbik7XG4gICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3Rpb25DaGFuZ2VzLm5vZGVzLmFkZGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJzZWxlY3ROb2RlXCIsIGV2ZW50LCBwb2ludGVyKTtcbiAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGlvbkNoYW5nZXMuZWRnZXMuYWRkZWQubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmdlbmVyYXRlQ2xpY2tFdmVudChcInNlbGVjdEVkZ2VcIiwgZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGZpcmUgdGhlIHNlbGVjdCBldmVudCBpZiBhbnl0aGluZyBoYXMgYmVlbiBzZWxlY3RlZCBvciBkZXNlbGVjdGVkXG4gICAgICBpZiAoc2VsZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgLy8gc2VsZWN0IG9yIHVuc2VsZWN0XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVDbGlja0V2ZW50KFwic2VsZWN0XCIsIGV2ZW50LCBwb2ludGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5vZGUgYW5kIGVkZ2UgaWRzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3tub2RlczogQXJyYXkuPHN0cmluZz4sIGVkZ2VzOiBBcnJheS48c3RyaW5nPn19IEFycmF5cyB3aXRoIHRoZVxuICAgICAqIGlkcyBvZiB0aGUgc2VsZWN0ZWQgbm9kZXMgYW5kIGVkZ2VzLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWxlY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlczogdGhpcy5nZXRTZWxlY3RlZE5vZGVJZHMoKSxcbiAgICAgICAgZWRnZXM6IHRoaXMuZ2V0U2VsZWN0ZWRFZGdlSWRzKClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBub2Rlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgd2l0aCBzZWxlY3RlZCBub2Rlcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZWxlY3RlZE5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGVkTm9kZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZ2V0Tm9kZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGVkZ2VzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSB3aXRoIHNlbGVjdGVkIGVkZ2VzLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFNlbGVjdGVkRWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0ZWRFZGdlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5nZXRFZGdlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbm9kZSBpZHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IHdpdGggdGhlIGlkcyBvZiB0aGUgc2VsZWN0ZWQgbm9kZXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2VsZWN0ZWROb2RlSWRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGVkTm9kZUlkcygpIHtcbiAgICAgIHZhciBfY29udGV4dDtcbiAgICAgIHJldHVybiBfbWFwSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dCA9IHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmdldE5vZGVzKCkpLmNhbGwoX2NvbnRleHQsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLmlkO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBlZGdlIGlkcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgd2l0aCB0aGUgaWRzIG9mIHRoZSBzZWxlY3RlZCBlZGdlcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZWxlY3RlZEVkZ2VJZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0ZWRFZGdlSWRzKCkge1xuICAgICAgdmFyIF9jb250ZXh0MjtcbiAgICAgIHJldHVybiBfbWFwSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDIgPSB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5nZXRFZGdlcygpKS5jYWxsKF9jb250ZXh0MiwgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2UuaWQ7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHt7bm9kZXM6IEFycmF5LjxzdHJpbmc+LCBlZGdlczogQXJyYXkuPHN0cmluZz59fSBzZWxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRTZWxlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgIXNlbGVjdGlvbi5ub2RlcyAmJiAhc2VsZWN0aW9uLmVkZ2VzKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTZWxlY3Rpb24gbXVzdCBiZSBhbiBvYmplY3Qgd2l0aCBub2RlcyBhbmQvb3IgZWRnZXMgcHJvcGVydGllc1wiKTtcbiAgICAgIH1cblxuICAgICAgLy8gZmlyc3QgdW5zZWxlY3QgYW55IHNlbGVjdGVkIG5vZGUsIGlmIG9wdGlvbiBpcyB0cnVlIG9yIHVuZGVmaW5lZFxuICAgICAgaWYgKG9wdGlvbnMudW5zZWxlY3RBbGwgfHwgb3B0aW9ucy51bnNlbGVjdEFsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3Rpb24ubm9kZXMpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIoc2VsZWN0aW9uLm5vZGVzKSxcbiAgICAgICAgICBfc3RlcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIGlkID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tpZF07XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ05vZGUgd2l0aCBpZCBcIicgKyBpZCArICdcIiBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRvbid0IHNlbGVjdCBlZGdlcyB3aXRoIGl0XG4gICAgICAgICAgICB0aGlzLnNlbGVjdE9iamVjdChub2RlLCBvcHRpb25zLmhpZ2hsaWdodEVkZ2VzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGlvbi5lZGdlcykge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIoc2VsZWN0aW9uLmVkZ2VzKSxcbiAgICAgICAgICBfc3RlcDI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBfaWQgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgICB2YXIgZWRnZSA9IHRoaXMuYm9keS5lZGdlc1tfaWRdO1xuICAgICAgICAgICAgaWYgKCFlZGdlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdFZGdlIHdpdGggaWQgXCInICsgX2lkICsgJ1wiIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWxlY3RPYmplY3QoZWRnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuY29tbWl0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2VsZWN0IHplcm8gb3IgbW9yZSBub2RlcyB3aXRoIHRoZSBvcHRpb24gdG8gaGlnaGxpZ2h0IGVkZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdIHwgc3RyaW5nW119IHNlbGVjdGlvbiAgICAgQW4gYXJyYXkgd2l0aCB0aGUgaWRzIG9mIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCBub2Rlcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtoaWdobGlnaHRFZGdlc11cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3ROb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3ROb2RlcyhzZWxlY3Rpb24pIHtcbiAgICAgIHZhciBoaWdobGlnaHRFZGdlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5sZW5ndGggPT09IHVuZGVmaW5lZCkgdGhyb3cgXCJTZWxlY3Rpb24gbXVzdCBiZSBhbiBhcnJheSB3aXRoIGlkc1wiO1xuICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oe1xuICAgICAgICBub2Rlczogc2VsZWN0aW9uXG4gICAgICB9LCB7XG4gICAgICAgIGhpZ2hsaWdodEVkZ2VzOiBoaWdobGlnaHRFZGdlc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2VsZWN0IHplcm8gb3IgbW9yZSBlZGdlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBzZWxlY3Rpb24gICAgIEFuIGFycmF5IHdpdGggdGhlIGlkcyBvZiB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgbm9kZXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0RWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0RWRnZXMoc2VsZWN0aW9uKSB7XG4gICAgICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ubGVuZ3RoID09PSB1bmRlZmluZWQpIHRocm93IFwiU2VsZWN0aW9uIG11c3QgYmUgYW4gYXJyYXkgd2l0aCBpZHNcIjtcbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHtcbiAgICAgICAgZWRnZXM6IHNlbGVjdGlvblxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgdGhlIHNlbGVjdGlvbjogcmVtb3ZlIGlkcyBvZiBub2RlcyB3aGljaCBubyBsb25nZXIgZXhpc3RcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlU2VsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbigpIHtcbiAgICAgIGZvciAodmFyIG5vZGUgaW4gdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZ2V0Tm9kZXMoKSkge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkubm9kZXMsIG5vZGUuaWQpKSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZGVsZXRlTm9kZXMobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGVkZ2UgaW4gdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZ2V0RWRnZXMoKSkge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkuZWRnZXMsIGVkZ2UuaWQpKSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZGVsZXRlRWRnZXMoZWRnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgYWxsIHRoZSB2aXN1YWwgZWxlbWVudHMgY2xpY2tlZCB3aGljaCBhcmUgb24gdGhlIGdpdmVuIHBvaW50LlxuICAgICAqXG4gICAgICogQWxsIGVsZW1lbnRzIGFyZSByZXR1cm5lZDsgdGhpcyBpbmNsdWRlcyBub2RlcywgZWRnZXMgYW5kIHRoZWlyIGxhYmVscy5cbiAgICAgKiBUaGUgb3JkZXIgcmV0dXJuZWQgaXMgZnJvbSBoaWdoZXN0IHRvIGxvd2VzdCwgaS5lLiBlbGVtZW50IDAgb2YgdGhlIHJldHVyblxuICAgICAqIHZhbHVlIGlzIHRoZSB0b3Btb3N0IGl0ZW0gY2xpY2tlZCBvbi5cbiAgICAgKlxuICAgICAqIFRoZSByZXR1cm4gdmFsdWUgY29uc2lzdHMgb2YgYW4gYXJyYXkgb2YgdGhlIGZvbGxvd2luZyBwb3NzaWJsZSBlbGVtZW50czpcbiAgICAgKlxuICAgICAqIC0gYHtub2RlSWQ6bnVtYmVyfWAgICAgICAgICAgICAgLSBub2RlIHdpdGggZ2l2ZW4gaWQgY2xpY2tlZCBvblxuICAgICAqIC0gYHtub2RlSWQ6bnVtYmVyLCBsYWJlbElkOjB9YCAgLSBsYWJlbCBvZiBub2RlIHdpdGggZ2l2ZW4gaWQgY2xpY2tlZCBvblxuICAgICAqIC0gYHtlZGdlSWQ6bnVtYmVyfWAgICAgICAgICAgICAgLSBlZGdlIHdpdGggZ2l2ZW4gaWQgY2xpY2tlZCBvblxuICAgICAqIC0gYHtlZGdlOm51bWJlciwgbGFiZWxJZDowfWAgICAgLSBsYWJlbCBvZiBlZGdlIHdpdGggZ2l2ZW4gaWQgY2xpY2tlZCBvblxuICAgICAqXG4gICAgICogIyMgTk9URVNcbiAgICAgKlxuICAgICAqIC0gQ3VycmVudGx5LCB0aGVyZSBpcyBvbmx5IG9uZSBsYWJlbCBhc3NvY2lhdGVkIHdpdGggYSBub2RlIG9yIGFuIGVkZ2UsXG4gICAgICogICBidXQgdGhpcyBpcyBleHBlY3RlZCB0byBjaGFuZ2Ugc29tZXdoZXJlIGluIHRoZSBmdXR1cmUuXG4gICAgICogLSBTaW5jZSB0aGVyZSBpcyBubyB6LWluZGV4aW5nIHlldCwgaXQgaXMgbm90IHJlYWxseSBwb3NzaWJsZSB0byBzZXQgdGhlIG5vZGVzIGFuZFxuICAgICAqICAgZWRnZXMgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIEZvciB0aGUgdGltZSBiZWluZywgbm9kZXMgY29tZSBmaXJzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7cG9pbnR9IHBvaW50ZXIgIG1vdXNlIHBvc2l0aW9uIGluIHNjcmVlbiBjb29yZGluYXRlc1xuICAgICAqIEByZXR1cm5zIHtBcnJheS48bm9kZUNsaWNrSXRlbXxub2RlTGFiZWxDbGlja0l0ZW18ZWRnZUNsaWNrSXRlbXxlZGdlTGFiZWxDbGlja0l0ZW0+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2xpY2tlZEl0ZW1zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENsaWNrZWRJdGVtcyhwb2ludGVyKSB7XG4gICAgICB2YXIgcG9pbnQgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyhwb2ludGVyKTtcbiAgICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgICAvLyBOb3RlIHJldmVyc2Ugb3JkZXI7IHdlIHdhbnQgdGhlIHRvcG1vc3QgY2xpY2tlZCBpdGVtcyB0byBiZSBmaXJzdCBpbiB0aGUgYXJyYXlcbiAgICAgIC8vIEFsc28gbm90ZSB0aGF0IHNlbGVjdGVkIG5vZGVzIGFyZSBkaXNyZWdhcmRlZCBoZXJlOyB0aGVzZSBub3JtYWxseSBkaXNwbGF5IG9uIHRvcFxuICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgZm9yICh2YXIgaSA9IG5vZGVJbmRpY2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbbm9kZUluZGljZXNbaV1dO1xuICAgICAgICB2YXIgcmV0ID0gbm9kZS5nZXRJdGVtc09uUG9pbnQocG9pbnQpO1xuICAgICAgICBpdGVtcy5wdXNoLmFwcGx5KGl0ZW1zLCByZXQpOyAvLyBBcHBlbmQgdGhlIHJldHVybiB2YWx1ZSB0byB0aGUgcnVubmluZyBsaXN0LlxuICAgICAgfVxuXG4gICAgICB2YXIgZWRnZUluZGljZXMgPSB0aGlzLmJvZHkuZWRnZUluZGljZXM7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICBmb3IgKHZhciBfaSA9IGVkZ2VJbmRpY2VzLmxlbmd0aCAtIDE7IF9pID49IDA7IF9pLS0pIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tlZGdlSW5kaWNlc1tfaV1dO1xuICAgICAgICB2YXIgX3JldCA9IGVkZ2UuZ2V0SXRlbXNPblBvaW50KHBvaW50KTtcbiAgICAgICAgaXRlbXMucHVzaC5hcHBseShpdGVtcywgX3JldCk7IC8vIEFwcGVuZCB0aGUgcmV0dXJuIHZhbHVlIHRvIHRoZSBydW5uaW5nIGxpc3QuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFNlbGVjdGlvbkhhbmRsZXI7XG59KCk7XG5cbnZhciBhcnJheVNsaWNlID0gYXJyYXlTbGljZVNpbXBsZTtcblxudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxudmFyIG1lcmdlU29ydCA9IGZ1bmN0aW9uIChhcnJheSwgY29tcGFyZWZuKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHZhciBtaWRkbGUgPSBmbG9vcihsZW5ndGggLyAyKTtcbiAgcmV0dXJuIGxlbmd0aCA8IDggPyBpbnNlcnRpb25Tb3J0KGFycmF5LCBjb21wYXJlZm4pIDogbWVyZ2UoXG4gICAgYXJyYXksXG4gICAgbWVyZ2VTb3J0KGFycmF5U2xpY2UoYXJyYXksIDAsIG1pZGRsZSksIGNvbXBhcmVmbiksXG4gICAgbWVyZ2VTb3J0KGFycmF5U2xpY2UoYXJyYXksIG1pZGRsZSksIGNvbXBhcmVmbiksXG4gICAgY29tcGFyZWZuXG4gICk7XG59O1xuXG52YXIgaW5zZXJ0aW9uU29ydCA9IGZ1bmN0aW9uIChhcnJheSwgY29tcGFyZWZuKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHZhciBpID0gMTtcbiAgdmFyIGVsZW1lbnQsIGo7XG5cbiAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICBqID0gaTtcbiAgICBlbGVtZW50ID0gYXJyYXlbaV07XG4gICAgd2hpbGUgKGogJiYgY29tcGFyZWZuKGFycmF5W2ogLSAxXSwgZWxlbWVudCkgPiAwKSB7XG4gICAgICBhcnJheVtqXSA9IGFycmF5Wy0tal07XG4gICAgfVxuICAgIGlmIChqICE9PSBpKyspIGFycmF5W2pdID0gZWxlbWVudDtcbiAgfSByZXR1cm4gYXJyYXk7XG59O1xuXG52YXIgbWVyZ2UgPSBmdW5jdGlvbiAoYXJyYXksIGxlZnQsIHJpZ2h0LCBjb21wYXJlZm4pIHtcbiAgdmFyIGxsZW5ndGggPSBsZWZ0Lmxlbmd0aDtcbiAgdmFyIHJsZW5ndGggPSByaWdodC5sZW5ndGg7XG4gIHZhciBsaW5kZXggPSAwO1xuICB2YXIgcmluZGV4ID0gMDtcblxuICB3aGlsZSAobGluZGV4IDwgbGxlbmd0aCB8fCByaW5kZXggPCBybGVuZ3RoKSB7XG4gICAgYXJyYXlbbGluZGV4ICsgcmluZGV4XSA9IChsaW5kZXggPCBsbGVuZ3RoICYmIHJpbmRleCA8IHJsZW5ndGgpXG4gICAgICA/IGNvbXBhcmVmbihsZWZ0W2xpbmRleF0sIHJpZ2h0W3JpbmRleF0pIDw9IDAgPyBsZWZ0W2xpbmRleCsrXSA6IHJpZ2h0W3JpbmRleCsrXVxuICAgICAgOiBsaW5kZXggPCBsbGVuZ3RoID8gbGVmdFtsaW5kZXgrK10gOiByaWdodFtyaW5kZXgrK107XG4gIH0gcmV0dXJuIGFycmF5O1xufTtcblxudmFyIGFycmF5U29ydCA9IG1lcmdlU29ydDtcblxudmFyIHVzZXJBZ2VudCQxID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgZmlyZWZveCA9IHVzZXJBZ2VudCQxLm1hdGNoKC9maXJlZm94XFwvKFxcZCspL2kpO1xuXG52YXIgZW5naW5lRmZWZXJzaW9uID0gISFmaXJlZm94ICYmICtmaXJlZm94WzFdO1xuXG52YXIgVUEgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciBlbmdpbmVJc0llT3JFZGdlID0gL01TSUV8VHJpZGVudC8udGVzdChVQSk7XG5cbnZhciB1c2VyQWdlbnQgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciB3ZWJraXQgPSB1c2VyQWdlbnQubWF0Y2goL0FwcGxlV2ViS2l0XFwvKFxcZCspXFwuLyk7XG5cbnZhciBlbmdpbmVXZWJraXRWZXJzaW9uID0gISF3ZWJraXQgJiYgK3dlYmtpdFsxXTtcblxudmFyICQkMiA9IF9leHBvcnQ7XG52YXIgdW5jdXJyeVRoaXMgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGFDYWxsYWJsZSQxID0gYUNhbGxhYmxlJDc7XG52YXIgdG9PYmplY3QkMSA9IHRvT2JqZWN0JGU7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMSA9IGxlbmd0aE9mQXJyYXlMaWtlJGM7XG52YXIgZGVsZXRlUHJvcGVydHlPclRocm93ID0gZGVsZXRlUHJvcGVydHlPclRocm93JDI7XG52YXIgdG9TdHJpbmcgPSB0b1N0cmluZyRhO1xudmFyIGZhaWxzID0gZmFpbHMkdztcbnZhciBpbnRlcm5hbFNvcnQgPSBhcnJheVNvcnQ7XG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCQyID0gYXJyYXlNZXRob2RJc1N0cmljdCQ2O1xudmFyIEZGID0gZW5naW5lRmZWZXJzaW9uO1xudmFyIElFX09SX0VER0UgPSBlbmdpbmVJc0llT3JFZGdlO1xudmFyIFY4ID0gZW5naW5lVjhWZXJzaW9uO1xudmFyIFdFQktJVCA9IGVuZ2luZVdlYmtpdFZlcnNpb247XG5cbnZhciB0ZXN0ID0gW107XG52YXIgbmF0aXZlU29ydCA9IHVuY3VycnlUaGlzKHRlc3Quc29ydCk7XG52YXIgcHVzaCA9IHVuY3VycnlUaGlzKHRlc3QucHVzaCk7XG5cbi8vIElFOC1cbnZhciBGQUlMU19PTl9VTkRFRklORUQgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHRlc3Quc29ydCh1bmRlZmluZWQpO1xufSk7XG4vLyBWOCBidWdcbnZhciBGQUlMU19PTl9OVUxMID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICB0ZXN0LnNvcnQobnVsbCk7XG59KTtcbi8vIE9sZCBXZWJLaXRcbnZhciBTVFJJQ1RfTUVUSE9EJDEgPSBhcnJheU1ldGhvZElzU3RyaWN0JDIoJ3NvcnQnKTtcblxudmFyIFNUQUJMRV9TT1JUID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZmVhdHVyZSBkZXRlY3Rpb24gY2FuIGJlIHRvbyBzbG93LCBzbyBjaGVjayBlbmdpbmVzIHZlcnNpb25zXG4gIGlmIChWOCkgcmV0dXJuIFY4IDwgNzA7XG4gIGlmIChGRiAmJiBGRiA+IDMpIHJldHVybjtcbiAgaWYgKElFX09SX0VER0UpIHJldHVybiB0cnVlO1xuICBpZiAoV0VCS0lUKSByZXR1cm4gV0VCS0lUIDwgNjAzO1xuXG4gIHZhciByZXN1bHQgPSAnJztcbiAgdmFyIGNvZGUsIGNociwgdmFsdWUsIGluZGV4O1xuXG4gIC8vIGdlbmVyYXRlIGFuIGFycmF5IHdpdGggbW9yZSA1MTIgZWxlbWVudHMgKENoYWtyYSBhbmQgb2xkIFY4IGZhaWxzIG9ubHkgaW4gdGhpcyBjYXNlKVxuICBmb3IgKGNvZGUgPSA2NTsgY29kZSA8IDc2OyBjb2RlKyspIHtcbiAgICBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuXG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICBjYXNlIDY2OiBjYXNlIDY5OiBjYXNlIDcwOiBjYXNlIDcyOiB2YWx1ZSA9IDM7IGJyZWFrO1xuICAgICAgY2FzZSA2ODogY2FzZSA3MTogdmFsdWUgPSA0OyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHZhbHVlID0gMjtcbiAgICB9XG5cbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCA0NzsgaW5kZXgrKykge1xuICAgICAgdGVzdC5wdXNoKHsgazogY2hyICsgaW5kZXgsIHY6IHZhbHVlIH0pO1xuICAgIH1cbiAgfVxuXG4gIHRlc3Quc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYi52IC0gYS52OyB9KTtcblxuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB0ZXN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNociA9IHRlc3RbaW5kZXhdLmsuY2hhckF0KDApO1xuICAgIGlmIChyZXN1bHQuY2hhckF0KHJlc3VsdC5sZW5ndGggLSAxKSAhPT0gY2hyKSByZXN1bHQgKz0gY2hyO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdCAhPT0gJ0RHQkVGSEFDSUpLJztcbn0pO1xuXG52YXIgRk9SQ0VEJDEgPSBGQUlMU19PTl9VTkRFRklORUQgfHwgIUZBSUxTX09OX05VTEwgfHwgIVNUUklDVF9NRVRIT0QkMSB8fCAhU1RBQkxFX1NPUlQ7XG5cbnZhciBnZXRTb3J0Q29tcGFyZSA9IGZ1bmN0aW9uIChjb21wYXJlZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgcmV0dXJuIC0xO1xuICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHJldHVybiAxO1xuICAgIGlmIChjb21wYXJlZm4gIT09IHVuZGVmaW5lZCkgcmV0dXJuICtjb21wYXJlZm4oeCwgeSkgfHwgMDtcbiAgICByZXR1cm4gdG9TdHJpbmcoeCkgPiB0b1N0cmluZyh5KSA/IDEgOiAtMTtcbiAgfTtcbn07XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuc29ydGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb3J0XG4kJDIoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCQxIH0sIHtcbiAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHtcbiAgICBpZiAoY29tcGFyZWZuICE9PSB1bmRlZmluZWQpIGFDYWxsYWJsZSQxKGNvbXBhcmVmbik7XG5cbiAgICB2YXIgYXJyYXkgPSB0b09iamVjdCQxKHRoaXMpO1xuXG4gICAgaWYgKFNUQUJMRV9TT1JUKSByZXR1cm4gY29tcGFyZWZuID09PSB1bmRlZmluZWQgPyBuYXRpdmVTb3J0KGFycmF5KSA6IG5hdGl2ZVNvcnQoYXJyYXksIGNvbXBhcmVmbik7XG5cbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB2YXIgYXJyYXlMZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQxKGFycmF5KTtcbiAgICB2YXIgaXRlbXNMZW5ndGgsIGluZGV4O1xuXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgYXJyYXlMZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGlmIChpbmRleCBpbiBhcnJheSkgcHVzaChpdGVtcywgYXJyYXlbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpbnRlcm5hbFNvcnQoaXRlbXMsIGdldFNvcnRDb21wYXJlKGNvbXBhcmVmbikpO1xuXG4gICAgaXRlbXNMZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQxKGl0ZW1zKTtcbiAgICBpbmRleCA9IDA7XG5cbiAgICB3aGlsZSAoaW5kZXggPCBpdGVtc0xlbmd0aCkgYXJyYXlbaW5kZXhdID0gaXRlbXNbaW5kZXgrK107XG4gICAgd2hpbGUgKGluZGV4IDwgYXJyYXlMZW5ndGgpIGRlbGV0ZVByb3BlcnR5T3JUaHJvdyhhcnJheSwgaW5kZXgrKyk7XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbn0pO1xuXG52YXIgZW50cnlWaXJ0dWFsJDIgPSBlbnRyeVZpcnR1YWwkaTtcblxudmFyIHNvcnQkMyA9IGVudHJ5VmlydHVhbCQyKCdBcnJheScpLnNvcnQ7XG5cbnZhciBpc1Byb3RvdHlwZU9mJDIgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCQyID0gc29ydCQzO1xuXG52YXIgQXJyYXlQcm90b3R5cGUkMiA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIHNvcnQkMiA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuc29ydDtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSQyIHx8IChpc1Byb3RvdHlwZU9mJDIoQXJyYXlQcm90b3R5cGUkMiwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkMi5zb3J0KSA/IG1ldGhvZCQyIDogb3duO1xufTtcblxudmFyIHBhcmVudCQyID0gc29ydCQyO1xuXG52YXIgc29ydCQxID0gcGFyZW50JDI7XG5cbnZhciBzb3J0ID0gc29ydCQxO1xuXG52YXIgX3NvcnRJbnN0YW5jZVByb3BlcnR5ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHNvcnQpO1xuXG52YXIgYUNhbGxhYmxlID0gYUNhbGxhYmxlJDc7XG52YXIgdG9PYmplY3QgPSB0b09iamVjdCRlO1xudmFyIEluZGV4ZWRPYmplY3QgPSBpbmRleGVkT2JqZWN0O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gbGVuZ3RoT2ZBcnJheUxpa2UkYztcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyByZWR1Y2UsIHJlZHVjZVJpZ2h0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfUklHSFQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBjYWxsYmFja2ZuLCBhcmd1bWVudHNMZW5ndGgsIG1lbW8pIHtcbiAgICBhQ2FsbGFibGUoY2FsbGJhY2tmbik7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGF0KTtcbiAgICB2YXIgc2VsZiA9IEluZGV4ZWRPYmplY3QoTyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xuICAgIHZhciBpbmRleCA9IElTX1JJR0hUID8gbGVuZ3RoIC0gMSA6IDA7XG4gICAgdmFyIGkgPSBJU19SSUdIVCA/IC0xIDogMTtcbiAgICBpZiAoYXJndW1lbnRzTGVuZ3RoIDwgMikgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgICAgIG1lbW8gPSBzZWxmW2luZGV4XTtcbiAgICAgICAgaW5kZXggKz0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpbmRleCArPSBpO1xuICAgICAgaWYgKElTX1JJR0hUID8gaW5kZXggPCAwIDogbGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICAgIHRocm93IG5ldyAkVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoO0lTX1JJR0hUID8gaW5kZXggPj0gMCA6IGxlbmd0aCA+IGluZGV4OyBpbmRleCArPSBpKSBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgbWVtbyA9IGNhbGxiYWNrZm4obWVtbywgc2VsZltpbmRleF0sIGluZGV4LCBPKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG59O1xuXG52YXIgYXJyYXlSZWR1Y2UgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlXG4gIGxlZnQ6IGNyZWF0ZU1ldGhvZChmYWxzZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VyaWdodFxuICByaWdodDogY3JlYXRlTWV0aG9kKHRydWUpXG59O1xuXG52YXIgZ2xvYmFsJDEgPSBnbG9iYWwkbjtcbnZhciBjbGFzc29mID0gY2xhc3NvZlJhdyQyO1xuXG52YXIgZW5naW5lSXNOb2RlID0gY2xhc3NvZihnbG9iYWwkMS5wcm9jZXNzKSA9PT0gJ3Byb2Nlc3MnO1xuXG52YXIgJCQxID0gX2V4cG9ydDtcbnZhciAkcmVkdWNlID0gYXJyYXlSZWR1Y2UubGVmdDtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0JDEgPSBhcnJheU1ldGhvZElzU3RyaWN0JDY7XG52YXIgQ0hST01FX1ZFUlNJT04gPSBlbmdpbmVWOFZlcnNpb247XG52YXIgSVNfTk9ERSA9IGVuZ2luZUlzTm9kZTtcblxuLy8gQ2hyb21lIDgwLTgyIGhhcyBhIGNyaXRpY2FsIGJ1Z1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTA0OTk4MlxudmFyIENIUk9NRV9CVUcgPSAhSVNfTk9ERSAmJiBDSFJPTUVfVkVSU0lPTiA+IDc5ICYmIENIUk9NRV9WRVJTSU9OIDwgODM7XG52YXIgRk9SQ0VEID0gQ0hST01FX0JVRyB8fCAhYXJyYXlNZXRob2RJc1N0cmljdCQxKCdyZWR1Y2UnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlXG4kJDEoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBsZW5ndGgsIGxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCQxID0gZW50cnlWaXJ0dWFsJGk7XG5cbnZhciByZWR1Y2UkMyA9IGVudHJ5VmlydHVhbCQxKCdBcnJheScpLnJlZHVjZTtcblxudmFyIGlzUHJvdG90eXBlT2YkMSA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJDEgPSByZWR1Y2UkMztcblxudmFyIEFycmF5UHJvdG90eXBlJDEgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciByZWR1Y2UkMiA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQucmVkdWNlO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJDEgfHwgKGlzUHJvdG90eXBlT2YkMShBcnJheVByb3RvdHlwZSQxLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSQxLnJlZHVjZSkgPyBtZXRob2QkMSA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQkMSA9IHJlZHVjZSQyO1xuXG52YXIgcmVkdWNlJDEgPSBwYXJlbnQkMTtcblxudmFyIHJlZHVjZSA9IHJlZHVjZSQxO1xuXG52YXIgX3JlZHVjZUluc3RhbmNlUHJvcGVydHkgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMocmVkdWNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IF9SZWZsZWN0JGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIV9SZWZsZWN0JGNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoX1JlZmxlY3QkY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKF9SZWZsZWN0JGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogSGVscGVyIGNsYXNzZXMgZm9yIExheW91dEVuZ2luZS5cbiAqXG4gKiBTdHJhdGVneSBwYXR0ZXJuIGZvciB1c2FnZSBvZiBkaXJlY3Rpb24gbWV0aG9kcyBmb3IgaGllcmFyY2hpY2FsIGxheW91dHMuXG4gKi9cbi8qKlxuICogSW50ZXJmYWNlIGRlZmluaXRpb24gZm9yIGRpcmVjdGlvbiBzdHJhdGVneSBjbGFzc2VzLlxuICpcbiAqIFRoaXMgY2xhc3MgZGVzY3JpYmVzIHRoZSBpbnRlcmZhY2UgZm9yIHRoZSBTdHJhdGVneVxuICogcGF0dGVybiBjbGFzc2VzIHVzZWQgdG8gZGlmZmVyZW50aWF0ZSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbFxuICogZGlyZWN0aW9uIG9mIGhpZXJhcmNoaWNhbCByZXN1bHRzLlxuICpcbiAqIEZvciBhIGdpdmVuIGRpcmVjdGlvbiwgb25lIGNvb3JkaW5hdGUgd2lsbCBiZSAnZml4ZWQnLCBtZWFuaW5nIHRoYXQgaXQgaXNcbiAqIGRldGVybWluZWQgYnkgbGV2ZWwuXG4gKiBUaGUgb3RoZXIgY29vcmRpbmF0ZSBpcyAndW5maXhlZCcsIG1lYW5pbmcgdGhhdCB0aGUgbm9kZXMgb24gYSBnaXZlbiBsZXZlbFxuICogY2FuIHN0aWxsIG1vdmUgYWxvbmcgdGhhdCBjb29yZGluYXRlLiBTbzpcbiAqXG4gKiAtIGB2ZXJ0aWNhbGAgbGF5b3V0OiBgeGAgdW5maXhlZCwgYHlgIGZpeGVkIHBlciBsZXZlbFxuICogLSBgaG9yaXpvbnRhbGAgbGF5b3V0OiBgeGAgZml4ZWQgcGVyIGxldmVsLCBgeWAgdW5maXhlZFxuICpcbiAqIFRoZSBsb2NhbCBtZXRob2RzIGFyZSBzdHVicyBhbmQgc2hvdWxkIGJlIHJlZ2FyZGVkIGFzIGFic3RyYWN0LlxuICogRGVyaXZlZCBjbGFzc2VzICoqbXVzdCoqIGltcGxlbWVudCBhbGwgdGhlIG1ldGhvZHMgdGhlbXNlbHZlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgRGlyZWN0aW9uSW50ZXJmYWNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGlyZWN0aW9uSW50ZXJmYWNlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaXJlY3Rpb25JbnRlcmZhY2UpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhEaXJlY3Rpb25JbnRlcmZhY2UsIFt7XG4gICAga2V5OiBcImFic3RyYWN0XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFic3RyYWN0KCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgaW5zdGFudGlhdGUgYWJzdHJhY3QgY2xhc3MhXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSBkdW1teSBjYWxsIHdoaWNoIGlzIHVzZWQgdG8gc3VwcHJlc3MgdGhlIGpzZG9jIGVycm9ycyBvZiB0eXBlOlxuICAgICAqXG4gICAgICogICBcIidwYXJhbScgaXMgYXNzaWduZWQgYSB2YWx1ZSBidXQgbmV2ZXIgdXNlZFwiXG4gICAgICpcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZmFrZV91c2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFrZV91c2UoKSB7XG4gICAgICAvLyBEbyBub3RoaW5nIHNwZWNpYWxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIHRvIHVzZSB0byB0cmFuc2xhdGUgZHluYW1pYyBjdXJ2ZXMgdG8sIGluIHRoZSBjYXNlIG9mIGhpZXJhcmNoaWNhbCBsYXlvdXQuXG4gICAgICogRHluYW1pYyBjdXJ2ZXMgZG8gbm90IHdvcmsgZm9yIHRoZXNlLlxuICAgICAqXG4gICAgICogVGhlIHZhbHVlIHNob3VsZCBiZSBwZXJwZW5kaWN1bGFyIHRvIHRoZSBhY3R1YWwgZGlyZWN0aW9uIG9mIHRoZSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBEaXJlY3Rpb24sIGVpdGhlciAndmVydGljYWwnIG9yICdob3Jpem9udGFsJ1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImN1cnZlVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXJ2ZVR5cGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hYnN0cmFjdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGNvb3JkaW5hdGUgdGhhdCBpcyBub3QgZml4ZWQgZm9yIHRoaXMgZGlyZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIHJlYWRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSBvZiB0aGUgdW5maXhlZCBjb29yZGluYXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9zaXRpb24obm9kZSkge1xuICAgICAgdGhpcy5mYWtlX3VzZShub2RlKTtcbiAgICAgIHJldHVybiB0aGlzLmFic3RyYWN0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiB0aGUgY29vcmRpbmF0ZSB0aGF0IGlzIG5vdCBmaXhlZCBmb3IgdGhpcyBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gYWRqdXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZXZlbF0gaWYgc3BlY2lmaWVkLCB0aGUgaGllcmFyY2h5IGxldmVsIHRoYXQgdGhpcyBub2RlIHNob3VsZCBiZSBmaXhlZCB0b1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBvc2l0aW9uKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgICB2YXIgbGV2ZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZmFrZV91c2Uobm9kZSwgcG9zaXRpb24sIGxldmVsKTtcbiAgICAgIHRoaXMuYWJzdHJhY3QoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHdpZHRoIG9mIGEgdHJlZS5cbiAgICAgKlxuICAgICAqIEEgYHRyZWVgIGhlcmUgaXMgYSBzdWJzZXQgb2Ygbm9kZXMgd2l0aGluIHRoZSBuZXR3b3JrIHdoaWNoIGFyZSBub3QgY29ubmVjdGVkIHRvIG90aGVyIG5vZGVzLFxuICAgICAqIG9ubHkgYW1vbmcgdGhlbXNlbHZlcy4gSW4gZXNzZW5jZSwgaXQgaXMgYSBzdWItbmV0d29yay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggbnVtYmVyIG9mIGEgdHJlZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSB3aWR0aCBvZiBhIHRyZWUgaW4gdGhlIHZpZXcgY29vcmRpbmF0ZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRUcmVlU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUcmVlU2l6ZShpbmRleCkge1xuICAgICAgdGhpcy5mYWtlX3VzZShpbmRleCk7XG4gICAgICByZXR1cm4gdGhpcy5hYnN0cmFjdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNvcnQgYXJyYXkgb2Ygbm9kZXMgb24gdGhlIHVuZml4ZWQgY29vcmRpbmF0ZXMuXG4gICAgICpcbiAgICAgKiBOb3RlOioqIGNocm9tZSBoYXMgbm9uLXN0YWJsZSBzb3J0aW5nIGltcGxlbWVudGF0aW9uLCB3aGljaFxuICAgICAqIGhhcyBhIHRlbmRlbmN5IHRvIGNoYW5nZSB0aGUgb3JkZXIgb2YgdGhlIGFycmF5IGl0ZW1zLFxuICAgICAqIGV2ZW4gaWYgdGhlIGN1c3RvbSBzb3J0IGZ1bmN0aW9uIHJldHVybnMgMC5cbiAgICAgKlxuICAgICAqIEZvciB0aGlzIHJlYXNvbiwgYW4gZXh0ZXJuYWwgc29ydCBpbXBsZW1lbnRhdGlvbiBpcyB1c2VkLFxuICAgICAqIHdoaWNoIGhhcyB0aGUgYWRkZWQgYmVuZWZpdCBvZiBiZWluZyBmYXN0ZXIgdGhhbiB0aGUgc3RhbmRhcmRcbiAgICAgKiBwbGF0Zm9ybXMgaW1wbGVtZW50YXRpb24uIFRoaXMgaGFzIGJlZW4gdmVyaWZpZWQgb24gYG5vZGUuanNgLFxuICAgICAqIGBmaXJlZm94YCBhbmQgYGNocm9tZWAgKGFsbCBsaW51eCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gbm9kZUFycmF5IGFycmF5IG9mIG5vZGVzIHRvIHNvcnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvcnQobm9kZUFycmF5KSB7XG4gICAgICB0aGlzLmZha2VfdXNlKG5vZGVBcnJheSk7XG4gICAgICB0aGlzLmFic3RyYWN0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWduIHRoZSBmaXhlZCBjb29yZGluYXRlIG9mIHRoZSBub2RlIHRvIHRoZSBnaXZlbiBsZXZlbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIGFkanVzdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbCBUaGUgbGV2ZWwgdG8gZml4IHRvXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpeChub2RlLCBsZXZlbCkge1xuICAgICAgdGhpcy5mYWtlX3VzZShub2RlLCBsZXZlbCk7XG4gICAgICB0aGlzLmFic3RyYWN0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGFuIG9mZnNldCB0byB0aGUgdW5maXhlZCBjb29yZGluYXRlIG9mIHRoZSBnaXZlbiBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlSWR9IG5vZGVJZCBJZCBvZiB0aGUgbm9kZSB0byBhZGp1c3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlmZiBPZmZzZXQgdG8gYWRkIHRvIHRoZSB1bmZpeGVkIGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdChub2RlSWQsIGRpZmYpIHtcbiAgICAgIHRoaXMuZmFrZV91c2Uobm9kZUlkLCBkaWZmKTtcbiAgICAgIHRoaXMuYWJzdHJhY3QoKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIERpcmVjdGlvbkludGVyZmFjZTtcbn0oKTtcbi8qKlxuICogVmVydGljYWwgU3RyYXRlZ3lcbiAqXG4gKiBDb29yZGluYXRlIGB5YCBpcyBmaXhlZCBvbiBsZXZlbHMsIGNvb3JkaW5hdGUgYHhgIGlzIHVuZml4ZWQuXG4gKlxuICogQGF1Z21lbnRzIERpcmVjdGlvbkludGVyZmFjZVxuICogQHByaXZhdGVcbiAqL1xudmFyIFZlcnRpY2FsU3RyYXRlZ3kgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9EaXJlY3Rpb25JbnRlcmZhY2UpIHtcbiAgX2luaGVyaXRzKFZlcnRpY2FsU3RyYXRlZ3ksIF9EaXJlY3Rpb25JbnRlcmZhY2UpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFZlcnRpY2FsU3RyYXRlZ3kpO1xuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGxheW91dCByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBMYXlvdXRFbmdpbmUgaW5zdGFuY2UuXG4gICAqL1xuICBmdW5jdGlvbiBWZXJ0aWNhbFN0cmF0ZWd5KGxheW91dCkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmVydGljYWxTdHJhdGVneSk7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICBfdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIF9jcmVhdGVDbGFzcyhWZXJ0aWNhbFN0cmF0ZWd5LCBbe1xuICAgIGtleTogXCJjdXJ2ZVR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3VydmVUeXBlKCkge1xuICAgICAgcmV0dXJuIFwiaG9yaXpvbnRhbFwiO1xuICAgIH1cblxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvc2l0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLng7XG4gICAgfVxuXG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UG9zaXRpb24obm9kZSwgcG9zaXRpb24pIHtcbiAgICAgIHZhciBsZXZlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5sYXlvdXQuaGllcmFyY2hpY2FsLmFkZFRvT3JkZXJpbmcobm9kZSwgbGV2ZWwpO1xuICAgICAgfVxuICAgICAgbm9kZS54ID0gcG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VHJlZVNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJlZVNpemUoaW5kZXgpIHtcbiAgICAgIHZhciByZXMgPSB0aGlzLmxheW91dC5oaWVyYXJjaGljYWwuZ2V0VHJlZVNpemUodGhpcy5sYXlvdXQuYm9keS5ub2RlcywgaW5kZXgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluOiByZXMubWluX3gsXG4gICAgICAgIG1heDogcmVzLm1heF94XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcInNvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29ydChub2RlQXJyYXkpIHtcbiAgICAgIF9zb3J0SW5zdGFuY2VQcm9wZXJ0eShub2RlQXJyYXkpLmNhbGwobm9kZUFycmF5LCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS54IC0gYi54O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpeChub2RlLCBsZXZlbCkge1xuICAgICAgbm9kZS55ID0gdGhpcy5sYXlvdXQub3B0aW9ucy5oaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uICogbGV2ZWw7XG4gICAgICBub2RlLm9wdGlvbnMuZml4ZWQueSA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQobm9kZUlkLCBkaWZmKSB7XG4gICAgICB0aGlzLmxheW91dC5ib2R5Lm5vZGVzW25vZGVJZF0ueCArPSBkaWZmO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVmVydGljYWxTdHJhdGVneTtcbn0oRGlyZWN0aW9uSW50ZXJmYWNlKTtcbi8qKlxuICogSG9yaXpvbnRhbCBTdHJhdGVneVxuICpcbiAqIENvb3JkaW5hdGUgYHhgIGlzIGZpeGVkIG9uIGxldmVscywgY29vcmRpbmF0ZSBgeWAgaXMgdW5maXhlZC5cbiAqXG4gKiBAYXVnbWVudHMgRGlyZWN0aW9uSW50ZXJmYWNlXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgSG9yaXpvbnRhbFN0cmF0ZWd5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRGlyZWN0aW9uSW50ZXJmYWNlMikge1xuICBfaW5oZXJpdHMoSG9yaXpvbnRhbFN0cmF0ZWd5LCBfRGlyZWN0aW9uSW50ZXJmYWNlMik7XG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKEhvcml6b250YWxTdHJhdGVneSk7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbGF5b3V0IHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IExheW91dEVuZ2luZSBpbnN0YW5jZS5cbiAgICovXG4gIGZ1bmN0aW9uIEhvcml6b250YWxTdHJhdGVneShsYXlvdXQpIHtcbiAgICB2YXIgX3RoaXMyO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIb3Jpem9udGFsU3RyYXRlZ3kpO1xuICAgIF90aGlzMiA9IF9zdXBlcjIuY2FsbCh0aGlzKTtcbiAgICBfdGhpczIubGF5b3V0ID0gbGF5b3V0O1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgX2NyZWF0ZUNsYXNzKEhvcml6b250YWxTdHJhdGVneSwgW3tcbiAgICBrZXk6IFwiY3VydmVUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1cnZlVHlwZSgpIHtcbiAgICAgIHJldHVybiBcInZlcnRpY2FsXCI7XG4gICAgfVxuXG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9zaXRpb24obm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUueTtcbiAgICB9XG5cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3NpdGlvbihub2RlLCBwb3NpdGlvbikge1xuICAgICAgdmFyIGxldmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxheW91dC5oaWVyYXJjaGljYWwuYWRkVG9PcmRlcmluZyhub2RlLCBsZXZlbCk7XG4gICAgICB9XG4gICAgICBub2RlLnkgPSBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRUcmVlU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUcmVlU2l6ZShpbmRleCkge1xuICAgICAgdmFyIHJlcyA9IHRoaXMubGF5b3V0LmhpZXJhcmNoaWNhbC5nZXRUcmVlU2l6ZSh0aGlzLmxheW91dC5ib2R5Lm5vZGVzLCBpbmRleCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW46IHJlcy5taW5feSxcbiAgICAgICAgbWF4OiByZXMubWF4X3lcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gIH0sIHtcbiAgICBrZXk6IFwic29ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb3J0KG5vZGVBcnJheSkge1xuICAgICAgX3NvcnRJbnN0YW5jZVByb3BlcnR5KG5vZGVBcnJheSkuY2FsbChub2RlQXJyYXksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnkgLSBiLnk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJmaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZml4KG5vZGUsIGxldmVsKSB7XG4gICAgICBub2RlLnggPSB0aGlzLmxheW91dC5vcHRpb25zLmhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24gKiBsZXZlbDtcbiAgICAgIG5vZGUub3B0aW9ucy5maXhlZC54ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdChub2RlSWQsIGRpZmYpIHtcbiAgICAgIHRoaXMubGF5b3V0LmJvZHkubm9kZXNbbm9kZUlkXS55ICs9IGRpZmY7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBIb3Jpem9udGFsU3RyYXRlZ3k7XG59KERpcmVjdGlvbkludGVyZmFjZSk7XG5cbnZhciAkID0gX2V4cG9ydDtcbnZhciAkZXZlcnkgPSBhcnJheUl0ZXJhdGlvbi5ldmVyeTtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gYXJyYXlNZXRob2RJc1N0cmljdCQ2O1xuXG52YXIgU1RSSUNUX01FVEhPRCA9IGFycmF5TWV0aG9kSXNTdHJpY3QoJ2V2ZXJ5Jyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZXZlcnlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZXZlcnlcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFTVFJJQ1RfTUVUSE9EIH0sIHtcbiAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRldmVyeSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG52YXIgZW50cnlWaXJ0dWFsID0gZW50cnlWaXJ0dWFsJGk7XG5cbnZhciBldmVyeSQzID0gZW50cnlWaXJ0dWFsKCdBcnJheScpLmV2ZXJ5O1xuXG52YXIgaXNQcm90b3R5cGVPZiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kID0gZXZlcnkkMztcblxudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgZXZlcnkkMiA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuZXZlcnk7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUgfHwgKGlzUHJvdG90eXBlT2YoQXJyYXlQcm90b3R5cGUsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlLmV2ZXJ5KSA/IG1ldGhvZCA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQgPSBldmVyeSQyO1xuXG52YXIgZXZlcnkkMSA9IHBhcmVudDtcblxudmFyIGV2ZXJ5ID0gZXZlcnkkMTtcblxudmFyIF9ldmVyeUluc3RhbmNlUHJvcGVydHkgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZXZlcnkpO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBfU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIF9nZXRJdGVyYXRvck1ldGhvZChvKSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoX0FycmF5JGlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDEobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDEobywgbWluTGVuKSB7IHZhciBfY29udGV4dDk7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQxKG8sIG1pbkxlbik7IHZhciBuID0gX3NsaWNlSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpLmNhbGwoX2NvbnRleHQ5LCA4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBfQXJyYXkkZnJvbSQxKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDEobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkMShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuLyoqXHJcbiAqIFRyeSB0byBhc3NpZ24gbGV2ZWxzIHRvIG5vZGVzIGFjY29yZGluZyB0byB0aGVpciBwb3NpdGlvbnMgaW4gdGhlIGN5Y2xpYyDigJxoaWVyYXJjaHnigJ0uXHJcbiAqXHJcbiAqIEBwYXJhbSBub2RlcyAtIFZpc2libGUgbm9kZXMgb2YgdGhlIGdyYXBoLlxyXG4gKiBAcGFyYW0gbGV2ZWxzIC0gSWYgcHJlc2VudCBsZXZlbHMgd2lsbCBiZSBhZGRlZCB0byBpdCwgaWYgbm90IGEgbmV3IG9iamVjdCB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAqIEByZXR1cm5zIFBvcHVsYXRlZCBub2RlIGxldmVscy5cclxuICovXG5mdW5jdGlvbiBmaWxsTGV2ZWxzQnlEaXJlY3Rpb25DeWNsaWMobm9kZXMsIGxldmVscykge1xuICB2YXIgZWRnZXMgPSBuZXcgX1NldCgpO1xuICBfZm9yRWFjaEluc3RhbmNlUHJvcGVydHkobm9kZXMpLmNhbGwobm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIF9jb250ZXh0O1xuICAgIF9mb3JFYWNoSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dCA9IG5vZGUuZWRnZXMpLmNhbGwoX2NvbnRleHQsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICBpZiAoZWRnZS5jb25uZWN0ZWQpIHtcbiAgICAgICAgZWRnZXMuYWRkKGVkZ2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgX2ZvckVhY2hJbnN0YW5jZVByb3BlcnR5KGVkZ2VzKS5jYWxsKGVkZ2VzLCBmdW5jdGlvbiAoZWRnZSkge1xuICAgIHZhciBmcm9tSWQgPSBlZGdlLmZyb20uaWQ7XG4gICAgdmFyIHRvSWQgPSBlZGdlLnRvLmlkO1xuICAgIGlmIChsZXZlbHNbZnJvbUlkXSA9PSBudWxsKSB7XG4gICAgICBsZXZlbHNbZnJvbUlkXSA9IDA7XG4gICAgfVxuICAgIGlmIChsZXZlbHNbdG9JZF0gPT0gbnVsbCB8fCBsZXZlbHNbZnJvbUlkXSA+PSBsZXZlbHNbdG9JZF0pIHtcbiAgICAgIGxldmVsc1t0b0lkXSA9IGxldmVsc1tmcm9tSWRdICsgMTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbGV2ZWxzO1xufVxuLyoqXHJcbiAqIEFzc2lnbiBsZXZlbHMgdG8gbm9kZXMgYWNjb3JkaW5nIHRvIHRoZWlyIHBvc2l0aW9ucyBpbiB0aGUgaGllcmFyY2h5LiBMZWF2ZXMgd2lsbCBiZSBsaW5lZCB1cCBhdCB0aGUgYm90dG9tIGFuZCBhbGwgb3RoZXIgbm9kZXMgYXMgY2xvc2UgdG8gdGhlaXIgY2hpbGRyZW4gYXMgcG9zc2libGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBub2RlcyAtIFZpc2libGUgbm9kZXMgb2YgdGhlIGdyYXBoLlxyXG4gKiBAcmV0dXJucyBQb3B1bGF0ZWQgbm9kZSBsZXZlbHMuXHJcbiAqL1xuZnVuY3Rpb24gZmlsbExldmVsc0J5RGlyZWN0aW9uTGVhdmVzKG5vZGVzKSB7XG4gIHJldHVybiBmaWxsTGV2ZWxzQnlEaXJlY3Rpb24oXG4gIC8vIFBpY2sgb25seSBsZWF2ZXMgKG5vZGVzIHdpdGhvdXQgY2hpbGRyZW4pLlxuICBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBfY29udGV4dDIsIF9jb250ZXh0MztcbiAgICByZXR1cm4gX2V2ZXJ5SW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDIgPSBfZmlsdGVySW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDMgPSBub2RlLmVkZ2VzXG4gICAgLy8gVGFrZSBvbmx5IHZpc2libGUgbm9kZXMgaW50byBhY2NvdW50LlxuICAgICkuY2FsbChfY29udGV4dDMsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICByZXR1cm4gbm9kZXMuaGFzKGVkZ2UudG9JZCk7XG4gICAgfSlcbiAgICAvLyBDaGVjayB0aGF0IGFsbCBlZGdlcyBsZWFkIHRvIHRoaXMgbm9kZSAobGVhZikuXG4gICAgKS5jYWxsKF9jb250ZXh0MiwgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLnRvID09PSBub2RlO1xuICAgIH0pO1xuICB9LFxuICAvLyBVc2UgdGhlIGxvd2VzdCBsZXZlbC5cbiAgZnVuY3Rpb24gKG5ld0xldmVsLCBvbGRMZXZlbCkge1xuICAgIHJldHVybiBvbGRMZXZlbCA+IG5ld0xldmVsO1xuICB9LFxuICAvLyBHbyBhZ2FpbnN0IHRoZSBkaXJlY3Rpb24gb2YgdGhlIGVkZ2VzLlxuICBcImZyb21cIiwgbm9kZXMpO1xufVxuLyoqXHJcbiAqIEFzc2lnbiBsZXZlbHMgdG8gbm9kZXMgYWNjb3JkaW5nIHRvIHRoZWlyIHBvc2l0aW9ucyBpbiB0aGUgaGllcmFyY2h5LiBSb290cyB3aWxsIGJlIGxpbmVkIHVwIGF0IHRoZSB0b3AgYW5kIGFsbCBub2RlcyBhcyBjbG9zZSB0byB0aGVpciBwYXJlbnRzIGFzIHBvc3NpYmxlLlxyXG4gKlxyXG4gKiBAcGFyYW0gbm9kZXMgLSBWaXNpYmxlIG5vZGVzIG9mIHRoZSBncmFwaC5cclxuICogQHJldHVybnMgUG9wdWxhdGVkIG5vZGUgbGV2ZWxzLlxyXG4gKi9cbmZ1bmN0aW9uIGZpbGxMZXZlbHNCeURpcmVjdGlvblJvb3RzKG5vZGVzKSB7XG4gIHJldHVybiBmaWxsTGV2ZWxzQnlEaXJlY3Rpb24oXG4gIC8vIFBpY2sgb25seSByb290cyAobm9kZXMgd2l0aG91dCBwYXJlbnRzKS5cbiAgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgX2NvbnRleHQ0LCBfY29udGV4dDU7XG4gICAgcmV0dXJuIF9ldmVyeUluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQ0ID0gX2ZpbHRlckluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQ1ID0gbm9kZS5lZGdlc1xuICAgIC8vIFRha2Ugb25seSB2aXNpYmxlIG5vZGVzIGludG8gYWNjb3VudC5cbiAgICApLmNhbGwoX2NvbnRleHQ1LCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgcmV0dXJuIG5vZGVzLmhhcyhlZGdlLnRvSWQpO1xuICAgIH0pXG4gICAgLy8gQ2hlY2sgdGhhdCBhbGwgZWRnZXMgbGVhZCBmcm9tIHRoaXMgbm9kZSAocm9vdCkuXG4gICAgKS5jYWxsKF9jb250ZXh0NCwgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLmZyb20gPT09IG5vZGU7XG4gICAgfSk7XG4gIH0sXG4gIC8vIFVzZSB0aGUgaGlnaGVzdCBsZXZlbC5cbiAgZnVuY3Rpb24gKG5ld0xldmVsLCBvbGRMZXZlbCkge1xuICAgIHJldHVybiBvbGRMZXZlbCA8IG5ld0xldmVsO1xuICB9LFxuICAvLyBHbyBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBlZGdlcy5cbiAgXCJ0b1wiLCBub2Rlcyk7XG59XG4vKipcclxuICogQXNzaWduIGxldmVscyB0byBub2RlcyBhY2NvcmRpbmcgdG8gdGhlaXIgcG9zaXRpb25zIGluIHRoZSBoaWVyYXJjaHkuXHJcbiAqXHJcbiAqIEBwYXJhbSBpc0VudHJ5Tm9kZSAtIENoZWNrcyBhbmQgcmV0dXJuIHRydWUgaWYgdGhlIGdyYXBoIHNob3VsZCBiZSB0cmF2ZXJzZWQgZnJvbSB0aGlzIG5vZGUuXHJcbiAqIEBwYXJhbSBzaG91bGRMZXZlbEJlUmVwbGFjZWQgLSBDaGVja3MgYW5kIHJldHVybnMgdHJ1ZSBpZiB0aGUgbGV2ZWwgb2YgZ2l2ZW4gbm9kZSBzaG91bGQgYmUgdXBkYXRlZCB0byB0aGUgbmV3IHZhbHVlLlxyXG4gKiBAcGFyYW0gZGlyZWN0aW9uIC0gV2hldGVyIHRoZSBncmFwaCBzaG91bGQgYmUgdHJhdmVyc2VkIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGVkZ2VzIGBcInRvXCJgIG9yIGluIHRoZSBvdGhlciB3YXkgYFwiZnJvbVwiYC5cclxuICogQHBhcmFtIG5vZGVzIC0gVmlzaWJsZSBub2RlcyBvZiB0aGUgZ3JhcGguXHJcbiAqIEByZXR1cm5zIFBvcHVsYXRlZCBub2RlIGxldmVscy5cclxuICovXG5mdW5jdGlvbiBmaWxsTGV2ZWxzQnlEaXJlY3Rpb24oaXNFbnRyeU5vZGUsIHNob3VsZExldmVsQmVSZXBsYWNlZCwgZGlyZWN0aW9uLCBub2Rlcykge1xuICB2YXIgX2NvbnRleHQ2O1xuICB2YXIgbGV2ZWxzID0gX09iamVjdCRjcmVhdGUkMShudWxsKTtcbiAgLy8gSWYgYWN5Y2xpYywgdGhlIGdyYXBoIGNhbiBiZSB3YWxrZWQgdGhyb3VnaCB3aXRoIChtb3N0IGxpa2VseSB3YXkpIGZld2VyXG4gIC8vIHN0ZXBzIHRoYW4gdGhlIG51bWJlciBiZWxsb3cuIFRoZSBleGFjdCB2YWx1ZSBpc24ndCB0b28gaW1wb3J0YW50IGFzIGxvbmdcbiAgLy8gYXMgaXQncyBxdWljayB0byBjb21wdXRlIChkb2Vzbid0IGltcGFjdCBhY3ljbGljIGdyYXBocyB0b28gbXVjaCksIGlzXG4gIC8vIGhpZ2hlciB0aGFuIHRoZSBudW1iZXIgb2Ygc3RlcHMgYWN0dWFsbHkgbmVlZGVkIChkb2Vzbid0IGN1dCBvZmYgYmVmb3JlXG4gIC8vIGFjeWNsaWMgZ3JhcGggaXMgd2Fsa2VkIHRocm91Z2gpIGFuZCBwcmV2ZW50cyBpbmZpbml0ZSBsb29wcyAoY3V0cyBvZmYgZm9yXG4gIC8vIGN5Y2xpYyBncmFwaHMpLlxuICB2YXIgbGltaXQgPSBfcmVkdWNlSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDYgPSBfdG9Db25zdW1hYmxlQXJyYXkoX3ZhbHVlc0luc3RhbmNlUHJvcGVydHkobm9kZXMpLmNhbGwobm9kZXMpKSkuY2FsbChfY29udGV4dDYsIGZ1bmN0aW9uIChhY2MsIG5vZGUpIHtcbiAgICByZXR1cm4gYWNjICsgMSArIG5vZGUuZWRnZXMubGVuZ3RoO1xuICB9LCAwKTtcbiAgdmFyIGVkZ2VJZFByb3AgPSBkaXJlY3Rpb24gKyBcIklkXCI7XG4gIHZhciBuZXdMZXZlbERpZmYgPSBkaXJlY3Rpb24gPT09IFwidG9cIiA/IDEgOiAtMTtcbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDEobm9kZXMpLFxuICAgIF9zdGVwO1xuICB0cnkge1xuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksXG4gICAgICAgICAgZW50cnlOb2RlSWQgPSBfc3RlcCR2YWx1ZVswXSxcbiAgICAgICAgICBlbnRyeU5vZGUgPSBfc3RlcCR2YWx1ZVsxXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAvLyBTa2lwIGlmIHRoZSBub2RlIGlzIG5vdCB2aXNpYmxlLlxuICAgICAgICAhbm9kZXMuaGFzKGVudHJ5Tm9kZUlkKSB8fFxuICAgICAgICAvLyBTa2lwIGlmIHRoZSBub2RlIGlzIG5vdCBhbiBlbnRyeSBub2RlLlxuICAgICAgICAhaXNFbnRyeU5vZGUoZW50cnlOb2RlKSkge1xuICAgICAgICAgIHJldHVybiAwOyAvLyBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIC8vIExpbmUgdXAgYWxsIHRoZSBlbnRyeSBub2RlcyBvbiBsZXZlbCAwLlxuICAgICAgICBsZXZlbHNbZW50cnlOb2RlSWRdID0gMDtcbiAgICAgICAgdmFyIHN0YWNrID0gW2VudHJ5Tm9kZV07XG4gICAgICAgIHZhciBkb25lID0gMDtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoKSB7XG4gICAgICAgICAgICB2YXIgX2NvbnRleHQ3LCBfY29udGV4dDg7XG4gICAgICAgICAgICBpZiAoIW5vZGVzLmhhcyhlbnRyeU5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgLy8gU2tpcCBpZiB0aGUgbm9kZSBpcyBub3QgdmlzaWJsZS5cbiAgICAgICAgICAgICAgcmV0dXJuIDA7IC8vIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV3TGV2ZWwgPSBsZXZlbHNbbm9kZS5pZF0gKyBuZXdMZXZlbERpZmY7XG4gICAgICAgICAgICBfZm9yRWFjaEluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQ3ID0gX2ZpbHRlckluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQ4ID0gbm9kZS5lZGdlcykuY2FsbChfY29udGV4dDgsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGRpc2Nvbm5lY3RlZCBlZGdlcy5cbiAgICAgICAgICAgICAgICBlZGdlLmNvbm5lY3RlZCAmJlxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBjaXJjdWxhciBlZGdlcy5cbiAgICAgICAgICAgICAgICBlZGdlLnRvICE9PSBlZGdlLmZyb20gJiZcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZWRnZXMgbGVhZGluZyB0byB0aGUgbm9kZSB0aGF0J3MgY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgICAgICAgICAgICBlZGdlW2RpcmVjdGlvbl0gIT09IG5vZGUgJiZcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZWRnZXMgY29ubmVjdGluZyB0byBhbiBpbnZpc2libGUgbm9kZS5cbiAgICAgICAgICAgICAgICBub2Rlcy5oYXMoZWRnZS50b0lkKSAmJlxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlZGdlcyBjb25uZWN0aW5nIGZyb20gYW4gaW52aXNpYmxlIG5vZGUuXG4gICAgICAgICAgICAgICAgbm9kZXMuaGFzKGVkZ2UuZnJvbUlkKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSkpLmNhbGwoX2NvbnRleHQ3LCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgICAgICB2YXIgdGFyZ2V0Tm9kZUlkID0gZWRnZVtlZGdlSWRQcm9wXTtcbiAgICAgICAgICAgICAgdmFyIG9sZExldmVsID0gbGV2ZWxzW3RhcmdldE5vZGVJZF07XG4gICAgICAgICAgICAgIGlmIChvbGRMZXZlbCA9PSBudWxsIHx8IHNob3VsZExldmVsQmVSZXBsYWNlZChuZXdMZXZlbCwgb2xkTGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWxzW3RhcmdldE5vZGVJZF0gPSBuZXdMZXZlbDtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGVkZ2VbZGlyZWN0aW9uXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGRvbmUgPiBsaW1pdCkge1xuICAgICAgICAgICAgICAvLyBUaGlzIHdvdWxkIHJ1biBmb3JldmVyIG9uIGEgY3ljbGljIGdyYXBoLlxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHY6IHtcbiAgICAgICAgICAgICAgICAgIHY6IGZpbGxMZXZlbHNCeURpcmVjdGlvbkN5Y2xpYyhub2RlcywgbGV2ZWxzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICsrZG9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIF9yZXQyO1xuICAgICAgICB3aGlsZSAobm9kZSA9IHN0YWNrLnBvcCgpKSB7XG4gICAgICAgICAgX3JldDIgPSBfbG9vcDIoKTtcbiAgICAgICAgICBpZiAoX3JldDIgPT09IDApIGNvbnRpbnVlO1xuICAgICAgICAgIGlmIChfcmV0MikgcmV0dXJuIF9yZXQyLnY7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfcmV0O1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICBfcmV0ID0gX2xvb3AoKTtcbiAgICAgIGlmIChfcmV0ID09PSAwKSBjb250aW51ZTtcbiAgICAgIGlmIChfcmV0KSByZXR1cm4gX3JldC52O1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG4gIHJldHVybiBsZXZlbHM7XG59XG5cbi8qKlxuICogVGhlcmUncyBhIG1peC11cCB3aXRoIHRlcm1zIGluIHRoZSBjb2RlLiBGb2xsb3dpbmcgYXJlIHRoZSBmb3JtYWwgZGVmaW5pdGlvbnM6XG4gKlxuICogICB0cmVlICAgLSBhIHN0cmljdCBoaWVyYXJjaGljYWwgbmV0d29yaywgaS5lLiBldmVyeSBub2RlIGhhcyBhdCBtb3N0IG9uZSBwYXJlbnRcbiAqICAgZm9yZXN0IC0gYSBjb2xsZWN0aW9uIG9mIHRyZWVzLiBUaGVzZSBkaXN0aW5jdCB0cmVlcyBhcmUgdGh1cyBub3QgY29ubmVjdGVkLlxuICpcbiAqIFNvOlxuICogLSBpbiBhIG5ldHdvcmsgdGhhdCBpcyBub3QgYSB0cmVlLCB0aGVyZSBleGlzdCBub2RlcyB3aXRoIG11bHRpcGxlIHBhcmVudHMuXG4gKiAtIGEgbmV0d29yayBjb25zaXN0aW5nIG9mIHVuY29ubmVjdGVkIHN1Yi1uZXR3b3Jrcywgb2Ygd2hpY2ggYXQgbGVhc3Qgb25lXG4gKiAgIGlzIG5vdCBhIHRyZWUsIGlzIG5vdCBhIGZvcmVzdC5cbiAqXG4gKiBJbiB0aGUgY29kZSwgdGhlIGRlZmluaXRpb25zIGFyZTpcbiAqXG4gKiAgIHRyZWUgICAtIGFueSBkaXNjb25uZWN0ZWQgc3ViLW5ldHdvcmssIHN0cmljdCBoaWVyYXJjaGljYWwgb3Igbm90LlxuICogICBmb3Jlc3QgLSBhIGJ1bmNoIG9mIHRoZXNlIHN1Yi1uZXR3b3Jrc1xuICpcbiAqIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdHJlZSBhbmQgbm90LXRyZWUgaXMgaW1wb3J0YW50IGluIHRoZSBjb2RlLCBub3RhYmx5IHdpdGhpblxuICogdG8gdGhlIGJsb2NrLXNoaWZ0aW5nIGFsZ29yaXRobS4gVGhlIGFsZ29yaXRobSBhc3N1bWVzIGZvcm1hbCB0cmVlcyBhbmQgZmFpbHNcbiAqIGZvciBub3QtdHJlZXMsIG9mdGVuIGluIGEgc3BlY3RhY3VsYXIgbWFubmVyIChzZWFyY2ggZm9yICdleHBsb2RpbmcgbmV0d29yaycgaW4gdGhlIGlzc3VlcykuXG4gKlxuICogSW4gb3JkZXIgdG8gZGlzdGluZ3Vpc2ggdGhlIGRlZmluaXRpb25zIGluIHRoZSBmb2xsb3dpbmcgY29kZSwgdGhlIGFkamVjdGl2ZSAnZm9ybWFsJyBpc1xuICogdXNlZC4gSWYgJ2Zvcm1hbCcgaXMgYWJzZW50LCB5b3UgbXVzdCBhc3N1bWUgdGhlIG5vbi1mb3JtYWwgZGVmaW5pdGlvbi5cbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBOT1RFU1xuICogPT09PT1cbiAqXG4gKiBBIGhpZXJhcmNoaWNhbCBsYXlvdXQgaXMgYSBkaWZmZXJlbnQgdGhpbmcgZnJvbSBhIGhpZXJhcmNoaWNhbCBuZXR3b3JrLlxuICogVGhlIGxheW91dCBpcyBhIHdheSB0byBhcnJhbmdlIHRoZSBub2RlcyBpbiB0aGUgdmlldzsgdGhpcyBjYW4gYmUgZG9uZVxuICogb24gbm9uLWhpZXJhcmNoaWNhbCBuZXR3b3JrcyBhcyB3ZWxsLiBUaGUgY29udmVyc2UgaXMgYWxzbyBwb3NzaWJsZS5cbiAqL1xuXG4vKipcbiAqIENvbnRhaW5lciBmb3IgZGVyaXZlZCBkYXRhIG9uIGN1cnJlbnQgbmV0d29yaywgcmVsYXRpbmcgdG8gaGllcmFyY2h5LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBIaWVyYXJjaGljYWxTdGF0dXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZnVuY3Rpb24gSGllcmFyY2hpY2FsU3RhdHVzKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIaWVyYXJjaGljYWxTdGF0dXMpO1xuICAgIHRoaXMuY2hpbGRyZW5SZWZlcmVuY2UgPSB7fTsgLy8gY2hpbGQgaWQncyBwZXIgbm9kZSBpZFxuICAgIHRoaXMucGFyZW50UmVmZXJlbmNlID0ge307IC8vIHBhcmVudCBpZCdzIHBlciBub2RlIGlkXG4gICAgdGhpcy50cmVlcyA9IHt9OyAvLyB0cmVlIGlkIHBlciBub2RlIGlkOyBpLmUuIHRvIHdoaWNoIHRyZWUgZG9lcyBnaXZlbiBub2RlIGlkIGJlbG9uZ1xuXG4gICAgdGhpcy5kaXN0cmlidXRpb25PcmRlcmluZyA9IHt9OyAvLyBUaGUgbm9kZXMgcGVyIGxldmVsLCBpbiB0aGUgZGlzcGxheSBvcmRlclxuICAgIHRoaXMubGV2ZWxzID0ge307IC8vIGhpZXJhcmNoeSBsZXZlbCBwZXIgbm9kZSBpZFxuICAgIHRoaXMuZGlzdHJpYnV0aW9uSW5kZXggPSB7fTsgLy8gVGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlIGluIHRoZSBsZXZlbCBzb3J0aW5nIG9yZGVyLCBwZXIgbm9kZSBpZC5cblxuICAgIHRoaXMuaXNUcmVlID0gZmFsc2U7IC8vIFRydWUgaWYgY3VycmVudCBuZXR3b3JrIGlzIGEgZm9ybWFsIHRyZWVcbiAgICB0aGlzLnRyZWVJbmRleCA9IC0xOyAvLyBIaWdoZXN0IHRyZWUgaWQgaW4gY3VycmVudCBuZXR3b3JrLlxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgcmVsYXRpb24gYmV0d2VlbiBnaXZlbiBub2RlcyB0byB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlLmlkfSBwYXJlbnROb2RlSWRcbiAgICogQHBhcmFtIHtOb2RlLmlkfSBjaGlsZE5vZGVJZFxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKEhpZXJhcmNoaWNhbFN0YXR1cywgW3tcbiAgICBrZXk6IFwiYWRkUmVsYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUmVsYXRpb24ocGFyZW50Tm9kZUlkLCBjaGlsZE5vZGVJZCkge1xuICAgICAgaWYgKHRoaXMuY2hpbGRyZW5SZWZlcmVuY2VbcGFyZW50Tm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5SZWZlcmVuY2VbcGFyZW50Tm9kZUlkXSA9IFtdO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGlsZHJlblJlZmVyZW5jZVtwYXJlbnROb2RlSWRdLnB1c2goY2hpbGROb2RlSWQpO1xuICAgICAgaWYgKHRoaXMucGFyZW50UmVmZXJlbmNlW2NoaWxkTm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucGFyZW50UmVmZXJlbmNlW2NoaWxkTm9kZUlkXSA9IFtdO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJlbnRSZWZlcmVuY2VbY2hpbGROb2RlSWRdLnB1c2gocGFyZW50Tm9kZUlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgY3VycmVudCBzdGF0ZSBpcyBmb3IgYSBmb3JtYWwgdHJlZSBvciBmb3JtYWwgZm9yZXN0LlxuICAgICAqXG4gICAgICogVGhpcyBpcyB0aGUgY2FzZSBpZiBldmVyeSBub2RlIGhhcyBhdCBtb3N0IG9uZSBwYXJlbnQuXG4gICAgICpcbiAgICAgKiBQcmU6IHBhcmVudFJlZmVyZW5jZSBpbml0J2VkIHByb3Blcmx5IGZvciBjdXJyZW50IG5ldHdvcmtcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjaGVja0lmVHJlZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0lmVHJlZSgpIHtcbiAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5wYXJlbnRSZWZlcmVuY2UpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50UmVmZXJlbmNlW2ldLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aGlzLmlzVHJlZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5pc1RyZWUgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIHNlcGFyYXRlIHRyZWVzIGluIHRoZSBjdXJyZW50IG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm51bVRyZWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG51bVRyZWVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJlZUluZGV4ICsgMTsgLy8gVGhpcyBhc3N1bWVzIHRoZSBpbmRleGVzIGFyZSBhc3NpZ25lZCBjb25zZWNpdGl2ZWx5XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWduIGEgdHJlZSBpZCB0byBhIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdHJlZUlkXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VHJlZUluZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRyZWVJbmRleChub2RlLCB0cmVlSWQpIHtcbiAgICAgIGlmICh0cmVlSWQgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAvLyBEb24ndCBib3RoZXJcblxuICAgICAgaWYgKHRoaXMudHJlZXNbbm9kZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnRyZWVzW25vZGUuaWRdID0gdHJlZUlkO1xuICAgICAgICB0aGlzLnRyZWVJbmRleCA9IE1hdGgubWF4KHRyZWVJZCwgdGhpcy50cmVlSW5kZXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZSBsZXZlbCBmb3IgZ2l2ZW4gaWQgaXMgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIFNldHMgbGV2ZWwgdG8gemVybyBmb3IgZ2l2ZW4gbm9kZSBpZCBpZiBub3QgYWxyZWFkeSBwcmVzZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImVuc3VyZUxldmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuc3VyZUxldmVsKG5vZGVJZCkge1xuICAgICAgaWYgKHRoaXMubGV2ZWxzW25vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxldmVsc1tub2RlSWRdID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIG1heGltdW0gbGV2ZWwgb2YgYSBicmFuY2guXG4gICAgICpcbiAgICAgKiBUT0RPOiBOZXZlciBlbnRlcmVkOyBmaW5kIGEgdGVzdCBjYXNlIHRvIHRlc3QgdGhpcyFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXhMZXZlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXhMZXZlbChub2RlSWQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgYWNjdW11bGF0b3IgPSB7fTtcbiAgICAgIHZhciBfZ2V0TWF4TGV2ZWwgPSBmdW5jdGlvbiBfZ2V0TWF4TGV2ZWwobm9kZUlkKSB7XG4gICAgICAgIGlmIChhY2N1bXVsYXRvcltub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gYWNjdW11bGF0b3Jbbm9kZUlkXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGV2ZWwgPSBfdGhpcy5sZXZlbHNbbm9kZUlkXTtcbiAgICAgICAgaWYgKF90aGlzLmNoaWxkcmVuUmVmZXJlbmNlW25vZGVJZF0pIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBfdGhpcy5jaGlsZHJlblJlZmVyZW5jZVtub2RlSWRdO1xuICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGxldmVsID0gTWF0aC5tYXgobGV2ZWwsIF9nZXRNYXhMZXZlbChjaGlsZHJlbltpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhY2N1bXVsYXRvcltub2RlSWRdID0gbGV2ZWw7XG4gICAgICAgIHJldHVybiBsZXZlbDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX2dldE1heExldmVsKG5vZGVJZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVBXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlQlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImxldmVsRG93bnN0cmVhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZXZlbERvd25zdHJlYW0obm9kZUEsIG5vZGVCKSB7XG4gICAgICBpZiAodGhpcy5sZXZlbHNbbm9kZUIuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gc2V0IGluaXRpYWwgbGV2ZWxcbiAgICAgICAgaWYgKHRoaXMubGV2ZWxzW25vZGVBLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5sZXZlbHNbbm9kZUEuaWRdID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgbGV2ZWxcbiAgICAgICAgdGhpcy5sZXZlbHNbbm9kZUIuaWRdID0gdGhpcy5sZXZlbHNbbm9kZUEuaWRdICsgMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTbWFsbCB1dGlsIG1ldGhvZCB0byBzZXQgdGhlIG1pbmltdW0gbGV2ZWxzIG9mIHRoZSBub2RlcyB0byB6ZXJvLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IG5vZGVzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TWluTGV2ZWxUb1plcm9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TWluTGV2ZWxUb1plcm8obm9kZXMpIHtcbiAgICAgIHZhciBtaW5MZXZlbCA9IDFlOTtcbiAgICAgIC8vIGdldCB0aGUgbWluaW11bSBsZXZlbFxuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIG5vZGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5sZXZlbHNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtaW5MZXZlbCA9IE1hdGgubWluKHRoaXMubGV2ZWxzW25vZGVJZF0sIG1pbkxldmVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gc3VidHJhY3QgdGhlIG1pbmltdW0gZnJvbSB0aGUgc2V0IHNvIHdlIGhhdmUgYSByYW5nZSBzdGFydGluZyBmcm9tIDBcbiAgICAgIGZvciAodmFyIF9ub2RlSWQgaW4gbm9kZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2RlcywgX25vZGVJZCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5sZXZlbHNbX25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5sZXZlbHNbX25vZGVJZF0gLT0gbWluTGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBtaW4gYW5kIG1heCB4eS1jb29yZGluYXRlcyBvZiBhIGdpdmVuIHRyZWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE5vZGU+fSBub2Rlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHt7bWluX3g6IG51bWJlciwgbWF4X3g6IG51bWJlciwgbWluX3k6IG51bWJlciwgbWF4X3k6IG51bWJlcn19XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VHJlZVNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJlZVNpemUobm9kZXMsIGluZGV4KSB7XG4gICAgICB2YXIgbWluX3ggPSAxZTk7XG4gICAgICB2YXIgbWF4X3ggPSAtMWU5O1xuICAgICAgdmFyIG1pbl95ID0gMWU5O1xuICAgICAgdmFyIG1heF95ID0gLTFlOTtcbiAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLnRyZWVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy50cmVlcywgbm9kZUlkKSkge1xuICAgICAgICAgIGlmICh0aGlzLnRyZWVzW25vZGVJZF0gPT09IGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW25vZGVJZF07XG4gICAgICAgICAgICBtaW5feCA9IE1hdGgubWluKG5vZGUueCwgbWluX3gpO1xuICAgICAgICAgICAgbWF4X3ggPSBNYXRoLm1heChub2RlLngsIG1heF94KTtcbiAgICAgICAgICAgIG1pbl95ID0gTWF0aC5taW4obm9kZS55LCBtaW5feSk7XG4gICAgICAgICAgICBtYXhfeSA9IE1hdGgubWF4KG5vZGUueSwgbWF4X3kpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluX3g6IG1pbl94LFxuICAgICAgICBtYXhfeDogbWF4X3gsXG4gICAgICAgIG1pbl95OiBtaW5feSxcbiAgICAgICAgbWF4X3k6IG1heF95XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHR3byBub2RlcyBoYXZlIHRoZSBzYW1lIHBhcmVudChzKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlMVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZTJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdHdvIG5vZGVzIGhhdmUgYSBzYW1lIGFuY2VzdG9yIG5vZGUsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImhhc1NhbWVQYXJlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzU2FtZVBhcmVudChub2RlMSwgbm9kZTIpIHtcbiAgICAgIHZhciBwYXJlbnRzMSA9IHRoaXMucGFyZW50UmVmZXJlbmNlW25vZGUxLmlkXTtcbiAgICAgIHZhciBwYXJlbnRzMiA9IHRoaXMucGFyZW50UmVmZXJlbmNlW25vZGUyLmlkXTtcbiAgICAgIGlmIChwYXJlbnRzMSA9PT0gdW5kZWZpbmVkIHx8IHBhcmVudHMyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzMS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcmVudHMyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHBhcmVudHMxW2ldID09IHBhcmVudHMyW2pdKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0d28gbm9kZXMgYXJlIGluIHRoZSBzYW1lIHRyZWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUxXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlMlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoaXMgaXMgc28sIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImluU2FtZVN1Yk5ldHdvcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5TYW1lU3ViTmV0d29yayhub2RlMSwgbm9kZTIpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyZWVzW25vZGUxLmlkXSA9PT0gdGhpcy50cmVlc1tub2RlMi5pZF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgbGlzdCBvZiB0aGUgZGlzdGluY3QgbGV2ZWxzIGluIHRoZSBjdXJyZW50IG5ldHdvcmtcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRMZXZlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGV2ZWxzKCkge1xuICAgICAgcmV0dXJuIF9PYmplY3Qka2V5cyh0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBub2RlIHRvIHRoZSBvcmRlcmluZyBwZXIgbGV2ZWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFkZFRvT3JkZXJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVG9PcmRlcmluZyhub2RlLCBsZXZlbCkge1xuICAgICAgaWYgKHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1ByZXNlbnQgPSBmYWxzZTtcbiAgICAgIHZhciBjdXJMZXZlbCA9IHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdO1xuICAgICAgZm9yICh2YXIgbiBpbiBjdXJMZXZlbCkge1xuICAgICAgICAvL2lmIChjdXJMZXZlbFtuXS5pZCA9PT0gbm9kZS5pZCkge1xuICAgICAgICBpZiAoY3VyTGV2ZWxbbl0gPT09IG5vZGUpIHtcbiAgICAgICAgICBpc1ByZXNlbnQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzUHJlc2VudCkge1xuICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXS5wdXNoKG5vZGUpO1xuICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbkluZGV4W25vZGUuaWRdID0gdGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF0ubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEhpZXJhcmNoaWNhbFN0YXR1cztcbn0oKTtcbi8qKlxuICogVGhlIExheW91dCBFbmdpbmVcbiAqL1xudmFyIExheW91dEVuZ2luZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKi9cbiAgZnVuY3Rpb24gTGF5b3V0RW5naW5lKGJvZHkpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGF5b3V0RW5naW5lKTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoZXJlIGFsd2F5cyBpcyBzb21lIFJORyBiZWNhdXNlIHRoZSBzZXRPcHRpb25zIG1ldGhvZCB3b24ndFxuICAgIC8vIHNldCBpdCB1bmxlc3MgdGhlcmUncyBhIHNlZWQgZm9yIGl0LlxuICAgIHRoaXMuX3Jlc2V0Uk5HKE1hdGgucmFuZG9tKCkgKyBcIjpcIiArIF9EYXRlJG5vdygpKTtcbiAgICB0aGlzLnNldFBoeXNpY3MgPSBmYWxzZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLm9wdGlvbnNCYWNrdXAgPSB7XG4gICAgICBwaHlzaWNzOiB7fVxuICAgIH07XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHJhbmRvbVNlZWQ6IHVuZGVmaW5lZCxcbiAgICAgIGltcHJvdmVkTGF5b3V0OiB0cnVlLFxuICAgICAgY2x1c3RlclRocmVzaG9sZDogMTUwLFxuICAgICAgaGllcmFyY2hpY2FsOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBsZXZlbFNlcGFyYXRpb246IDE1MCxcbiAgICAgICAgbm9kZVNwYWNpbmc6IDEwMCxcbiAgICAgICAgdHJlZVNwYWNpbmc6IDIwMCxcbiAgICAgICAgYmxvY2tTaGlmdGluZzogdHJ1ZSxcbiAgICAgICAgZWRnZU1pbmltaXphdGlvbjogdHJ1ZSxcbiAgICAgICAgcGFyZW50Q2VudHJhbGl6YXRpb246IHRydWUsXG4gICAgICAgIGRpcmVjdGlvbjogXCJVRFwiLFxuICAgICAgICAvLyBVRCwgRFUsIExSLCBSTFxuICAgICAgICBzb3J0TWV0aG9kOiBcImh1YnNpemVcIiAvLyBodWJzaXplLCBkaXJlY3RlZFxuICAgICAgfVxuICAgIH07XG5cbiAgICBfT2JqZWN0JGFzc2lnbih0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogQmluZHMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoTGF5b3V0RW5naW5lLCBbe1xuICAgIGtleTogXCJiaW5kRXZlbnRMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhQ2hhbmdlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5zZXR1cEhpZXJhcmNoaWNhbExheW91dCgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhTG9hZGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLmxheW91dE5ldHdvcmsoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfcmVzZXRIaWVyYXJjaGljYWxMYXlvdXRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuc2V0dXBIaWVyYXJjaGljYWxMYXlvdXQoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfYWRqdXN0RWRnZXNGb3JIaWVyYXJjaGljYWxMYXlvdXRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMyLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVuYWJsZWQgIT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2V0IHRoZSB0eXBlIG9mIHN0YXRpYyBzbW9vdGggY3VydmUgaW4gY2FzZSBpdCBpcyByZXF1aXJlZFxuICAgICAgICB2YXIgdHlwZSA9IF90aGlzMi5kaXJlY3Rpb24uY3VydmVUeXBlKCk7XG5cbiAgICAgICAgLy8gZm9yY2UgYWxsIGVkZ2VzIGludG8gc3RhdGljIHNtb290aCBjdXJ2ZXMuXG4gICAgICAgIF90aGlzMi5ib2R5LmVtaXR0ZXIuZW1pdChcIl9mb3JjZURpc2FibGVEeW5hbWljQ3VydmVzXCIsIHR5cGUsIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYWxsT3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMsIGFsbE9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGhpZXJhcmNoaWNhbCA9IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWw7XG4gICAgICAgIHZhciBwcmV2SGllcmFyY2hpY2FsU3RhdGUgPSBoaWVyYXJjaGljYWwuZW5hYmxlZDtcbiAgICAgICAgc2VsZWN0aXZlRGVlcEV4dGVuZChbXCJyYW5kb21TZWVkXCIsIFwiaW1wcm92ZWRMYXlvdXRcIiwgXCJjbHVzdGVyVGhyZXNob2xkXCJdLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zLCBcImhpZXJhcmNoaWNhbFwiKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucmFuZG9tU2VlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5fcmVzZXRSTkcob3B0aW9ucy5yYW5kb21TZWVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGllcmFyY2hpY2FsLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAocHJldkhpZXJhcmNoaWNhbFN0YXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyByZWZyZXNoIHRoZSBvdmVycmlkZGVuIG9wdGlvbnMgZm9yIG5vZGVzIGFuZCBlZGdlcy5cbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJyZWZyZXNoXCIsIHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgbGV2ZWwgc2VwYXJhdGlvbiBpcyB0aGUgcmlnaHQgd2F5IHVwXG4gICAgICAgICAgaWYgKGhpZXJhcmNoaWNhbC5kaXJlY3Rpb24gPT09IFwiUkxcIiB8fCBoaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSBcIkRVXCIpIHtcbiAgICAgICAgICAgIGlmIChoaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uID4gMCkge1xuICAgICAgICAgICAgICBoaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiAqPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zZXREaXJlY3Rpb25TdHJhdGVneSgpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVzZXRIaWVyYXJjaGljYWxMYXlvdXRcIik7XG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGUgaGllcmFyY2hpY2FsIHN5c3RlbSBuZWVkcyBpdCdzIG93biBwaHlzaWNzIGFuZCBzbW9vdGggY3VydmUgc2V0dGluZ3MsXG4gICAgICAgICAgLy8gd2UgYWRhcHQgdGhlIG90aGVyIG9wdGlvbnMgaWYgbmVlZGVkLlxuICAgICAgICAgIHJldHVybiB0aGlzLmFkYXB0QWxsT3B0aW9uc0ZvckhpZXJhcmNoaWNhbExheW91dChhbGxPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocHJldkhpZXJhcmNoaWNhbFN0YXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyByZWZyZXNoIHRoZSBvdmVycmlkZGVuIG9wdGlvbnMgZm9yIG5vZGVzIGFuZCBlZGdlcy5cbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJyZWZyZXNoXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZXBFeHRlbmQoYWxsT3B0aW9ucywgdGhpcy5vcHRpb25zQmFja3VwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGxPcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvciB3aXRoIGdpdmVuIHNlZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gc2VlZCAtIFRoZSBzZWVkIHRoYXQgd2lsbCBiZSBmb3J3YXJkZWQgdGhlIHRoZSBSTkcuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc2V0Uk5HXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNldFJORyhzZWVkKSB7XG4gICAgICB0aGlzLmluaXRpYWxSYW5kb21TZWVkID0gc2VlZDtcbiAgICAgIHRoaXMuX3JuZyA9IEFsZWEodGhpcy5pbml0aWFsUmFuZG9tU2VlZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYWxsT3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRhcHRBbGxPcHRpb25zRm9ySGllcmFyY2hpY2FsTGF5b3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkYXB0QWxsT3B0aW9uc0ZvckhpZXJhcmNoaWNhbExheW91dChhbGxPcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBiYWNrdXBQaHlzaWNzID0gdGhpcy5vcHRpb25zQmFja3VwLnBoeXNpY3M7XG5cbiAgICAgICAgLy8gc2V0IHRoZSBwaHlzaWNzXG4gICAgICAgIGlmIChhbGxPcHRpb25zLnBoeXNpY3MgPT09IHVuZGVmaW5lZCB8fCBhbGxPcHRpb25zLnBoeXNpY3MgPT09IHRydWUpIHtcbiAgICAgICAgICBhbGxPcHRpb25zLnBoeXNpY3MgPSB7XG4gICAgICAgICAgICBlbmFibGVkOiBiYWNrdXBQaHlzaWNzLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBiYWNrdXBQaHlzaWNzLmVuYWJsZWQsXG4gICAgICAgICAgICBzb2x2ZXI6IFwiaGllcmFyY2hpY2FsUmVwdWxzaW9uXCJcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJhY2t1cFBoeXNpY3MuZW5hYmxlZCA9IGJhY2t1cFBoeXNpY3MuZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGJhY2t1cFBoeXNpY3MuZW5hYmxlZDtcbiAgICAgICAgICBiYWNrdXBQaHlzaWNzLnNvbHZlciA9IGJhY2t1cFBoeXNpY3Muc29sdmVyIHx8IFwiYmFybmVzSHV0XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihhbGxPcHRpb25zLnBoeXNpY3MpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgYmFja3VwUGh5c2ljcy5lbmFibGVkID0gYWxsT3B0aW9ucy5waHlzaWNzLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhbGxPcHRpb25zLnBoeXNpY3MuZW5hYmxlZDtcbiAgICAgICAgICBiYWNrdXBQaHlzaWNzLnNvbHZlciA9IGFsbE9wdGlvbnMucGh5c2ljcy5zb2x2ZXIgfHwgXCJiYXJuZXNIdXRcIjtcbiAgICAgICAgICBhbGxPcHRpb25zLnBoeXNpY3Muc29sdmVyID0gXCJoaWVyYXJjaGljYWxSZXB1bHNpb25cIjtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxPcHRpb25zLnBoeXNpY3MgIT09IGZhbHNlKSB7XG4gICAgICAgICAgYmFja3VwUGh5c2ljcy5zb2x2ZXIgPSBcImJhcm5lc0h1dFwiO1xuICAgICAgICAgIGFsbE9wdGlvbnMucGh5c2ljcyA9IHtcbiAgICAgICAgICAgIHNvbHZlcjogXCJoaWVyYXJjaGljYWxSZXB1bHNpb25cIlxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgdGhlIHR5cGUgb2Ygc3RhdGljIHNtb290aCBjdXJ2ZSBpbiBjYXNlIGl0IGlzIHJlcXVpcmVkXG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5kaXJlY3Rpb24uY3VydmVUeXBlKCk7XG5cbiAgICAgICAgLy8gZGlzYWJsZSBzbW9vdGggY3VydmVzIGlmIG5vdGhpbmcgaXMgZGVmaW5lZC4gSWYgc21vb3RoIGN1cnZlcyBoYXZlIGJlZW4gdHVybmVkIG9uLFxuICAgICAgICAvLyB0dXJuIHRoZW0gaW50byBzdGF0aWMgc21vb3RoIGN1cnZlcy5cbiAgICAgICAgaWYgKGFsbE9wdGlvbnMuZWRnZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMub3B0aW9uc0JhY2t1cC5lZGdlcyA9IHtcbiAgICAgICAgICAgIHNtb290aDoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiBcImR5bmFtaWNcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgYWxsT3B0aW9ucy5lZGdlcyA9IHtcbiAgICAgICAgICAgIHNtb290aDogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnNCYWNrdXAuZWRnZXMgPSB7XG4gICAgICAgICAgICBzbW9vdGg6IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogXCJkeW5hbWljXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBhbGxPcHRpb25zLmVkZ2VzLnNtb290aCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc0JhY2t1cC5lZGdlcyA9IHtcbiAgICAgICAgICAgICAgc21vb3RoOiBhbGxPcHRpb25zLmVkZ2VzLnNtb290aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoID0ge1xuICAgICAgICAgICAgICBlbmFibGVkOiBhbGxPcHRpb25zLmVkZ2VzLnNtb290aCxcbiAgICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNtb290aCA9IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoO1xuXG4gICAgICAgICAgICAvLyBhbGxvdyBjdXN0b20gdHlwZXMgZXhjZXB0IGZvciBkeW5hbWljXG4gICAgICAgICAgICBpZiAoc21vb3RoLnR5cGUgIT09IHVuZGVmaW5lZCAmJiBzbW9vdGgudHlwZSAhPT0gXCJkeW5hbWljXCIpIHtcbiAgICAgICAgICAgICAgdHlwZSA9IHNtb290aC50eXBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUT0RPOiB0aGlzIGlzIG9wdGlvbnMgbWVyZ2luZzsgc2VlIGlmIHRoZSBzdGFuZGFyZCByb3V0aW5lcyBjYW4gYmUgdXNlZCBoZXJlLlxuICAgICAgICAgICAgdGhpcy5vcHRpb25zQmFja3VwLmVkZ2VzID0ge1xuICAgICAgICAgICAgICBzbW9vdGg6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBzbW9vdGguZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHNtb290aC5lbmFibGVkLFxuICAgICAgICAgICAgICAgIHR5cGU6IHNtb290aC50eXBlID09PSB1bmRlZmluZWQgPyBcImR5bmFtaWNcIiA6IHNtb290aC50eXBlLFxuICAgICAgICAgICAgICAgIHJvdW5kbmVzczogc21vb3RoLnJvdW5kbmVzcyA9PT0gdW5kZWZpbmVkID8gMC41IDogc21vb3RoLnJvdW5kbmVzcyxcbiAgICAgICAgICAgICAgICBmb3JjZURpcmVjdGlvbjogc21vb3RoLmZvcmNlRGlyZWN0aW9uID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IHNtb290aC5mb3JjZURpcmVjdGlvblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBOT1RFOiBDb3B5aW5nIGFuIG9iamVjdCB0byBzZWxmOyB0aGlzIGlzIGJhc2ljYWxseSBzZXR0aW5nIGRlZmF1bHRzIGZvciB1bmRlZmluZWQgdmFyaWFibGVzXG4gICAgICAgICAgICBhbGxPcHRpb25zLmVkZ2VzLnNtb290aCA9IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogc21vb3RoLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBzbW9vdGguZW5hYmxlZCxcbiAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgcm91bmRuZXNzOiBzbW9vdGgucm91bmRuZXNzID09PSB1bmRlZmluZWQgPyAwLjUgOiBzbW9vdGgucm91bmRuZXNzLFxuICAgICAgICAgICAgICBmb3JjZURpcmVjdGlvbjogc21vb3RoLmZvcmNlRGlyZWN0aW9uID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IHNtb290aC5mb3JjZURpcmVjdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3JjZSBhbGwgZWRnZXMgaW50byBzdGF0aWMgc21vb3RoIGN1cnZlcy5cbiAgICAgICAgLy8gT25seSBhcHBsaWVzIHRvIGVkZ2VzIHRoYXQgZG8gbm90IHVzZSB0aGUgZ2xvYmFsIG9wdGlvbnMgZm9yIHNtb290aC5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9mb3JjZURpc2FibGVEeW5hbWljQ3VydmVzXCIsIHR5cGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFsbE9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gbm9kZXNBcnJheVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInBvc2l0aW9uSW5pdGlhbGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc2l0aW9uSW5pdGlhbGx5KG5vZGVzQXJyYXkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVuYWJsZWQgIT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fcmVzZXRSTkcodGhpcy5pbml0aWFsUmFuZG9tU2VlZCk7XG4gICAgICAgIHZhciByYWRpdXMgPSBub2Rlc0FycmF5Lmxlbmd0aCArIDUwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzQXJyYXlbaV07XG4gICAgICAgICAgdmFyIGFuZ2xlID0gMiAqIE1hdGguUEkgKiB0aGlzLl9ybmcoKTtcbiAgICAgICAgICBpZiAobm9kZS54ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vZGUueCA9IHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vZGUueSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub2RlLnkgPSByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIEthbWFkYSBLYXdhaSB0byBwb3NpdGlvbiBub2Rlcy4gVGhpcyBpcyBxdWl0ZSBhIGhlYXZ5IGFsZ29yaXRobSBzbyBpZiB0aGVyZSBhcmUgYSBsb3Qgb2Ygbm9kZXMgd2VcbiAgICAgKiBjbHVzdGVyIHRoZW0gZmlyc3QgdG8gcmVkdWNlIHRoZSBhbW91bnQuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwibGF5b3V0TmV0d29ya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsYXlvdXROZXR3b3JrKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCAhPT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuaW1wcm92ZWRMYXlvdXQgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG5cbiAgICAgICAgLy8gZmlyc3QgY2hlY2sgaWYgd2Ugc2hvdWxkIEthbWFkYSBLYXdhaSB0byBsYXlvdXQuIFRoZSB0aHJlc2hvbGQgaXMgaWYgbGVzcyB0aGFuIGhhbGYgb2YgdGhlIHZpc2libGVcbiAgICAgICAgLy8gbm9kZXMgaGF2ZSBwcmVkZWZpbmVkIHBvc2l0aW9ucyB3ZSB1c2UgdGhpcy5cbiAgICAgICAgdmFyIHBvc2l0aW9uRGVmaW5lZCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW2luZGljZXNbaV1dO1xuICAgICAgICAgIGlmIChub2RlLnByZWRlZmluZWRQb3NpdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcG9zaXRpb25EZWZpbmVkICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbGVzcyB0aGFuIGhhbGYgb2YgdGhlIG5vZGVzIGhhdmUgYSBwcmVkZWZpbmVkIHBvc2l0aW9uIHdlIGNvbnRpbnVlXG4gICAgICAgIGlmIChwb3NpdGlvbkRlZmluZWQgPCAwLjUgKiBpbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBNQVhfTEVWRUxTID0gMTA7XG4gICAgICAgICAgdmFyIGxldmVsID0gMDtcbiAgICAgICAgICB2YXIgY2x1c3RlclRocmVzaG9sZCA9IHRoaXMub3B0aW9ucy5jbHVzdGVyVGhyZXNob2xkO1xuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBEZWZpbmUgdGhlIG9wdGlvbnMgZm9yIHRoZSBoaWRkZW4gY2x1c3RlciBub2Rlc1xuICAgICAgICAgIC8vIFRoZXNlIG9wdGlvbnMgZG9uJ3QgcHJvcGFnYXRlIG91dHNpZGUgdGhlIGNsdXN0ZXJpbmcgcGhhc2UuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBTb21lIG9wdGlvbnMgYXJlIGV4cGxpY2l0bHkgZGlzYWJsZWQsIGJlY2F1c2UgdGhleSBtYXkgYmUgc2V0IGluIGdyb3VwIG9yIGRlZmF1bHQgbm9kZSBvcHRpb25zLlxuICAgICAgICAgIC8vIFRoZSBjbHVzdGVycyBhcmUgbmV2ZXIgZGlzcGxheWVkLCBzbyBtb3N0IGV4cGxpY2l0IHNldHRpbmdzIGhlcmUgc2VydmUgYXMgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9ucy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFRoZSBleHBsaWNpdCBzZXR0aW5nIG9mICdzaGFwZScgaXMgdG8gYXZvaWQgYHNoYXBlOiAnaW1hZ2UnYDsgaW1hZ2VzIGFyZSBub3QgcGFzc2VkIHRvIHRoZSBoaWRkZW5cbiAgICAgICAgICAvLyBjbHVzdGVyIG5vZGVzLCBsZWFkaW5nIHRvIGFuIGV4Y2VwdGlvbiBvbiBjcmVhdGlvbi5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIEFsbCBzZXR0aW5ncyBoZXJlIGFyZSBwZXJmb3JtYW5jZSByZWxhdGVkLCBleGNlcHQgd2hlbiBub3RlZCBvdGhlcndpc2UuXG4gICAgICAgICAgLy9cbiAgICAgICAgICB2YXIgY2x1c3Rlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgc2hhcGU6IFwiZWxsaXBzZVwiLFxuICAgICAgICAgICAgICAvLyBCdWdmaXg6IGF2b2lkIHR5cGUgJ2ltYWdlJywgbm8gaW1hZ2VzIHN1cHBsaWVkXG4gICAgICAgICAgICAgIGxhYmVsOiBcIlwiLFxuICAgICAgICAgICAgICAvLyBhdm9pZCBsYWJlbCBoYW5kbGluZ1xuICAgICAgICAgICAgICBncm91cDogXCJcIixcbiAgICAgICAgICAgICAgLy8gYXZvaWQgZ3JvdXAgaGFuZGxpbmdcbiAgICAgICAgICAgICAgZm9udDoge1xuICAgICAgICAgICAgICAgIG11bHRpOiBmYWxzZVxuICAgICAgICAgICAgICB9IC8vIGF2b2lkIGZvbnQgcHJvcGFnYXRpb25cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNsdXN0ZXJFZGdlUHJvcGVydGllczoge1xuICAgICAgICAgICAgICBsYWJlbDogXCJcIixcbiAgICAgICAgICAgICAgLy8gYXZvaWQgbGFiZWwgaGFuZGxpbmdcbiAgICAgICAgICAgICAgZm9udDoge1xuICAgICAgICAgICAgICAgIG11bHRpOiBmYWxzZVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAvLyBhdm9pZCBmb250IHByb3BhZ2F0aW9uXG4gICAgICAgICAgICAgIHNtb290aDoge1xuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlIC8vIGF2b2lkIGRyYXdpbmcgcGVuYWx0eSBmb3IgY29tcGxleCBlZGdlc1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBhIGxvdCBvZiBub2Rlcywgd2UgY2x1c3RlciBiZWZvcmUgd2UgcnVuIHRoZSBhbGdvcml0aG0uXG4gICAgICAgICAgLy8gTk9URTogdGhpcyBwYXJ0IGZhaWxzIHRvIGZpbmQgY2x1c3RlcnMgZm9yIGxhcmdlIHNjYWxlLWZyZWUgbmV0d29ya3MsIHdoaWNoIHNob3VsZFxuICAgICAgICAgIC8vICAgICAgIGJlIGVhc2lseSBjbHVzdGVyYWJsZS5cbiAgICAgICAgICAvLyBUT0RPOiBleGFtaW5lIHdoeSB0aGlzIGlzIHNvXG4gICAgICAgICAgaWYgKGluZGljZXMubGVuZ3RoID4gY2x1c3RlclRocmVzaG9sZCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0TGVuZ3RoID0gaW5kaWNlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaW5kaWNlcy5sZW5ndGggPiBjbHVzdGVyVGhyZXNob2xkICYmIGxldmVsIDw9IE1BWF9MRVZFTFMpIHtcbiAgICAgICAgICAgICAgLy9jb25zb2xlLnRpbWUoXCJjbHVzdGVyaW5nXCIpXG4gICAgICAgICAgICAgIGxldmVsICs9IDE7XG4gICAgICAgICAgICAgIHZhciBiZWZvcmUgPSBpbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG1hbnkgbm9kZXMgd2UgZG8gYSBodWJzaXplIGNsdXN0ZXJcbiAgICAgICAgICAgICAgaWYgKGxldmVsICUgMyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5tb2R1bGVzLmNsdXN0ZXJpbmcuY2x1c3RlckJyaWRnZXMoY2x1c3Rlck9wdGlvbnMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5tb2R1bGVzLmNsdXN0ZXJpbmcuY2x1c3Rlck91dGxpZXJzKGNsdXN0ZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgYWZ0ZXIgPSBpbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKGJlZm9yZSA9PSBhZnRlciAmJiBsZXZlbCAlIDMgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWNsdXN0ZXJBbGwoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2xheW91dEZhaWxlZFwiKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCJUaGlzIG5ldHdvcmsgY291bGQgbm90IGJlIHBvc2l0aW9uZWQgYnkgdGhpcyB2ZXJzaW9uIG9mIHRoZSBpbXByb3ZlZCBsYXlvdXQgYWxnb3JpdGhtLlwiICsgXCIgUGxlYXNlIGRpc2FibGUgaW1wcm92ZWRMYXlvdXQgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vY29uc29sZS50aW1lRW5kKFwiY2x1c3RlcmluZ1wiKVxuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGJlZm9yZSxsZXZlbCxhZnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpbmNyZWFzZSB0aGUgc2l6ZSBvZiB0aGUgZWRnZXNcbiAgICAgICAgICAgIHRoaXMuYm9keS5tb2R1bGVzLmthbWFkYUthd2FpLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICBzcHJpbmdMZW5ndGg6IE1hdGgubWF4KDE1MCwgMiAqIHN0YXJ0TGVuZ3RoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsZXZlbCA+IE1BWF9MRVZFTFMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlRoZSBjbHVzdGVyaW5nIGRpZG4ndCBzdWNjZWVkIHdpdGhpbiB0aGUgYW1vdW50IG9mIGludGVyYXRpb25zIGFsbG93ZWQsXCIgKyBcIiBwcm9ncmVzc2luZyB3aXRoIHBhcnRpYWwgcmVzdWx0LlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBwb3NpdGlvbiB0aGUgc3lzdGVtIGZvciB0aGVzZSBub2RlcyBhbmQgZWRnZXNcbiAgICAgICAgICB0aGlzLmJvZHkubW9kdWxlcy5rYW1hZGFLYXdhaS5zb2x2ZShpbmRpY2VzLCB0aGlzLmJvZHkuZWRnZUluZGljZXMsIHRydWUpO1xuXG4gICAgICAgICAgLy8gc2hpZnQgdG8gY2VudGVyIHBvaW50XG4gICAgICAgICAgdGhpcy5fc2hpZnRUb0NlbnRlcigpO1xuXG4gICAgICAgICAgLy8gcGVydHVyYiB0aGUgbm9kZXMgYSBsaXR0bGUgYml0IHRvIGZvcmNlIHRoZSBwaHlzaWNzIHRvIGtpY2sgaW5cbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gNzA7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGluZGljZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHBlcnR1cmIgdGhlIG5vZGVzIHRoYXQgYXJlbid0IGZpeGVkXG4gICAgICAgICAgICB2YXIgX25vZGUgPSB0aGlzLmJvZHkubm9kZXNbaW5kaWNlc1tfaV1dO1xuICAgICAgICAgICAgaWYgKF9ub2RlLnByZWRlZmluZWRQb3NpdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgX25vZGUueCArPSAoMC41IC0gdGhpcy5fcm5nKCkpICogb2Zmc2V0O1xuICAgICAgICAgICAgICBfbm9kZS55ICs9ICgwLjUgLSB0aGlzLl9ybmcoKSkgKiBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdW5jbHVzdGVyIGFsbCBjbHVzdGVyc1xuICAgICAgICAgIHRoaXMuX2RlY2x1c3RlckFsbCgpO1xuXG4gICAgICAgICAgLy8gcmVwb3NpdGlvbiBhbGwgYmV6aWVyIG5vZGVzLlxuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVwb3NpdGlvbkJlemllck5vZGVzXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZSBhbGwgdGhlIG5vZGVzIHRvd2FyZHMgdG8gdGhlIGNlbnRlciBzbyBncmF2aXRhdGlvbmFsIHB1bGwgd2lsIG5vdCBtb3ZlIHRoZSBub2RlcyBhd2F5IGZyb20gdmlld1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfc2hpZnRUb0NlbnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hpZnRUb0NlbnRlcigpIHtcbiAgICAgIHZhciByYW5nZSA9IE5ldHdvcmtVdGlsLmdldFJhbmdlQ29yZSh0aGlzLmJvZHkubm9kZXMsIHRoaXMuYm9keS5ub2RlSW5kaWNlcyk7XG4gICAgICB2YXIgY2VudGVyID0gTmV0d29ya1V0aWwuZmluZENlbnRlcihyYW5nZSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbaV1dO1xuICAgICAgICBub2RlLnggLT0gY2VudGVyLng7XG4gICAgICAgIG5vZGUueSAtPSBjZW50ZXIueTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIGFsbCBjbHVzdGVyc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZGVjbHVzdGVyQWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWNsdXN0ZXJBbGwoKSB7XG4gICAgICB2YXIgY2x1c3RlcnNQcmVzZW50ID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChjbHVzdGVyc1ByZXNlbnQgPT09IHRydWUpIHtcbiAgICAgICAgY2x1c3RlcnNQcmVzZW50ID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbaV1dLmlzQ2x1c3RlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY2x1c3RlcnNQcmVzZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5tb2R1bGVzLmNsdXN0ZXJpbmcub3BlbkNsdXN0ZXIodGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldLCB7fSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2x1c3RlcnNQcmVzZW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcnwqfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFNlZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmluaXRpYWxSYW5kb21TZWVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIG1haW4gZnVuY3Rpb24gdG8gbGF5b3V0IHRoZSBub2RlcyBpbiBhIGhpZXJhcmNoaWNhbCB3YXkuXG4gICAgICogSXQgY2hlY2tzIGlmIHRoZSBub2RlIGRldGFpbHMgYXJlIHN1cHBsaWVkIGNvcnJlY3RseVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXR1cEhpZXJhcmNoaWNhbExheW91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cEhpZXJhcmNoaWNhbExheW91dCgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVuYWJsZWQgPT09IHRydWUgJiYgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gZ2V0IHRoZSBzaXplIG9mIHRoZSBsYXJnZXN0IGh1YnMgYW5kIGNoZWNrIGlmIHRoZSB1c2VyIGhhcyBkZWZpbmVkIGEgbGV2ZWwgZm9yIGEgbm9kZS5cbiAgICAgICAgdmFyIG5vZGUsIG5vZGVJZDtcbiAgICAgICAgdmFyIGRlZmluZWRMZXZlbCA9IGZhbHNlO1xuICAgICAgICB2YXIgdW5kZWZpbmVkTGV2ZWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYXN0Tm9kZU9uTGV2ZWwgPSB7fTtcbiAgICAgICAgdGhpcy5oaWVyYXJjaGljYWwgPSBuZXcgSGllcmFyY2hpY2FsU3RhdHVzKCk7XG4gICAgICAgIGZvciAobm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5Lm5vZGVzLCBub2RlSWQpKSB7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgICBpZiAobm9kZS5vcHRpb25zLmxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZGVmaW5lZExldmVsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy5oaWVyYXJjaGljYWwubGV2ZWxzW25vZGVJZF0gPSBub2RlLm9wdGlvbnMubGV2ZWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1bmRlZmluZWRMZXZlbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIHVzZXIgZGVmaW5lZCBzb21lIGxldmVscyBidXQgbm90IGFsbCwgYWxlcnQgYW5kIHJ1biB3aXRob3V0IGhpZXJhcmNoaWNhbCBsYXlvdXRcbiAgICAgICAgaWYgKHVuZGVmaW5lZExldmVsID09PSB0cnVlICYmIGRlZmluZWRMZXZlbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvIHVzZSB0aGUgaGllcmFyY2hpY2FsIGxheW91dCwgbm9kZXMgcmVxdWlyZSBlaXRoZXIgbm8gcHJlZGVmaW5lZCBsZXZlbHNcIiArIFwiIG9yIGxldmVscyBoYXZlIHRvIGJlIGRlZmluZWQgZm9yIGFsbCBub2Rlcy5cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZGVmaW5lIGxldmVscyBpZiB1bmRlZmluZWQgYnkgdGhlIHVzZXJzLiBCYXNlZCBvbiBodWJzaXplLlxuICAgICAgICAgIGlmICh1bmRlZmluZWRMZXZlbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHNvcnRNZXRob2QgPSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLnNvcnRNZXRob2Q7XG4gICAgICAgICAgICBpZiAoc29ydE1ldGhvZCA9PT0gXCJodWJzaXplXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZGV0ZXJtaW5lTGV2ZWxzQnlIdWJzaXplKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvcnRNZXRob2QgPT09IFwiZGlyZWN0ZWRcIikge1xuICAgICAgICAgICAgICB0aGlzLl9kZXRlcm1pbmVMZXZlbHNEaXJlY3RlZCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3J0TWV0aG9kID09PSBcImN1c3RvbVwiKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2RldGVybWluZUxldmVsc0N1c3RvbUNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZmFsbGJhY2sgZm9yIGNhc2VzIHdoZXJlIHRoZXJlIGFyZSBub2RlcyBidXQgbm8gZWRnZXNcbiAgICAgICAgICBmb3IgKHZhciBfbm9kZUlkMiBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5Lm5vZGVzLCBfbm9kZUlkMikpIHtcbiAgICAgICAgICAgICAgdGhpcy5oaWVyYXJjaGljYWwuZW5zdXJlTGV2ZWwoX25vZGVJZDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjaGVjayB0aGUgZGlzdHJpYnV0aW9uIG9mIHRoZSBub2RlcyBwZXIgbGV2ZWwuXG4gICAgICAgICAgdmFyIGRpc3RyaWJ1dGlvbiA9IHRoaXMuX2dldERpc3RyaWJ1dGlvbigpO1xuXG4gICAgICAgICAgLy8gZ2V0IHRoZSBwYXJlbnQgY2hpbGRyZW4gcmVsYXRpb25zLlxuICAgICAgICAgIHRoaXMuX2dlbmVyYXRlTWFwKCk7XG5cbiAgICAgICAgICAvLyBwbGFjZSB0aGUgbm9kZXMgb24gdGhlIGNhbnZhcy5cbiAgICAgICAgICB0aGlzLl9wbGFjZU5vZGVzQnlIaWVyYXJjaHkoZGlzdHJpYnV0aW9uKTtcblxuICAgICAgICAgIC8vIGNvbmRlbnNlIHRoZSB3aGl0ZXNwYWNlLlxuICAgICAgICAgIHRoaXMuX2NvbmRlbnNlSGllcmFyY2h5KCk7XG5cbiAgICAgICAgICAvLyBzaGlmdCB0byBjZW50ZXIgc28gZ3Jhdml0eSBkb2VzIG5vdCBoYXZlIHRvIGRvIG11Y2hcbiAgICAgICAgICB0aGlzLl9zaGlmdFRvQ2VudGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jb25kZW5zZUhpZXJhcmNoeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29uZGVuc2VIaWVyYXJjaHkoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIC8vIEdsb2JhbCB2YXIgaW4gdGhpcyBzY29wZSB0byBkZWZpbmUgd2hlbiB0aGUgbW92ZW1lbnQgaGFzIHN0b3BwZWQuXG4gICAgICB2YXIgc3RpbGxTaGlmdGluZyA9IGZhbHNlO1xuICAgICAgdmFyIGJyYW5jaGVzID0ge307XG4gICAgICAvLyBmaXJzdCB3ZSBoYXZlIHNvbWUgbWV0aG9kcyB0byBoZWxwIHNoaWZ0aW5nIHRyZWVzIGFyb3VuZC5cbiAgICAgIC8vIHRoZSBtYWluIG1ldGhvZCB0byBzaGlmdCB0aGUgdHJlZXNcbiAgICAgIHZhciBzaGlmdFRyZWVzID0gZnVuY3Rpb24gc2hpZnRUcmVlcygpIHtcbiAgICAgICAgdmFyIHRyZWVTaXplcyA9IGdldFRyZWVTaXplcygpO1xuICAgICAgICB2YXIgc2hpZnRCeSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZVNpemVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgIHZhciBkaWZmID0gdHJlZVNpemVzW2ldLm1heCAtIHRyZWVTaXplc1tpICsgMV0ubWluO1xuICAgICAgICAgIHNoaWZ0QnkgKz0gZGlmZiArIF90aGlzMy5vcHRpb25zLmhpZXJhcmNoaWNhbC50cmVlU3BhY2luZztcbiAgICAgICAgICBzaGlmdFRyZWUoaSArIDEsIHNoaWZ0QnkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBzaGlmdCBhIHNpbmdsZSB0cmVlIGJ5IGFuIG9mZnNldFxuICAgICAgdmFyIHNoaWZ0VHJlZSA9IGZ1bmN0aW9uIHNoaWZ0VHJlZShpbmRleCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciB0cmVlcyA9IF90aGlzMy5oaWVyYXJjaGljYWwudHJlZXM7XG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0cmVlcykge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodHJlZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICAgIGlmICh0cmVlc1tub2RlSWRdID09PSBpbmRleCkge1xuICAgICAgICAgICAgICBfdGhpczMuZGlyZWN0aW9uLnNoaWZ0KG5vZGVJZCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIGdldCB0aGUgd2lkdGggb2YgYWxsIHRyZWVzXG4gICAgICB2YXIgZ2V0VHJlZVNpemVzID0gZnVuY3Rpb24gZ2V0VHJlZVNpemVzKCkge1xuICAgICAgICB2YXIgdHJlZVdpZHRocyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzMy5oaWVyYXJjaGljYWwubnVtVHJlZXMoKTsgaSsrKSB7XG4gICAgICAgICAgdHJlZVdpZHRocy5wdXNoKF90aGlzMy5kaXJlY3Rpb24uZ2V0VHJlZVNpemUoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmVlV2lkdGhzO1xuICAgICAgfTtcblxuICAgICAgLy8gZ2V0IGEgbWFwIG9mIGFsbCBub2RlcyBpbiB0aGlzIGJyYW5jaFxuICAgICAgdmFyIGdldEJyYW5jaE5vZGVzID0gZnVuY3Rpb24gZ2V0QnJhbmNoTm9kZXMoc291cmNlLCBtYXApIHtcbiAgICAgICAgaWYgKG1hcFtzb3VyY2UuaWRdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1hcFtzb3VyY2UuaWRdID0gdHJ1ZTtcbiAgICAgICAgaWYgKF90aGlzMy5oaWVyYXJjaGljYWwuY2hpbGRyZW5SZWZlcmVuY2Vbc291cmNlLmlkXSkge1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IF90aGlzMy5oaWVyYXJjaGljYWwuY2hpbGRyZW5SZWZlcmVuY2Vbc291cmNlLmlkXTtcbiAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBnZXRCcmFuY2hOb2RlcyhfdGhpczMuYm9keS5ub2Rlc1tjaGlsZHJlbltpXV0sIG1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBnZXQgYSBtaW4gbWF4IHdpZHRoIGFzIHdlbGwgYXMgdGhlIG1heGltdW0gbW92ZW1lbnQgc3BhY2UgaXQgaGFzIG9uIGVpdGhlciBzaWRlc1xuICAgICAgLy8gd2UgdXNlIG1pbiBtYXggdGVybWlub2xvZ3kgYmVjYXVzZSB3aWR0aCBhbmQgaGVpZ2h0IGNhbiBpbnRlcmNoYW5nZSBkZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbGF5b3V0XG4gICAgICB2YXIgZ2V0QnJhbmNoQm91bmRhcnkgPSBmdW5jdGlvbiBnZXRCcmFuY2hCb3VuZGFyeShicmFuY2hNYXApIHtcbiAgICAgICAgdmFyIG1heExldmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxZTk7XG4gICAgICAgIHZhciBtaW5TcGFjZSA9IDFlOTtcbiAgICAgICAgdmFyIG1heFNwYWNlID0gMWU5O1xuICAgICAgICB2YXIgbWluID0gMWU5O1xuICAgICAgICB2YXIgbWF4ID0gLTFlOTtcbiAgICAgICAgZm9yICh2YXIgYnJhbmNoTm9kZSBpbiBicmFuY2hNYXApIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGJyYW5jaE1hcCwgYnJhbmNoTm9kZSkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gX3RoaXMzLmJvZHkubm9kZXNbYnJhbmNoTm9kZV07XG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSBfdGhpczMuaGllcmFyY2hpY2FsLmxldmVsc1tub2RlLmlkXTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZSk7XG5cbiAgICAgICAgICAgIC8vIGdldCB0aGUgc3BhY2UgYXJvdW5kIHRoZSBub2RlLlxuICAgICAgICAgICAgdmFyIF90aGlzMyRfZ2V0U3BhY2VBcm91biA9IF90aGlzMy5fZ2V0U3BhY2VBcm91bmROb2RlKG5vZGUsIGJyYW5jaE1hcCksXG4gICAgICAgICAgICAgIF90aGlzMyRfZ2V0U3BhY2VBcm91bjIgPSBfc2xpY2VkVG9BcnJheShfdGhpczMkX2dldFNwYWNlQXJvdW4sIDIpLFxuICAgICAgICAgICAgICBtaW5TcGFjZU5vZGUgPSBfdGhpczMkX2dldFNwYWNlQXJvdW4yWzBdLFxuICAgICAgICAgICAgICBtYXhTcGFjZU5vZGUgPSBfdGhpczMkX2dldFNwYWNlQXJvdW4yWzFdO1xuICAgICAgICAgICAgbWluU3BhY2UgPSBNYXRoLm1pbihtaW5TcGFjZU5vZGUsIG1pblNwYWNlKTtcbiAgICAgICAgICAgIG1heFNwYWNlID0gTWF0aC5taW4obWF4U3BhY2VOb2RlLCBtYXhTcGFjZSk7XG5cbiAgICAgICAgICAgIC8vIHRoZSB3aWR0aCBpcyBvbmx5IHJlbGV2YW50IGZvciB0aGUgbGV2ZWxzIHR3byBub2RlcyBoYXZlIGluIGNvbW1vbi4gVGhpcyBpcyB3aHkgd2UgZmlsdGVyIG9uIHRoaXMuXG4gICAgICAgICAgICBpZiAobGV2ZWwgPD0gbWF4TGV2ZWwpIHtcbiAgICAgICAgICAgICAgbWluID0gTWF0aC5taW4ocG9zaXRpb24sIG1pbik7XG4gICAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KHBvc2l0aW9uLCBtYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW21pbiwgbWF4LCBtaW5TcGFjZSwgbWF4U3BhY2VdO1xuICAgICAgfTtcblxuICAgICAgLy8gY2hlY2sgd2hhdCB0aGUgbWF4aW11bSBsZXZlbCBpcyB0aGVzZSBub2RlcyBoYXZlIGluIGNvbW1vbi5cbiAgICAgIHZhciBnZXRDb2xsaXNpb25MZXZlbCA9IGZ1bmN0aW9uIGdldENvbGxpc2lvbkxldmVsKG5vZGUxLCBub2RlMikge1xuICAgICAgICB2YXIgbWF4TGV2ZWwxID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5nZXRNYXhMZXZlbChub2RlMS5pZCk7XG4gICAgICAgIHZhciBtYXhMZXZlbDIgPSBfdGhpczMuaGllcmFyY2hpY2FsLmdldE1heExldmVsKG5vZGUyLmlkKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKG1heExldmVsMSwgbWF4TGV2ZWwyKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29uZGVuc2UgZWxlbWVudHMuIFRoZXNlIGNhbiBiZSBub2RlcyBvciBicmFuY2hlcyBkZXBlbmRpbmcgb24gdGhlIGNhbGxiYWNrLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBsZXZlbHNcbiAgICAgICAqIEBwYXJhbSB7Kn0gY2VudGVyUGFyZW50c1xuICAgICAgICovXG4gICAgICB2YXIgc2hpZnRFbGVtZW50c0Nsb3NlciA9IGZ1bmN0aW9uIHNoaWZ0RWxlbWVudHNDbG9zZXIoY2FsbGJhY2ssIGxldmVscywgY2VudGVyUGFyZW50cykge1xuICAgICAgICB2YXIgaGllciA9IF90aGlzMy5oaWVyYXJjaGljYWw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGxldmVsID0gbGV2ZWxzW2ldO1xuICAgICAgICAgIHZhciBsZXZlbE5vZGVzID0gaGllci5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF07XG4gICAgICAgICAgaWYgKGxldmVsTm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZXZlbE5vZGVzLmxlbmd0aCAtIDE7IGorKykge1xuICAgICAgICAgICAgICB2YXIgbm9kZTEgPSBsZXZlbE5vZGVzW2pdO1xuICAgICAgICAgICAgICB2YXIgbm9kZTIgPSBsZXZlbE5vZGVzW2ogKyAxXTtcblxuICAgICAgICAgICAgICAvLyBOT1RFOiBsb2dpYyBtYWludGFpbmVkIGFzIGl0IHdhczsgaWYgbm9kZXMgaGF2ZSBzYW1lIGFuY2VzdG9yLFxuICAgICAgICAgICAgICAvLyAgICAgICB0aGVuIG9mIGNvdXJzZSB0aGV5IGFyZSBpbiB0aGUgc2FtZSBzdWItbmV0d29yay5cbiAgICAgICAgICAgICAgaWYgKGhpZXIuaGFzU2FtZVBhcmVudChub2RlMSwgbm9kZTIpICYmIGhpZXIuaW5TYW1lU3ViTmV0d29yayhub2RlMSwgbm9kZTIpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobm9kZTEsIG5vZGUyLCBjZW50ZXJQYXJlbnRzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gY2FsbGJhY2sgZm9yIHNoaWZ0aW5nIGJyYW5jaGVzXG4gICAgICB2YXIgYnJhbmNoU2hpZnRDYWxsYmFjayA9IGZ1bmN0aW9uIGJyYW5jaFNoaWZ0Q2FsbGJhY2sobm9kZTEsIG5vZGUyKSB7XG4gICAgICAgIHZhciBjZW50ZXJQYXJlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgICAvL3dpbmRvdy5DQUxMQkFDS1MucHVzaCgoKSA9PiB7XG4gICAgICAgIHZhciBwb3MxID0gX3RoaXMzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihub2RlMSk7XG4gICAgICAgIHZhciBwb3MyID0gX3RoaXMzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihub2RlMik7XG4gICAgICAgIHZhciBkaWZmQWJzID0gTWF0aC5hYnMocG9zMiAtIHBvczEpO1xuICAgICAgICB2YXIgbm9kZVNwYWNpbmcgPSBfdGhpczMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmc7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJOT1cgQ0hFQ0tJTkc6XCIsIG5vZGUxLmlkLCBub2RlMi5pZCwgZGlmZkFicyk7XG4gICAgICAgIGlmIChkaWZmQWJzID4gbm9kZVNwYWNpbmcpIHtcbiAgICAgICAgICB2YXIgYnJhbmNoTm9kZXMxID0ge307XG4gICAgICAgICAgdmFyIGJyYW5jaE5vZGVzMiA9IHt9O1xuICAgICAgICAgIGdldEJyYW5jaE5vZGVzKG5vZGUxLCBicmFuY2hOb2RlczEpO1xuICAgICAgICAgIGdldEJyYW5jaE5vZGVzKG5vZGUyLCBicmFuY2hOb2RlczIpO1xuXG4gICAgICAgICAgLy8gY2hlY2sgdGhlIGxhcmdlc3QgZGlzdGFuY2UgYmV0d2VlbiB0aGUgYnJhbmNoZXNcbiAgICAgICAgICB2YXIgbWF4TGV2ZWwgPSBnZXRDb2xsaXNpb25MZXZlbChub2RlMSwgbm9kZTIpO1xuICAgICAgICAgIHZhciBicmFuY2hOb2RlQm91bmRhcnkxID0gZ2V0QnJhbmNoQm91bmRhcnkoYnJhbmNoTm9kZXMxLCBtYXhMZXZlbCk7XG4gICAgICAgICAgdmFyIGJyYW5jaE5vZGVCb3VuZGFyeTIgPSBnZXRCcmFuY2hCb3VuZGFyeShicmFuY2hOb2RlczIsIG1heExldmVsKTtcbiAgICAgICAgICB2YXIgbWF4MSA9IGJyYW5jaE5vZGVCb3VuZGFyeTFbMV07XG4gICAgICAgICAgdmFyIG1pbjIgPSBicmFuY2hOb2RlQm91bmRhcnkyWzBdO1xuICAgICAgICAgIHZhciBtaW5TcGFjZTIgPSBicmFuY2hOb2RlQm91bmRhcnkyWzJdO1xuXG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhub2RlMS5pZCwgZ2V0QnJhbmNoQm91bmRhcnkoYnJhbmNoTm9kZXMxLCBtYXhMZXZlbCksIG5vZGUyLmlkLFxuICAgICAgICAgIC8vICAgICAgICAgICAgZ2V0QnJhbmNoQm91bmRhcnkoYnJhbmNoTm9kZXMyLCBtYXhMZXZlbCksIG1heExldmVsKTtcbiAgICAgICAgICB2YXIgZGlmZkJyYW5jaCA9IE1hdGguYWJzKG1heDEgLSBtaW4yKTtcbiAgICAgICAgICBpZiAoZGlmZkJyYW5jaCA+IG5vZGVTcGFjaW5nKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gbWF4MSAtIG1pbjIgKyBub2RlU3BhY2luZztcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAtbWluU3BhY2UyICsgbm9kZVNwYWNpbmcpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gLW1pblNwYWNlMiArIG5vZGVTcGFjaW5nO1xuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiUkVTRVRUSU5HIE9GRlNFVFwiLCBtYXgxIC0gbWluMiArIHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcsIC1taW5TcGFjZTIsIG9mZnNldCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTSElGVElOR1wiLCBub2RlMi5pZCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgX3RoaXMzLl9zaGlmdEJsb2NrKG5vZGUyLmlkLCBvZmZzZXQpO1xuICAgICAgICAgICAgICBzdGlsbFNoaWZ0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKGNlbnRlclBhcmVudCA9PT0gdHJ1ZSkgX3RoaXMzLl9jZW50ZXJQYXJlbnQobm9kZTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL3RoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO30pXG4gICAgICB9O1xuXG4gICAgICB2YXIgbWluaW1pemVFZGdlTGVuZ3RoID0gZnVuY3Rpb24gbWluaW1pemVFZGdlTGVuZ3RoKGl0ZXJhdGlvbnMsIG5vZGUpIHtcbiAgICAgICAgLy93aW5kb3cuQ0FMTEJBQ0tTLnB1c2goKCkgPT4ge1xuICAgICAgICAvLyAgY29uc29sZS5sb2coXCJ0c1wiLG5vZGUuaWQpO1xuICAgICAgICB2YXIgbm9kZUlkID0gbm9kZS5pZDtcbiAgICAgICAgdmFyIGFsbEVkZ2VzID0gbm9kZS5lZGdlcztcbiAgICAgICAgdmFyIG5vZGVMZXZlbCA9IF90aGlzMy5oaWVyYXJjaGljYWwubGV2ZWxzW25vZGUuaWRdO1xuXG4gICAgICAgIC8vIGdhdGhlciBjb25zdGFudHNcbiAgICAgICAgdmFyIEMyID0gX3RoaXMzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiAqIF90aGlzMy5vcHRpb25zLmhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb247XG4gICAgICAgIHZhciByZWZlcmVuY2VOb2RlcyA9IHt9O1xuICAgICAgICB2YXIgYWJvdmVFZGdlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBhbGxFZGdlc1tpXTtcbiAgICAgICAgICBpZiAoZWRnZS50b0lkICE9IGVkZ2UuZnJvbUlkKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJOb2RlID0gZWRnZS50b0lkID09IG5vZGVJZCA/IGVkZ2UuZnJvbSA6IGVkZ2UudG87XG4gICAgICAgICAgICByZWZlcmVuY2VOb2Rlc1thbGxFZGdlc1tpXS5pZF0gPSBvdGhlck5vZGU7XG4gICAgICAgICAgICBpZiAoX3RoaXMzLmhpZXJhcmNoaWNhbC5sZXZlbHNbb3RoZXJOb2RlLmlkXSA8IG5vZGVMZXZlbCkge1xuICAgICAgICAgICAgICBhYm92ZUVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGlmZmVyZW50aWF0ZWQgc3VtIG9mIGxlbmd0aHMgYmFzZWQgb24gb25seSBtb3Zpbmcgb25lIG5vZGUgb3ZlciBvbmUgYXhpc1xuICAgICAgICB2YXIgZ2V0RnggPSBmdW5jdGlvbiBnZXRGeChwb2ludCwgZWRnZXMpIHtcbiAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBlZGdlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICBpZiAocmVmZXJlbmNlTm9kZXNbZWRnZXNbX2kyXS5pZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgYSA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24ocmVmZXJlbmNlTm9kZXNbZWRnZXNbX2kyXS5pZF0pIC0gcG9pbnQ7XG4gICAgICAgICAgICAgIHN1bSArPSBhIC8gTWF0aC5zcXJ0KGEgKiBhICsgQzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGRvdWJseSBkaWZmZXJlbnRpYXRlZCBzdW0gb2YgbGVuZ3RocyBiYXNlZCBvbiBvbmx5IG1vdmluZyBvbmUgbm9kZSBvdmVyIG9uZSBheGlzXG4gICAgICAgIHZhciBnZXRERnggPSBmdW5jdGlvbiBnZXRERngocG9pbnQsIGVkZ2VzKSB7XG4gICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgZWRnZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICAgICAgaWYgKHJlZmVyZW5jZU5vZGVzW2VkZ2VzW19pM10uaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIGEgPSBfdGhpczMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKHJlZmVyZW5jZU5vZGVzW2VkZ2VzW19pM10uaWRdKSAtIHBvaW50O1xuICAgICAgICAgICAgICBzdW0gLT0gQzIgKiBNYXRoLnBvdyhhICogYSArIEMyLCAtMS41KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldEd1ZXNzID0gZnVuY3Rpb24gZ2V0R3Vlc3MoaXRlcmF0aW9ucywgZWRnZXMpIHtcbiAgICAgICAgICB2YXIgZ3Vlc3MgPSBfdGhpczMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5vZGUpO1xuICAgICAgICAgIC8vIE5ld3RvbidzIG1ldGhvZCBmb3Igb3B0aW1pemF0aW9uXG4gICAgICAgICAgdmFyIGd1ZXNzTWFwID0ge307XG4gICAgICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgaXRlcmF0aW9uczsgX2k0KyspIHtcbiAgICAgICAgICAgIHZhciBmeCA9IGdldEZ4KGd1ZXNzLCBlZGdlcyk7XG4gICAgICAgICAgICB2YXIgZGZ4ID0gZ2V0REZ4KGd1ZXNzLCBlZGdlcyk7XG5cbiAgICAgICAgICAgIC8vIHdlIGxpbWl0IHRoZSBtb3ZlbWVudCB0byBhdm9pZCBpbnN0YWJpbGl0eS5cbiAgICAgICAgICAgIHZhciBsaW1pdCA9IDQwO1xuICAgICAgICAgICAgdmFyIHJhdGlvID0gTWF0aC5tYXgoLWxpbWl0LCBNYXRoLm1pbihsaW1pdCwgTWF0aC5yb3VuZChmeCAvIGRmeCkpKTtcbiAgICAgICAgICAgIGd1ZXNzID0gZ3Vlc3MgLSByYXRpbztcbiAgICAgICAgICAgIC8vIHJlZHVjZSBkdXBsaWNhdGVzXG4gICAgICAgICAgICBpZiAoZ3Vlc3NNYXBbZ3Vlc3NdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBndWVzc01hcFtndWVzc10gPSBfaTQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBndWVzcztcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1vdmVCcmFuY2ggPSBmdW5jdGlvbiBtb3ZlQnJhbmNoKGd1ZXNzKSB7XG4gICAgICAgICAgLy8gcG9zaXRpb24gbm9kZSBpZiB0aGVyZSBpcyBzcGFjZVxuICAgICAgICAgIHZhciBub2RlUG9zaXRpb24gPSBfdGhpczMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5vZGUpO1xuXG4gICAgICAgICAgLy8gY2hlY2sgbW92YWJsZSBhcmVhIG9mIHRoZSBicmFuY2hcbiAgICAgICAgICBpZiAoYnJhbmNoZXNbbm9kZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGJyYW5jaE5vZGVzID0ge307XG4gICAgICAgICAgICBnZXRCcmFuY2hOb2Rlcyhub2RlLCBicmFuY2hOb2Rlcyk7XG4gICAgICAgICAgICBicmFuY2hlc1tub2RlLmlkXSA9IGJyYW5jaE5vZGVzO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYnJhbmNoQm91bmRhcnkgPSBnZXRCcmFuY2hCb3VuZGFyeShicmFuY2hlc1tub2RlLmlkXSk7XG4gICAgICAgICAgdmFyIG1pblNwYWNlQnJhbmNoID0gYnJhbmNoQm91bmRhcnlbMl07XG4gICAgICAgICAgdmFyIG1heFNwYWNlQnJhbmNoID0gYnJhbmNoQm91bmRhcnlbM107XG4gICAgICAgICAgdmFyIGRpZmYgPSBndWVzcyAtIG5vZGVQb3NpdGlvbjtcblxuICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBhbGxvd2VkIHRvIG1vdmUgdGhlIG5vZGU6XG4gICAgICAgICAgdmFyIGJyYW5jaE9mZnNldCA9IDA7XG4gICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICBicmFuY2hPZmZzZXQgPSBNYXRoLm1pbihkaWZmLCBtYXhTcGFjZUJyYW5jaCAtIF90aGlzMy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkaWZmIDwgMCkge1xuICAgICAgICAgICAgYnJhbmNoT2Zmc2V0ID0gLU1hdGgubWluKC1kaWZmLCBtaW5TcGFjZUJyYW5jaCAtIF90aGlzMy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChicmFuY2hPZmZzZXQgIT0gMCkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIm1vdmluZyBicmFuY2g6XCIsYnJhbmNoT2Zmc2V0LCBtYXhTcGFjZUJyYW5jaCwgbWluU3BhY2VCcmFuY2gpXG4gICAgICAgICAgICBfdGhpczMuX3NoaWZ0QmxvY2sobm9kZS5pZCwgYnJhbmNoT2Zmc2V0KTtcbiAgICAgICAgICAgIC8vdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG4gICAgICAgICAgICBzdGlsbFNoaWZ0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtb3ZlTm9kZSA9IGZ1bmN0aW9uIG1vdmVOb2RlKGd1ZXNzKSB7XG4gICAgICAgICAgdmFyIG5vZGVQb3NpdGlvbiA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZSk7XG5cbiAgICAgICAgICAvLyBwb3NpdGlvbiBub2RlIGlmIHRoZXJlIGlzIHNwYWNlXG4gICAgICAgICAgdmFyIF90aGlzMyRfZ2V0U3BhY2VBcm91bjMgPSBfdGhpczMuX2dldFNwYWNlQXJvdW5kTm9kZShub2RlKSxcbiAgICAgICAgICAgIF90aGlzMyRfZ2V0U3BhY2VBcm91bjQgPSBfc2xpY2VkVG9BcnJheShfdGhpczMkX2dldFNwYWNlQXJvdW4zLCAyKSxcbiAgICAgICAgICAgIG1pblNwYWNlID0gX3RoaXMzJF9nZXRTcGFjZUFyb3VuNFswXSxcbiAgICAgICAgICAgIG1heFNwYWNlID0gX3RoaXMzJF9nZXRTcGFjZUFyb3VuNFsxXTtcbiAgICAgICAgICB2YXIgZGlmZiA9IGd1ZXNzIC0gbm9kZVBvc2l0aW9uO1xuICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBhbGxvd2VkIHRvIG1vdmUgdGhlIG5vZGU6XG4gICAgICAgICAgdmFyIG5ld1Bvc2l0aW9uID0gbm9kZVBvc2l0aW9uO1xuICAgICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgbmV3UG9zaXRpb24gPSBNYXRoLm1pbihub2RlUG9zaXRpb24gKyAobWF4U3BhY2UgLSBfdGhpczMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpLCBndWVzcyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkaWZmIDwgMCkge1xuICAgICAgICAgICAgbmV3UG9zaXRpb24gPSBNYXRoLm1heChub2RlUG9zaXRpb24gLSAobWluU3BhY2UgLSBfdGhpczMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpLCBndWVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXdQb3NpdGlvbiAhPT0gbm9kZVBvc2l0aW9uKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwibW92aW5nIE5vZGU6XCIsZGlmZiwgbWluU3BhY2UsIG1heFNwYWNlKTtcbiAgICAgICAgICAgIF90aGlzMy5kaXJlY3Rpb24uc2V0UG9zaXRpb24obm9kZSwgbmV3UG9zaXRpb24pO1xuICAgICAgICAgICAgLy90aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICAgICAgICAgIHN0aWxsU2hpZnRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGd1ZXNzID0gZ2V0R3Vlc3MoaXRlcmF0aW9ucywgYWJvdmVFZGdlcyk7XG4gICAgICAgIG1vdmVCcmFuY2goZ3Vlc3MpO1xuICAgICAgICBndWVzcyA9IGdldEd1ZXNzKGl0ZXJhdGlvbnMsIGFsbEVkZ2VzKTtcbiAgICAgICAgbW92ZU5vZGUoZ3Vlc3MpO1xuICAgICAgICAvL30pXG4gICAgICB9O1xuXG4gICAgICAvLyBtZXRob2QgdG8gcmVtb3ZlIHdoaXRlc3BhY2UgYmV0d2VlbiBicmFuY2hlcy4gQmVjYXVzZSB3ZSBkbyBib3R0b20gdXAsIHdlIGNhbiBjZW50ZXIgdGhlIHBhcmVudHMuXG4gICAgICB2YXIgbWluaW1pemVFZGdlTGVuZ3RoQm90dG9tVXAgPSBmdW5jdGlvbiBtaW5pbWl6ZUVkZ2VMZW5ndGhCb3R0b21VcChpdGVyYXRpb25zKSB7XG4gICAgICAgIHZhciBsZXZlbHMgPSBfdGhpczMuaGllcmFyY2hpY2FsLmdldExldmVscygpO1xuICAgICAgICBsZXZlbHMgPSBfcmV2ZXJzZUluc3RhbmNlUHJvcGVydHkobGV2ZWxzKS5jYWxsKGxldmVscyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgICAgc3RpbGxTaGlmdGluZyA9IGZhbHNlO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGV2ZWxzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbal07XG4gICAgICAgICAgICB2YXIgbGV2ZWxOb2RlcyA9IF90aGlzMy5oaWVyYXJjaGljYWwuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdO1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsZXZlbE5vZGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgIG1pbmltaXplRWRnZUxlbmd0aCgxMDAwLCBsZXZlbE5vZGVzW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0aWxsU2hpZnRpbmcgIT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJGSU5JU0hFRCBtaW5pbWl6ZUVkZ2VMZW5ndGhCb3R0b21VcCBJTiBcIiArIGkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBtZXRob2QgdG8gcmVtb3ZlIHdoaXRlc3BhY2UgYmV0d2VlbiBicmFuY2hlcy4gQmVjYXVzZSB3ZSBkbyBib3R0b20gdXAsIHdlIGNhbiBjZW50ZXIgdGhlIHBhcmVudHMuXG4gICAgICB2YXIgc2hpZnRCcmFuY2hlc0Nsb3NlckJvdHRvbVVwID0gZnVuY3Rpb24gc2hpZnRCcmFuY2hlc0Nsb3NlckJvdHRvbVVwKGl0ZXJhdGlvbnMpIHtcbiAgICAgICAgdmFyIGxldmVscyA9IF90aGlzMy5oaWVyYXJjaGljYWwuZ2V0TGV2ZWxzKCk7XG4gICAgICAgIGxldmVscyA9IF9yZXZlcnNlSW5zdGFuY2VQcm9wZXJ0eShsZXZlbHMpLmNhbGwobGV2ZWxzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgICBzdGlsbFNoaWZ0aW5nID0gZmFsc2U7XG4gICAgICAgICAgc2hpZnRFbGVtZW50c0Nsb3NlcihicmFuY2hTaGlmdENhbGxiYWNrLCBsZXZlbHMsIHRydWUpO1xuICAgICAgICAgIGlmIChzdGlsbFNoaWZ0aW5nICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiRklOSVNIRUQgc2hpZnRCcmFuY2hlc0Nsb3NlckJvdHRvbVVwIElOIFwiICsgKGkrMSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBjZW50ZXIgYWxsIHBhcmVudHNcbiAgICAgIHZhciBjZW50ZXJBbGxQYXJlbnRzID0gZnVuY3Rpb24gY2VudGVyQWxsUGFyZW50cygpIHtcbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIF90aGlzMy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfdGhpczMuYm9keS5ub2Rlcywgbm9kZUlkKSkgX3RoaXMzLl9jZW50ZXJQYXJlbnQoX3RoaXMzLmJvZHkubm9kZXNbbm9kZUlkXSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIGNlbnRlciBhbGwgcGFyZW50c1xuICAgICAgdmFyIGNlbnRlckFsbFBhcmVudHNCb3R0b21VcCA9IGZ1bmN0aW9uIGNlbnRlckFsbFBhcmVudHNCb3R0b21VcCgpIHtcbiAgICAgICAgdmFyIGxldmVscyA9IF90aGlzMy5oaWVyYXJjaGljYWwuZ2V0TGV2ZWxzKCk7XG4gICAgICAgIGxldmVscyA9IF9yZXZlcnNlSW5zdGFuY2VQcm9wZXJ0eShsZXZlbHMpLmNhbGwobGV2ZWxzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbaV07XG4gICAgICAgICAgdmFyIGxldmVsTm9kZXMgPSBfdGhpczMuaGllcmFyY2hpY2FsLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXTtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxldmVsTm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIF90aGlzMy5fY2VudGVyUGFyZW50KGxldmVsTm9kZXNbal0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gdGhlIGFjdHVhbCB3b3JrIGlzIGRvbmUgaGVyZS5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmJsb2NrU2hpZnRpbmcgPT09IHRydWUpIHtcbiAgICAgICAgc2hpZnRCcmFuY2hlc0Nsb3NlckJvdHRvbVVwKDUpO1xuICAgICAgICBjZW50ZXJBbGxQYXJlbnRzKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIG1pbmltaXplIGVkZ2UgbGVuZ3RoXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5lZGdlTWluaW1pemF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgIG1pbmltaXplRWRnZUxlbmd0aEJvdHRvbVVwKDIwKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLnBhcmVudENlbnRyYWxpemF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgIGNlbnRlckFsbFBhcmVudHNCb3R0b21VcCgpO1xuICAgICAgfVxuICAgICAgc2hpZnRUcmVlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZ2l2ZXMgdGhlIHNwYWNlIGFyb3VuZCB0aGUgbm9kZS4gSUYgYSBtYXAgaXMgc3VwcGxpZWQsIGl0IHdpbGwgb25seSBjaGVjayBhZ2FpbnN0IG5vZGVzIE5PVCBpbiB0aGUgbWFwLlxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBvbmx5IGdldCB0aGUgZGlzdGFuY2VzIHRvIG5vZGVzIG91dHNpZGUgb2YgYSBicmFuY2guXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0ge3tOb2RlLmlkOiB2aXMuTm9kZX19IG1hcFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXRTcGFjZUFyb3VuZE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFNwYWNlQXJvdW5kTm9kZShub2RlLCBtYXApIHtcbiAgICAgIHZhciB1c2VNYXAgPSB0cnVlO1xuICAgICAgaWYgKG1hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVzZU1hcCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGxldmVsID0gdGhpcy5oaWVyYXJjaGljYWwubGV2ZWxzW25vZGUuaWRdO1xuICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5oaWVyYXJjaGljYWwuZGlzdHJpYnV0aW9uSW5kZXhbbm9kZS5pZF07XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5vZGUpO1xuICAgICAgICB2YXIgb3JkZXJpbmcgPSB0aGlzLmhpZXJhcmNoaWNhbC5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF07XG4gICAgICAgIHZhciBtaW5TcGFjZSA9IDFlOTtcbiAgICAgICAgdmFyIG1heFNwYWNlID0gMWU5O1xuICAgICAgICBpZiAoaW5kZXggIT09IDApIHtcbiAgICAgICAgICB2YXIgcHJldk5vZGUgPSBvcmRlcmluZ1tpbmRleCAtIDFdO1xuICAgICAgICAgIGlmICh1c2VNYXAgPT09IHRydWUgJiYgbWFwW3ByZXZOb2RlLmlkXSA9PT0gdW5kZWZpbmVkIHx8IHVzZU1hcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhciBwcmV2UG9zID0gdGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24ocHJldk5vZGUpO1xuICAgICAgICAgICAgbWluU3BhY2UgPSBwb3NpdGlvbiAtIHByZXZQb3M7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCAhPSBvcmRlcmluZy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgdmFyIG5leHROb2RlID0gb3JkZXJpbmdbaW5kZXggKyAxXTtcbiAgICAgICAgICBpZiAodXNlTWFwID09PSB0cnVlICYmIG1hcFtuZXh0Tm9kZS5pZF0gPT09IHVuZGVmaW5lZCB8fCB1c2VNYXAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFBvcyA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5leHROb2RlKTtcbiAgICAgICAgICAgIG1heFNwYWNlID0gTWF0aC5taW4obWF4U3BhY2UsIG5leHRQb3MgLSBwb3NpdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbWluU3BhY2UsIG1heFNwYWNlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2UgdXNlIHRoaXMgbWV0aG9kIHRvIGNlbnRlciBhIHBhcmVudCBub2RlIGFuZCBjaGVjayBpZiBpdCBkb2VzIG5vdCBjcm9zcyBvdGhlciBub2RlcyB3aGVuIGl0IGRvZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jZW50ZXJQYXJlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NlbnRlclBhcmVudChub2RlKSB7XG4gICAgICBpZiAodGhpcy5oaWVyYXJjaGljYWwucGFyZW50UmVmZXJlbmNlW25vZGUuaWRdKSB7XG4gICAgICAgIHZhciBwYXJlbnRzID0gdGhpcy5oaWVyYXJjaGljYWwucGFyZW50UmVmZXJlbmNlW25vZGUuaWRdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcGFyZW50SWQgPSBwYXJlbnRzW2ldO1xuICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gdGhpcy5ib2R5Lm5vZGVzW3BhcmVudElkXTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmhpZXJhcmNoaWNhbC5jaGlsZHJlblJlZmVyZW5jZVtwYXJlbnRJZF07XG4gICAgICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgcmFuZ2Ugb2YgdGhlIGNoaWxkcmVuXG4gICAgICAgICAgICB2YXIgbmV3UG9zaXRpb24gPSB0aGlzLl9nZXRDZW50ZXJQb3NpdGlvbihjaGlsZHJlbik7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihwYXJlbnROb2RlKTtcbiAgICAgICAgICAgIHZhciBfdGhpcyRfZ2V0U3BhY2VBcm91bmQgPSB0aGlzLl9nZXRTcGFjZUFyb3VuZE5vZGUocGFyZW50Tm9kZSksXG4gICAgICAgICAgICAgIF90aGlzJF9nZXRTcGFjZUFyb3VuZDIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0U3BhY2VBcm91bmQsIDIpLFxuICAgICAgICAgICAgICBtaW5TcGFjZSA9IF90aGlzJF9nZXRTcGFjZUFyb3VuZDJbMF0sXG4gICAgICAgICAgICAgIG1heFNwYWNlID0gX3RoaXMkX2dldFNwYWNlQXJvdW5kMlsxXTtcbiAgICAgICAgICAgIHZhciBkaWZmID0gcG9zaXRpb24gLSBuZXdQb3NpdGlvbjtcbiAgICAgICAgICAgIGlmIChkaWZmIDwgMCAmJiBNYXRoLmFicyhkaWZmKSA8IG1heFNwYWNlIC0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyB8fCBkaWZmID4gMCAmJiBNYXRoLmFicyhkaWZmKSA8IG1pblNwYWNlIC0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZykge1xuICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbi5zZXRQb3NpdGlvbihwYXJlbnROb2RlLCBuZXdQb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBwbGFjZXMgdGhlIG5vZGVzIG9uIHRoZSBjYW52YXMgYmFzZWQgb24gdGhlIGhpZXJhcmNoaWFsIGRpc3RyaWJ1dGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkaXN0cmlidXRpb24gfCBvYnRhaW5lZCBieSB0aGUgZnVuY3Rpb24gdGhpcy5fZ2V0RGlzdHJpYnV0aW9uKClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9wbGFjZU5vZGVzQnlIaWVyYXJjaHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BsYWNlTm9kZXNCeUhpZXJhcmNoeShkaXN0cmlidXRpb24pIHtcbiAgICAgIHRoaXMucG9zaXRpb25lZE5vZGVzID0ge307XG4gICAgICAvLyBzdGFydCBwbGFjaW5nIGFsbCB0aGUgbGV2ZWwgMCBub2RlcyBmaXJzdC4gVGhlbiByZWN1cnNpdmVseSBwb3NpdGlvbiB0aGVpciBicmFuY2hlcy5cbiAgICAgIGZvciAodmFyIGxldmVsIGluIGRpc3RyaWJ1dGlvbikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRpc3RyaWJ1dGlvbiwgbGV2ZWwpKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0O1xuICAgICAgICAgIC8vIHNvcnQgbm9kZXMgaW4gbGV2ZWwgYnkgcG9zaXRpb246XG4gICAgICAgICAgdmFyIG5vZGVBcnJheSA9IF9PYmplY3Qka2V5cyhkaXN0cmlidXRpb25bbGV2ZWxdKTtcbiAgICAgICAgICBub2RlQXJyYXkgPSB0aGlzLl9pbmRleEFycmF5VG9Ob2Rlcyhub2RlQXJyYXkpO1xuICAgICAgICAgIF9zb3J0SW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dCA9IHRoaXMuZGlyZWN0aW9uKS5jYWxsKF9jb250ZXh0LCBub2RlQXJyYXkpO1xuICAgICAgICAgIHZhciBoYW5kbGVkTm9kZUNvdW50ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2RlQXJyYXlbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbmVkTm9kZXNbbm9kZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgc3BhY2luZyA9IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmc7XG4gICAgICAgICAgICAgIHZhciBwb3MgPSBzcGFjaW5nICogaGFuZGxlZE5vZGVDb3VudDtcbiAgICAgICAgICAgICAgLy8gV2UgZ2V0IHRoZSBYIG9yIFkgdmFsdWVzIHdlIG5lZWQgYW5kIHN0b3JlIHRoZW0gaW4gcG9zIGFuZCBwcmV2aW91c1Bvcy5cbiAgICAgICAgICAgICAgLy8gVGhlIGdldCBhbmQgc2V0IG1ha2Ugc3VyZSB3ZSBnZXQgWCBvciBZXG4gICAgICAgICAgICAgIGlmIChoYW5kbGVkTm9kZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHBvcyA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5vZGVBcnJheVtpIC0gMV0pICsgc3BhY2luZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbi5zZXRQb3NpdGlvbihub2RlLCBwb3MsIGxldmVsKTtcbiAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVQb3NpdGlvbkFuZENvbnRpbnVlKG5vZGUsIGxldmVsLCBwb3MpO1xuICAgICAgICAgICAgICBoYW5kbGVkTm9kZUNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIHJlY3Vyc2l2ZWx5IGNhbGxlZCBmdW5jdGlvbiB0byBlbnVtZXJhdGUgdGhlIGJyYW5jaGVzIGZyb20gdGhlIGxhcmdlc3QgaHVicyBhbmQgcGxhY2UgdGhlIG5vZGVzXG4gICAgICogb24gYSBYIHBvc2l0aW9uIHRoYXQgZW5zdXJlcyB0aGVyZSB3aWxsIGJlIG5vIG92ZXJsYXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IHBhcmVudElkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmVudExldmVsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfcGxhY2VCcmFuY2hOb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGxhY2VCcmFuY2hOb2RlcyhwYXJlbnRJZCwgcGFyZW50TGV2ZWwpIHtcbiAgICAgIHZhciBfY29udGV4dDI7XG4gICAgICB2YXIgY2hpbGRSZWYgPSB0aGlzLmhpZXJhcmNoaWNhbC5jaGlsZHJlblJlZmVyZW5jZVtwYXJlbnRJZF07XG5cbiAgICAgIC8vIGlmIHRoaXMgaXMgbm90IGEgcGFyZW50LCBjYW5jZWwgdGhlIHBsYWNpbmcuIFRoaXMgY2FuIGhhcHBlbiB3aXRoIG11bHRpcGxlIHBhcmVudHMgdG8gb25lIGNoaWxkLlxuICAgICAgaWYgKGNoaWxkUmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQgYSBsaXN0IG9mIGNoaWxkTm9kZXNcbiAgICAgIHZhciBjaGlsZE5vZGVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkUmVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoaWxkTm9kZXMucHVzaCh0aGlzLmJvZHkubm9kZXNbY2hpbGRSZWZbaV1dKTtcbiAgICAgIH1cblxuICAgICAgLy8gdXNlIHRoZSBwb3NpdGlvbnMgdG8gb3JkZXIgdGhlIG5vZGVzLlxuICAgICAgX3NvcnRJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0MiA9IHRoaXMuZGlyZWN0aW9uKS5jYWxsKF9jb250ZXh0MiwgY2hpbGROb2Rlcyk7XG5cbiAgICAgIC8vIHBvc2l0aW9uIHRoZSBjaGlsZE5vZGVzXG4gICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBjaGlsZE5vZGVzLmxlbmd0aDsgX2k1KyspIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbX2k1XTtcbiAgICAgICAgdmFyIGNoaWxkTm9kZUxldmVsID0gdGhpcy5oaWVyYXJjaGljYWwubGV2ZWxzW2NoaWxkTm9kZS5pZF07XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBjaGlsZCBub2RlIGlzIGJlbG93IHRoZSBwYXJlbnQgbm9kZSBhbmQgaWYgaXQgaGFzIGFscmVhZHkgYmVlbiBwb3NpdGlvbmVkLlxuICAgICAgICBpZiAoY2hpbGROb2RlTGV2ZWwgPiBwYXJlbnRMZXZlbCAmJiB0aGlzLnBvc2l0aW9uZWROb2Rlc1tjaGlsZE5vZGUuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBnZXQgdGhlIGFtb3VudCBvZiBzcGFjZSByZXF1aXJlZCBmb3IgdGhpcyBub2RlLiBJZiBwYXJlbnQgdGhlIHdpZHRoIGlzIGJhc2VkIG9uIHRoZSBhbW91bnQgb2YgY2hpbGRyZW4uXG4gICAgICAgICAgdmFyIHNwYWNpbmcgPSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nO1xuICAgICAgICAgIHZhciBwb3MgPSB2b2lkIDA7XG5cbiAgICAgICAgICAvLyB3ZSBnZXQgdGhlIFggb3IgWSB2YWx1ZXMgd2UgbmVlZCBhbmQgc3RvcmUgdGhlbSBpbiBwb3MgYW5kIHByZXZpb3VzUG9zLlxuICAgICAgICAgIC8vIFRoZSBnZXQgYW5kIHNldCBtYWtlIHN1cmUgd2UgZ2V0IFggb3IgWVxuICAgICAgICAgIGlmIChfaTUgPT09IDApIHtcbiAgICAgICAgICAgIHBvcyA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKHRoaXMuYm9keS5ub2Rlc1twYXJlbnRJZF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihjaGlsZE5vZGVzW19pNSAtIDFdKSArIHNwYWNpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZGlyZWN0aW9uLnNldFBvc2l0aW9uKGNoaWxkTm9kZSwgcG9zLCBjaGlsZE5vZGVMZXZlbCk7XG4gICAgICAgICAgdGhpcy5fdmFsaWRhdGVQb3NpdGlvbkFuZENvbnRpbnVlKGNoaWxkTm9kZSwgY2hpbGROb2RlTGV2ZWwsIHBvcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNlbnRlciB0aGUgcGFyZW50IG5vZGVzLlxuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuX2dldENlbnRlclBvc2l0aW9uKGNoaWxkTm9kZXMpO1xuICAgICAgdGhpcy5kaXJlY3Rpb24uc2V0UG9zaXRpb24odGhpcy5ib2R5Lm5vZGVzW3BhcmVudElkXSwgY2VudGVyLCBwYXJlbnRMZXZlbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgY2hlY2tzIGZvciBvdmVybGFwIGFuZCBpZiByZXF1aXJlZCBzaGlmdHMgdGhlIGJyYW5jaC4gSXQgYWxzbyBrZWVwcyByZWNvcmRzIG9mIHBvc2l0aW9uZWQgbm9kZXMuXG4gICAgICogRmluYWxseSBpdCB3aWxsIGNhbGwgX3BsYWNlQnJhbmNoTm9kZXMgdG8gcGxhY2UgdGhlIGJyYW5jaCBub2Rlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl92YWxpZGF0ZVBvc2l0aW9uQW5kQ29udGludWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ZhbGlkYXRlUG9zaXRpb25BbmRDb250aW51ZShub2RlLCBsZXZlbCwgcG9zKSB7XG4gICAgICAvLyBUaGlzIG1ldGhvZCBvbmx5IHdvcmtzIGZvciBmb3JtYWwgdHJlZXMgYW5kIGZvcm1hbCBmb3Jlc3RzXG4gICAgICAvLyBFYXJseSBleGl0IGlmIHRoaXMgaXMgbm90IHRoZSBjYXNlXG4gICAgICBpZiAoIXRoaXMuaGllcmFyY2hpY2FsLmlzVHJlZSkgcmV0dXJuO1xuXG4gICAgICAvLyBpZiBvdmVybGFwIGhhcyBiZWVuIGRldGVjdGVkLCB3ZSBzaGlmdCB0aGUgYnJhbmNoXG4gICAgICBpZiAodGhpcy5sYXN0Tm9kZU9uTGV2ZWxbbGV2ZWxdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzUG9zID0gdGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24odGhpcy5ib2R5Lm5vZGVzW3RoaXMubGFzdE5vZGVPbkxldmVsW2xldmVsXV0pO1xuICAgICAgICBpZiAocG9zIC0gcHJldmlvdXNQb3MgPCB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nKSB7XG4gICAgICAgICAgdmFyIGRpZmYgPSBwcmV2aW91c1BvcyArIHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcgLSBwb3M7XG4gICAgICAgICAgdmFyIHNoYXJlZFBhcmVudCA9IHRoaXMuX2ZpbmRDb21tb25QYXJlbnQodGhpcy5sYXN0Tm9kZU9uTGV2ZWxbbGV2ZWxdLCBub2RlLmlkKTtcbiAgICAgICAgICB0aGlzLl9zaGlmdEJsb2NrKHNoYXJlZFBhcmVudC53aXRoQ2hpbGQsIGRpZmYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3ROb2RlT25MZXZlbFtsZXZlbF0gPSBub2RlLmlkOyAvLyBzdG9yZSBjaGFuZ2UgaW4gcG9zaXRpb24uXG4gICAgICB0aGlzLnBvc2l0aW9uZWROb2Rlc1tub2RlLmlkXSA9IHRydWU7XG4gICAgICB0aGlzLl9wbGFjZUJyYW5jaE5vZGVzKG5vZGUuaWQsIGxldmVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWNlaXZlcyBhbiBhcnJheSB3aXRoIG5vZGUgaW5kaWNlcyBhbmQgcmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSBhY3R1YWwgbm9kZSByZWZlcmVuY2VzLlxuICAgICAqIFVzZWQgZm9yIHNvcnRpbmcgYmFzZWQgb24gbm9kZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZS5pZD59IGlkQXJyYXlcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPE5vZGU+fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9pbmRleEFycmF5VG9Ob2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5kZXhBcnJheVRvTm9kZXMoaWRBcnJheSkge1xuICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXkucHVzaCh0aGlzLmJvZHkubm9kZXNbaWRBcnJheVtpXV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZ2V0IHRoZSBkaXN0cmlidXRpb24gb2YgbGV2ZWxzIGJhc2VkIG9uIGh1YnNpemVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RGlzdHJpYnV0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0cmlidXRpb24oKSB7XG4gICAgICB2YXIgZGlzdHJpYnV0aW9uID0ge307XG4gICAgICB2YXIgbm9kZUlkLCBub2RlO1xuXG4gICAgICAvLyB3ZSBmaXggWSBiZWNhdXNlIHRoZSBoaWVyYXJjaHkgaXMgdmVydGljYWwsXG4gICAgICAvLyB3ZSBmaXggWCBzbyB3ZSBkbyBub3QgZ2l2ZSBhIG5vZGUgYW4geCBwb3NpdGlvbiBmb3IgYSBzZWNvbmQgdGltZS5cbiAgICAgIC8vIHRoZSBmaXggb2YgWCBpcyByZW1vdmVkIGFmdGVyIHRoZSB4IHZhbHVlIGhhcyBiZWVuIHNldC5cbiAgICAgIGZvciAobm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5ub2Rlcywgbm9kZUlkKSkge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZUlkXSA9PT0gdW5kZWZpbmVkID8gMCA6IHRoaXMuaGllcmFyY2hpY2FsLmxldmVsc1tub2RlSWRdO1xuICAgICAgICAgIHRoaXMuZGlyZWN0aW9uLmZpeChub2RlLCBsZXZlbCk7XG4gICAgICAgICAgaWYgKGRpc3RyaWJ1dGlvbltsZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGlzdHJpYnV0aW9uW2xldmVsXSA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaXN0cmlidXRpb25bbGV2ZWxdW25vZGVJZF0gPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlzdHJpYnV0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgYWN0aXZlIChpLmUuIHZpc2libGUpIGVkZ2VzIGZvciB0aGlzIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48dmlzLkVkZ2U+fSBBcnJheSBvZiBlZGdlIGluc3RhbmNlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEFjdGl2ZUVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRBY3RpdmVFZGdlcyhub2RlKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvckVhY2gkMShub2RlLmVkZ2VzLCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICB2YXIgX2NvbnRleHQzO1xuICAgICAgICBpZiAoX2luZGV4T2ZJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0MyA9IF90aGlzNC5ib2R5LmVkZ2VJbmRpY2VzKS5jYWxsKF9jb250ZXh0MywgZWRnZS5pZCkgIT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZWRnZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGh1YnNpemVzIGZvciBhbGwgYWN0aXZlIG5vZGVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXRIdWJTaXplc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SHViU2l6ZXMoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgICAgIHZhciBodWJTaXplcyA9IHt9O1xuICAgICAgdmFyIG5vZGVJZHMgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICBmb3JFYWNoJDEobm9kZUlkcywgZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICB2YXIgbm9kZSA9IF90aGlzNS5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgIHZhciBodWJTaXplID0gX3RoaXM1Ll9nZXRBY3RpdmVFZGdlcyhub2RlKS5sZW5ndGg7XG4gICAgICAgIGh1YlNpemVzW2h1YlNpemVdID0gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNYWtlIGFuIGFycmF5IG9mIHRoZSBzaXplIHNvcnRlZCBkZXNjZW5kaW5nXG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3JFYWNoJDEoaHViU2l6ZXMsIGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKE51bWJlcihzaXplKSk7XG4gICAgICB9KTtcbiAgICAgIF9zb3J0SW5zdGFuY2VQcm9wZXJ0eShyZXN1bHQpLmNhbGwocmVzdWx0LCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYiAtIGE7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhpcyBmdW5jdGlvbiBhbGxvY2F0ZXMgbm9kZXMgaW4gbGV2ZWxzIGJhc2VkIG9uIHRoZSByZWN1cnNpdmUgYnJhbmNoaW5nIGZyb20gdGhlIGxhcmdlc3QgaHVicy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RldGVybWluZUxldmVsc0J5SHVic2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGV0ZXJtaW5lTGV2ZWxzQnlIdWJzaXplKCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG4gICAgICB2YXIgbGV2ZWxEb3duc3RyZWFtID0gZnVuY3Rpb24gbGV2ZWxEb3duc3RyZWFtKG5vZGVBLCBub2RlQikge1xuICAgICAgICBfdGhpczYuaGllcmFyY2hpY2FsLmxldmVsRG93bnN0cmVhbShub2RlQSwgbm9kZUIpO1xuICAgICAgfTtcbiAgICAgIHZhciBodWJTaXplcyA9IHRoaXMuX2dldEh1YlNpemVzKCk7XG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgdmFyIGh1YlNpemUgPSBodWJTaXplc1tpXTtcbiAgICAgICAgaWYgKGh1YlNpemUgPT09IDApIHJldHVybiAxOyAvLyBicmVha1xuICAgICAgICBmb3JFYWNoJDEoX3RoaXM2LmJvZHkubm9kZUluZGljZXMsIGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IF90aGlzNi5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgaWYgKGh1YlNpemUgPT09IF90aGlzNi5fZ2V0QWN0aXZlRWRnZXMobm9kZSkubGVuZ3RoKSB7XG4gICAgICAgICAgICBfdGhpczYuX2NyYXdsTmV0d29yayhsZXZlbERvd25zdHJlYW0sIG5vZGVJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGh1YlNpemVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChfbG9vcCgpKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUT0RPOiByZWxlYXNlIGZlYXR1cmVcbiAgICAgKiBUT0RPOiBEZXRlcm1pbmUgaWYgdGhpcyBmZWF0dXJlIGlzIG5lZWRlZCBhdCBhbGxcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RldGVybWluZUxldmVsc0N1c3RvbUNhbGxiYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRlcm1pbmVMZXZlbHNDdXN0b21DYWxsYmFjaygpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuICAgICAgdmFyIG1pbkxldmVsID0gMTAwMDAwO1xuXG4gICAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBjb21lIGZyb20gb3B0aW9ucy5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSBUaGlzIHNob3VsZCBldmVudHVhbGx5IGJlIGltcGxlbWVudGVkIHdpdGggdGhlc2UgcGFyYW1ldGVycyB1c2VkLlxuICAgICAgdmFyIGN1c3RvbUNhbGxiYWNrID0gZnVuY3Rpb24gY3VzdG9tQ2FsbGJhY2sobm9kZUEsIG5vZGVCLCBlZGdlKSB7fTtcblxuICAgICAgLy8gVE9ETzogcGVyaGFwcyBtb3ZlIHRvIEhpZXJhcmNoaWNhbFN0YXR1cy5cbiAgICAgIC8vICAgICAgIEJ1dCBJIGN1cnJlbnRseSBkb24ndCBzZWUgdGhlIHBvaW50LCB0aGlzIG1ldGhvZCBpcyBub3QgdXNlZC5cbiAgICAgIHZhciBsZXZlbEJ5RGlyZWN0aW9uID0gZnVuY3Rpb24gbGV2ZWxCeURpcmVjdGlvbihub2RlQSwgbm9kZUIsIGVkZ2UpIHtcbiAgICAgICAgdmFyIGxldmVsQSA9IF90aGlzNy5oaWVyYXJjaGljYWwubGV2ZWxzW25vZGVBLmlkXTtcbiAgICAgICAgLy8gc2V0IGluaXRpYWwgbGV2ZWxcbiAgICAgICAgaWYgKGxldmVsQSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGV2ZWxBID0gX3RoaXM3LmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZUEuaWRdID0gbWluTGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpZmYgPSBjdXN0b21DYWxsYmFjayhOZXR3b3JrVXRpbC5jbG9uZU9wdGlvbnMobm9kZUEsIFwibm9kZVwiKSwgTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKG5vZGVCLCBcIm5vZGVcIiksIE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyhlZGdlLCBcImVkZ2VcIikpO1xuICAgICAgICBfdGhpczcuaGllcmFyY2hpY2FsLmxldmVsc1tub2RlQi5pZF0gPSBsZXZlbEEgKyBkaWZmO1xuICAgICAgfTtcbiAgICAgIHRoaXMuX2NyYXdsTmV0d29yayhsZXZlbEJ5RGlyZWN0aW9uKTtcbiAgICAgIHRoaXMuaGllcmFyY2hpY2FsLnNldE1pbkxldmVsVG9aZXJvKHRoaXMuYm9keS5ub2Rlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxsb2NhdGUgbm9kZXMgaW4gbGV2ZWxzIGJhc2VkIG9uIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGVkZ2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZGV0ZXJtaW5lTGV2ZWxzRGlyZWN0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZUxldmVsc0RpcmVjdGVkKCkge1xuICAgICAgdmFyIF9jb250ZXh0NCxcbiAgICAgICAgX3RoaXM4ID0gdGhpcztcbiAgICAgIHZhciBub2RlcyA9IF9yZWR1Y2VJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0NCA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcykuY2FsbChfY29udGV4dDQsIGZ1bmN0aW9uIChhY2MsIGlkKSB7XG4gICAgICAgIGFjYy5zZXQoaWQsIF90aGlzOC5ib2R5Lm5vZGVzW2lkXSk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCBuZXcgX01hcCgpKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLnNoYWtlVG93YXJkcyA9PT0gXCJyb290c1wiKSB7XG4gICAgICAgIHRoaXMuaGllcmFyY2hpY2FsLmxldmVscyA9IGZpbGxMZXZlbHNCeURpcmVjdGlvblJvb3RzKG5vZGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGllcmFyY2hpY2FsLmxldmVscyA9IGZpbGxMZXZlbHNCeURpcmVjdGlvbkxlYXZlcyhub2Rlcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmhpZXJhcmNoaWNhbC5zZXRNaW5MZXZlbFRvWmVybyh0aGlzLmJvZHkubm9kZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgYm9va2tlZXBpbmcgb2YgcGFyZW50IGFuZCBjaGlsZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dlbmVyYXRlTWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZW5lcmF0ZU1hcCgpIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuICAgICAgdmFyIGZpbGxJblJlbGF0aW9ucyA9IGZ1bmN0aW9uIGZpbGxJblJlbGF0aW9ucyhwYXJlbnROb2RlLCBjaGlsZE5vZGUpIHtcbiAgICAgICAgaWYgKF90aGlzOS5oaWVyYXJjaGljYWwubGV2ZWxzW2NoaWxkTm9kZS5pZF0gPiBfdGhpczkuaGllcmFyY2hpY2FsLmxldmVsc1twYXJlbnROb2RlLmlkXSkge1xuICAgICAgICAgIF90aGlzOS5oaWVyYXJjaGljYWwuYWRkUmVsYXRpb24ocGFyZW50Tm9kZS5pZCwgY2hpbGROb2RlLmlkKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMuX2NyYXdsTmV0d29yayhmaWxsSW5SZWxhdGlvbnMpO1xuICAgICAgdGhpcy5oaWVyYXJjaGljYWwuY2hlY2tJZlRyZWUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmF3bCBvdmVyIHRoZSBlbnRpcmUgbmV0d29yayBhbmQgdXNlIGEgY2FsbGJhY2sgb24gZWFjaCBub2RlIGNvdXBsZSB0aGF0IGlzIGNvbm5lY3RlZCB0byBlYWNoIG90aGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWZ1bmN0aW9uKCl7fV0gICAgICAgICAgfCB3aWxsIHJlY2VpdmUgbm9kZUEsIG5vZGVCIGFuZCB0aGUgY29ubmVjdGluZyBlZGdlLiBBIGFuZCBCIGFyZSBkaXN0aW5jdC5cbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IHN0YXJ0aW5nTm9kZUlkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY3Jhd2xOZXR3b3JrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmF3bE5ldHdvcmsoKSB7XG4gICAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgdmFyIHN0YXJ0aW5nTm9kZUlkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgcHJvZ3Jlc3MgPSB7fTtcbiAgICAgIHZhciBjcmF3bGVyID0gZnVuY3Rpb24gY3Jhd2xlcihub2RlLCB0cmVlKSB7XG4gICAgICAgIGlmIChwcm9ncmVzc1tub2RlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgX3RoaXMxMC5oaWVyYXJjaGljYWwuc2V0VHJlZUluZGV4KG5vZGUsIHRyZWUpO1xuICAgICAgICAgIHByb2dyZXNzW25vZGUuaWRdID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgY2hpbGROb2RlO1xuICAgICAgICAgIHZhciBlZGdlcyA9IF90aGlzMTAuX2dldEFjdGl2ZUVkZ2VzKG5vZGUpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgICAgICAgICBpZiAoZWRnZS5jb25uZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgaWYgKGVkZ2UudG9JZCA9PSBub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ICc9PT0nIGJlY2F1c2UgaWQncyBjYW4gYmUgc3RyaW5nIGFuZCBudW1lcmljXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlID0gZWRnZS5mcm9tO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGVkZ2UudG87XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgIT0gY2hpbGROb2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ICchPT0nIGJlY2F1c2UgaWQncyBjYW4gYmUgc3RyaW5nIGFuZCBudW1lcmljXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobm9kZSwgY2hpbGROb2RlLCBlZGdlKTtcbiAgICAgICAgICAgICAgICBjcmF3bGVyKGNoaWxkTm9kZSwgdHJlZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoc3RhcnRpbmdOb2RlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBDcmF3bCBvdmVyIGFsbCBub2Rlc1xuICAgICAgICB2YXIgdHJlZUluZGV4ID0gMDsgLy8gU2VydmVzIHRvIHBhc3MgYSB1bmlxdWUgaWQgZm9yIHRoZSBjdXJyZW50IGRpc3RpbmN0IHRyZWVcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBub2RlSWQgPSB0aGlzLmJvZHkubm9kZUluZGljZXNbaV07XG4gICAgICAgICAgaWYgKHByb2dyZXNzW25vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgIGNyYXdsZXIobm9kZSwgdHJlZUluZGV4KTtcbiAgICAgICAgICAgIHRyZWVJbmRleCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ3Jhd2wgZnJvbSB0aGUgZ2l2ZW4gc3RhcnRpbmcgbm9kZVxuICAgICAgICB2YXIgX25vZGUyID0gdGhpcy5ib2R5Lm5vZGVzW3N0YXJ0aW5nTm9kZUlkXTtcbiAgICAgICAgaWYgKF9ub2RlMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIk5vZGUgbm90IGZvdW5kOlwiLCBzdGFydGluZ05vZGVJZCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNyYXdsZXIoX25vZGUyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaGlmdCBhIGJyYW5jaCBhIGNlcnRhaW4gZGlzdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gcGFyZW50SWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlmZlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NoaWZ0QmxvY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NoaWZ0QmxvY2socGFyZW50SWQsIGRpZmYpIHtcbiAgICAgIHZhciBfdGhpczExID0gdGhpcztcbiAgICAgIHZhciBwcm9ncmVzcyA9IHt9O1xuICAgICAgdmFyIHNoaWZ0ZXIgPSBmdW5jdGlvbiBzaGlmdGVyKHBhcmVudElkKSB7XG4gICAgICAgIGlmIChwcm9ncmVzc1twYXJlbnRJZF0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJvZ3Jlc3NbcGFyZW50SWRdID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMxMS5kaXJlY3Rpb24uc2hpZnQocGFyZW50SWQsIGRpZmYpO1xuICAgICAgICB2YXIgY2hpbGRSZWYgPSBfdGhpczExLmhpZXJhcmNoaWNhbC5jaGlsZHJlblJlZmVyZW5jZVtwYXJlbnRJZF07XG4gICAgICAgIGlmIChjaGlsZFJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZFJlZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2hpZnRlcihjaGlsZFJlZltpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2hpZnRlcihwYXJlbnRJZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBhIGNvbW1vbiBwYXJlbnQgYmV0d2VlbiBicmFuY2hlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gY2hpbGRBXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBjaGlsZEJcbiAgICAgKiBAcmV0dXJucyB7e2ZvdW5kUGFyZW50LCB3aXRoQ2hpbGR9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmRDb21tb25QYXJlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRDb21tb25QYXJlbnQoY2hpbGRBLCBjaGlsZEIpIHtcbiAgICAgIHZhciBfdGhpczEyID0gdGhpcztcbiAgICAgIHZhciBwYXJlbnRzID0ge307XG4gICAgICB2YXIgaXRlcmF0ZVBhcmVudHMgPSBmdW5jdGlvbiBpdGVyYXRlUGFyZW50cyhwYXJlbnRzLCBjaGlsZCkge1xuICAgICAgICB2YXIgcGFyZW50UmVmID0gX3RoaXMxMi5oaWVyYXJjaGljYWwucGFyZW50UmVmZXJlbmNlW2NoaWxkXTtcbiAgICAgICAgaWYgKHBhcmVudFJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRSZWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRSZWZbaV07XG4gICAgICAgICAgICBwYXJlbnRzW3BhcmVudF0gPSB0cnVlO1xuICAgICAgICAgICAgaXRlcmF0ZVBhcmVudHMocGFyZW50cywgcGFyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgZmluZFBhcmVudCA9IGZ1bmN0aW9uIGZpbmRQYXJlbnQocGFyZW50cywgY2hpbGQpIHtcbiAgICAgICAgdmFyIHBhcmVudFJlZiA9IF90aGlzMTIuaGllcmFyY2hpY2FsLnBhcmVudFJlZmVyZW5jZVtjaGlsZF07XG4gICAgICAgIGlmIChwYXJlbnRSZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50UmVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50UmVmW2ldO1xuICAgICAgICAgICAgaWYgKHBhcmVudHNbcGFyZW50XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZm91bmRQYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgICAgICAgICB3aXRoQ2hpbGQ6IGNoaWxkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYnJhbmNoID0gZmluZFBhcmVudChwYXJlbnRzLCBwYXJlbnQpO1xuICAgICAgICAgICAgaWYgKGJyYW5jaC5mb3VuZFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZvdW5kUGFyZW50OiBudWxsLFxuICAgICAgICAgIHdpdGhDaGlsZDogY2hpbGRcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBpdGVyYXRlUGFyZW50cyhwYXJlbnRzLCBjaGlsZEEpO1xuICAgICAgcmV0dXJuIGZpbmRQYXJlbnQocGFyZW50cywgY2hpbGRCKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHN0cmF0ZWd5IHBhdHRlcm4gZm9yIGhhbmRsaW5nIHRoZSBjb29yZGluYXRlcyBnaXZlbiB0aGUgY3VycmVudCBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGUgaW5kaXZpZHVhbCBpbnN0YW5jZXMgY29udGFpbiBhbGwgdGhlIG9wZXJhdGlvbnMgYW5kIGRhdGEgc3BlY2lmaWMgdG8gYSBsYXlvdXQgZGlyZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RvTm90VXBkYXRlPWZhbHNlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RGlyZWN0aW9uU3RyYXRlZ3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGlyZWN0aW9uU3RyYXRlZ3koKSB7XG4gICAgICB2YXIgaXNWZXJ0aWNhbCA9IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSBcIlVEXCIgfHwgdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5kaXJlY3Rpb24gPT09IFwiRFVcIjtcbiAgICAgIGlmIChpc1ZlcnRpY2FsKSB7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gbmV3IFZlcnRpY2FsU3RyYXRlZ3kodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IG5ldyBIb3Jpem9udGFsU3RyYXRlZ3kodGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBjZW50ZXIgcG9zaXRpb24gb2YgYSBicmFuY2ggZnJvbSB0aGUgcGFzc2VkIGxpc3Qgb2YgY2hpbGQgbm9kZXNcbiAgICAgKlxuICAgICAqIFRoaXMgdGFrZXMgaW50byBhY2NvdW50IHRoZSBwb3NpdGlvbnMgb2YgYWxsIHRoZSBjaGlsZCBub2Rlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE5vZGV8dmlzLk5vZGUuaWQ+fSBjaGlsZE5vZGVzICBBcnJheSBvZiBlaXRoZXIgY2hpbGQgbm9kZXMgb3Igbm9kZSBpZCdzXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXRDZW50ZXJQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q2VudGVyUG9zaXRpb24oY2hpbGROb2Rlcykge1xuICAgICAgdmFyIG1pblBvcyA9IDFlOTtcbiAgICAgIHZhciBtYXhQb3MgPSAtMWU5O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZE5vZGUgPSB2b2lkIDA7XG4gICAgICAgIGlmIChjaGlsZE5vZGVzW2ldLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjaGlsZE5vZGVJZCA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgY2hpbGROb2RlID0gdGhpcy5ib2R5Lm5vZGVzW2NoaWxkTm9kZUlkXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihjaGlsZE5vZGUpO1xuICAgICAgICBtaW5Qb3MgPSBNYXRoLm1pbihtaW5Qb3MsIHBvc2l0aW9uKTtcbiAgICAgICAgbWF4UG9zID0gTWF0aC5tYXgobWF4UG9zLCBwb3NpdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gMC41ICogKG1pblBvcyArIG1heFBvcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBMYXlvdXRFbmdpbmU7XG59KCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBfU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIF9nZXRJdGVyYXRvck1ldGhvZChvKSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoX0FycmF5JGlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgdmFyIF9jb250ZXh0MzI7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IF9zbGljZUluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQzMiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkuY2FsbChfY29udGV4dDMyLCA4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBfQXJyYXkkZnJvbSQxKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG5cbi8qKlxuICogQ2xlYXJzIHRoZSB0b29sYmFyIGRpdiBlbGVtZW50IG9mIGNoaWxkcmVuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIE1hbmlwdWxhdGlvblN5c3RlbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gICAqIEBwYXJhbSB7U2VsZWN0aW9uSGFuZGxlcn0gc2VsZWN0aW9uSGFuZGxlclxuICAgKiBAcGFyYW0ge0ludGVyYWN0aW9uSGFuZGxlcn0gaW50ZXJhY3Rpb25IYW5kbGVyXG4gICAqL1xuICBmdW5jdGlvbiBNYW5pcHVsYXRpb25TeXN0ZW0oYm9keSwgY2FudmFzLCBzZWxlY3Rpb25IYW5kbGVyLCBpbnRlcmFjdGlvbkhhbmRsZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgX2NvbnRleHQsXG4gICAgICBfY29udGV4dDI7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hbmlwdWxhdGlvblN5c3RlbSk7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIgPSBzZWxlY3Rpb25IYW5kbGVyO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyID0gaW50ZXJhY3Rpb25IYW5kbGVyO1xuICAgIHRoaXMuZWRpdE1vZGUgPSBmYWxzZTtcbiAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVkaXRNb2RlRGl2ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2xvc2VEaXYgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZG9tRXZlbnRMaXN0ZW5lckNsZWFudXBRdWV1ZSA9IFtdO1xuICAgIHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnMgPSB7fTtcbiAgICB0aGlzLnRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zID0gW107XG4gICAgdGhpcy50b3VjaFRpbWUgPSAwO1xuICAgIHRoaXMudGVtcG9yYXJ5SWRzID0ge1xuICAgICAgbm9kZXM6IFtdLFxuICAgICAgZWRnZXM6IFtdXG4gICAgfTtcbiAgICB0aGlzLmd1aUVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmluTW9kZSA9IGZhbHNlO1xuICAgIHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBpbml0aWFsbHlBY3RpdmU6IGZhbHNlLFxuICAgICAgYWRkTm9kZTogdHJ1ZSxcbiAgICAgIGFkZEVkZ2U6IHRydWUsXG4gICAgICBlZGl0Tm9kZTogdW5kZWZpbmVkLFxuICAgICAgZWRpdEVkZ2U6IHRydWUsXG4gICAgICBkZWxldGVOb2RlOiB0cnVlLFxuICAgICAgZGVsZXRlRWRnZTogdHJ1ZSxcbiAgICAgIGNvbnRyb2xOb2RlU3R5bGU6IHtcbiAgICAgICAgc2hhcGU6IFwiZG90XCIsXG4gICAgICAgIHNpemU6IDYsXG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogXCIjZmYwMDAwXCIsXG4gICAgICAgICAgYm9yZGVyOiBcIiMzYzNjM2NcIixcbiAgICAgICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IFwiIzA3Zjk2OFwiLFxuICAgICAgICAgICAgYm9yZGVyOiBcIiMzYzNjM2NcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYm9yZGVyV2lkdGg6IDIsXG4gICAgICAgIGJvcmRlcldpZHRoU2VsZWN0ZWQ6IDJcbiAgICAgIH1cbiAgICB9O1xuICAgIF9PYmplY3QkYXNzaWduKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLl9jbGVhbigpO1xuICAgIH0pO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFDaGFuZ2VkXCIsIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0ID0gdGhpcy5fcmVzdG9yZSkuY2FsbChfY29udGV4dCwgdGhpcykpO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3Jlc2V0RGF0YVwiLCBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDIgPSB0aGlzLl9yZXN0b3JlKS5jYWxsKF9jb250ZXh0MiwgdGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHNvbWV0aGluZyBjaGFuZ2VzIGluIHRoZSBkYXRhIGR1cmluZyBlZGl0aW5nLCBzd2l0Y2ggYmFjayB0byB0aGUgaW5pdGlhbCBkYXRhbWFuaXB1bGF0aW9uIHN0YXRlIGFuZCBjbG9zZSBhbGwgZWRpdCBtb2Rlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhNYW5pcHVsYXRpb25TeXN0ZW0sIFt7XG4gICAga2V5OiBcIl9yZXN0b3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXN0b3JlKCkge1xuICAgICAgaWYgKHRoaXMuaW5Nb2RlICE9PSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmluaXRpYWxseUFjdGl2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBPcHRpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhbGxPcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbE9wdGlvbnNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucywgYWxsT3B0aW9ucywgZ2xvYmFsT3B0aW9ucykge1xuICAgICAgaWYgKGFsbE9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYWxsT3B0aW9ucy5sb2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5sb2NhbGUgPSBhbGxPcHRpb25zLmxvY2FsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMubG9jYWxlID0gZ2xvYmFsT3B0aW9ucy5sb2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbE9wdGlvbnMubG9jYWxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmxvY2FsZXMgPSBhbGxPcHRpb25zLmxvY2FsZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmxvY2FsZXMgPSBnbG9iYWxPcHRpb25zLmxvY2FsZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkID0gb3B0aW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgZGVlcEV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5pdGlhbGx5QWN0aXZlID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5lZGl0TW9kZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0dXAoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBlZGl0LW1vZGUuIERyYXdzIHRoZSBET00gcmVxdWlyZWQgYW5kIGNsZWFucyB1cCBhZnRlciBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZUVkaXRNb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZUVkaXRNb2RlKCkge1xuICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIEVkaXQgTW9kZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZUVkaXRNb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZUVkaXRNb2RlKCkge1xuICAgICAgdGhpcy5lZGl0TW9kZSA9IHRydWU7XG4gICAgICB0aGlzLl9jbGVhbigpO1xuICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICB0aGlzLmNsb3NlRGl2LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIHRoaXMuZWRpdE1vZGVEaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlcyBFZGl0IE1vZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkaXNhYmxlRWRpdE1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZUVkaXRNb2RlKCkge1xuICAgICAgdGhpcy5lZGl0TW9kZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fY2xlYW4oKTtcbiAgICAgIGlmICh0aGlzLmd1aUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB0aGlzLmNsb3NlRGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICB0aGlzLl9jcmVhdGVFZGl0QnV0dG9uKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgbWFpbiB0b29sYmFyLiBSZW1vdmVzIGZ1bmN0aW9ucyBib3VuZCB0byB0aGUgc2VsZWN0IGV2ZW50LiBCaW5kcyBhbGwgdGhlIGJ1dHRvbnMgb2YgdGhlIHRvb2xiYXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNob3dNYW5pcHVsYXRvclRvb2xiYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpIHtcbiAgICAgIC8vIHJlc3RvcmUgdGhlIHN0YXRlIG9mIGFueSBib3VuZCBmdW5jdGlvbnMgb3IgZXZlbnRzLCByZW1vdmUgY29udHJvbCBub2RlcywgcmVzdG9yZSBwaHlzaWNzXG4gICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICAvLyByZXNldCBnbG9iYWwgdmFyaWFibGVzXG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTSA9IHt9O1xuXG4gICAgICAvLyBpZiB0aGUgZ3VpIGlzIGVuYWJsZWQsIGRyYXcgYWxsIGVsZW1lbnRzLlxuICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgX2NvbnRleHQzLCBfY29udGV4dDQ7XG4gICAgICAgIC8vIGEgX3Jlc3RvcmUgd2lsbCBoaWRlIHRoZXNlIG1lbnVzXG4gICAgICAgIHRoaXMuZWRpdE1vZGUgPSB0cnVlO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICB0aGlzLmNsb3NlRGl2LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIHZhciBzZWxlY3RlZE5vZGVDb3VudCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZE5vZGVDb3VudCgpO1xuICAgICAgICB2YXIgc2VsZWN0ZWRFZGdlQ291bnQgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWRFZGdlQ291bnQoKTtcbiAgICAgICAgdmFyIHNlbGVjdGVkVG90YWxDb3VudCA9IHNlbGVjdGVkTm9kZUNvdW50ICsgc2VsZWN0ZWRFZGdlQ291bnQ7XG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTtcbiAgICAgICAgdmFyIG5lZWRTZXBlcmF0b3IgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hZGROb2RlICE9PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuX2NyZWF0ZUFkZE5vZGVCdXR0b24obG9jYWxlKTtcbiAgICAgICAgICBuZWVkU2VwZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFkZEVkZ2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKG5lZWRTZXBlcmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcigxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmVlZFNlcGVyYXRvciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2NyZWF0ZUFkZEVkZ2VCdXR0b24obG9jYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZWN0ZWROb2RlQ291bnQgPT09IDEgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy5lZGl0Tm9kZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgaWYgKG5lZWRTZXBlcmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcigyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmVlZFNlcGVyYXRvciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2NyZWF0ZUVkaXROb2RlQnV0dG9uKGxvY2FsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRFZGdlQ291bnQgPT09IDEgJiYgc2VsZWN0ZWROb2RlQ291bnQgPT09IDAgJiYgdGhpcy5vcHRpb25zLmVkaXRFZGdlICE9PSBmYWxzZSkge1xuICAgICAgICAgIGlmIChuZWVkU2VwZXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoMyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5lZWRTZXBlcmF0b3IgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jcmVhdGVFZGl0RWRnZUJ1dHRvbihsb2NhbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGJ1dHRvbnNcbiAgICAgICAgaWYgKHNlbGVjdGVkVG90YWxDb3VudCAhPT0gMCkge1xuICAgICAgICAgIGlmIChzZWxlY3RlZE5vZGVDb3VudCA+IDAgJiYgdGhpcy5vcHRpb25zLmRlbGV0ZU5vZGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAobmVlZFNlcGVyYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVEZWxldGVCdXR0b24obG9jYWxlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdGVkTm9kZUNvdW50ID09PSAwICYmIHRoaXMub3B0aW9ucy5kZWxldGVFZGdlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKG5lZWRTZXBlcmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlRGVsZXRlQnV0dG9uKGxvY2FsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmluZCB0aGUgY2xvc2UgYnV0dG9uXG4gICAgICAgIHRoaXMuX2JpbmRFbGVtZW50RXZlbnRzKHRoaXMuY2xvc2VEaXYsIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MyA9IHRoaXMudG9nZ2xlRWRpdE1vZGUpLmNhbGwoX2NvbnRleHQzLCB0aGlzKSk7XG5cbiAgICAgICAgLy8gcmVmcmVzaCB0aGlzIGJhciBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHNlbGVjdGVkXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRFdmVudChcInNlbGVjdFwiLCBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDQgPSB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIpLmNhbGwoX2NvbnRleHQ0LCB0aGlzKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlZHJhdyB0byBzaG93IGFueSBwb3NzaWJsZSBjaGFuZ2VzXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIHRvb2xiYXIgZm9yIGFkZGluZyBOb2Rlc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFkZE5vZGVNb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE5vZGVNb2RlKCkge1xuICAgICAgdmFyIF9jb250ZXh0NjtcbiAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIGd1aSwgZW5hYmxlIGVkaXQgbW9kZSBpZiBpdCB3YXNudCBhbHJlYWR5LlxuICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgIT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyByZXN0b3JlIHRoZSBzdGF0ZSBvZiBhbnkgYm91bmQgZnVuY3Rpb25zIG9yIGV2ZW50cywgcmVtb3ZlIGNvbnRyb2wgbm9kZXMsIHJlc3RvcmUgcGh5c2ljc1xuICAgICAgdGhpcy5fY2xlYW4oKTtcbiAgICAgIHRoaXMuaW5Nb2RlID0gXCJhZGROb2RlXCI7XG4gICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBfY29udGV4dDU7XG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET00gPSB7fTtcbiAgICAgICAgdGhpcy5fY3JlYXRlQmFja0J1dHRvbihsb2NhbGUpO1xuICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoKTtcbiAgICAgICAgdGhpcy5fY3JlYXRlRGVzY3JpcHRpb24obG9jYWxlW1wiYWRkRGVzY3JpcHRpb25cIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImFkZERlc2NyaXB0aW9uXCJdKTtcblxuICAgICAgICAvLyBiaW5kIHRoZSBjbG9zZSBidXR0b25cbiAgICAgICAgdGhpcy5fYmluZEVsZW1lbnRFdmVudHModGhpcy5jbG9zZURpdiwgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQ1ID0gdGhpcy50b2dnbGVFZGl0TW9kZSkuY2FsbChfY29udGV4dDUsIHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRFdmVudChcImNsaWNrXCIsIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0NiA9IHRoaXMuX3BlcmZvcm1BZGROb2RlKS5jYWxsKF9jb250ZXh0NiwgdGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNhbGwgdGhlIGJvdW5kIGZ1bmN0aW9uIHRvIGhhbmRsZSB0aGUgZWRpdGluZyBvZiB0aGUgbm9kZS4gVGhlIG5vZGUgaGFzIHRvIGJlIHNlbGVjdGVkLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImVkaXROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXROb2RlKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICAvLyB3aGVuIHVzaW5nIHRoZSBndWksIGVuYWJsZSBlZGl0IG1vZGUgaWYgaXQgd2FzbnQgYWxyZWFkeS5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcbiAgICAgIHRoaXMuX2NsZWFuKCk7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZE5vZGVzKClbMF07XG4gICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaW5Nb2RlID0gXCJlZGl0Tm9kZVwiO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5lZGl0Tm9kZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgaWYgKG5vZGUuaXNDbHVzdGVyICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGRlZXBFeHRlbmQoe30sIG5vZGUub3B0aW9ucywgZmFsc2UpO1xuICAgICAgICAgICAgZGF0YS54ID0gbm9kZS54O1xuICAgICAgICAgICAgZGF0YS55ID0gbm9kZS55O1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lZGl0Tm9kZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVkaXROb2RlKGRhdGEsIGZ1bmN0aW9uIChmaW5hbGl6ZWREYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmFsaXplZERhdGEgIT09IG51bGwgJiYgZmluYWxpemVkRGF0YSAhPT0gdW5kZWZpbmVkICYmIF90aGlzMi5pbk1vZGUgPT09IFwiZWRpdE5vZGVcIikge1xuICAgICAgICAgICAgICAgICAgLy8gaWYgZm9yIHdoYXRldmVyIHJlYXNvbiB0aGUgbW9kZSBoYXMgY2hhbmdlcyAoZHVlIHRvIGRhdGFzZXQgY2hhbmdlKSBkaXNyZWdhcmQgdGhlIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpczIuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKS51cGRhdGUoZmluYWxpemVkRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzMi5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZ1bmN0aW9uIGZvciBlZGl0IGRvZXMgbm90IHN1cHBvcnQgdHdvIGFyZ3VtZW50cyAoZGF0YSwgY2FsbGJhY2spXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVtcImVkaXRDbHVzdGVyRXJyb3JcIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImVkaXRDbHVzdGVyRXJyb3JcIl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBmdW5jdGlvbiBoYXMgYmVlbiBjb25maWd1cmVkIHRvIGhhbmRsZSB0aGUgZWRpdGluZyBvZiBub2Rlcy5cIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSB0aGUgdG9vbGJhciB0byBjb25uZWN0IG5vZGVzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRWRnZU1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRWRnZU1vZGUoKSB7XG4gICAgICB2YXIgX2NvbnRleHQ4LCBfY29udGV4dDksIF9jb250ZXh0MTAsIF9jb250ZXh0MTEsIF9jb250ZXh0MTI7XG4gICAgICAvLyB3aGVuIHVzaW5nIHRoZSBndWksIGVuYWJsZSBlZGl0IG1vZGUgaWYgaXQgd2FzbnQgYWxyZWFkeS5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcbiAgICAgIHRoaXMuX2NsZWFuKCk7XG4gICAgICB0aGlzLmluTW9kZSA9IFwiYWRkRWRnZVwiO1xuICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgX2NvbnRleHQ3O1xuICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NID0ge307XG4gICAgICAgIHRoaXMuX2NyZWF0ZUJhY2tCdXR0b24obG9jYWxlKTtcbiAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKCk7XG4gICAgICAgIHRoaXMuX2NyZWF0ZURlc2NyaXB0aW9uKGxvY2FsZVtcImVkZ2VEZXNjcmlwdGlvblwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiZWRnZURlc2NyaXB0aW9uXCJdKTtcblxuICAgICAgICAvLyBiaW5kIHRoZSBjbG9zZSBidXR0b25cbiAgICAgICAgdGhpcy5fYmluZEVsZW1lbnRFdmVudHModGhpcy5jbG9zZURpdiwgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQ3ID0gdGhpcy50b2dnbGVFZGl0TW9kZSkuY2FsbChfY29udGV4dDcsIHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgLy8gdGVtcG9yYXJpbHkgb3ZlcmxvYWQgZnVuY3Rpb25zXG4gICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvblRvdWNoXCIsIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0OCA9IHRoaXMuX2hhbmRsZUNvbm5lY3QpLmNhbGwoX2NvbnRleHQ4LCB0aGlzKSk7XG4gICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvbkRyYWdFbmRcIiwgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQ5ID0gdGhpcy5fZmluaXNoQ29ubmVjdCkuY2FsbChfY29udGV4dDksIHRoaXMpKTtcbiAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uRHJhZ1wiLCBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDEwID0gdGhpcy5fZHJhZ0NvbnRyb2xOb2RlKS5jYWxsKF9jb250ZXh0MTAsIHRoaXMpKTtcbiAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uUmVsZWFzZVwiLCBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDExID0gdGhpcy5fZmluaXNoQ29ubmVjdCkuY2FsbChfY29udGV4dDExLCB0aGlzKSk7XG4gICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvbkRyYWdTdGFydFwiLCBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDEyID0gdGhpcy5fZHJhZ1N0YXJ0RWRnZSkuY2FsbChfY29udGV4dDEyLCB0aGlzKSk7XG4gICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvbkhvbGRcIiwgZnVuY3Rpb24gKCkge30pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSB0aGUgdG9vbGJhciB0byBlZGl0IGVkZ2VzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZWRpdEVkZ2VNb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXRFZGdlTW9kZSgpIHtcbiAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIGd1aSwgZW5hYmxlIGVkaXQgbW9kZSBpZiBpdCB3YXNuJ3QgYWxyZWFkeS5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcbiAgICAgIHRoaXMuX2NsZWFuKCk7XG4gICAgICB0aGlzLmluTW9kZSA9IFwiZWRpdEVkZ2VcIjtcbiAgICAgIGlmIChfdHlwZW9mKHRoaXMub3B0aW9ucy5lZGl0RWRnZSkgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy5lZGl0RWRnZS5lZGl0V2l0aG91dERyYWcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLmVkZ2VCZWluZ0VkaXRlZElkID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkRWRnZUlkcygpWzBdO1xuICAgICAgICBpZiAodGhpcy5lZGdlQmVpbmdFZGl0ZWRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZF07XG4gICAgICAgICAgdGhpcy5fcGVyZm9ybUVkaXRFZGdlKGVkZ2UuZnJvbS5pZCwgZWRnZS50by5pZCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBfY29udGV4dDEzO1xuICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NID0ge307XG4gICAgICAgIHRoaXMuX2NyZWF0ZUJhY2tCdXR0b24obG9jYWxlKTtcbiAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKCk7XG4gICAgICAgIHRoaXMuX2NyZWF0ZURlc2NyaXB0aW9uKGxvY2FsZVtcImVkaXRFZGdlRGVzY3JpcHRpb25cIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImVkaXRFZGdlRGVzY3JpcHRpb25cIl0pO1xuXG4gICAgICAgIC8vIGJpbmQgdGhlIGNsb3NlIGJ1dHRvblxuICAgICAgICB0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyh0aGlzLmNsb3NlRGl2LCBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDEzID0gdGhpcy50b2dnbGVFZGl0TW9kZSkuY2FsbChfY29udGV4dDEzLCB0aGlzKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmVkZ2VCZWluZ0VkaXRlZElkID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkRWRnZUlkcygpWzBdO1xuICAgICAgaWYgKHRoaXMuZWRnZUJlaW5nRWRpdGVkSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgX2NvbnRleHQxNCwgX2NvbnRleHQxNSwgX2NvbnRleHQxNiwgX2NvbnRleHQxNztcbiAgICAgICAgdmFyIF9lZGdlID0gdGhpcy5ib2R5LmVkZ2VzW3RoaXMuZWRnZUJlaW5nRWRpdGVkSWRdO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBjb250cm9sIG5vZGVzXG4gICAgICAgIHZhciBjb250cm9sTm9kZUZyb20gPSB0aGlzLl9nZXROZXdUYXJnZXROb2RlKF9lZGdlLmZyb20ueCwgX2VkZ2UuZnJvbS55KTtcbiAgICAgICAgdmFyIGNvbnRyb2xOb2RlVG8gPSB0aGlzLl9nZXROZXdUYXJnZXROb2RlKF9lZGdlLnRvLngsIF9lZGdlLnRvLnkpO1xuICAgICAgICB0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlcy5wdXNoKGNvbnRyb2xOb2RlRnJvbS5pZCk7XG4gICAgICAgIHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzLnB1c2goY29udHJvbE5vZGVUby5pZCk7XG4gICAgICAgIHRoaXMuYm9keS5ub2Rlc1tjb250cm9sTm9kZUZyb20uaWRdID0gY29udHJvbE5vZGVGcm9tO1xuICAgICAgICB0aGlzLmJvZHkubm9kZUluZGljZXMucHVzaChjb250cm9sTm9kZUZyb20uaWQpO1xuICAgICAgICB0aGlzLmJvZHkubm9kZXNbY29udHJvbE5vZGVUby5pZF0gPSBjb250cm9sTm9kZVRvO1xuICAgICAgICB0aGlzLmJvZHkubm9kZUluZGljZXMucHVzaChjb250cm9sTm9kZVRvLmlkKTtcblxuICAgICAgICAvLyB0ZW1wb3JhcmlseSBvdmVybG9hZCBVSSBmdW5jdGlvbnMsIGNsZWFuZWQgdXAgYXV0b21hdGljYWxseSBiZWNhdXNlIG9mIF90ZW1wb3JhcnlCaW5kVUlcbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25Ub3VjaFwiLCBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDE0ID0gdGhpcy5fY29udHJvbE5vZGVUb3VjaCkuY2FsbChfY29udGV4dDE0LCB0aGlzKSk7IC8vIHVzZWQgdG8gZ2V0IHRoZSBwb3NpdGlvblxuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvblRhcFwiLCBmdW5jdGlvbiAoKSB7fSk7IC8vIGRpc2FibGVkXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uSG9sZFwiLCBmdW5jdGlvbiAoKSB7fSk7IC8vIGRpc2FibGVkXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uRHJhZ1N0YXJ0XCIsIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MTUgPSB0aGlzLl9jb250cm9sTm9kZURyYWdTdGFydCkuY2FsbChfY29udGV4dDE1LCB0aGlzKSk7IC8vIHVzZWQgdG8gc2VsZWN0IGNvbnRyb2wgbm9kZVxuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvbkRyYWdcIiwgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQxNiA9IHRoaXMuX2NvbnRyb2xOb2RlRHJhZykuY2FsbChfY29udGV4dDE2LCB0aGlzKSk7IC8vIHVzZWQgdG8gZHJhZyBjb250cm9sIG5vZGVcbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25EcmFnRW5kXCIsIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MTcgPSB0aGlzLl9jb250cm9sTm9kZURyYWdFbmQpLmNhbGwoX2NvbnRleHQxNywgdGhpcykpOyAvLyB1c2VkIHRvIGNvbm5lY3Qgb3IgcmV2ZXJ0IGNvbnRyb2wgbm9kZXNcbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25Nb3VzZU1vdmVcIiwgZnVuY3Rpb24gKCkge30pOyAvLyBkaXNhYmxlZFxuXG4gICAgICAgIC8vIGNyZWF0ZSBmdW5jdGlvbiB0byBwb3NpdGlvbiBjb250cm9sIG5vZGVzIGNvcnJlY3RseSBvbiBtb3ZlbWVudFxuICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IGNsZWFuZWQgdXAgYmVjYXVzZSB3ZSB1c2UgdGhlIHRlbXBvcmFyeSBiaW5kXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRFdmVudChcImJlZm9yZURyYXdpbmdcIiwgZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSBfZWRnZS5lZGdlVHlwZS5maW5kQm9yZGVyUG9zaXRpb25zKGN0eCk7XG4gICAgICAgICAgaWYgKGNvbnRyb2xOb2RlRnJvbS5zZWxlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRyb2xOb2RlRnJvbS54ID0gcG9zaXRpb25zLmZyb20ueDtcbiAgICAgICAgICAgIGNvbnRyb2xOb2RlRnJvbS55ID0gcG9zaXRpb25zLmZyb20ueTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbnRyb2xOb2RlVG8uc2VsZWN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb250cm9sTm9kZVRvLnggPSBwb3NpdGlvbnMudG8ueDtcbiAgICAgICAgICAgIGNvbnRyb2xOb2RlVG8ueSA9IHBvc2l0aW9ucy50by55O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZGVsZXRlIGV2ZXJ5dGhpbmcgaW4gdGhlIHNlbGVjdGlvblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVNlbGVjdGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZVNlbGVjdGVkKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICAvLyB3aGVuIHVzaW5nIHRoZSBndWksIGVuYWJsZSBlZGl0IG1vZGUgaWYgaXQgd2FzbnQgYWxyZWFkeS5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcbiAgICAgIHRoaXMuX2NsZWFuKCk7XG4gICAgICB0aGlzLmluTW9kZSA9IFwiZGVsZXRlXCI7XG4gICAgICB2YXIgc2VsZWN0ZWROb2RlcyA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZE5vZGVJZHMoKTtcbiAgICAgIHZhciBzZWxlY3RlZEVkZ2VzID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkRWRnZUlkcygpO1xuICAgICAgdmFyIGRlbGV0ZUZ1bmN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHNlbGVjdGVkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW3NlbGVjdGVkTm9kZXNbaV1dLmlzQ2x1c3RlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgYWxlcnQodGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV1bXCJkZWxldGVDbHVzdGVyRXJyb3JcIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImRlbGV0ZUNsdXN0ZXJFcnJvclwiXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmRlbGV0ZU5vZGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGRlbGV0ZUZ1bmN0aW9uID0gdGhpcy5vcHRpb25zLmRlbGV0ZU5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRFZGdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmRlbGV0ZUVkZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGRlbGV0ZUZ1bmN0aW9uID0gdGhpcy5vcHRpb25zLmRlbGV0ZUVkZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGVsZXRlRnVuY3Rpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICBub2Rlczogc2VsZWN0ZWROb2RlcyxcbiAgICAgICAgICBlZGdlczogc2VsZWN0ZWRFZGdlc1xuICAgICAgICB9O1xuICAgICAgICBpZiAoZGVsZXRlRnVuY3Rpb24ubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgZGVsZXRlRnVuY3Rpb24oZGF0YSwgZnVuY3Rpb24gKGZpbmFsaXplZERhdGEpIHtcbiAgICAgICAgICAgIGlmIChmaW5hbGl6ZWREYXRhICE9PSBudWxsICYmIGZpbmFsaXplZERhdGEgIT09IHVuZGVmaW5lZCAmJiBfdGhpczMuaW5Nb2RlID09PSBcImRlbGV0ZVwiKSB7XG4gICAgICAgICAgICAgIC8vIGlmIGZvciB3aGF0ZXZlciByZWFzb24gdGhlIG1vZGUgaGFzIGNoYW5nZXMgKGR1ZSB0byBkYXRhc2V0IGNoYW5nZSkgZGlzcmVnYXJkIHRoZSBjYWxsYmFjaykge1xuICAgICAgICAgICAgICBfdGhpczMuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS5yZW1vdmUoZmluYWxpemVkRGF0YS5lZGdlcyk7XG4gICAgICAgICAgICAgIF90aGlzMy5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpLnJlbW92ZShmaW5hbGl6ZWREYXRhLm5vZGVzKTtcbiAgICAgICAgICAgICAgX3RoaXMzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpO1xuICAgICAgICAgICAgICBfdGhpczMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3RoaXMzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpO1xuICAgICAgICAgICAgICBfdGhpczMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBmdW5jdGlvbiBmb3IgZGVsZXRlIGRvZXMgbm90IHN1cHBvcnQgdHdvIGFyZ3VtZW50cyAoZGF0YSwgY2FsbGJhY2spXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkucmVtb3ZlKHNlbGVjdGVkRWRnZXMpO1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5ub2Rlcy5nZXREYXRhU2V0KCkucmVtb3ZlKHNlbGVjdGVkTm9kZXMpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpO1xuICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogUFJJVkFURSAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovL1xuXG4gICAgLyoqXG4gICAgICogZHJhdyBvciByZW1vdmUgdGhlIERPTVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfc2V0dXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIC8vIEVuYWJsZSB0aGUgR1VJXG4gICAgICAgIHRoaXMuZ3VpRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVdyYXBwZXJzKCk7XG4gICAgICAgIGlmICh0aGlzLmVkaXRNb2RlID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuX2NyZWF0ZUVkaXRCdXR0b24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTWFuaXB1bGF0aW9uRE9NKCk7XG5cbiAgICAgICAgLy8gZGlzYWJsZSB0aGUgZ3VpXG4gICAgICAgIHRoaXMuZ3VpRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSB0aGUgZGl2IG92ZXJsYXlzIHRoYXQgY29udGFpbiB0aGUgRE9NXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVXcmFwcGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlV3JhcHBlcnMoKSB7XG4gICAgICAvLyBsb2FkIHRoZSBtYW5pcHVsYXRvciBIVE1MIGVsZW1lbnRzLiBBbGwgc3R5bGluZyBkb25lIGluIGNzcy5cbiAgICAgIGlmICh0aGlzLm1hbmlwdWxhdGlvbkRpdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuY2xhc3NOYW1lID0gXCJ2aXMtbWFuaXB1bGF0aW9uXCI7XG4gICAgICAgIGlmICh0aGlzLmVkaXRNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5tYW5pcHVsYXRpb25EaXYpO1xuICAgICAgfVxuXG4gICAgICAvLyBjb250YWluZXIgZm9yIHRoZSBlZGl0IGJ1dHRvbi5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlRGl2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5lZGl0TW9kZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZWRpdE1vZGVEaXYuY2xhc3NOYW1lID0gXCJ2aXMtZWRpdC1tb2RlXCI7XG4gICAgICAgIGlmICh0aGlzLmVkaXRNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuZWRpdE1vZGVEaXYpO1xuICAgICAgfVxuXG4gICAgICAvLyBjb250YWluZXIgZm9yIHRoZSBjbG9zZSBkaXYgYnV0dG9uXG4gICAgICBpZiAodGhpcy5jbG9zZURpdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBfdGhpcyRvcHRpb25zJGxvY2FsZXMsIF90aGlzJG9wdGlvbnMkbG9jYWxlczI7XG4gICAgICAgIHRoaXMuY2xvc2VEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgICB0aGlzLmNsb3NlRGl2LmNsYXNzTmFtZSA9IFwidmlzLWNsb3NlXCI7XG4gICAgICAgIHRoaXMuY2xvc2VEaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCAoX3RoaXMkb3B0aW9ucyRsb2NhbGVzID0gKF90aGlzJG9wdGlvbnMkbG9jYWxlczIgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXSkgPT09IG51bGwgfHwgX3RoaXMkb3B0aW9ucyRsb2NhbGVzMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkb3B0aW9ucyRsb2NhbGVzMltcImNsb3NlXCJdKSAhPT0gbnVsbCAmJiBfdGhpcyRvcHRpb25zJGxvY2FsZXMgIT09IHZvaWQgMCA/IF90aGlzJG9wdGlvbnMkbG9jYWxlcyA6IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJjbG9zZVwiXSk7XG4gICAgICAgIHRoaXMuY2xvc2VEaXYuc3R5bGUuZGlzcGxheSA9IHRoaXMubWFuaXB1bGF0aW9uRGl2LnN0eWxlLmRpc3BsYXk7XG4gICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuY2xvc2VEaXYpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdlbmVyYXRlIGEgbmV3IHRhcmdldCBub2RlLiBVc2VkIGZvciBjcmVhdGluZyBuZXcgZWRnZXMgYW5kIGVkaXRpbmcgZWRnZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7Tm9kZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXROZXdUYXJnZXROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXROZXdUYXJnZXROb2RlKHgsIHkpIHtcbiAgICAgIHZhciBjb250cm9sTm9kZVN0eWxlID0gZGVlcEV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLmNvbnRyb2xOb2RlU3R5bGUpO1xuICAgICAgY29udHJvbE5vZGVTdHlsZS5pZCA9IFwidGFyZ2V0Tm9kZVwiICsgdjQoKTtcbiAgICAgIGNvbnRyb2xOb2RlU3R5bGUuaGlkZGVuID0gZmFsc2U7XG4gICAgICBjb250cm9sTm9kZVN0eWxlLnBoeXNpY3MgPSBmYWxzZTtcbiAgICAgIGNvbnRyb2xOb2RlU3R5bGUueCA9IHg7XG4gICAgICBjb250cm9sTm9kZVN0eWxlLnkgPSB5O1xuXG4gICAgICAvLyB3ZSBoYXZlIHRvIGRlZmluZSB0aGUgYm91bmRpbmcgYm94IGluIG9yZGVyIGZvciB0aGUgbm9kZXMgdG8gYmUgZHJhd24gaW1tZWRpYXRlbHlcbiAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVOb2RlKGNvbnRyb2xOb2RlU3R5bGUpO1xuICAgICAgbm9kZS5zaGFwZS5ib3VuZGluZ0JveCA9IHtcbiAgICAgICAgbGVmdDogeCxcbiAgICAgICAgcmlnaHQ6IHgsXG4gICAgICAgIHRvcDogeSxcbiAgICAgICAgYm90dG9tOiB5XG4gICAgICB9O1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBlZGl0IGJ1dHRvblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVFZGl0QnV0dG9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVFZGl0QnV0dG9uKCkge1xuICAgICAgdmFyIF9jb250ZXh0MTg7XG4gICAgICAvLyByZXN0b3JlIGV2ZXJ5dGhpbmcgdG8gaXQncyBvcmlnaW5hbCBzdGF0ZSAoaWYgYXBwbGljYWJsZSlcbiAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgIC8vIHJlc2V0IHRoZSBtYW5pcHVsYXRpb25ET01cbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NID0ge307XG5cbiAgICAgIC8vIGVtcHR5IHRoZSBlZGl0TW9kZURpdlxuICAgICAgcmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMuZWRpdE1vZGVEaXYpO1xuXG4gICAgICAvLyBjcmVhdGUgdGhlIGNvbnRlbnRzIGZvciB0aGUgZWRpdE1vZGUgYnV0dG9uXG4gICAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKFwiZWRpdE1vZGVcIiwgXCJ2aXMtZWRpdCB2aXMtZWRpdC1tb2RlXCIsIGxvY2FsZVtcImVkaXRcIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImVkaXRcIl0pO1xuICAgICAgdGhpcy5lZGl0TW9kZURpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuXG4gICAgICAvLyBiaW5kIGEgaGFtbWVyIGxpc3RlbmVyIHRvIHRoZSBidXR0b24sIGNhbGxpbmcgdGhlIGZ1bmN0aW9uIHRvZ2dsZUVkaXRNb2RlLlxuICAgICAgdGhpcy5fYmluZEVsZW1lbnRFdmVudHMoYnV0dG9uLCBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDE4ID0gdGhpcy50b2dnbGVFZGl0TW9kZSkuY2FsbChfY29udGV4dDE4LCB0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhpcyBmdW5jdGlvbiBjbGVhbnMgdXAgYWZ0ZXIgZXZlcnl0aGluZyB0aGlzIG1vZHVsZSBkb2VzLiBUZW1wb3JhcnkgZWxlbWVudHMsIGZ1bmN0aW9ucyBhbmQgZXZlbnRzIGFyZSByZW1vdmVkLCBwaHlzaWNzIHJlc3RvcmVkLCBoYW1tZXJzIHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jbGVhblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xlYW4oKSB7XG4gICAgICAvLyBub3QgaW4gbW9kZVxuICAgICAgdGhpcy5pbk1vZGUgPSBmYWxzZTtcblxuICAgICAgLy8gX2NsZWFuIHRoZSBkaXZzXG4gICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLmVkaXRNb2RlRGl2KTtcbiAgICAgICAgcmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMubWFuaXB1bGF0aW9uRGl2KTtcblxuICAgICAgICAvLyByZW1vdmVzIGFsbCB0aGUgYmluZGluZ3MgYW5kIG92ZXJsb2Fkc1xuICAgICAgICB0aGlzLl9jbGVhbnVwRE9NRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIHRlbXBvcmFyeSBub2RlcyBhbmQgZWRnZXNcbiAgICAgIHRoaXMuX2NsZWFudXBUZW1wb3JhcnlOb2Rlc0FuZEVkZ2VzKCk7XG5cbiAgICAgIC8vIHJlc3RvcmUgb3ZlcmxvYWRlZCBVSSBmdW5jdGlvbnNcbiAgICAgIHRoaXMuX3VuYmluZFRlbXBvcmFyeVVJcygpO1xuXG4gICAgICAvLyByZW1vdmUgdGhlIHRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zXG4gICAgICB0aGlzLl91bmJpbmRUZW1wb3JhcnlFdmVudHMoKTtcblxuICAgICAgLy8gcmVzdG9yZSB0aGUgcGh5c2ljcyBpZiByZXF1aXJlZFxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInJlc3RvcmVQaHlzaWNzXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVhY2ggZG9tIGVsZW1lbnQgaGFzIGl0J3Mgb3duIGhhbW1lci4gVGhleSBhcmUgc3RvcmVkIGluIHRoaXMubWFuaXB1bGF0aW9uSGFtbWVycy4gVGhpcyBjbGVhbnMgdGhlbSB1cC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NsZWFudXBET01FdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xlYW51cERPTUV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF9jb250ZXh0MTk7XG4gICAgICAvLyBfY2xlYW4gRE9NIGV2ZW50IGxpc3RlbmVyIGJpbmRpbmdzXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoX3NwbGljZUluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQxOSA9IHRoaXMuX2RvbUV2ZW50TGlzdGVuZXJDbGVhbnVwUXVldWUpLmNhbGwoX2NvbnRleHQxOSwgMCkpLFxuICAgICAgICBfc3RlcDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGNhbGxiYWNrID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgRE9NIGVsZW1lbnRzIGNyZWF0ZWQgYnkgdGhpcyBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9yZW1vdmVNYW5pcHVsYXRpb25ET01cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZU1hbmlwdWxhdGlvbkRPTSgpIHtcbiAgICAgIC8vIHJlbW92ZXMgYWxsIHRoZSBiaW5kaW5ncyBhbmQgb3ZlcmxvYWRzXG4gICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICAvLyBlbXB0eSB0aGUgbWFuaXB1bGF0aW9uIGRpdnNcbiAgICAgIHJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLm1hbmlwdWxhdGlvbkRpdik7XG4gICAgICByZWN1cnNpdmVET01EZWxldGUodGhpcy5lZGl0TW9kZURpdik7XG4gICAgICByZWN1cnNpdmVET01EZWxldGUodGhpcy5jbG9zZURpdik7XG5cbiAgICAgIC8vIHJlbW92ZSB0aGUgbWFuaXB1bGF0aW9uIGRpdnNcbiAgICAgIGlmICh0aGlzLm1hbmlwdWxhdGlvbkRpdikge1xuICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5yZW1vdmVDaGlsZCh0aGlzLm1hbmlwdWxhdGlvbkRpdik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lZGl0TW9kZURpdikge1xuICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5yZW1vdmVDaGlsZCh0aGlzLmVkaXRNb2RlRGl2KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNsb3NlRGl2KSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLnJlbW92ZUNoaWxkKHRoaXMuY2xvc2VEaXYpO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgdGhlIHJlZmVyZW5jZXMgdG8gdW5kZWZpbmVkXG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdiA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZWRpdE1vZGVEaXYgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmNsb3NlRGl2ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBhIHNlcGVyYXRvciBsaW5lLiB0aGUgaW5kZXggaXMgdG8gZGlmZmVyZW50aWF0ZSBpbiB0aGUgbWFuaXB1bGF0aW9uIGRvbVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleD0xXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVNlcGVyYXRvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlU2VwZXJhdG9yKCkge1xuICAgICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01bXCJzZXBlcmF0b3JMaW5lRGl2XCIgKyBpbmRleF0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01bXCJzZXBlcmF0b3JMaW5lRGl2XCIgKyBpbmRleF0uY2xhc3NOYW1lID0gXCJ2aXMtc2VwYXJhdG9yLWxpbmVcIjtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKHRoaXMubWFuaXB1bGF0aW9uRE9NW1wic2VwZXJhdG9yTGluZURpdlwiICsgaW5kZXhdKTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tICAgIERPTSBmdW5jdGlvbnMgZm9yIGJ1dHRvbnMgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xvY2FsZX0gbG9jYWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlQWRkTm9kZUJ1dHRvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQWRkTm9kZUJ1dHRvbihsb2NhbGUpIHtcbiAgICAgIHZhciBfY29udGV4dDIwO1xuICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihcImFkZE5vZGVcIiwgXCJ2aXMtYWRkXCIsIGxvY2FsZVtcImFkZE5vZGVcIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImFkZE5vZGVcIl0pO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgIHRoaXMuX2JpbmRFbGVtZW50RXZlbnRzKGJ1dHRvbiwgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQyMCA9IHRoaXMuYWRkTm9kZU1vZGUpLmNhbGwoX2NvbnRleHQyMCwgdGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMb2NhbGV9IGxvY2FsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUFkZEVkZ2VCdXR0b25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUFkZEVkZ2VCdXR0b24obG9jYWxlKSB7XG4gICAgICB2YXIgX2NvbnRleHQyMTtcbiAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oXCJhZGRFZGdlXCIsIFwidmlzLWNvbm5lY3RcIiwgbG9jYWxlW1wiYWRkRWRnZVwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiYWRkRWRnZVwiXSk7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgICAgdGhpcy5fYmluZEVsZW1lbnRFdmVudHMoYnV0dG9uLCBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDIxID0gdGhpcy5hZGRFZGdlTW9kZSkuY2FsbChfY29udGV4dDIxLCB0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xvY2FsZX0gbG9jYWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlRWRpdE5vZGVCdXR0b25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUVkaXROb2RlQnV0dG9uKGxvY2FsZSkge1xuICAgICAgdmFyIF9jb250ZXh0MjI7XG4gICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKFwiZWRpdE5vZGVcIiwgXCJ2aXMtZWRpdFwiLCBsb2NhbGVbXCJlZGl0Tm9kZVwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiZWRpdE5vZGVcIl0pO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgIHRoaXMuX2JpbmRFbGVtZW50RXZlbnRzKGJ1dHRvbiwgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQyMiA9IHRoaXMuZWRpdE5vZGUpLmNhbGwoX2NvbnRleHQyMiwgdGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMb2NhbGV9IGxvY2FsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUVkaXRFZGdlQnV0dG9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVFZGl0RWRnZUJ1dHRvbihsb2NhbGUpIHtcbiAgICAgIHZhciBfY29udGV4dDIzO1xuICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihcImVkaXRFZGdlXCIsIFwidmlzLWVkaXRcIiwgbG9jYWxlW1wiZWRpdEVkZ2VcIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImVkaXRFZGdlXCJdKTtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgICB0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyhidXR0b24sIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MjMgPSB0aGlzLmVkaXRFZGdlTW9kZSkuY2FsbChfY29udGV4dDIzLCB0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xvY2FsZX0gbG9jYWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlRGVsZXRlQnV0dG9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVEZWxldGVCdXR0b24obG9jYWxlKSB7XG4gICAgICB2YXIgX2NvbnRleHQyNDtcbiAgICAgIHZhciBkZWxldGVCdG5DbGFzcztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgIGRlbGV0ZUJ0bkNsYXNzID0gXCJ2aXMtZGVsZXRlLXJ0bFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQnRuQ2xhc3MgPSBcInZpcy1kZWxldGVcIjtcbiAgICAgIH1cbiAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oXCJkZWxldGVcIiwgZGVsZXRlQnRuQ2xhc3MsIGxvY2FsZVtcImRlbFwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiZGVsXCJdKTtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgICB0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyhidXR0b24sIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MjQgPSB0aGlzLmRlbGV0ZVNlbGVjdGVkKS5jYWxsKF9jb250ZXh0MjQsIHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG9jYWxlfSBsb2NhbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVCYWNrQnV0dG9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVCYWNrQnV0dG9uKGxvY2FsZSkge1xuICAgICAgdmFyIF9jb250ZXh0MjU7XG4gICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKFwiYmFja1wiLCBcInZpcy1iYWNrXCIsIGxvY2FsZVtcImJhY2tcIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImJhY2tcIl0pO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgIHRoaXMuX2JpbmRFbGVtZW50RXZlbnRzKGJ1dHRvbiwgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQyNSA9IHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcikuY2FsbChfY29udGV4dDI1LCB0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgICAqIEBwYXJhbSB7bGFiZWx9IGxhYmVsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsQ2xhc3NOYW1lXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUJ1dHRvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQnV0dG9uKGlkLCBjbGFzc05hbWUsIGxhYmVsKSB7XG4gICAgICB2YXIgbGFiZWxDbGFzc05hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFwidmlzLWxhYmVsXCI7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArIFwiRGl2XCJdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgXCJEaXZcIl0uY2xhc3NOYW1lID0gXCJ2aXMtYnV0dG9uIFwiICsgY2xhc3NOYW1lO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyBcIkxhYmVsXCJdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgXCJMYWJlbFwiXS5jbGFzc05hbWUgPSBsYWJlbENsYXNzTmFtZTtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgXCJMYWJlbFwiXS5pbm5lclRleHQgPSBsYWJlbDtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgXCJEaXZcIl0uYXBwZW5kQ2hpbGQodGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyBcIkxhYmVsXCJdKTtcbiAgICAgIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArIFwiRGl2XCJdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVEZXNjcmlwdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlRGVzY3JpcHRpb24obGFiZWwpIHtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW1wiZGVzY3JpcHRpb25MYWJlbFwiXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtcImRlc2NyaXB0aW9uTGFiZWxcIl0uY2xhc3NOYW1lID0gXCJ2aXMtbm9uZVwiO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01bXCJkZXNjcmlwdGlvbkxhYmVsXCJdLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQodGhpcy5tYW5pcHVsYXRpb25ET01bXCJkZXNjcmlwdGlvbkxhYmVsXCJdKTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFbmQgb2YgRE9NIGZ1bmN0aW9ucyBmb3IgYnV0dG9ucyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgLyoqXG4gICAgICogdGhpcyBiaW5kcyBhbiBldmVudCB1bnRpbCBjbGVhbnVwIGJ5IHRoZSBjbGVhbiBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXdGdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3RlbXBvcmFyeUJpbmRFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdGVtcG9yYXJ5QmluZEV2ZW50KGV2ZW50LCBuZXdGdW5jdGlvbikge1xuICAgICAgdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9ucy5wdXNoKHtcbiAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICBib3VuZEZ1bmN0aW9uOiBuZXdGdW5jdGlvblxuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihldmVudCwgbmV3RnVuY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRoaXMgb3ZlcnJpZGVzIGFuIFVJIGZ1bmN0aW9uIHVudGlsIGNsZWFudXAgYnkgdGhlIGNsZWFuIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gVUlmdW5jdGlvbk5hbWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXdGdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3RlbXBvcmFyeUJpbmRVSVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdGVtcG9yYXJ5QmluZFVJKFVJZnVuY3Rpb25OYW1lLCBuZXdGdW5jdGlvbikge1xuICAgICAgaWYgKHRoaXMuYm9keS5ldmVudExpc3RlbmVyc1tVSWZ1bmN0aW9uTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zW1VJZnVuY3Rpb25OYW1lXSA9IHRoaXMuYm9keS5ldmVudExpc3RlbmVyc1tVSWZ1bmN0aW9uTmFtZV07XG4gICAgICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVyc1tVSWZ1bmN0aW9uTmFtZV0gPSBuZXdGdW5jdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgVUkgZnVuY3Rpb24gZG9lcyBub3QgZXhpc3QuIFR5cG8/IFlvdSB0cmllZDogXCIgKyBVSWZ1bmN0aW9uTmFtZSArIFwiIHBvc3NpYmxlIGFyZTogXCIgKyBfSlNPTiRzdHJpbmdpZnkoX09iamVjdCRrZXlzKHRoaXMuYm9keS5ldmVudExpc3RlbmVycykpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlIHRoZSBvdmVycmlkZGVuIFVJIGZ1bmN0aW9ucyB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VuYmluZFRlbXBvcmFyeVVJc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5iaW5kVGVtcG9yYXJ5VUlzKCkge1xuICAgICAgZm9yICh2YXIgZnVuY3Rpb25OYW1lIGluIHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zLCBmdW5jdGlvbk5hbWUpKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzW2Z1bmN0aW9uTmFtZV0gPSB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zW2Z1bmN0aW9uTmFtZV07XG4gICAgICAgICAgZGVsZXRlIHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnNbZnVuY3Rpb25OYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVuYmluZCB0aGUgZXZlbnRzIGNyZWF0ZWQgYnkgX3RlbXBvcmFyeUJpbmRFdmVudFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfdW5iaW5kVGVtcG9yYXJ5RXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91bmJpbmRUZW1wb3JhcnlFdmVudHMoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IHRoaXMudGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnNbaV0uZXZlbnQ7XG4gICAgICAgIHZhciBib3VuZEZ1bmN0aW9uID0gdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9uc1tpXS5ib3VuZEZ1bmN0aW9uO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vZmYoZXZlbnROYW1lLCBib3VuZEZ1bmN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnMgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaW5kIGFuIGhhbW1lciBpbnN0YW5jZSB0byBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBkb21FbGVtZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYm91bmRGdW5jdGlvblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9iaW5kRWxlbWVudEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluZEVsZW1lbnRFdmVudHMoZG9tRWxlbWVudCwgYm91bmRGdW5jdGlvbikge1xuICAgICAgLy8gQmluZCB0b3VjaCBldmVudHMuXG4gICAgICB2YXIgaGFtbWVyID0gbmV3IEhhbW1lcihkb21FbGVtZW50LCB7fSk7XG4gICAgICBvblRvdWNoKGhhbW1lciwgYm91bmRGdW5jdGlvbik7XG4gICAgICB0aGlzLl9kb21FdmVudExpc3RlbmVyQ2xlYW51cFF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICBoYW1tZXIuZGVzdHJveSgpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEJpbmQga2V5Ym9hcmQgZXZlbnRzLlxuICAgICAgdmFyIGtleXVwTGlzdGVuZXIgPSBmdW5jdGlvbiBrZXl1cExpc3RlbmVyKF9yZWYpIHtcbiAgICAgICAgdmFyIGtleUNvZGUgPSBfcmVmLmtleUNvZGUsXG4gICAgICAgICAga2V5ID0gX3JlZi5rZXk7XG4gICAgICAgIGlmIChrZXkgPT09IFwiRW50ZXJcIiB8fCBrZXkgPT09IFwiIFwiIHx8IGtleUNvZGUgPT09IDEzIHx8IGtleUNvZGUgPT09IDMyKSB7XG4gICAgICAgICAgYm91bmRGdW5jdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwga2V5dXBMaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgdGhpcy5fZG9tRXZlbnRMaXN0ZW5lckNsZWFudXBRdWV1ZS5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwga2V5dXBMaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTmVhdGx5IGNsZWFuIHVwIHRlbXBvcmFyeSBlZGdlcyBhbmQgbm9kZXNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NsZWFudXBUZW1wb3JhcnlOb2Rlc0FuZEVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhbnVwVGVtcG9yYXJ5Tm9kZXNBbmRFZGdlcygpIHtcbiAgICAgIC8vIF9jbGVhbiB0ZW1wb3JhcnkgZWRnZXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MjY7XG4gICAgICAgIHRoaXMuYm9keS5lZGdlc1t0aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1tpXV0uZGlzY29ubmVjdCgpO1xuICAgICAgICBkZWxldGUgdGhpcy5ib2R5LmVkZ2VzW3RoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzW2ldXTtcbiAgICAgICAgdmFyIGluZGV4VGVtcEVkZ2UgPSBfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQyNiA9IHRoaXMuYm9keS5lZGdlSW5kaWNlcykuY2FsbChfY29udGV4dDI2LCB0aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1tpXSk7XG4gICAgICAgIGlmIChpbmRleFRlbXBFZGdlICE9PSAtMSkge1xuICAgICAgICAgIHZhciBfY29udGV4dDI3O1xuICAgICAgICAgIF9zcGxpY2VJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0MjcgPSB0aGlzLmJvZHkuZWRnZUluZGljZXMpLmNhbGwoX2NvbnRleHQyNywgaW5kZXhUZW1wRWRnZSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gX2NsZWFuIHRlbXBvcmFyeSBub2Rlc1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX2NvbnRleHQyODtcbiAgICAgICAgZGVsZXRlIHRoaXMuYm9keS5ub2Rlc1t0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1tfaV1dO1xuICAgICAgICB2YXIgaW5kZXhUZW1wTm9kZSA9IF9pbmRleE9mSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDI4ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzKS5jYWxsKF9jb250ZXh0MjgsIHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzW19pXSk7XG4gICAgICAgIGlmIChpbmRleFRlbXBOb2RlICE9PSAtMSkge1xuICAgICAgICAgIHZhciBfY29udGV4dDI5O1xuICAgICAgICAgIF9zcGxpY2VJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0MjkgPSB0aGlzLmJvZHkubm9kZUluZGljZXMpLmNhbGwoX2NvbnRleHQyOSwgaW5kZXhUZW1wTm9kZSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudGVtcG9yYXJ5SWRzID0ge1xuICAgICAgICBub2RlczogW10sXG4gICAgICAgIGVkZ2VzOiBbXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRURJVCBFREdFIEZVTkNUSU9OUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAvKipcbiAgICAgKiB0aGUgdG91Y2ggaXMgdXNlZCB0byBnZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBpbml0aWFsIGNsaWNrXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jb250cm9sTm9kZVRvdWNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb250cm9sTm9kZVRvdWNoKGV2ZW50KSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgIHRoaXMubGFzdFRvdWNoID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICB0aGlzLmxhc3RUb3VjaC50cmFuc2xhdGlvbiA9IF9PYmplY3QkYXNzaWduKHt9LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbik7IC8vIGNvcHkgdGhlIG9iamVjdFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRoZSBkcmFnIHN0YXJ0IGlzIHVzZWQgdG8gbWFyayBvbmUgb2YgdGhlIGNvbnRyb2wgbm9kZXMgYXMgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jb250cm9sTm9kZURyYWdTdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29udHJvbE5vZGVEcmFnU3RhcnQoKSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMubGFzdFRvdWNoO1xuICAgICAgdmFyIHBvaW50ZXJPYmogPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpO1xuICAgICAgdmFyIGZyb20gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMF1dO1xuICAgICAgdmFyIHRvID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMudGVtcG9yYXJ5SWRzLm5vZGVzWzFdXTtcbiAgICAgIHZhciBlZGdlID0gdGhpcy5ib2R5LmVkZ2VzW3RoaXMuZWRnZUJlaW5nRWRpdGVkSWRdO1xuICAgICAgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGZyb21TZWxlY3QgPSBmcm9tLmlzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopO1xuICAgICAgdmFyIHRvU2VsZWN0ID0gdG8uaXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaik7XG4gICAgICBpZiAoZnJvbVNlbGVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgPSBmcm9tO1xuICAgICAgICBlZGdlLmVkZ2VUeXBlLmZyb20gPSBmcm9tO1xuICAgICAgfSBlbHNlIGlmICh0b1NlbGVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgPSB0bztcbiAgICAgICAgZWRnZS5lZGdlVHlwZS50byA9IHRvO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSB1c2UgdGhlIHNlbGVjdGlvbiB0byBmaW5kIHRoZSBub2RlIHRoYXQgaXMgYmVpbmcgZHJhZ2dlZC4gV2UgZXhwbGljaXRseSBzZWxlY3QgaXQgaGVyZS5cbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0T2JqZWN0KHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBkcmFnZ2luZyB0aGUgY29udHJvbCBub2RlcyBvciB0aGUgY2FudmFzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jb250cm9sTm9kZURyYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbnRyb2xOb2RlRHJhZyhldmVudCkge1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImRpc2FibGVQaHlzaWNzXCIpO1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgIHZhciBwb3MgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyhwb2ludGVyKTtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUueCA9IHBvcy54O1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUueSA9IHBvcy55O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIub25EcmFnKGV2ZW50KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbm5lY3Rpbmcgb3IgcmVzdG9yaW5nIHRoZSBjb250cm9sIG5vZGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50ICAgVGhlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY29udHJvbE5vZGVEcmFnRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb250cm9sTm9kZURyYWdFbmQoZXZlbnQpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICB2YXIgcG9pbnRlck9iaiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fcG9pbnRlclRvUG9zaXRpb25PYmplY3QocG9pbnRlcik7XG4gICAgICB2YXIgZWRnZSA9IHRoaXMuYm9keS5lZGdlc1t0aGlzLmVkZ2VCZWluZ0VkaXRlZElkXTtcbiAgICAgIC8vIGlmIHRoZSBub2RlIHRoYXQgd2FzIGRyYWdnZWQgaXMgbm90IGEgY29udHJvbCBub2RlLCByZXR1cm5cbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIHVzZSB0aGUgc2VsZWN0aW9uIHRvIGZpbmQgdGhlIG5vZGUgdGhhdCBpcyBiZWluZyBkcmFnZ2VkLiBXZSBleHBsaWNpdGx5IERFc2VsZWN0IHRoZSBjb250cm9sIG5vZGUgaGVyZS5cbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuICAgICAgdmFyIG92ZXJsYXBwaW5nTm9kZUlkcyA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2V0QWxsTm9kZXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaik7XG4gICAgICB2YXIgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgIGZvciAodmFyIGkgPSBvdmVybGFwcGluZ05vZGVJZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKG92ZXJsYXBwaW5nTm9kZUlkc1tpXSAhPT0gdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlLmlkKSB7XG4gICAgICAgICAgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tvdmVybGFwcGluZ05vZGVJZHNbaV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBwZXJmb3JtIHRoZSBjb25uZWN0aW9uXG4gICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChub2RlLmlzQ2x1c3RlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGFsZXJ0KHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdW1wiY3JlYXRlRWRnZUVycm9yXCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJjcmVhdGVFZGdlRXJyb3JcIl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBmcm9tID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMudGVtcG9yYXJ5SWRzLm5vZGVzWzBdXTtcbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlLmlkID09PSBmcm9tLmlkKSB7XG4gICAgICAgICAgICB0aGlzLl9wZXJmb3JtRWRpdEVkZ2Uobm9kZS5pZCwgZWRnZS50by5pZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BlcmZvcm1FZGl0RWRnZShlZGdlLmZyb20uaWQsIG5vZGUuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRnZS51cGRhdGVFZGdlVHlwZSgpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwicmVzdG9yZVBoeXNpY3NcIik7XG4gICAgICB9XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRU5EIE9GIEVESVQgRURHRSBGVU5DVElPTlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBBREQgRURHRSBGVU5DVElPTlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuICAgIC8qKlxuICAgICAqIHRoZSBmdW5jdGlvbiBib3VuZCB0byB0aGUgc2VsZWN0aW9uIGV2ZW50LiBJdCBjaGVja3MgaWYgeW91IHdhbnQgdG8gY29ubmVjdCBhIGNsdXN0ZXIgYW5kIGNoYW5nZXMgdGhlIGRlc2NyaXB0aW9uXG4gICAgICogdG8gd2FsayB0aGUgdXNlciB0aHJvdWdoIHRoZSBwcm9jZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVDb25uZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVDb25uZWN0KGV2ZW50KSB7XG4gICAgICAvLyBjaGVjayB0byBhdm9pZCBkb3VibGUgZmlyZWluZyBvZiB0aGlzIGZ1bmN0aW9uLlxuICAgICAgaWYgKG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdGhpcy50b3VjaFRpbWUgPiAxMDApIHtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2ggPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2gudHJhbnNsYXRpb24gPSBfT2JqZWN0JGFzc2lnbih7fSwgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24pOyAvLyBjb3B5IHRoZSBvYmplY3RcblxuICAgICAgICB0aGlzLmludGVyYWN0aW9uSGFuZGxlci5kcmFnLnBvaW50ZXIgPSB0aGlzLmxhc3RUb3VjaDsgLy8gRHJhZyBwb2ludGVyIGlzIG5vdCB1cGRhdGVkIHdoZW4gYWRkaW5nIGVkZ2VzXG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyLmRyYWcudHJhbnNsYXRpb24gPSB0aGlzLmxhc3RUb3VjaC50cmFuc2xhdGlvbjtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmxhc3RUb3VjaDtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0Tm9kZUF0KHBvaW50ZXIpO1xuICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG5vZGUuaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVtcImNyZWF0ZUVkZ2VFcnJvclwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiY3JlYXRlRWRnZUVycm9yXCJdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGEgbm9kZSB0aGUgdGVtcG9yYXJ5IGxpbmUgY2FuIGxvb2sgYXRcbiAgICAgICAgICAgIHZhciB0YXJnZXROb2RlID0gdGhpcy5fZ2V0TmV3VGFyZ2V0Tm9kZShub2RlLngsIG5vZGUueSk7XG4gICAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbdGFyZ2V0Tm9kZS5pZF0gPSB0YXJnZXROb2RlO1xuICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLnB1c2godGFyZ2V0Tm9kZS5pZCk7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHRlbXBvcmFyeSBlZGdlXG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbkVkZ2UgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZUVkZ2Uoe1xuICAgICAgICAgICAgICBpZDogXCJjb25uZWN0aW9uRWRnZVwiICsgdjQoKSxcbiAgICAgICAgICAgICAgZnJvbTogbm9kZS5pZCxcbiAgICAgICAgICAgICAgdG86IHRhcmdldE5vZGUuaWQsXG4gICAgICAgICAgICAgIHBoeXNpY3M6IGZhbHNlLFxuICAgICAgICAgICAgICBzbW9vdGg6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29udGludW91c1wiLFxuICAgICAgICAgICAgICAgIHJvdW5kbmVzczogMC41XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVkZ2VzW2Nvbm5lY3Rpb25FZGdlLmlkXSA9IGNvbm5lY3Rpb25FZGdlO1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLnB1c2goY29ubmVjdGlvbkVkZ2UuaWQpO1xuICAgICAgICAgICAgdGhpcy50ZW1wb3JhcnlJZHMubm9kZXMucHVzaCh0YXJnZXROb2RlLmlkKTtcbiAgICAgICAgICAgIHRoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzLnB1c2goY29ubmVjdGlvbkVkZ2UuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvdWNoVGltZSA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9kcmFnQ29udHJvbE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYWdDb250cm9sTm9kZShldmVudCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgIHZhciBwb2ludGVyT2JqID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChwb2ludGVyKTtcbiAgICAgIC8vIHJlbWVtYmVyIHRoZSBlZGdlIGlkXG4gICAgICB2YXIgY29ubmVjdEZyb21JZCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmICh0aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1swXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbm5lY3RGcm9tSWQgPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbMF1dLmZyb21JZDtcbiAgICAgIH1cblxuICAgICAgLy8gZ2V0IHRoZSBvdmVybGFwcGluZyBub2RlIGJ1dCBOT1QgdGhlIHRlbXBvcmFyeSBub2RlO1xuICAgICAgdmFyIG92ZXJsYXBwaW5nTm9kZUlkcyA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2V0QWxsTm9kZXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaik7XG4gICAgICB2YXIgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgIGZvciAodmFyIGkgPSBvdmVybGFwcGluZ05vZGVJZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MzA7XG4gICAgICAgIC8vIGlmIHRoZSBub2RlIGlkIGlzIE5PVCBhIHRlbXBvcmFyeSBub2RlLCBhY2NlcHQgdGhlIG5vZGUuXG4gICAgICAgIGlmIChfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQzMCA9IHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzKS5jYWxsKF9jb250ZXh0MzAsIG92ZXJsYXBwaW5nTm9kZUlkc1tpXSkgPT09IC0xKSB7XG4gICAgICAgICAgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tvdmVybGFwcGluZ05vZGVJZHNbaV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBldmVudC5jb250cm9sRWRnZSA9IHtcbiAgICAgICAgZnJvbTogY29ubmVjdEZyb21JZCxcbiAgICAgICAgdG86IG5vZGUgPyBub2RlLmlkIDogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImNvbnRyb2xOb2RlRHJhZ2dpbmdcIiwgZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgaWYgKHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzWzBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHRhcmdldE5vZGUgPSB0aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMF1dOyAvLyB0aGVyZSBpcyBvbmx5IG9uZSB0ZW1wIG5vZGUgaW4gdGhlIGFkZCBlZGdlIG1vZGUuXG4gICAgICAgIHRhcmdldE5vZGUueCA9IHRoaXMuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueCk7XG4gICAgICAgIHRhcmdldE5vZGUueSA9IHRoaXMuY2FudmFzLl9ZY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIub25EcmFnKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IHRoZSBuZXcgZWRnZSB0byB0aGUgdGFyZ2V0IGlmIG9uZSBleGlzdHMsIG90aGVyd2lzZSByZW1vdmUgdGVtcCBsaW5lXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9maW5pc2hDb25uZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5pc2hDb25uZWN0KGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgdmFyIHBvaW50ZXJPYmogPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpO1xuXG4gICAgICAvLyByZW1lbWJlciB0aGUgZWRnZSBpZFxuICAgICAgdmFyIGNvbm5lY3RGcm9tSWQgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAodGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbMF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25uZWN0RnJvbUlkID0gdGhpcy5ib2R5LmVkZ2VzW3RoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzWzBdXS5mcm9tSWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIGdldCB0aGUgb3ZlcmxhcHBpbmcgbm9kZSBidXQgTk9UIHRoZSB0ZW1wb3Jhcnkgbm9kZTtcbiAgICAgIHZhciBvdmVybGFwcGluZ05vZGVJZHMgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopO1xuICAgICAgdmFyIG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICBmb3IgKHZhciBpID0gb3ZlcmxhcHBpbmdOb2RlSWRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBfY29udGV4dDMxO1xuICAgICAgICAvLyBpZiB0aGUgbm9kZSBpZCBpcyBOT1QgYSB0ZW1wb3Jhcnkgbm9kZSwgYWNjZXB0IHRoZSBub2RlLlxuICAgICAgICBpZiAoX2luZGV4T2ZJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0MzEgPSB0aGlzLnRlbXBvcmFyeUlkcy5ub2RlcykuY2FsbChfY29udGV4dDMxLCBvdmVybGFwcGluZ05vZGVJZHNbaV0pID09PSAtMSkge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbb3ZlcmxhcHBpbmdOb2RlSWRzW2ldXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjbGVhbiB0ZW1wb3Jhcnkgbm9kZXMgYW5kIGVkZ2VzLlxuICAgICAgdGhpcy5fY2xlYW51cFRlbXBvcmFyeU5vZGVzQW5kRWRnZXMoKTtcblxuICAgICAgLy8gcGVyZm9ybSB0aGUgY29ubmVjdGlvblxuICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobm9kZS5pc0NsdXN0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVtcImNyZWF0ZUVkZ2VFcnJvclwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiY3JlYXRlRWRnZUVycm9yXCJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2Nvbm5lY3RGcm9tSWRdICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ib2R5Lm5vZGVzW25vZGUuaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlcmZvcm1BZGRFZGdlKGNvbm5lY3RGcm9tSWQsIG5vZGUuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXZlbnQuY29udHJvbEVkZ2UgPSB7XG4gICAgICAgIGZyb206IGNvbm5lY3RGcm9tSWQsXG4gICAgICAgIHRvOiBub2RlID8gbm9kZS5pZCA6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJjb250cm9sTm9kZURyYWdFbmRcIiwgZXZlbnQsIHBvaW50ZXIpO1xuXG4gICAgICAvLyBObyBuZWVkIHRvIGRvIF9nZW5lcmF0ZWNsaWNrZXZlbnQoJ2RyYWdFbmQnKSBoZXJlLCB0aGUgcmVndWxhciBkcmFnRW5kIGV2ZW50IGZpcmVzLlxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYWdTdGFydEVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYWdTdGFydEVkZ2UoZXZlbnQpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5sYXN0VG91Y2g7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZHJhZ1N0YXJ0XCIsIGV2ZW50LCBwb2ludGVyLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFTkQgT0YgQUREIEVER0UgRlVOQ1RJT05TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFBlcmZvcm1pbmcgYWxsIHRoZSBhY3R1YWwgZGF0YSBtYW5pcHVsYXRpb24gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBub2RlIG9uIHRoZSBzcGVjaWZpZWQgbG9jYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjbGlja0RhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9wZXJmb3JtQWRkTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGVyZm9ybUFkZE5vZGUoY2xpY2tEYXRhKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHtcbiAgICAgICAgaWQ6IHY0KCksXG4gICAgICAgIHg6IGNsaWNrRGF0YS5wb2ludGVyLmNhbnZhcy54LFxuICAgICAgICB5OiBjbGlja0RhdGEucG9pbnRlci5jYW52YXMueSxcbiAgICAgICAgbGFiZWw6IFwibmV3XCJcbiAgICAgIH07XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5hZGROb2RlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hZGROb2RlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5hZGROb2RlKGRlZmF1bHREYXRhLCBmdW5jdGlvbiAoZmluYWxpemVkRGF0YSkge1xuICAgICAgICAgICAgaWYgKGZpbmFsaXplZERhdGEgIT09IG51bGwgJiYgZmluYWxpemVkRGF0YSAhPT0gdW5kZWZpbmVkICYmIF90aGlzNC5pbk1vZGUgPT09IFwiYWRkTm9kZVwiKSB7XG4gICAgICAgICAgICAgIC8vIGlmIGZvciB3aGF0ZXZlciByZWFzb24gdGhlIG1vZGUgaGFzIGNoYW5nZXMgKGR1ZSB0byBkYXRhc2V0IGNoYW5nZSkgZGlzcmVnYXJkIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgICBfdGhpczQuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKS5hZGQoZmluYWxpemVkRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpczQuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBmdW5jdGlvbiBmb3IgYWRkIGRvZXMgbm90IHN1cHBvcnQgdHdvIGFyZ3VtZW50cyAoZGF0YSxjYWxsYmFjaylcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKS5hZGQoZGVmYXVsdERhdGEpO1xuICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb25uZWN0IHR3byBub2RlcyB3aXRoIGEgbmV3IGVkZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IHNvdXJjZU5vZGVJZFxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gdGFyZ2V0Tm9kZUlkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfcGVyZm9ybUFkZEVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BlcmZvcm1BZGRFZGdlKHNvdXJjZU5vZGVJZCwgdGFyZ2V0Tm9kZUlkKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHtcbiAgICAgICAgZnJvbTogc291cmNlTm9kZUlkLFxuICAgICAgICB0bzogdGFyZ2V0Tm9kZUlkXG4gICAgICB9O1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuYWRkRWRnZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWRkRWRnZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuYWRkRWRnZShkZWZhdWx0RGF0YSwgZnVuY3Rpb24gKGZpbmFsaXplZERhdGEpIHtcbiAgICAgICAgICAgIGlmIChmaW5hbGl6ZWREYXRhICE9PSBudWxsICYmIGZpbmFsaXplZERhdGEgIT09IHVuZGVmaW5lZCAmJiBfdGhpczUuaW5Nb2RlID09PSBcImFkZEVkZ2VcIikge1xuICAgICAgICAgICAgICAvLyBpZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHRoZSBtb2RlIGhhcyBjaGFuZ2VzIChkdWUgdG8gZGF0YXNldCBjaGFuZ2UpIGRpc3JlZ2FyZCB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgX3RoaXM1LmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkuYWRkKGZpbmFsaXplZERhdGEpO1xuICAgICAgICAgICAgICBfdGhpczUuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuICAgICAgICAgICAgICBfdGhpczUuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBmdW5jdGlvbiBmb3IgY29ubmVjdCBkb2VzIG5vdCBzdXBwb3J0IHR3byBhcmd1bWVudHMgKGRhdGEsY2FsbGJhY2spXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkuYWRkKGRlZmF1bHREYXRhKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7XG4gICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbm5lY3QgdHdvIG5vZGVzIHdpdGggYSBuZXcgZWRnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gc291cmNlTm9kZUlkXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSB0YXJnZXROb2RlSWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9wZXJmb3JtRWRpdEVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BlcmZvcm1FZGl0RWRnZShzb3VyY2VOb2RlSWQsIHRhcmdldE5vZGVJZCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB7XG4gICAgICAgIGlkOiB0aGlzLmVkZ2VCZWluZ0VkaXRlZElkLFxuICAgICAgICBmcm9tOiBzb3VyY2VOb2RlSWQsXG4gICAgICAgIHRvOiB0YXJnZXROb2RlSWQsXG4gICAgICAgIGxhYmVsOiB0aGlzLmJvZHkuZGF0YS5lZGdlcy5nZXQodGhpcy5lZGdlQmVpbmdFZGl0ZWRJZCkubGFiZWxcbiAgICAgIH07XG4gICAgICB2YXIgZWVGdW5jdCA9IHRoaXMub3B0aW9ucy5lZGl0RWRnZTtcbiAgICAgIGlmIChfdHlwZW9mKGVlRnVuY3QpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGVlRnVuY3QgPSBlZUZ1bmN0LmVkaXRXaXRob3V0RHJhZztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZWVGdW5jdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmIChlZUZ1bmN0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGVlRnVuY3QoZGVmYXVsdERhdGEsIGZ1bmN0aW9uIChmaW5hbGl6ZWREYXRhKSB7XG4gICAgICAgICAgICBpZiAoZmluYWxpemVkRGF0YSA9PT0gbnVsbCB8fCBmaW5hbGl6ZWREYXRhID09PSB1bmRlZmluZWQgfHwgX3RoaXM2LmluTW9kZSAhPT0gXCJlZGl0RWRnZVwiKSB7XG4gICAgICAgICAgICAgIC8vIGlmIGZvciB3aGF0ZXZlciByZWFzb24gdGhlIG1vZGUgaGFzIGNoYW5nZXMgKGR1ZSB0byBkYXRhc2V0IGNoYW5nZSkgZGlzcmVnYXJkIHRoZSBjYWxsYmFjaykge1xuICAgICAgICAgICAgICBfdGhpczYuYm9keS5lZGdlc1tkZWZhdWx0RGF0YS5pZF0udXBkYXRlRWRnZVR5cGUoKTtcbiAgICAgICAgICAgICAgX3RoaXM2LmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICAgICAgICAgICAgX3RoaXM2LnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF90aGlzNi5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLnVwZGF0ZShmaW5hbGl6ZWREYXRhKTtcbiAgICAgICAgICAgICAgX3RoaXM2LnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgICAgICAgICAgX3RoaXM2LnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZnVuY3Rpb24gZm9yIGVkaXQgZG9lcyBub3Qgc3VwcG9ydCB0d28gYXJndW1lbnRzIChkYXRhLCBjYWxsYmFjaylcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS51cGRhdGUoZGVmYXVsdERhdGEpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBNYW5pcHVsYXRpb25TeXN0ZW07XG59KCk7XG5cbi8qKlxyXG4gKiBUaGlzIG9iamVjdCBjb250YWlucyBhbGwgcG9zc2libGUgb3B0aW9ucy4gSXQgd2lsbCBjaGVjayBpZiB0aGUgdHlwZXMgYXJlIGNvcnJlY3QsIGlmIHJlcXVpcmVkIGlmIHRoZSBvcHRpb24gaXMgb25lXHJcbiAqIG9mIHRoZSBhbGxvd2VkIHZhbHVlcy5cclxuICpcclxuICogX19hbnlfXyBtZWFucyB0aGF0IHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBkb2VzIG5vdCBtYXR0ZXIuXHJcbiAqIF9fdHlwZV9fIGlzIGEgcmVxdWlyZWQgZmllbGQgZm9yIGFsbCBvYmplY3RzIGFuZCBjb250YWlucyB0aGUgYWxsb3dlZCB0eXBlcyBvZiBhbGwgb2JqZWN0c1xyXG4gKi9cbnZhciBzdHJpbmcgPSBcInN0cmluZ1wiO1xudmFyIGJvb2wgPSBcImJvb2xlYW5cIjtcbnZhciBudW1iZXIgPSBcIm51bWJlclwiO1xudmFyIGFycmF5ID0gXCJhcnJheVwiO1xudmFyIG9iamVjdCA9IFwib2JqZWN0XCI7IC8vIHNob3VsZCBvbmx5IGJlIGluIGEgX190eXBlX18gcHJvcGVydHlcbnZhciBkb20gPSBcImRvbVwiO1xudmFyIGFueSA9IFwiYW55XCI7XG4vLyBMaXN0IG9mIGVuZHBvaW50c1xudmFyIGVuZFBvaW50cyA9IFtcImFycm93XCIsIFwiYmFyXCIsIFwiYm94XCIsIFwiY2lyY2xlXCIsIFwiY3Jvd1wiLCBcImN1cnZlXCIsIFwiZGlhbW9uZFwiLCBcImltYWdlXCIsIFwiaW52X2N1cnZlXCIsIFwiaW52X3RyaWFuZ2xlXCIsIFwidHJpYW5nbGVcIiwgXCJ2ZWVcIl07XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gLS0gVGhlIF9fKl9fIGZvcm1hdCBpcyB1c2VkIHRvIHByZXZlbnQgY29sbGlzaW9ucyB3aXRoIGFjdHVhbCBvcHRpb24gbmFtZXMuICovXG52YXIgbm9kZU9wdGlvbnMgPSB7XG4gIGJvcmRlcldpZHRoOiB7XG4gICAgbnVtYmVyOiBudW1iZXJcbiAgfSxcbiAgYm9yZGVyV2lkdGhTZWxlY3RlZDoge1xuICAgIG51bWJlcjogbnVtYmVyLFxuICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICB9LFxuICBicm9rZW5JbWFnZToge1xuICAgIHN0cmluZzogc3RyaW5nLFxuICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICB9LFxuICBjaG9zZW46IHtcbiAgICBsYWJlbDoge1xuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIG5vZGU6IHtcbiAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBib29sZWFuOiBib29sXG4gICAgfVxuICB9LFxuICBjb2xvcjoge1xuICAgIGJvcmRlcjoge1xuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIGJhY2tncm91bmQ6IHtcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfSxcbiAgICBoaWdobGlnaHQ6IHtcbiAgICAgIGJvcmRlcjoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIGJhY2tncm91bmQ6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH1cbiAgICB9LFxuICAgIGhvdmVyOiB7XG4gICAgICBib3JkZXI6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9XG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH1cbiAgfSxcbiAgb3BhY2l0eToge1xuICAgIG51bWJlcjogbnVtYmVyLFxuICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICB9LFxuICBmaXhlZDoge1xuICAgIHg6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIHk6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9XG4gIH0sXG4gIGZvbnQ6IHtcbiAgICBhbGlnbjoge1xuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIGNvbG9yOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH0sXG4gICAgc2l6ZToge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIGZhY2U6IHtcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH0sXG4gICAgc3Ryb2tlV2lkdGg6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBzdHJva2VDb2xvcjoge1xuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIHZhZGp1c3Q6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBtdWx0aToge1xuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfSxcbiAgICBib2xkOiB7XG4gICAgICBjb2xvcjoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBmYWNlOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgbW9kOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgdmFkanVzdDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfVxuICAgIH0sXG4gICAgYm9sZGl0YWw6IHtcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGZhY2U6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBtb2Q6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICB2YWRqdXN0OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9XG4gICAgfSxcbiAgICBpdGFsOiB7XG4gICAgICBjb2xvcjoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBmYWNlOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgbW9kOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgdmFkanVzdDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfVxuICAgIH0sXG4gICAgbW9ubzoge1xuICAgICAgY29sb3I6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZmFjZToge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIG1vZDoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIHZhZGp1c3Q6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH1cbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfVxuICB9LFxuICBncm91cDoge1xuICAgIHN0cmluZzogc3RyaW5nLFxuICAgIG51bWJlcjogbnVtYmVyLFxuICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICB9LFxuICBoZWlnaHRDb25zdHJhaW50OiB7XG4gICAgbWluaW11bToge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIHZhbGlnbjoge1xuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH1cbiAgfSxcbiAgaGlkZGVuOiB7XG4gICAgYm9vbGVhbjogYm9vbFxuICB9LFxuICBpY29uOiB7XG4gICAgZmFjZToge1xuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIGNvZGU6IHtcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfSxcbiAgICBzaXplOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgY29sb3I6IHtcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfSxcbiAgICB3ZWlnaHQ6IHtcbiAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdFxuICAgIH1cbiAgfSxcbiAgaWQ6IHtcbiAgICBzdHJpbmc6IHN0cmluZyxcbiAgICBudW1iZXI6IG51bWJlclxuICB9LFxuICBpbWFnZToge1xuICAgIHNlbGVjdGVkOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZyxcbiAgICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICAgIH0sXG4gICAgdW5zZWxlY3RlZDoge1xuICAgICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfVxuICB9LFxuICBpbWFnZVBhZGRpbmc6IHtcbiAgICB0b3A6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIGJvdHRvbToge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH1cbiAgfSxcbiAgbGFiZWw6IHtcbiAgICBzdHJpbmc6IHN0cmluZyxcbiAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgfSxcbiAgbGFiZWxIaWdobGlnaHRCb2xkOiB7XG4gICAgYm9vbGVhbjogYm9vbFxuICB9LFxuICBsZXZlbDoge1xuICAgIG51bWJlcjogbnVtYmVyLFxuICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICB9LFxuICBtYXJnaW46IHtcbiAgICB0b3A6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIGJvdHRvbToge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH1cbiAgfSxcbiAgbWFzczoge1xuICAgIG51bWJlcjogbnVtYmVyXG4gIH0sXG4gIHBoeXNpY3M6IHtcbiAgICBib29sZWFuOiBib29sXG4gIH0sXG4gIHNjYWxpbmc6IHtcbiAgICBtaW46IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBtYXg6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBsYWJlbDoge1xuICAgICAgZW5hYmxlZDoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgbWluOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgbWF4OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgbWF4VmlzaWJsZToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGRyYXdUaHJlc2hvbGQ6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfVxuICAgIH0sXG4gICAgY3VzdG9tU2NhbGluZ0Z1bmN0aW9uOiB7XG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICB9XG4gIH0sXG4gIHNoYWRvdzoge1xuICAgIGVuYWJsZWQ6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGNvbG9yOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH0sXG4gICAgc2l6ZToge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIHg6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH1cbiAgfSxcbiAgc2hhcGU6IHtcbiAgICBzdHJpbmc6IFtcImN1c3RvbVwiLCBcImVsbGlwc2VcIiwgXCJjaXJjbGVcIiwgXCJkYXRhYmFzZVwiLCBcImJveFwiLCBcInRleHRcIiwgXCJpbWFnZVwiLCBcImNpcmN1bGFySW1hZ2VcIiwgXCJkaWFtb25kXCIsIFwiZG90XCIsIFwic3RhclwiLCBcInRyaWFuZ2xlXCIsIFwidHJpYW5nbGVEb3duXCIsIFwic3F1YXJlXCIsIFwiaWNvblwiLCBcImhleGFnb25cIl1cbiAgfSxcbiAgY3R4UmVuZGVyZXI6IHtcbiAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHNoYXBlUHJvcGVydGllczoge1xuICAgIGJvcmRlckRhc2hlczoge1xuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIGFycmF5OiBhcnJheVxuICAgIH0sXG4gICAgYm9yZGVyUmFkaXVzOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgaW50ZXJwb2xhdGlvbjoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgdXNlSW1hZ2VTaXplOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICB1c2VCb3JkZXJXaXRoSW1hZ2U6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGNvb3JkaW5hdGVPcmlnaW46IHtcbiAgICAgIHN0cmluZzogW1wiY2VudGVyXCIsIFwidG9wLWxlZnRcIl1cbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdFxuICAgIH1cbiAgfSxcbiAgc2l6ZToge1xuICAgIG51bWJlcjogbnVtYmVyXG4gIH0sXG4gIHRpdGxlOiB7XG4gICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgZG9tOiBkb20sXG4gICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gIH0sXG4gIHZhbHVlOiB7XG4gICAgbnVtYmVyOiBudW1iZXIsXG4gICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gIH0sXG4gIHdpZHRoQ29uc3RyYWludDoge1xuICAgIG1pbmltdW06IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBtYXhpbXVtOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfVxuICB9LFxuICB4OiB7XG4gICAgbnVtYmVyOiBudW1iZXJcbiAgfSxcbiAgeToge1xuICAgIG51bWJlcjogbnVtYmVyXG4gIH0sXG4gIF9fdHlwZV9fOiB7XG4gICAgb2JqZWN0OiBvYmplY3RcbiAgfVxufTtcbnZhciBhbGxPcHRpb25zID0ge1xuICBjb25maWd1cmU6IHtcbiAgICBlbmFibGVkOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBmaWx0ZXI6IHtcbiAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICBzdHJpbmc6IHN0cmluZyxcbiAgICAgIGFycmF5OiBhcnJheSxcbiAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIGNvbnRhaW5lcjoge1xuICAgICAgZG9tOiBkb21cbiAgICB9LFxuICAgIHNob3dCdXR0b246IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICBzdHJpbmc6IHN0cmluZyxcbiAgICAgIGFycmF5OiBhcnJheSxcbiAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICB9XG4gIH0sXG4gIGVkZ2VzOiB7XG4gICAgYXJyb3dzOiB7XG4gICAgICB0bzoge1xuICAgICAgICBlbmFibGVkOiB7XG4gICAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgICB9LFxuICAgICAgICBzY2FsZUZhY3Rvcjoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICBzdHJpbmc6IGVuZFBvaW50c1xuICAgICAgICB9LFxuICAgICAgICBpbWFnZUhlaWdodDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIGltYWdlV2lkdGg6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBzcmM6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBfX3R5cGVfXzoge1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1pZGRsZToge1xuICAgICAgICBlbmFibGVkOiB7XG4gICAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgICB9LFxuICAgICAgICBzY2FsZUZhY3Rvcjoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICBzdHJpbmc6IGVuZFBvaW50c1xuICAgICAgICB9LFxuICAgICAgICBpbWFnZVdpZHRoOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgaW1hZ2VIZWlnaHQ6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBzcmM6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBfX3R5cGVfXzoge1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGZyb206IHtcbiAgICAgICAgZW5hYmxlZDoge1xuICAgICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgICAgfSxcbiAgICAgICAgc2NhbGVGYWN0b3I6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgc3RyaW5nOiBlbmRQb2ludHNcbiAgICAgICAgfSxcbiAgICAgICAgaW1hZ2VXaWR0aDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIGltYWdlSGVpZ2h0OiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgc3JjOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgX190eXBlX186IHtcbiAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICBib29sZWFuOiBib29sXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBzdHJpbmc6IFtcImZyb21cIiwgXCJ0b1wiLCBcIm1pZGRsZVwiXSxcbiAgICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICAgIH1cbiAgICB9LFxuICAgIGVuZFBvaW50T2Zmc2V0OiB7XG4gICAgICBmcm9tOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgdG86IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH1cbiAgICB9LFxuICAgIGFycm93U3RyaWtldGhyb3VnaDoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgYmFja2dyb3VuZDoge1xuICAgICAgZW5hYmxlZDoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgY29sb3I6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZGFzaGVzOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICAgIGFycmF5OiBhcnJheVxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9XG4gICAgfSxcbiAgICBjaG9zZW46IHtcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICAgIH0sXG4gICAgICBlZGdlOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfVxuICAgIH0sXG4gICAgY29sb3I6IHtcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBpbmhlcml0OiB7XG4gICAgICAgIHN0cmluZzogW1wiZnJvbVwiLCBcInRvXCIsIFwiYm90aFwiXSxcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH1cbiAgICB9LFxuICAgIGRhc2hlczoge1xuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIGFycmF5OiBhcnJheVxuICAgIH0sXG4gICAgZm9udDoge1xuICAgICAgY29sb3I6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZmFjZToge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIGJhY2tncm91bmQ6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBzdHJva2VXaWR0aDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHN0cm9rZUNvbG9yOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgYWxpZ246IHtcbiAgICAgICAgc3RyaW5nOiBbXCJob3Jpem9udGFsXCIsIFwidG9wXCIsIFwibWlkZGxlXCIsIFwiYm90dG9tXCJdXG4gICAgICB9LFxuICAgICAgdmFkanVzdDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIG11bHRpOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgYm9sZDoge1xuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBmYWNlOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgbW9kOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgdmFkanVzdDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGJvbGRpdGFsOiB7XG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIGZhY2U6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBtb2Q6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICB2YWRqdXN0OiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgX190eXBlX186IHtcbiAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaXRhbDoge1xuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBmYWNlOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgbW9kOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgdmFkanVzdDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1vbm86IHtcbiAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgZmFjZToge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIG1vZDoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIHZhZGp1c3Q6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBfX3R5cGVfXzoge1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH1cbiAgICB9LFxuICAgIGhpZGRlbjoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgaG92ZXJXaWR0aDoge1xuICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIixcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBsYWJlbDoge1xuICAgICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgICB9LFxuICAgIGxhYmVsSGlnaGxpZ2h0Qm9sZDoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgbGVuZ3RoOiB7XG4gICAgICBudW1iZXI6IG51bWJlcixcbiAgICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICAgIH0sXG4gICAgcGh5c2ljczoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgc2NhbGluZzoge1xuICAgICAgbWluOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgbWF4OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZW5hYmxlZDoge1xuICAgICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgICAgfSxcbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgbWF4VmlzaWJsZToge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIGRyYXdUaHJlc2hvbGQ6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBfX3R5cGVfXzoge1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGN1c3RvbVNjYWxpbmdGdW5jdGlvbjoge1xuICAgICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICAgIH1cbiAgICB9LFxuICAgIHNlbGVjdGlvbldpZHRoOiB7XG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiLFxuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIHNlbGZSZWZlcmVuY2VTaXplOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgc2VsZlJlZmVyZW5jZToge1xuICAgICAgc2l6ZToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGFuZ2xlOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgcmVuZGVyQmVoaW5kVGhlTm9kZToge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICAgIH1cbiAgICB9LFxuICAgIHNoYWRvdzoge1xuICAgICAgZW5hYmxlZDoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgY29sb3I6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgeDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfVxuICAgIH0sXG4gICAgc21vb3RoOiB7XG4gICAgICBlbmFibGVkOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICB0eXBlOiB7XG4gICAgICAgIHN0cmluZzogW1wiZHluYW1pY1wiLCBcImNvbnRpbnVvdXNcIiwgXCJkaXNjcmV0ZVwiLCBcImRpYWdvbmFsQ3Jvc3NcIiwgXCJzdHJhaWdodENyb3NzXCIsIFwiaG9yaXpvbnRhbFwiLCBcInZlcnRpY2FsXCIsIFwiY3VydmVkQ1dcIiwgXCJjdXJ2ZWRDQ1dcIiwgXCJjdWJpY0JlemllclwiXVxuICAgICAgfSxcbiAgICAgIHJvdW5kbmVzczoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGZvcmNlRGlyZWN0aW9uOiB7XG4gICAgICAgIHN0cmluZzogW1wiaG9yaXpvbnRhbFwiLCBcInZlcnRpY2FsXCIsIFwibm9uZVwiXSxcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9XG4gICAgfSxcbiAgICB0aXRsZToge1xuICAgICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgICB9LFxuICAgIHdpZHRoOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgd2lkdGhDb25zdHJhaW50OiB7XG4gICAgICBtYXhpbXVtOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9XG4gICAgfSxcbiAgICB2YWx1ZToge1xuICAgICAgbnVtYmVyOiBudW1iZXIsXG4gICAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdFxuICAgIH1cbiAgfSxcbiAgZ3JvdXBzOiB7XG4gICAgdXNlRGVmYXVsdEdyb3Vwczoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgX19hbnlfXzogbm9kZU9wdGlvbnMsXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgfVxuICB9LFxuICBpbnRlcmFjdGlvbjoge1xuICAgIGRyYWdOb2Rlczoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgZHJhZ1ZpZXc6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGhpZGVFZGdlc09uRHJhZzoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgaGlkZUVkZ2VzT25ab29tOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBoaWRlTm9kZXNPbkRyYWc6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGhvdmVyOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBrZXlib2FyZDoge1xuICAgICAgZW5hYmxlZDoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgc3BlZWQ6IHtcbiAgICAgICAgeDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIHk6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICB6b29tOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgX190eXBlX186IHtcbiAgICAgICAgICBvYmplY3Q6IG9iamVjdFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYmluZFRvV2luZG93OiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBhdXRvRm9jdXM6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9XG4gICAgfSxcbiAgICBtdWx0aXNlbGVjdDoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgbmF2aWdhdGlvbkJ1dHRvbnM6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIHNlbGVjdGFibGU6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIHNlbGVjdENvbm5lY3RlZEVkZ2VzOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBob3ZlckNvbm5lY3RlZEVkZ2VzOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICB0b29sdGlwRGVsYXk6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICB6b29tVmlldzoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgem9vbVNwZWVkOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgfVxuICB9LFxuICBsYXlvdXQ6IHtcbiAgICByYW5kb21TZWVkOiB7XG4gICAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCIsXG4gICAgICBudW1iZXI6IG51bWJlcixcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfSxcbiAgICBpbXByb3ZlZExheW91dDoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgY2x1c3RlclRocmVzaG9sZDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIGhpZXJhcmNoaWNhbDoge1xuICAgICAgZW5hYmxlZDoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgbGV2ZWxTZXBhcmF0aW9uOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgbm9kZVNwYWNpbmc6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICB0cmVlU3BhY2luZzoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGJsb2NrU2hpZnRpbmc6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIGVkZ2VNaW5pbWl6YXRpb246IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIHBhcmVudENlbnRyYWxpemF0aW9uOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBkaXJlY3Rpb246IHtcbiAgICAgICAgc3RyaW5nOiBbXCJVRFwiLCBcIkRVXCIsIFwiTFJcIiwgXCJSTFwiXVxuICAgICAgfSxcbiAgICAgIHNvcnRNZXRob2Q6IHtcbiAgICAgICAgc3RyaW5nOiBbXCJodWJzaXplXCIsIFwiZGlyZWN0ZWRcIl1cbiAgICAgIH0sXG4gICAgICBzaGFrZVRvd2FyZHM6IHtcbiAgICAgICAgc3RyaW5nOiBbXCJsZWF2ZXNcIiwgXCJyb290c1wiXVxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9XG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICB9XG4gIH0sXG4gIG1hbmlwdWxhdGlvbjoge1xuICAgIGVuYWJsZWQ6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGluaXRpYWxseUFjdGl2ZToge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgYWRkTm9kZToge1xuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIGFkZEVkZ2U6IHtcbiAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICBlZGl0Tm9kZToge1xuICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAgZWRpdEVkZ2U6IHtcbiAgICAgIGVkaXRXaXRob3V0RHJhZzoge1xuICAgICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlbGV0ZU5vZGU6IHtcbiAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICBkZWxldGVFZGdlOiB7XG4gICAgICBib29sZWFuOiBib29sLFxuICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAgY29udHJvbE5vZGVTdHlsZTogbm9kZU9wdGlvbnMsXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH1cbiAgfSxcbiAgbm9kZXM6IG5vZGVPcHRpb25zLFxuICBwaHlzaWNzOiB7XG4gICAgZW5hYmxlZDoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgYmFybmVzSHV0OiB7XG4gICAgICB0aGV0YToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGdyYXZpdGF0aW9uYWxDb25zdGFudDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGNlbnRyYWxHcmF2aXR5OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgc3ByaW5nTGVuZ3RoOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgc3ByaW5nQ29uc3RhbnQ6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBkYW1waW5nOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgYXZvaWRPdmVybGFwOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICAgIH1cbiAgICB9LFxuICAgIGZvcmNlQXRsYXMyQmFzZWQ6IHtcbiAgICAgIHRoZXRhOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZ3Jhdml0YXRpb25hbENvbnN0YW50OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgY2VudHJhbEdyYXZpdHk6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBzcHJpbmdMZW5ndGg6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBzcHJpbmdDb25zdGFudDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGRhbXBpbmc6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBhdm9pZE92ZXJsYXA6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdFxuICAgICAgfVxuICAgIH0sXG4gICAgcmVwdWxzaW9uOiB7XG4gICAgICBjZW50cmFsR3Jhdml0eToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHNwcmluZ0xlbmd0aDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHNwcmluZ0NvbnN0YW50OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgbm9kZURpc3RhbmNlOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZGFtcGluZzoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgICB9XG4gICAgfSxcbiAgICBoaWVyYXJjaGljYWxSZXB1bHNpb246IHtcbiAgICAgIGNlbnRyYWxHcmF2aXR5OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgc3ByaW5nTGVuZ3RoOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgc3ByaW5nQ29uc3RhbnQ6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBub2RlRGlzdGFuY2U6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBkYW1waW5nOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgYXZvaWRPdmVybGFwOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICAgIH1cbiAgICB9LFxuICAgIG1heFZlbG9jaXR5OiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgbWluVmVsb2NpdHk6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBzb2x2ZXI6IHtcbiAgICAgIHN0cmluZzogW1wiYmFybmVzSHV0XCIsIFwicmVwdWxzaW9uXCIsIFwiaGllcmFyY2hpY2FsUmVwdWxzaW9uXCIsIFwiZm9yY2VBdGxhczJCYXNlZFwiXVxuICAgIH0sXG4gICAgc3RhYmlsaXphdGlvbjoge1xuICAgICAgZW5hYmxlZDoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgaXRlcmF0aW9uczoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHVwZGF0ZUludGVydmFsOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgb25seUR5bmFtaWNFZGdlczoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgZml0OiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfVxuICAgIH0sXG4gICAgdGltZXN0ZXA6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBhZGFwdGl2ZVRpbWVzdGVwOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICB3aW5kOiB7XG4gICAgICB4OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgICB9XG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBib29sZWFuOiBib29sXG4gICAgfVxuICB9LFxuICAvL2dsb2JhbHMgOlxuICBhdXRvUmVzaXplOiB7XG4gICAgYm9vbGVhbjogYm9vbFxuICB9LFxuICBjbGlja1RvVXNlOiB7XG4gICAgYm9vbGVhbjogYm9vbFxuICB9LFxuICBsb2NhbGU6IHtcbiAgICBzdHJpbmc6IHN0cmluZ1xuICB9LFxuICBsb2NhbGVzOiB7XG4gICAgX19hbnlfXzoge1xuICAgICAgYW55OiBhbnlcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdFxuICAgIH1cbiAgfSxcbiAgaGVpZ2h0OiB7XG4gICAgc3RyaW5nOiBzdHJpbmdcbiAgfSxcbiAgd2lkdGg6IHtcbiAgICBzdHJpbmc6IHN0cmluZ1xuICB9LFxuICBfX3R5cGVfXzoge1xuICAgIG9iamVjdDogb2JqZWN0XG4gIH1cbn07XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xuLyoqXHJcbiAqIFRoaXMgcHJvdmlkZXMgcmFuZ2VzLCBpbml0aWFsIHZhbHVlcywgc3RlcHMgYW5kIGRyb3Bkb3duIG1lbnUgY2hvaWNlcyBmb3IgdGhlXHJcbiAqIGNvbmZpZ3VyYXRpb24uXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIENoZWNrYm94OiBgYm9vbGVhbmBcclxuICogICBUaGUgdmFsdWUgc3VwbGxpZWQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxyXG4gKlxyXG4gKiBUZXh0IGZpZWxkOiBgc3RyaW5nYFxyXG4gKiAgIFRoZSBwYXNzZWQgdGV4dCB3aWxsIGJlIHVzZWQgYXMgdGhlIGluaXRpYWwgdmFsdWUuIEFueSB0ZXh0IHdpbGwgYmVcclxuICogICBhY2NlcHRlZCBhZnRlcndhcmRzLlxyXG4gKlxyXG4gKiBOdW1iZXIgcmFuZ2U6IGBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXWBcclxuICogICBUaGUgbWVhbmluZ3MgYXJlIGBbaW5pdGlhbCB2YWx1ZSwgbWluLCBtYXgsIHN0ZXBdYC5cclxuICpcclxuICogRHJvcGRvd246IGBbRXhjbHVkZTxzdHJpbmcsIFwiY29sb3JcIj4sIC4uLihzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuKVtdXWBcclxuICogICBUcmFuc2xhdGlvbnMgZm9yIHBlb3BsZSB3aXRoIHBvb3IgdW5kZXJzdGFuZGluZyBvZiBUeXBlU2NyaXB0OiB0aGUgZmlyc3RcclxuICogICB2YWx1ZSBhbHdheXMgaGFzIHRvIGJlIGEgc3RyaW5nIGJ1dCBuZXZlciBgXCJjb2xvclwiYCwgdGhlIHJlc3QgY2FuIGJlIGFueVxyXG4gKiAgIGNvbWJpbmF0aW9uIG9mIHN0cmluZ3MsIG51bWJlcnMgYW5kIGJvb2xlYW5zLlxyXG4gKlxyXG4gKiBDb2xvciBwaWNrZXI6IGBbXCJjb2xvclwiLCBzdHJpbmddYFxyXG4gKiAgIFRoZSBmaXJzdCB2YWx1ZSBzYXlzIHRoaXMgd2lsbCBiZSBhIGNvbG9yIHBpY2tlciBub3QgYSBkcm9wZG93biBtZW51LiBUaGVcclxuICogICBuZXh0IHZhbHVlIGlzIHRoZSBpbml0aWFsIGNvbG9yLlxyXG4gKi9cbnZhciBjb25maWd1cmVPcHRpb25zID0ge1xuICBub2Rlczoge1xuICAgIGJvcmRlcldpZHRoOiBbMSwgMCwgMTAsIDFdLFxuICAgIGJvcmRlcldpZHRoU2VsZWN0ZWQ6IFsyLCAwLCAxMCwgMV0sXG4gICAgY29sb3I6IHtcbiAgICAgIGJvcmRlcjogW1wiY29sb3JcIiwgXCIjMkI3Q0U5XCJdLFxuICAgICAgYmFja2dyb3VuZDogW1wiY29sb3JcIiwgXCIjOTdDMkZDXCJdLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogW1wiY29sb3JcIiwgXCIjMkI3Q0U5XCJdLFxuICAgICAgICBiYWNrZ3JvdW5kOiBbXCJjb2xvclwiLCBcIiNEMkU1RkZcIl1cbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFtcImNvbG9yXCIsIFwiIzJCN0NFOVwiXSxcbiAgICAgICAgYmFja2dyb3VuZDogW1wiY29sb3JcIiwgXCIjRDJFNUZGXCJdXG4gICAgICB9XG4gICAgfSxcbiAgICBvcGFjaXR5OiBbMCwgMCwgMSwgMC4xXSxcbiAgICBmaXhlZDoge1xuICAgICAgeDogZmFsc2UsXG4gICAgICB5OiBmYWxzZVxuICAgIH0sXG4gICAgZm9udDoge1xuICAgICAgY29sb3I6IFtcImNvbG9yXCIsIFwiIzM0MzQzNFwiXSxcbiAgICAgIHNpemU6IFsxNCwgMCwgMTAwLCAxXSxcbiAgICAgIGZhY2U6IFtcImFyaWFsXCIsIFwidmVyZGFuYVwiLCBcInRhaG9tYVwiXSxcbiAgICAgIGJhY2tncm91bmQ6IFtcImNvbG9yXCIsIFwibm9uZVwiXSxcbiAgICAgIHN0cm9rZVdpZHRoOiBbMCwgMCwgNTAsIDFdLFxuICAgICAgc3Ryb2tlQ29sb3I6IFtcImNvbG9yXCIsIFwiI2ZmZmZmZlwiXVxuICAgIH0sXG4gICAgLy9ncm91cDogJ3N0cmluZycsXG4gICAgaGlkZGVuOiBmYWxzZSxcbiAgICBsYWJlbEhpZ2hsaWdodEJvbGQ6IHRydWUsXG4gICAgLy9pY29uOiB7XG4gICAgLy8gIGZhY2U6ICdzdHJpbmcnLCAgLy8nRm9udEF3ZXNvbWUnLFxuICAgIC8vICBjb2RlOiAnc3RyaW5nJywgIC8vJ1xcdWYwMDcnLFxuICAgIC8vICBzaXplOiBbNTAsIDAsIDIwMCwgMV0sICAvLzUwLFxuICAgIC8vICBjb2xvcjogWydjb2xvcicsJyMyQjdDRTknXSAgIC8vJyNhYTAwZmYnXG4gICAgLy99LFxuICAgIC8vaW1hZ2U6ICdzdHJpbmcnLCAvLyAtLT4gVVJMXG4gICAgcGh5c2ljczogdHJ1ZSxcbiAgICBzY2FsaW5nOiB7XG4gICAgICBtaW46IFsxMCwgMCwgMjAwLCAxXSxcbiAgICAgIG1heDogWzMwLCAwLCAyMDAsIDFdLFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIG1pbjogWzE0LCAwLCAyMDAsIDFdLFxuICAgICAgICBtYXg6IFszMCwgMCwgMjAwLCAxXSxcbiAgICAgICAgbWF4VmlzaWJsZTogWzMwLCAwLCAyMDAsIDFdLFxuICAgICAgICBkcmF3VGhyZXNob2xkOiBbNSwgMCwgMjAsIDFdXG4gICAgICB9XG4gICAgfSxcbiAgICBzaGFkb3c6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgY29sb3I6IFwicmdiYSgwLDAsMCwwLjUpXCIsXG4gICAgICBzaXplOiBbMTAsIDAsIDIwLCAxXSxcbiAgICAgIHg6IFs1LCAtMzAsIDMwLCAxXSxcbiAgICAgIHk6IFs1LCAtMzAsIDMwLCAxXVxuICAgIH0sXG4gICAgc2hhcGU6IFtcImVsbGlwc2VcIiwgXCJib3hcIiwgXCJjaXJjbGVcIiwgXCJkYXRhYmFzZVwiLCBcImRpYW1vbmRcIiwgXCJkb3RcIiwgXCJzcXVhcmVcIiwgXCJzdGFyXCIsIFwidGV4dFwiLCBcInRyaWFuZ2xlXCIsIFwidHJpYW5nbGVEb3duXCIsIFwiaGV4YWdvblwiXSxcbiAgICBzaGFwZVByb3BlcnRpZXM6IHtcbiAgICAgIGJvcmRlckRhc2hlczogZmFsc2UsXG4gICAgICBib3JkZXJSYWRpdXM6IFs2LCAwLCAyMCwgMV0sXG4gICAgICBpbnRlcnBvbGF0aW9uOiB0cnVlLFxuICAgICAgdXNlSW1hZ2VTaXplOiBmYWxzZVxuICAgIH0sXG4gICAgc2l6ZTogWzI1LCAwLCAyMDAsIDFdXG4gIH0sXG4gIGVkZ2VzOiB7XG4gICAgYXJyb3dzOiB7XG4gICAgICB0bzoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgc2NhbGVGYWN0b3I6IFsxLCAwLCAzLCAwLjA1XSxcbiAgICAgICAgdHlwZTogXCJhcnJvd1wiXG4gICAgICB9LFxuICAgICAgbWlkZGxlOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBzY2FsZUZhY3RvcjogWzEsIDAsIDMsIDAuMDVdLFxuICAgICAgICB0eXBlOiBcImFycm93XCJcbiAgICAgIH0sXG4gICAgICBmcm9tOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBzY2FsZUZhY3RvcjogWzEsIDAsIDMsIDAuMDVdLFxuICAgICAgICB0eXBlOiBcImFycm93XCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGVuZFBvaW50T2Zmc2V0OiB7XG4gICAgICBmcm9tOiBbMCwgLTEwLCAxMCwgMV0sXG4gICAgICB0bzogWzAsIC0xMCwgMTAsIDFdXG4gICAgfSxcbiAgICBhcnJvd1N0cmlrZXRocm91Z2g6IHRydWUsXG4gICAgY29sb3I6IHtcbiAgICAgIGNvbG9yOiBbXCJjb2xvclwiLCBcIiM4NDg0ODRcIl0sXG4gICAgICBoaWdobGlnaHQ6IFtcImNvbG9yXCIsIFwiIzg0ODQ4NFwiXSxcbiAgICAgIGhvdmVyOiBbXCJjb2xvclwiLCBcIiM4NDg0ODRcIl0sXG4gICAgICBpbmhlcml0OiBbXCJmcm9tXCIsIFwidG9cIiwgXCJib3RoXCIsIHRydWUsIGZhbHNlXSxcbiAgICAgIG9wYWNpdHk6IFsxLCAwLCAxLCAwLjA1XVxuICAgIH0sXG4gICAgZGFzaGVzOiBmYWxzZSxcbiAgICBmb250OiB7XG4gICAgICBjb2xvcjogW1wiY29sb3JcIiwgXCIjMzQzNDM0XCJdLFxuICAgICAgc2l6ZTogWzE0LCAwLCAxMDAsIDFdLFxuICAgICAgZmFjZTogW1wiYXJpYWxcIiwgXCJ2ZXJkYW5hXCIsIFwidGFob21hXCJdLFxuICAgICAgYmFja2dyb3VuZDogW1wiY29sb3JcIiwgXCJub25lXCJdLFxuICAgICAgc3Ryb2tlV2lkdGg6IFsyLCAwLCA1MCwgMV0sXG4gICAgICBzdHJva2VDb2xvcjogW1wiY29sb3JcIiwgXCIjZmZmZmZmXCJdLFxuICAgICAgYWxpZ246IFtcImhvcml6b250YWxcIiwgXCJ0b3BcIiwgXCJtaWRkbGVcIiwgXCJib3R0b21cIl1cbiAgICB9LFxuICAgIGhpZGRlbjogZmFsc2UsXG4gICAgaG92ZXJXaWR0aDogWzEuNSwgMCwgNSwgMC4xXSxcbiAgICBsYWJlbEhpZ2hsaWdodEJvbGQ6IHRydWUsXG4gICAgcGh5c2ljczogdHJ1ZSxcbiAgICBzY2FsaW5nOiB7XG4gICAgICBtaW46IFsxLCAwLCAxMDAsIDFdLFxuICAgICAgbWF4OiBbMTUsIDAsIDEwMCwgMV0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBtaW46IFsxNCwgMCwgMjAwLCAxXSxcbiAgICAgICAgbWF4OiBbMzAsIDAsIDIwMCwgMV0sXG4gICAgICAgIG1heFZpc2libGU6IFszMCwgMCwgMjAwLCAxXSxcbiAgICAgICAgZHJhd1RocmVzaG9sZDogWzUsIDAsIDIwLCAxXVxuICAgICAgfVxuICAgIH0sXG4gICAgc2VsZWN0aW9uV2lkdGg6IFsxLjUsIDAsIDUsIDAuMV0sXG4gICAgc2VsZlJlZmVyZW5jZVNpemU6IFsyMCwgMCwgMjAwLCAxXSxcbiAgICBzZWxmUmVmZXJlbmNlOiB7XG4gICAgICBzaXplOiBbMjAsIDAsIDIwMCwgMV0sXG4gICAgICBhbmdsZTogW01hdGguUEkgLyAyLCAtNiAqIE1hdGguUEksIDYgKiBNYXRoLlBJLCBNYXRoLlBJIC8gOF0sXG4gICAgICByZW5kZXJCZWhpbmRUaGVOb2RlOiB0cnVlXG4gICAgfSxcbiAgICBzaGFkb3c6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgY29sb3I6IFwicmdiYSgwLDAsMCwwLjUpXCIsXG4gICAgICBzaXplOiBbMTAsIDAsIDIwLCAxXSxcbiAgICAgIHg6IFs1LCAtMzAsIDMwLCAxXSxcbiAgICAgIHk6IFs1LCAtMzAsIDMwLCAxXVxuICAgIH0sXG4gICAgc21vb3RoOiB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgdHlwZTogW1wiZHluYW1pY1wiLCBcImNvbnRpbnVvdXNcIiwgXCJkaXNjcmV0ZVwiLCBcImRpYWdvbmFsQ3Jvc3NcIiwgXCJzdHJhaWdodENyb3NzXCIsIFwiaG9yaXpvbnRhbFwiLCBcInZlcnRpY2FsXCIsIFwiY3VydmVkQ1dcIiwgXCJjdXJ2ZWRDQ1dcIiwgXCJjdWJpY0JlemllclwiXSxcbiAgICAgIGZvcmNlRGlyZWN0aW9uOiBbXCJob3Jpem9udGFsXCIsIFwidmVydGljYWxcIiwgXCJub25lXCJdLFxuICAgICAgcm91bmRuZXNzOiBbMC41LCAwLCAxLCAwLjA1XVxuICAgIH0sXG4gICAgd2lkdGg6IFsxLCAwLCAzMCwgMV1cbiAgfSxcbiAgbGF5b3V0OiB7XG4gICAgLy9yYW5kb21TZWVkOiBbMCwgMCwgNTAwLCAxXSxcbiAgICAvL2ltcHJvdmVkTGF5b3V0OiB0cnVlLFxuICAgIGhpZXJhcmNoaWNhbDoge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBsZXZlbFNlcGFyYXRpb246IFsxNTAsIDIwLCA1MDAsIDVdLFxuICAgICAgbm9kZVNwYWNpbmc6IFsxMDAsIDIwLCA1MDAsIDVdLFxuICAgICAgdHJlZVNwYWNpbmc6IFsyMDAsIDIwLCA1MDAsIDVdLFxuICAgICAgYmxvY2tTaGlmdGluZzogdHJ1ZSxcbiAgICAgIGVkZ2VNaW5pbWl6YXRpb246IHRydWUsXG4gICAgICBwYXJlbnRDZW50cmFsaXphdGlvbjogdHJ1ZSxcbiAgICAgIGRpcmVjdGlvbjogW1wiVURcIiwgXCJEVVwiLCBcIkxSXCIsIFwiUkxcIl0sXG4gICAgICBzb3J0TWV0aG9kOiBbXCJodWJzaXplXCIsIFwiZGlyZWN0ZWRcIl0sXG4gICAgICBzaGFrZVRvd2FyZHM6IFtcImxlYXZlc1wiLCBcInJvb3RzXCJdIC8vIGxlYXZlcywgcm9vdHNcbiAgICB9XG4gIH0sXG5cbiAgaW50ZXJhY3Rpb246IHtcbiAgICBkcmFnTm9kZXM6IHRydWUsXG4gICAgZHJhZ1ZpZXc6IHRydWUsXG4gICAgaGlkZUVkZ2VzT25EcmFnOiBmYWxzZSxcbiAgICBoaWRlRWRnZXNPblpvb206IGZhbHNlLFxuICAgIGhpZGVOb2Rlc09uRHJhZzogZmFsc2UsXG4gICAgaG92ZXI6IGZhbHNlLFxuICAgIGtleWJvYXJkOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIHNwZWVkOiB7XG4gICAgICAgIHg6IFsxMCwgMCwgNDAsIDFdLFxuICAgICAgICB5OiBbMTAsIDAsIDQwLCAxXSxcbiAgICAgICAgem9vbTogWzAuMDIsIDAsIDAuMSwgMC4wMDVdXG4gICAgICB9LFxuICAgICAgYmluZFRvV2luZG93OiB0cnVlLFxuICAgICAgYXV0b0ZvY3VzOiB0cnVlXG4gICAgfSxcbiAgICBtdWx0aXNlbGVjdDogZmFsc2UsXG4gICAgbmF2aWdhdGlvbkJ1dHRvbnM6IGZhbHNlLFxuICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgc2VsZWN0Q29ubmVjdGVkRWRnZXM6IHRydWUsXG4gICAgaG92ZXJDb25uZWN0ZWRFZGdlczogdHJ1ZSxcbiAgICB0b29sdGlwRGVsYXk6IFszMDAsIDAsIDEwMDAsIDI1XSxcbiAgICB6b29tVmlldzogdHJ1ZSxcbiAgICB6b29tU3BlZWQ6IFsxLCAwLjEsIDIsIDAuMV1cbiAgfSxcbiAgbWFuaXB1bGF0aW9uOiB7XG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgaW5pdGlhbGx5QWN0aXZlOiBmYWxzZVxuICB9LFxuICBwaHlzaWNzOiB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBiYXJuZXNIdXQ6IHtcbiAgICAgIHRoZXRhOiBbMC41LCAwLjEsIDEsIDAuMDVdLFxuICAgICAgZ3Jhdml0YXRpb25hbENvbnN0YW50OiBbLTIwMDAsIC0zMDAwMCwgMCwgNTBdLFxuICAgICAgY2VudHJhbEdyYXZpdHk6IFswLjMsIDAsIDEwLCAwLjA1XSxcbiAgICAgIHNwcmluZ0xlbmd0aDogWzk1LCAwLCA1MDAsIDVdLFxuICAgICAgc3ByaW5nQ29uc3RhbnQ6IFswLjA0LCAwLCAxLjIsIDAuMDA1XSxcbiAgICAgIGRhbXBpbmc6IFswLjA5LCAwLCAxLCAwLjAxXSxcbiAgICAgIGF2b2lkT3ZlcmxhcDogWzAsIDAsIDEsIDAuMDFdXG4gICAgfSxcbiAgICBmb3JjZUF0bGFzMkJhc2VkOiB7XG4gICAgICB0aGV0YTogWzAuNSwgMC4xLCAxLCAwLjA1XSxcbiAgICAgIGdyYXZpdGF0aW9uYWxDb25zdGFudDogWy01MCwgLTUwMCwgMCwgMV0sXG4gICAgICBjZW50cmFsR3Jhdml0eTogWzAuMDEsIDAsIDEsIDAuMDA1XSxcbiAgICAgIHNwcmluZ0xlbmd0aDogWzk1LCAwLCA1MDAsIDVdLFxuICAgICAgc3ByaW5nQ29uc3RhbnQ6IFswLjA4LCAwLCAxLjIsIDAuMDA1XSxcbiAgICAgIGRhbXBpbmc6IFswLjQsIDAsIDEsIDAuMDFdLFxuICAgICAgYXZvaWRPdmVybGFwOiBbMCwgMCwgMSwgMC4wMV1cbiAgICB9LFxuICAgIHJlcHVsc2lvbjoge1xuICAgICAgY2VudHJhbEdyYXZpdHk6IFswLjIsIDAsIDEwLCAwLjA1XSxcbiAgICAgIHNwcmluZ0xlbmd0aDogWzIwMCwgMCwgNTAwLCA1XSxcbiAgICAgIHNwcmluZ0NvbnN0YW50OiBbMC4wNSwgMCwgMS4yLCAwLjAwNV0sXG4gICAgICBub2RlRGlzdGFuY2U6IFsxMDAsIDAsIDUwMCwgNV0sXG4gICAgICBkYW1waW5nOiBbMC4wOSwgMCwgMSwgMC4wMV1cbiAgICB9LFxuICAgIGhpZXJhcmNoaWNhbFJlcHVsc2lvbjoge1xuICAgICAgY2VudHJhbEdyYXZpdHk6IFswLjIsIDAsIDEwLCAwLjA1XSxcbiAgICAgIHNwcmluZ0xlbmd0aDogWzEwMCwgMCwgNTAwLCA1XSxcbiAgICAgIHNwcmluZ0NvbnN0YW50OiBbMC4wMSwgMCwgMS4yLCAwLjAwNV0sXG4gICAgICBub2RlRGlzdGFuY2U6IFsxMjAsIDAsIDUwMCwgNV0sXG4gICAgICBkYW1waW5nOiBbMC4wOSwgMCwgMSwgMC4wMV0sXG4gICAgICBhdm9pZE92ZXJsYXA6IFswLCAwLCAxLCAwLjAxXVxuICAgIH0sXG4gICAgbWF4VmVsb2NpdHk6IFs1MCwgMCwgMTUwLCAxXSxcbiAgICBtaW5WZWxvY2l0eTogWzAuMSwgMC4wMSwgMC41LCAwLjAxXSxcbiAgICBzb2x2ZXI6IFtcImJhcm5lc0h1dFwiLCBcImZvcmNlQXRsYXMyQmFzZWRcIiwgXCJyZXB1bHNpb25cIiwgXCJoaWVyYXJjaGljYWxSZXB1bHNpb25cIl0sXG4gICAgdGltZXN0ZXA6IFswLjUsIDAuMDEsIDEsIDAuMDFdLFxuICAgIHdpbmQ6IHtcbiAgICAgIHg6IFswLCAtMTAsIDEwLCAwLjFdLFxuICAgICAgeTogWzAsIC0xMCwgMTAsIDAuMV1cbiAgICB9XG4gICAgLy9hZGFwdGl2ZVRpbWVzdGVwOiB0cnVlXG4gIH1cbn07XG5cbnZhciBjb25maWd1cmF0b3JIaWRlT3B0aW9uID0gZnVuY3Rpb24gY29uZmlndXJhdG9ySGlkZU9wdGlvbihwYXJlbnRQYXRoLCBvcHRpb25OYW1lLCBvcHRpb25zKSB7XG4gIHZhciBfY29udGV4dDtcbiAgaWYgKF9pbmNsdWRlc0luc3RhbmNlUHJvcGVydHkocGFyZW50UGF0aCkuY2FsbChwYXJlbnRQYXRoLCBcInBoeXNpY3NcIikgJiYgX2luY2x1ZGVzSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dCA9IGNvbmZpZ3VyZU9wdGlvbnMucGh5c2ljcy5zb2x2ZXIpLmNhbGwoX2NvbnRleHQsIG9wdGlvbk5hbWUpICYmIG9wdGlvbnMucGh5c2ljcy5zb2x2ZXIgIT09IG9wdGlvbk5hbWUgJiYgb3B0aW9uTmFtZSAhPT0gXCJ3aW5kXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgb3B0aW9ucyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRhbGxPcHRpb25zOiBhbGxPcHRpb25zLFxuXHRjb25maWd1cmF0b3JIaWRlT3B0aW9uOiBjb25maWd1cmF0b3JIaWRlT3B0aW9uLFxuXHRjb25maWd1cmVPcHRpb25zOiBjb25maWd1cmVPcHRpb25zXG59KTtcblxuLyoqXG4gKiAgVGhlIEZsb3lk4oCTV2Fyc2hhbGwgYWxnb3JpdGhtIGlzIGFuIGFsZ29yaXRobSBmb3IgZmluZGluZyBzaG9ydGVzdCBwYXRocyBpblxuICogIGEgd2VpZ2h0ZWQgZ3JhcGggd2l0aCBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBlZGdlIHdlaWdodHMgKGJ1dCB3aXRoIG5vIG5lZ2F0aXZlXG4gKiAgY3ljbGVzKS4gLSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GbG95ZOKAk1dhcnNoYWxsX2FsZ29yaXRobVxuICovXG52YXIgRmxveWRXYXJzaGFsbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBGbG95ZFdhcnNoYWxsKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGbG95ZFdhcnNoYWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gbm9kZXNBcnJheVxuICAgKiBAcGFyYW0ge0FycmF5LjxFZGdlPn0gZWRnZXNBcnJheVxuICAgKiBAcmV0dXJucyB7e319XG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoRmxveWRXYXJzaGFsbCwgW3tcbiAgICBrZXk6IFwiZ2V0RGlzdGFuY2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpc3RhbmNlcyhib2R5LCBub2Rlc0FycmF5LCBlZGdlc0FycmF5KSB7XG4gICAgICB2YXIgRF9tYXRyaXggPSB7fTtcbiAgICAgIHZhciBlZGdlcyA9IGJvZHkuZWRnZXM7XG5cbiAgICAgIC8vIHByZXBhcmUgbWF0cml4IHdpdGggbGFyZ2UgbnVtYmVyc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlc0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNBcnJheVtpXTtcbiAgICAgICAgdmFyIGNlbGwgPSB7fTtcbiAgICAgICAgRF9tYXRyaXhbbm9kZV0gPSBjZWxsO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjZWxsW25vZGVzQXJyYXlbal1dID0gaSA9PSBqID8gMCA6IDFlOTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBwdXQgdGhlIHdlaWdodHMgZm9yIHRoZSBlZGdlcyBpbi4gVGhpcyBhc3N1bWVzIHVuaWRpcmVjdGlvbmFsaXR5LlxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVkZ2VzQXJyYXkubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbZWRnZXNBcnJheVtfaV1dO1xuICAgICAgICAvLyBlZGdlIGhhcyB0byBiZSBjb25uZWN0ZWQgaWYgaXQgY291bnRzIHRvIHRoZSBkaXN0YW5jZXMuIElmIGl0IGlzIGNvbm5lY3RlZCB0byBpbm5lciBjbHVzdGVycyBpdCB3aWxsIGNyYXNoIHNvIHdlIGFsc28gY2hlY2sgaWYgaXQgaXMgaW4gdGhlIERfbWF0cml4XG4gICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCA9PT0gdHJ1ZSAmJiBEX21hdHJpeFtlZGdlLmZyb21JZF0gIT09IHVuZGVmaW5lZCAmJiBEX21hdHJpeFtlZGdlLnRvSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBEX21hdHJpeFtlZGdlLmZyb21JZF1bZWRnZS50b0lkXSA9IDE7XG4gICAgICAgICAgRF9tYXRyaXhbZWRnZS50b0lkXVtlZGdlLmZyb21JZF0gPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbm9kZUNvdW50ID0gbm9kZXNBcnJheS5sZW5ndGg7XG5cbiAgICAgIC8vIEFkYXB0ZWQgRmxveWRXYXJzaGFsbCBiYXNlZCBvbiB1bmlkaXJlY3Rpb25hbGl0eSB0byBncmVhdGx5IHJlZHVjZSBjb21wbGV4aXR5LlxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBub2RlQ291bnQ7IGsrKykge1xuICAgICAgICB2YXIga25vZGUgPSBub2Rlc0FycmF5W2tdO1xuICAgICAgICB2YXIga2NvbG0gPSBEX21hdHJpeFtrbm9kZV07XG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVDb3VudCAtIDE7IF9pMisrKSB7XG4gICAgICAgICAgdmFyIGlub2RlID0gbm9kZXNBcnJheVtfaTJdO1xuICAgICAgICAgIHZhciBpY29sbSA9IERfbWF0cml4W2lub2RlXTtcbiAgICAgICAgICBmb3IgKHZhciBfaiA9IF9pMiArIDE7IF9qIDwgbm9kZUNvdW50OyBfaisrKSB7XG4gICAgICAgICAgICB2YXIgam5vZGUgPSBub2Rlc0FycmF5W19qXTtcbiAgICAgICAgICAgIHZhciBqY29sbSA9IERfbWF0cml4W2pub2RlXTtcbiAgICAgICAgICAgIHZhciB2YWwgPSBNYXRoLm1pbihpY29sbVtqbm9kZV0sIGljb2xtW2tub2RlXSArIGtjb2xtW2pub2RlXSk7XG4gICAgICAgICAgICBpY29sbVtqbm9kZV0gPSB2YWw7XG4gICAgICAgICAgICBqY29sbVtpbm9kZV0gPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gRF9tYXRyaXg7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBGbG95ZFdhcnNoYWxsO1xufSgpO1xuXG4vKipcbiAqIEthbWFkYUthd2FpIHBvc2l0aW9ucyB0aGUgbm9kZXMgaW5pdGlhbGx5IGJhc2VkIG9uXG4gKlxuICogXCJBTiBBTEdPUklUSE0gRk9SIERSQVdJTkcgR0VORVJBTCBVTkRJUkVDVEVEIEdSQVBIU1wiXG4gKiAtLSBUb21paGlzYSBLQU1BREEgYW5kIFNhdG9ydSBLQVdBSSBpbiAxOTg5XG4gKlxuICogUG9zc2libGUgb3B0aW1pemF0aW9ucyBpbiB0aGUgZGlzdGFuY2UgY2FsY3VsYXRpb24gY2FuIGJlIGltcGxlbWVudGVkLlxuICovXG52YXIgS2FtYWRhS2F3YWkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVkZ2VMZW5ndGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVkZ2VTdHJlbmd0aFxuICAgKi9cbiAgZnVuY3Rpb24gS2FtYWRhS2F3YWkoYm9keSwgZWRnZUxlbmd0aCwgZWRnZVN0cmVuZ3RoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEthbWFkYUthd2FpKTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuc3ByaW5nTGVuZ3RoID0gZWRnZUxlbmd0aDtcbiAgICB0aGlzLnNwcmluZ0NvbnN0YW50ID0gZWRnZVN0cmVuZ3RoO1xuICAgIHRoaXMuZGlzdGFuY2VTb2x2ZXIgPSBuZXcgRmxveWRXYXJzaGFsbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vdCBzdXJlIGlmIG5lZWRlZCBidXQgY2FuIGJlIHVzZWQgdG8gdXBkYXRlIHRoZSBzcHJpbmcgbGVuZ3RoIGFuZCBzcHJpbmcgY29uc3RhbnRcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhLYW1hZGFLYXdhaSwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnNwcmluZ0xlbmd0aCkge1xuICAgICAgICAgIHRoaXMuc3ByaW5nTGVuZ3RoID0gb3B0aW9ucy5zcHJpbmdMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc3ByaW5nQ29uc3RhbnQpIHtcbiAgICAgICAgICB0aGlzLnNwcmluZ0NvbnN0YW50ID0gb3B0aW9ucy5zcHJpbmdDb25zdGFudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIHRoZSBzeXN0ZW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE5vZGU+fSBub2Rlc0FycmF5XG4gICAgICogQHBhcmFtIHtBcnJheS48dmlzLkVkZ2U+fSBlZGdlc0FycmF5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaWdub3JlQ2x1c3RlcnM9ZmFsc2VdXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUobm9kZXNBcnJheSwgZWRnZXNBcnJheSkge1xuICAgICAgdmFyIGlnbm9yZUNsdXN0ZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIC8vIGdldCBkaXN0YW5jZSBtYXRyaXhcbiAgICAgIHZhciBEX21hdHJpeCA9IHRoaXMuZGlzdGFuY2VTb2x2ZXIuZ2V0RGlzdGFuY2VzKHRoaXMuYm9keSwgbm9kZXNBcnJheSwgZWRnZXNBcnJheSk7IC8vIGRpc3RhbmNlIG1hdHJpeFxuXG4gICAgICAvLyBnZXQgdGhlIEwgTWF0cml4XG4gICAgICB0aGlzLl9jcmVhdGVMX21hdHJpeChEX21hdHJpeCk7XG5cbiAgICAgIC8vIGdldCB0aGUgSyBNYXRyaXhcbiAgICAgIHRoaXMuX2NyZWF0ZUtfbWF0cml4KERfbWF0cml4KTtcblxuICAgICAgLy8gaW5pdGlhbCBFIE1hdHJpeFxuICAgICAgdGhpcy5fY3JlYXRlRV9tYXRyaXgoKTtcblxuICAgICAgLy8gY2FsY3VsYXRlIHBvc2l0aW9uc1xuICAgICAgdmFyIHRocmVzaG9sZCA9IDAuMDE7XG4gICAgICB2YXIgaW5uZXJUaHJlc2hvbGQgPSAxO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSBNYXRoLm1heCgxMDAwLCBNYXRoLm1pbigxMCAqIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGgsIDYwMDApKTtcbiAgICAgIHZhciBtYXhJbm5lckl0ZXJhdGlvbnMgPSA1O1xuICAgICAgdmFyIG1heEVuZXJneSA9IDFlOTtcbiAgICAgIHZhciBoaWdoRV9ub2RlSWQgPSAwLFxuICAgICAgICBkRV9keCA9IDAsXG4gICAgICAgIGRFX2R5ID0gMCxcbiAgICAgICAgZGVsdGFfbSA9IDAsXG4gICAgICAgIHN1Ykl0ZXJhdGlvbnMgPSAwO1xuICAgICAgd2hpbGUgKG1heEVuZXJneSA+IHRocmVzaG9sZCAmJiBpdGVyYXRpb25zIDwgbWF4SXRlcmF0aW9ucykge1xuICAgICAgICBpdGVyYXRpb25zICs9IDE7XG4gICAgICAgIHZhciBfdGhpcyRfZ2V0SGlnaGVzdEVuZXIgPSB0aGlzLl9nZXRIaWdoZXN0RW5lcmd5Tm9kZShpZ25vcmVDbHVzdGVycyk7XG4gICAgICAgIHZhciBfdGhpcyRfZ2V0SGlnaGVzdEVuZXIyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX2dldEhpZ2hlc3RFbmVyLCA0KTtcbiAgICAgICAgaGlnaEVfbm9kZUlkID0gX3RoaXMkX2dldEhpZ2hlc3RFbmVyMlswXTtcbiAgICAgICAgbWF4RW5lcmd5ID0gX3RoaXMkX2dldEhpZ2hlc3RFbmVyMlsxXTtcbiAgICAgICAgZEVfZHggPSBfdGhpcyRfZ2V0SGlnaGVzdEVuZXIyWzJdO1xuICAgICAgICBkRV9keSA9IF90aGlzJF9nZXRIaWdoZXN0RW5lcjJbM107XG4gICAgICAgIGRlbHRhX20gPSBtYXhFbmVyZ3k7XG4gICAgICAgIHN1Ykl0ZXJhdGlvbnMgPSAwO1xuICAgICAgICB3aGlsZSAoZGVsdGFfbSA+IGlubmVyVGhyZXNob2xkICYmIHN1Ykl0ZXJhdGlvbnMgPCBtYXhJbm5lckl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICBzdWJJdGVyYXRpb25zICs9IDE7XG4gICAgICAgICAgdGhpcy5fbW92ZU5vZGUoaGlnaEVfbm9kZUlkLCBkRV9keCwgZEVfZHkpO1xuICAgICAgICAgIHZhciBfdGhpcyRfZ2V0RW5lcmd5ID0gdGhpcy5fZ2V0RW5lcmd5KGhpZ2hFX25vZGVJZCk7XG4gICAgICAgICAgdmFyIF90aGlzJF9nZXRFbmVyZ3kyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX2dldEVuZXJneSwgMyk7XG4gICAgICAgICAgZGVsdGFfbSA9IF90aGlzJF9nZXRFbmVyZ3kyWzBdO1xuICAgICAgICAgIGRFX2R4ID0gX3RoaXMkX2dldEVuZXJneTJbMV07XG4gICAgICAgICAgZEVfZHkgPSBfdGhpcyRfZ2V0RW5lcmd5MlsyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgbm9kZSB3aXRoIHRoZSBoaWdoZXN0IGVuZXJneVxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpZ25vcmVDbHVzdGVyc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXRIaWdoZXN0RW5lcmd5Tm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SGlnaGVzdEVuZXJneU5vZGUoaWdub3JlQ2x1c3RlcnMpIHtcbiAgICAgIHZhciBub2Rlc0FycmF5ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIG1heEVuZXJneSA9IDA7XG4gICAgICB2YXIgbWF4RW5lcmd5Tm9kZUlkID0gbm9kZXNBcnJheVswXTtcbiAgICAgIHZhciBkRV9keF9tYXggPSAwLFxuICAgICAgICBkRV9keV9tYXggPSAwO1xuICAgICAgZm9yICh2YXIgbm9kZUlkeCA9IDA7IG5vZGVJZHggPCBub2Rlc0FycmF5Lmxlbmd0aDsgbm9kZUlkeCsrKSB7XG4gICAgICAgIHZhciBtID0gbm9kZXNBcnJheVtub2RlSWR4XTtcbiAgICAgICAgLy8gYnkgbm90IGV2YWx1YXRpbmcgbm9kZXMgd2l0aCBwcmVkZWZpbmVkIHBvc2l0aW9ucyB3ZSBzaG91bGQgb25seSBtb3ZlIG5vZGVzIHRoYXQgaGF2ZSBubyBwb3NpdGlvbnMuXG4gICAgICAgIGlmIChub2Rlc1ttXS5wcmVkZWZpbmVkUG9zaXRpb24gIT09IHRydWUgfHwgbm9kZXNbbV0uaXNDbHVzdGVyID09PSB0cnVlICYmIGlnbm9yZUNsdXN0ZXJzID09PSB0cnVlIHx8IG5vZGVzW21dLm9wdGlvbnMuZml4ZWQueCAhPT0gdHJ1ZSB8fCBub2Rlc1ttXS5vcHRpb25zLmZpeGVkLnkgIT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkX2dldEVuZXJneTMgPSB0aGlzLl9nZXRFbmVyZ3kobSksXG4gICAgICAgICAgICBfdGhpcyRfZ2V0RW5lcmd5NCA9IF9zbGljZWRUb0FycmF5KF90aGlzJF9nZXRFbmVyZ3kzLCAzKSxcbiAgICAgICAgICAgIGRlbHRhX20gPSBfdGhpcyRfZ2V0RW5lcmd5NFswXSxcbiAgICAgICAgICAgIGRFX2R4ID0gX3RoaXMkX2dldEVuZXJneTRbMV0sXG4gICAgICAgICAgICBkRV9keSA9IF90aGlzJF9nZXRFbmVyZ3k0WzJdO1xuICAgICAgICAgIGlmIChtYXhFbmVyZ3kgPCBkZWx0YV9tKSB7XG4gICAgICAgICAgICBtYXhFbmVyZ3kgPSBkZWx0YV9tO1xuICAgICAgICAgICAgbWF4RW5lcmd5Tm9kZUlkID0gbTtcbiAgICAgICAgICAgIGRFX2R4X21heCA9IGRFX2R4O1xuICAgICAgICAgICAgZEVfZHlfbWF4ID0gZEVfZHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW21heEVuZXJneU5vZGVJZCwgbWF4RW5lcmd5LCBkRV9keF9tYXgsIGRFX2R5X21heF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlIHRoZSBlbmVyZ3kgb2YgYSBzaW5nbGUgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBtXG4gICAgICogQHJldHVybnMge251bWJlcltdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEVuZXJneVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RW5lcmd5KG0pIHtcbiAgICAgIHZhciBfdGhpcyRFX3N1bXMkbSA9IF9zbGljZWRUb0FycmF5KHRoaXMuRV9zdW1zW21dLCAyKSxcbiAgICAgICAgZEVfZHggPSBfdGhpcyRFX3N1bXMkbVswXSxcbiAgICAgICAgZEVfZHkgPSBfdGhpcyRFX3N1bXMkbVsxXTtcbiAgICAgIHZhciBkZWx0YV9tID0gTWF0aC5zcXJ0KE1hdGgucG93KGRFX2R4LCAyKSArIE1hdGgucG93KGRFX2R5LCAyKSk7XG4gICAgICByZXR1cm4gW2RlbHRhX20sIGRFX2R4LCBkRV9keV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbW92ZSB0aGUgbm9kZSBiYXNlZCBvbiBpdCdzIGVuZXJneVxuICAgICAqIHRoZSBkeCBhbmQgZHkgYXJlIGNhbGN1bGF0ZWQgZnJvbSB0aGUgbGluZWFyIHN5c3RlbSBwcm9wb3NlZCBieSBLYW1hZGEgYW5kIEthd2FpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkRV9keFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkRV9keVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX21vdmVOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlTm9kZShtLCBkRV9keCwgZEVfZHkpIHtcbiAgICAgIHZhciBub2Rlc0FycmF5ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIGQyRV9keDIgPSAwO1xuICAgICAgdmFyIGQyRV9keGR5ID0gMDtcbiAgICAgIHZhciBkMkVfZHkyID0gMDtcbiAgICAgIHZhciB4X20gPSBub2Rlc1ttXS54O1xuICAgICAgdmFyIHlfbSA9IG5vZGVzW21dLnk7XG4gICAgICB2YXIga20gPSB0aGlzLktfbWF0cml4W21dO1xuICAgICAgdmFyIGxtID0gdGhpcy5MX21hdHJpeFttXTtcbiAgICAgIGZvciAodmFyIGlJZHggPSAwOyBpSWR4IDwgbm9kZXNBcnJheS5sZW5ndGg7IGlJZHgrKykge1xuICAgICAgICB2YXIgaSA9IG5vZGVzQXJyYXlbaUlkeF07XG4gICAgICAgIGlmIChpICE9PSBtKSB7XG4gICAgICAgICAgdmFyIHhfaSA9IG5vZGVzW2ldLng7XG4gICAgICAgICAgdmFyIHlfaSA9IG5vZGVzW2ldLnk7XG4gICAgICAgICAgdmFyIGttYXQgPSBrbVtpXTtcbiAgICAgICAgICB2YXIgbG1hdCA9IGxtW2ldO1xuICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IDEuMCAvIE1hdGgucG93KE1hdGgucG93KHhfbSAtIHhfaSwgMikgKyBNYXRoLnBvdyh5X20gLSB5X2ksIDIpLCAxLjUpO1xuICAgICAgICAgIGQyRV9keDIgKz0ga21hdCAqICgxIC0gbG1hdCAqIE1hdGgucG93KHlfbSAtIHlfaSwgMikgKiBkZW5vbWluYXRvcik7XG4gICAgICAgICAgZDJFX2R4ZHkgKz0ga21hdCAqIChsbWF0ICogKHhfbSAtIHhfaSkgKiAoeV9tIC0geV9pKSAqIGRlbm9taW5hdG9yKTtcbiAgICAgICAgICBkMkVfZHkyICs9IGttYXQgKiAoMSAtIGxtYXQgKiBNYXRoLnBvdyh4X20gLSB4X2ksIDIpICogZGVub21pbmF0b3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBtYWtlIHRoZSB2YXJpYWJsZSBuYW1lcyBlYXNpZXIgdG8gbWFrZSB0aGUgc29sdmluZyBvZiB0aGUgbGluZWFyIHN5c3RlbSBlYXNpZXIgdG8gcmVhZFxuICAgICAgdmFyIEEgPSBkMkVfZHgyLFxuICAgICAgICBCID0gZDJFX2R4ZHksXG4gICAgICAgIEMgPSBkRV9keCxcbiAgICAgICAgRCA9IGQyRV9keTIsXG4gICAgICAgIEUgPSBkRV9keTtcblxuICAgICAgLy8gc29sdmUgdGhlIGxpbmVhciBzeXN0ZW0gZm9yIGR4IGFuZCBkeVxuICAgICAgdmFyIGR5ID0gKEMgLyBBICsgRSAvIEIpIC8gKEIgLyBBIC0gRCAvIEIpO1xuICAgICAgdmFyIGR4ID0gLShCICogZHkgKyBDKSAvIEE7XG5cbiAgICAgIC8vIG1vdmUgdGhlIG5vZGVcbiAgICAgIG5vZGVzW21dLnggKz0gZHg7XG4gICAgICBub2Rlc1ttXS55ICs9IGR5O1xuXG4gICAgICAvLyBSZWNhbGN1bGF0ZSBFX21hdHJpeCAoc2hvdWxkIGJlIGluY3JlbWVudGFsKVxuICAgICAgdGhpcy5fdXBkYXRlRV9tYXRyaXgobSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBMIG1hdHJpeDogZWRnZSBsZW5ndGggdGltZXMgc2hvcnRlc3QgcGF0aFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IERfbWF0cml4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlTF9tYXRyaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUxfbWF0cml4KERfbWF0cml4KSB7XG4gICAgICB2YXIgbm9kZXNBcnJheSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgIHZhciBlZGdlTGVuZ3RoID0gdGhpcy5zcHJpbmdMZW5ndGg7XG4gICAgICB0aGlzLkxfbWF0cml4ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5MX21hdHJpeFtub2Rlc0FycmF5W2ldXSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB0aGlzLkxfbWF0cml4W25vZGVzQXJyYXlbaV1dW25vZGVzQXJyYXlbal1dID0gZWRnZUxlbmd0aCAqIERfbWF0cml4W25vZGVzQXJyYXlbaV1dW25vZGVzQXJyYXlbal1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBLIG1hdHJpeDogc3ByaW5nIGNvbnN0YW50cyB0aW1lcyBzaG9ydGVzdCBwYXRoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gRF9tYXRyaXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVLX21hdHJpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlS19tYXRyaXgoRF9tYXRyaXgpIHtcbiAgICAgIHZhciBub2Rlc0FycmF5ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgdmFyIGVkZ2VTdHJlbmd0aCA9IHRoaXMuc3ByaW5nQ29uc3RhbnQ7XG4gICAgICB0aGlzLktfbWF0cml4ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5LX21hdHJpeFtub2Rlc0FycmF5W2ldXSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB0aGlzLktfbWF0cml4W25vZGVzQXJyYXlbaV1dW25vZGVzQXJyYXlbal1dID0gZWRnZVN0cmVuZ3RoICogTWF0aC5wb3coRF9tYXRyaXhbbm9kZXNBcnJheVtpXV1bbm9kZXNBcnJheVtqXV0sIC0yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgbWF0cml4IHdpdGggYWxsIGVuZXJnaWVzIGJldHdlZW4gbm9kZXNcbiAgICAgKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVFX21hdHJpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlRV9tYXRyaXgoKSB7XG4gICAgICB2YXIgbm9kZXNBcnJheSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHRoaXMuRV9tYXRyaXggPSB7fTtcbiAgICAgIHRoaXMuRV9zdW1zID0ge307XG4gICAgICBmb3IgKHZhciBtSWR4ID0gMDsgbUlkeCA8IG5vZGVzQXJyYXkubGVuZ3RoOyBtSWR4KyspIHtcbiAgICAgICAgdGhpcy5FX21hdHJpeFtub2Rlc0FycmF5W21JZHhdXSA9IFtdO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX21JZHggPSAwOyBfbUlkeCA8IG5vZGVzQXJyYXkubGVuZ3RoOyBfbUlkeCsrKSB7XG4gICAgICAgIHZhciBtID0gbm9kZXNBcnJheVtfbUlkeF07XG4gICAgICAgIHZhciB4X20gPSBub2Rlc1ttXS54O1xuICAgICAgICB2YXIgeV9tID0gbm9kZXNbbV0ueTtcbiAgICAgICAgdmFyIGRFX2R4ID0gMDtcbiAgICAgICAgdmFyIGRFX2R5ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaUlkeCA9IF9tSWR4OyBpSWR4IDwgbm9kZXNBcnJheS5sZW5ndGg7IGlJZHgrKykge1xuICAgICAgICAgIHZhciBpID0gbm9kZXNBcnJheVtpSWR4XTtcbiAgICAgICAgICBpZiAoaSAhPT0gbSkge1xuICAgICAgICAgICAgdmFyIHhfaSA9IG5vZGVzW2ldLng7XG4gICAgICAgICAgICB2YXIgeV9pID0gbm9kZXNbaV0ueTtcbiAgICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IDEuMCAvIE1hdGguc3FydChNYXRoLnBvdyh4X20gLSB4X2ksIDIpICsgTWF0aC5wb3coeV9tIC0geV9pLCAyKSk7XG4gICAgICAgICAgICB0aGlzLkVfbWF0cml4W21dW2lJZHhdID0gW3RoaXMuS19tYXRyaXhbbV1baV0gKiAoeF9tIC0geF9pIC0gdGhpcy5MX21hdHJpeFttXVtpXSAqICh4X20gLSB4X2kpICogZGVub21pbmF0b3IpLCB0aGlzLktfbWF0cml4W21dW2ldICogKHlfbSAtIHlfaSAtIHRoaXMuTF9tYXRyaXhbbV1baV0gKiAoeV9tIC0geV9pKSAqIGRlbm9taW5hdG9yKV07XG4gICAgICAgICAgICB0aGlzLkVfbWF0cml4W2ldW19tSWR4XSA9IHRoaXMuRV9tYXRyaXhbbV1baUlkeF07XG4gICAgICAgICAgICBkRV9keCArPSB0aGlzLkVfbWF0cml4W21dW2lJZHhdWzBdO1xuICAgICAgICAgICAgZEVfZHkgKz0gdGhpcy5FX21hdHJpeFttXVtpSWR4XVsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9TdG9yZSBzdW1cbiAgICAgICAgdGhpcy5FX3N1bXNbbV0gPSBbZEVfZHgsIGRFX2R5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgbWV0aG9kLCBqdXN0IGRvaW5nIHNpbmdsZSBjb2x1bW4gKHJvd3MgYXJlIGF1dG8tdXBkYXRlZCkgKHVwZGF0ZSBhbGwgc3VtcylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlRV9tYXRyaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUVfbWF0cml4KG0pIHtcbiAgICAgIHZhciBub2Rlc0FycmF5ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIGNvbG0gPSB0aGlzLkVfbWF0cml4W21dO1xuICAgICAgdmFyIGtjb2xtID0gdGhpcy5LX21hdHJpeFttXTtcbiAgICAgIHZhciBsY29sbSA9IHRoaXMuTF9tYXRyaXhbbV07XG4gICAgICB2YXIgeF9tID0gbm9kZXNbbV0ueDtcbiAgICAgIHZhciB5X20gPSBub2Rlc1ttXS55O1xuICAgICAgdmFyIGRFX2R4ID0gMDtcbiAgICAgIHZhciBkRV9keSA9IDA7XG4gICAgICBmb3IgKHZhciBpSWR4ID0gMDsgaUlkeCA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpSWR4KyspIHtcbiAgICAgICAgdmFyIGkgPSBub2Rlc0FycmF5W2lJZHhdO1xuICAgICAgICBpZiAoaSAhPT0gbSkge1xuICAgICAgICAgIC8vS2VlcCBvbGQgZW5lcmd5IHZhbHVlIGZvciBzdW0gbW9kaWZpY2F0aW9uIGJlbG93XG4gICAgICAgICAgdmFyIGNlbGwgPSBjb2xtW2lJZHhdO1xuICAgICAgICAgIHZhciBvbGREeCA9IGNlbGxbMF07XG4gICAgICAgICAgdmFyIG9sZER5ID0gY2VsbFsxXTtcblxuICAgICAgICAgIC8vQ2FsYyBuZXcgZW5lcmd5OlxuICAgICAgICAgIHZhciB4X2kgPSBub2Rlc1tpXS54O1xuICAgICAgICAgIHZhciB5X2kgPSBub2Rlc1tpXS55O1xuICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IDEuMCAvIE1hdGguc3FydChNYXRoLnBvdyh4X20gLSB4X2ksIDIpICsgTWF0aC5wb3coeV9tIC0geV9pLCAyKSk7XG4gICAgICAgICAgdmFyIGR4ID0ga2NvbG1baV0gKiAoeF9tIC0geF9pIC0gbGNvbG1baV0gKiAoeF9tIC0geF9pKSAqIGRlbm9taW5hdG9yKTtcbiAgICAgICAgICB2YXIgZHkgPSBrY29sbVtpXSAqICh5X20gLSB5X2kgLSBsY29sbVtpXSAqICh5X20gLSB5X2kpICogZGVub21pbmF0b3IpO1xuICAgICAgICAgIGNvbG1baUlkeF0gPSBbZHgsIGR5XTtcbiAgICAgICAgICBkRV9keCArPSBkeDtcbiAgICAgICAgICBkRV9keSArPSBkeTtcblxuICAgICAgICAgIC8vYWRkIG5ldyBlbmVyZ3kgdG8gc3VtIG9mIGVhY2ggY29sdW1uXG4gICAgICAgICAgdmFyIHN1bSA9IHRoaXMuRV9zdW1zW2ldO1xuICAgICAgICAgIHN1bVswXSArPSBkeCAtIG9sZER4O1xuICAgICAgICAgIHN1bVsxXSArPSBkeSAtIG9sZER5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL1N0b3JlIHN1bSBhdCAtMSBpbmRleFxuICAgICAgdGhpcy5FX3N1bXNbbV0gPSBbZEVfZHgsIGRFX2R5XTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthbWFkYUthd2FpO1xufSgpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldHdvcmsgdmlzdWFsaXphdGlvbiwgZGlzcGxheWluZyBub2RlcyBhbmQgZWRnZXMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgICBUaGUgRE9NIGVsZW1lbnQgaW4gd2hpY2ggdGhlIE5ldHdvcmsgd2lsbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgY3JlYXRlZC4gTm9ybWFsbHkgYSBkaXYgZWxlbWVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhICAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QXJyYXl9IG5vZGVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheX0gZWRnZXNcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICAgICAgT3B0aW9uc1xuICogQGNsYXNzIE5ldHdvcmtcbiAqL1xuZnVuY3Rpb24gTmV0d29yayhjb250YWluZXIsIGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIF9jb250ZXh0LFxuICAgIF9jb250ZXh0MixcbiAgICBfY29udGV4dDMsXG4gICAgX2NvbnRleHQ0LFxuICAgIF90aGlzID0gdGhpcztcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5ldHdvcmspKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yXCIpO1xuICB9XG5cbiAgLy8gc2V0IGNvbnN0YW50IHZhbHVlc1xuICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBsb2NhbGU6IFwiZW5cIixcbiAgICBsb2NhbGVzOiBsb2NhbGVzLFxuICAgIGNsaWNrVG9Vc2U6IGZhbHNlXG4gIH07XG4gIF9PYmplY3QkYXNzaWduKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgLyoqXG4gICAqIENvbnRhaW5lcnMgZm9yIG5vZGVzIGFuZCBlZGdlcy5cbiAgICpcbiAgICogJ2VkZ2VzJyBhbmQgJ25vZGVzJyBjb250YWluIHRoZSBmdWxsIGRlZmluaXRpb25zIG9mIGFsbCB0aGUgbmV0d29yayBlbGVtZW50cy5cbiAgICogJ25vZGVJbmRpY2VzJyBhbmQgJ2VkZ2VJbmRpY2VzJyBjb250YWluIHRoZSBpZCdzIG9mIHRoZSBhY3RpdmUgZWxlbWVudHMuXG4gICAqXG4gICAqIFRoZSBkaXN0aW5jdGlvbiBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgYSBkZWZpbmVkIG5vZGUgbmVlZCBub3QgYmUgYWN0aXZlLCBpLmUuXG4gICAqIHZpc2libGUgb24gdGhlIGNhbnZhcy4gVGhpcyBoYXBwZW5zIGluIHBhcnRpY3VsYXIgd2hlbiBjbHVzdGVycyBhcmUgZGVmaW5lZCwgaW5cbiAgICogdGhhdCBjYXNlIHRoZXJlIHdpbGwgYmUgbm9kZXMgYW5kIGVkZ2VzIG5vdCBkaXNwbGF5ZWQuXG4gICAqIFRoZSBib3R0b20gbGluZSBpcyB0aGF0IGFsbCBjb2RlIHdpdGggYWN0aW9ucyByZWxhdGVkIHRvIHZpc2liaWxpdHksICptdXN0KiB1c2VcbiAgICogJ25vZGVJbmRpY2VzJyBhbmQgJ2VkZ2VJbmRpY2VzJywgbm90ICdub2RlcycgYW5kICdlZGdlcycgZGlyZWN0bHkuXG4gICAqL1xuICB0aGlzLmJvZHkgPSB7XG4gICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgLy8gU2VlIGNvbW1lbnQgYWJvdmUgZm9yIGZvbGxvd2luZyBmaWVsZHNcbiAgICBub2Rlczoge30sXG4gICAgbm9kZUluZGljZXM6IFtdLFxuICAgIGVkZ2VzOiB7fSxcbiAgICBlZGdlSW5kaWNlczogW10sXG4gICAgZW1pdHRlcjoge1xuICAgICAgb246IF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0ID0gdGhpcy5vbikuY2FsbChfY29udGV4dCwgdGhpcyksXG4gICAgICBvZmY6IF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MiA9IHRoaXMub2ZmKS5jYWxsKF9jb250ZXh0MiwgdGhpcyksXG4gICAgICBlbWl0OiBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDMgPSB0aGlzLmVtaXQpLmNhbGwoX2NvbnRleHQzLCB0aGlzKSxcbiAgICAgIG9uY2U6IF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0NCA9IHRoaXMub25jZSkuY2FsbChfY29udGV4dDQsIHRoaXMpXG4gICAgfSxcbiAgICBldmVudExpc3RlbmVyczoge1xuICAgICAgb25UYXA6IGZ1bmN0aW9uIG9uVGFwKCkge30sXG4gICAgICBvblRvdWNoOiBmdW5jdGlvbiBvblRvdWNoKCkge30sXG4gICAgICBvbkRvdWJsZVRhcDogZnVuY3Rpb24gb25Eb3VibGVUYXAoKSB7fSxcbiAgICAgIG9uSG9sZDogZnVuY3Rpb24gb25Ib2xkKCkge30sXG4gICAgICBvbkRyYWdTdGFydDogZnVuY3Rpb24gb25EcmFnU3RhcnQoKSB7fSxcbiAgICAgIG9uRHJhZzogZnVuY3Rpb24gb25EcmFnKCkge30sXG4gICAgICBvbkRyYWdFbmQ6IGZ1bmN0aW9uIG9uRHJhZ0VuZCgpIHt9LFxuICAgICAgb25Nb3VzZVdoZWVsOiBmdW5jdGlvbiBvbk1vdXNlV2hlZWwoKSB7fSxcbiAgICAgIG9uUGluY2g6IGZ1bmN0aW9uIG9uUGluY2goKSB7fSxcbiAgICAgIG9uTW91c2VNb3ZlOiBmdW5jdGlvbiBvbk1vdXNlTW92ZSgpIHt9LFxuICAgICAgb25SZWxlYXNlOiBmdW5jdGlvbiBvblJlbGVhc2UoKSB7fSxcbiAgICAgIG9uQ29udGV4dDogZnVuY3Rpb24gb25Db250ZXh0KCkge31cbiAgICB9LFxuICAgIGRhdGE6IHtcbiAgICAgIG5vZGVzOiBudWxsLFxuICAgICAgLy8gQSBEYXRhU2V0IG9yIERhdGFWaWV3XG4gICAgICBlZGdlczogbnVsbCAvLyBBIERhdGFTZXQgb3IgRGF0YVZpZXdcbiAgICB9LFxuXG4gICAgZnVuY3Rpb25zOiB7XG4gICAgICBjcmVhdGVOb2RlOiBmdW5jdGlvbiBjcmVhdGVOb2RlKCkge30sXG4gICAgICBjcmVhdGVFZGdlOiBmdW5jdGlvbiBjcmVhdGVFZGdlKCkge30sXG4gICAgICBnZXRQb2ludGVyOiBmdW5jdGlvbiBnZXRQb2ludGVyKCkge31cbiAgICB9LFxuICAgIG1vZHVsZXM6IHt9LFxuICAgIHZpZXc6IHtcbiAgICAgIHNjYWxlOiAxLFxuICAgICAgdHJhbnNsYXRpb246IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfVxuICAgIH0sXG4gICAgc2VsZWN0aW9uQm94OiB7XG4gICAgICBzaG93OiBmYWxzZSxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0sXG4gICAgICAgIGVuZDoge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIGJpbmQgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuXG4gIC8vIHNldHRpbmcgdXAgYWxsIG1vZHVsZXNcbiAgdGhpcy5pbWFnZXMgPSBuZXcgSW1hZ2VzKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgfSk7IC8vIG9iamVjdCB3aXRoIGltYWdlc1xuICB0aGlzLmdyb3VwcyA9IG5ldyBHcm91cHMoKTsgLy8gb2JqZWN0IHdpdGggZ3JvdXBzXG4gIHRoaXMuY2FudmFzID0gbmV3IENhbnZhcyh0aGlzLmJvZHkpOyAvLyBET00gaGFuZGxlclxuICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIgPSBuZXcgU2VsZWN0aW9uSGFuZGxlcih0aGlzLmJvZHksIHRoaXMuY2FudmFzKTsgLy8gU2VsZWN0aW9uIGhhbmRsZXJcbiAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIgPSBuZXcgSW50ZXJhY3Rpb25IYW5kbGVyKHRoaXMuYm9keSwgdGhpcy5jYW52YXMsIHRoaXMuc2VsZWN0aW9uSGFuZGxlcik7IC8vIEludGVyYWN0aW9uIGhhbmRsZXIgaGFuZGxlcyBhbGwgdGhlIGhhbW1lciBiaW5kaW5ncyAodGhhdCBhcmUgYm91bmQgYnkgY2FudmFzKSwga2V5XG4gIHRoaXMudmlldyA9IG5ldyBWaWV3KHRoaXMuYm9keSwgdGhpcy5jYW52YXMpOyAvLyBjYW1lcmEgaGFuZGxlciwgZG9lcyBhbmltYXRpb25zIGFuZCB6b29tc1xuICB0aGlzLnJlbmRlcmVyID0gbmV3IENhbnZhc1JlbmRlcmVyKHRoaXMuYm9keSwgdGhpcy5jYW52YXMpOyAvLyByZW5kZXJlciwgc3RhcnRzIHJlbmRlcmxvb3AsIGhhcyBldmVudHMgdGhhdCBtb2R1bGVzIGNhbiBob29rIGludG9cbiAgdGhpcy5waHlzaWNzID0gbmV3IFBoeXNpY3NFbmdpbmUodGhpcy5ib2R5KTsgLy8gcGh5c2ljcyBlbmdpbmUsIGRvZXMgYWxsIHRoZSBzaW11bGF0aW9uc1xuICB0aGlzLmxheW91dEVuZ2luZSA9IG5ldyBMYXlvdXRFbmdpbmUodGhpcy5ib2R5KTsgLy8gbGF5b3V0IGVuZ2luZSBmb3IgaW5pdGFsIGxheW91dCBhbmQgaGllcmFyY2hpY2FsIGxheW91dFxuICB0aGlzLmNsdXN0ZXJpbmcgPSBuZXcgQ2x1c3RlckVuZ2luZSh0aGlzLmJvZHkpOyAvLyBjbHVzdGVyaW5nIGFwaVxuICB0aGlzLm1hbmlwdWxhdGlvbiA9IG5ldyBNYW5pcHVsYXRpb25TeXN0ZW0odGhpcy5ib2R5LCB0aGlzLmNhbnZhcywgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLCB0aGlzLmludGVyYWN0aW9uSGFuZGxlcik7IC8vIGRhdGEgbWFuaXB1bGF0aW9uIHN5c3RlbVxuXG4gIHRoaXMubm9kZXNIYW5kbGVyID0gbmV3IE5vZGVzSGFuZGxlcih0aGlzLmJvZHksIHRoaXMuaW1hZ2VzLCB0aGlzLmdyb3VwcywgdGhpcy5sYXlvdXRFbmdpbmUpOyAvLyBIYW5kbGUgYWRkaW5nLCBkZWxldGluZyBhbmQgdXBkYXRpbmcgb2Ygbm9kZXMgYXMgd2VsbCBhcyBnbG9iYWwgb3B0aW9uc1xuICB0aGlzLmVkZ2VzSGFuZGxlciA9IG5ldyBFZGdlc0hhbmRsZXIodGhpcy5ib2R5LCB0aGlzLmltYWdlcywgdGhpcy5ncm91cHMpOyAvLyBIYW5kbGUgYWRkaW5nLCBkZWxldGluZyBhbmQgdXBkYXRpbmcgb2YgZWRnZXMgYXMgd2VsbCBhcyBnbG9iYWwgb3B0aW9uc1xuXG4gIHRoaXMuYm9keS5tb2R1bGVzW1wia2FtYWRhS2F3YWlcIl0gPSBuZXcgS2FtYWRhS2F3YWkodGhpcy5ib2R5LCAxNTAsIDAuMDUpOyAvLyBMYXlvdXRpbmcgYWxnb3JpdGhtLlxuICB0aGlzLmJvZHkubW9kdWxlc1tcImNsdXN0ZXJpbmdcIl0gPSB0aGlzLmNsdXN0ZXJpbmc7XG5cbiAgLy8gY3JlYXRlIHRoZSBET00gZWxlbWVudHNcbiAgdGhpcy5jYW52YXMuX2NyZWF0ZSgpO1xuXG4gIC8vIGFwcGx5IG9wdGlvbnNcbiAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIC8vIGxvYWQgZGF0YSAodGhlIGRpc2FibGUgc3RhcnQgdmFyaWFibGUgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgZW5hYmxlZCBjbHVzdGVyaW5nKVxuICB0aGlzLnNldERhdGEoZGF0YSk7XG59XG5cbi8vIEV4dGVuZCBOZXR3b3JrIHdpdGggYW4gRW1pdHRlciBtaXhpblxuRW1pdHRlcihOZXR3b3JrLnByb3RvdHlwZSk7XG5cbi8qKlxuICogU2V0IG9wdGlvbnNcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICovXG5OZXR3b3JrLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG4gIGlmIChvcHRpb25zID09PSBudWxsKSB7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDsgLy8gVGhpcyBlbnN1cmVzIHRoYXQgb3B0aW9ucyBoYW5kbGluZyBkb2Vzbid0IGNyYXNoIGluIHRoZSBoYW5kbGluZ1xuICB9XG5cbiAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBlcnJvckZvdW5kID0gVmFsaWRhdG9yLnZhbGlkYXRlKG9wdGlvbnMsIGFsbE9wdGlvbnMpO1xuICAgIGlmIChlcnJvckZvdW5kID09PSB0cnVlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiJWNFcnJvcnMgaGF2ZSBiZWVuIGZvdW5kIGluIHRoZSBzdXBwbGllZCBvcHRpb25zIG9iamVjdC5cIiwgVkFMSURBVE9SX1BSSU5UX1NUWUxFKTtcbiAgICB9XG5cbiAgICAvLyBjb3B5IHRoZSBnbG9iYWwgZmllbGRzIG92ZXJcbiAgICB2YXIgZmllbGRzID0gW1wibG9jYWxlXCIsIFwibG9jYWxlc1wiLCBcImNsaWNrVG9Vc2VcIl07XG4gICAgc2VsZWN0aXZlRGVlcEV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAvLyBub3JtYWxpemUgdGhlIGxvY2FsZSBvciB1c2UgRW5nbGlzaFxuICAgIGlmIChvcHRpb25zLmxvY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLmxvY2FsZSA9IG5vcm1hbGl6ZUxhbmd1YWdlQ29kZShvcHRpb25zLmxvY2FsZXMgfHwgdGhpcy5vcHRpb25zLmxvY2FsZXMsIG9wdGlvbnMubG9jYWxlKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaGllcmFyY2hpY2FsIHN5c3RlbSBjYW4gYWRhcHQgdGhlIGVkZ2VzIGFuZCB0aGUgcGh5c2ljcyB0byBpdCdzIG93biBvcHRpb25zIGJlY2F1c2Ugbm90IGFsbCBjb21iaW5hdGlvbnMgd29yayB3aXRoIHRoZSBoaWVyYXJpY2hpY2FsIHN5c3RlbS5cbiAgICBvcHRpb25zID0gdGhpcy5sYXlvdXRFbmdpbmUuc2V0T3B0aW9ucyhvcHRpb25zLmxheW91dCwgb3B0aW9ucyk7XG4gICAgdGhpcy5jYW52YXMuc2V0T3B0aW9ucyhvcHRpb25zKTsgLy8gb3B0aW9ucyBmb3IgY2FudmFzIGFyZSBpbiBnbG9iYWxzXG5cbiAgICAvLyBwYXNzIHRoZSBvcHRpb25zIHRvIHRoZSBtb2R1bGVzXG4gICAgdGhpcy5ncm91cHMuc2V0T3B0aW9ucyhvcHRpb25zLmdyb3Vwcyk7XG4gICAgdGhpcy5ub2Rlc0hhbmRsZXIuc2V0T3B0aW9ucyhvcHRpb25zLm5vZGVzKTtcbiAgICB0aGlzLmVkZ2VzSGFuZGxlci5zZXRPcHRpb25zKG9wdGlvbnMuZWRnZXMpO1xuICAgIHRoaXMucGh5c2ljcy5zZXRPcHRpb25zKG9wdGlvbnMucGh5c2ljcyk7XG4gICAgdGhpcy5tYW5pcHVsYXRpb24uc2V0T3B0aW9ucyhvcHRpb25zLm1hbmlwdWxhdGlvbiwgb3B0aW9ucywgdGhpcy5vcHRpb25zKTsgLy8gbWFuaXB1bGF0aW9uIHVzZXMgdGhlIGxvY2FsZXMgaW4gdGhlIGdsb2JhbHNcblxuICAgIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyLnNldE9wdGlvbnMob3B0aW9ucy5pbnRlcmFjdGlvbik7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRPcHRpb25zKG9wdGlvbnMuaW50ZXJhY3Rpb24pOyAvLyBvcHRpb25zIGZvciByZW5kZXJpbmcgYXJlIGluIGludGVyYWN0aW9uXG4gICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNldE9wdGlvbnMob3B0aW9ucy5pbnRlcmFjdGlvbik7IC8vIG9wdGlvbnMgZm9yIHNlbGVjdGlvbiBhcmUgaW4gaW50ZXJhY3Rpb25cblxuICAgIC8vIHJlbG9hZCB0aGUgc2V0dGluZ3Mgb2YgdGhlIG5vZGVzIHRvIGFwcGx5IGNoYW5nZXMgaW4gZ3JvdXBzIHRoYXQgYXJlIG5vdCByZWZlcmVuY2VkIGJ5IHBvaW50ZXIuXG4gICAgaWYgKG9wdGlvbnMuZ3JvdXBzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJyZWZyZXNoTm9kZXNcIik7XG4gICAgfVxuICAgIC8vIHRoZXNlIHR3byBkbyBub3QgaGF2ZSBvcHRpb25zIGF0IHRoZSBtb21lbnQsIGhlcmUgZm9yIGNvbXBsZXRlbmVzc1xuICAgIC8vdGhpcy52aWV3LnNldE9wdGlvbnMob3B0aW9ucy52aWV3KTtcbiAgICAvL3RoaXMuY2x1c3RlcmluZy5zZXRPcHRpb25zKG9wdGlvbnMuY2x1c3RlcmluZyk7XG5cbiAgICBpZiAoXCJjb25maWd1cmVcIiBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoIXRoaXMuY29uZmlndXJhdG9yKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdG9yID0gbmV3IENvbmZpZ3VyYXRvcih0aGlzLCB0aGlzLmJvZHkuY29udGFpbmVyLCBjb25maWd1cmVPcHRpb25zLCB0aGlzLmNhbnZhcy5waXhlbFJhdGlvLCBjb25maWd1cmF0b3JIaWRlT3B0aW9uKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29uZmlndXJhdG9yLnNldE9wdGlvbnMob3B0aW9ucy5jb25maWd1cmUpO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSBjb25maWd1cmF0aW9uIHN5c3RlbSBpcyBlbmFibGVkLCBjb3B5IGFsbCBvcHRpb25zIGFuZCBwdXQgdGhlbSBpbnRvIHRoZSBjb25maWcgc3lzdGVtXG4gICAgaWYgKHRoaXMuY29uZmlndXJhdG9yICYmIHRoaXMuY29uZmlndXJhdG9yLm9wdGlvbnMuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIG5ldHdvcmtPcHRpb25zID0ge1xuICAgICAgICBub2Rlczoge30sXG4gICAgICAgIGVkZ2VzOiB7fSxcbiAgICAgICAgbGF5b3V0OiB7fSxcbiAgICAgICAgaW50ZXJhY3Rpb246IHt9LFxuICAgICAgICBtYW5pcHVsYXRpb246IHt9LFxuICAgICAgICBwaHlzaWNzOiB7fSxcbiAgICAgICAgZ2xvYmFsOiB7fVxuICAgICAgfTtcbiAgICAgIGRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMubm9kZXMsIHRoaXMubm9kZXNIYW5kbGVyLm9wdGlvbnMpO1xuICAgICAgZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5lZGdlcywgdGhpcy5lZGdlc0hhbmRsZXIub3B0aW9ucyk7XG4gICAgICBkZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLmxheW91dCwgdGhpcy5sYXlvdXRFbmdpbmUub3B0aW9ucyk7XG4gICAgICAvLyBsb2FkIHRoZSBzZWxlY3Rpb25IYW5kbGVyIGFuZCByZW5kZXIgZGVmYXVsdCBvcHRpb25zIGluIHRvIHRoZSBpbnRlcmFjdGlvbiBncm91cFxuICAgICAgZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5pbnRlcmFjdGlvbiwgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLm9wdGlvbnMpO1xuICAgICAgZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5pbnRlcmFjdGlvbiwgdGhpcy5yZW5kZXJlci5vcHRpb25zKTtcbiAgICAgIGRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMuaW50ZXJhY3Rpb24sIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyLm9wdGlvbnMpO1xuICAgICAgZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5tYW5pcHVsYXRpb24sIHRoaXMubWFuaXB1bGF0aW9uLm9wdGlvbnMpO1xuICAgICAgZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5waHlzaWNzLCB0aGlzLnBoeXNpY3Mub3B0aW9ucyk7XG5cbiAgICAgIC8vIGxvYWQgZ2xvYmFscyBpbnRvIHRoZSBnbG9iYWwgb2JqZWN0XG4gICAgICBkZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLmdsb2JhbCwgdGhpcy5jYW52YXMub3B0aW9ucyk7XG4gICAgICBkZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLmdsb2JhbCwgdGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMuY29uZmlndXJhdG9yLnNldE1vZHVsZU9wdGlvbnMobmV0d29ya09wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBuZXR3b3JrIGdsb2JhbCBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMuY2xpY2tUb1VzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAob3B0aW9ucy5jbGlja1RvVXNlID09PSB0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2YXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5hY3RpdmF0b3IgPSBuZXcgQWN0aXZhdG9yKHRoaXMuY2FudmFzLmZyYW1lKTtcbiAgICAgICAgICB0aGlzLmFjdGl2YXRvci5vbihcImNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczIuYm9keS5lbWl0dGVyLmVtaXQoXCJhY3RpdmF0ZVwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZhdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmFjdGl2YXRvci5kZXN0cm95KCk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuYWN0aXZhdG9yO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJhY3RpdmF0ZVwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImFjdGl2YXRlXCIpO1xuICAgIH1cbiAgICB0aGlzLmNhbnZhcy5zZXRTaXplKCk7XG4gICAgLy8gc3RhcnQgdGhlIHBoeXNpY3Mgc2ltdWxhdGlvbi4gQ2FuIGJlIHNhZmVseSBjYWxsZWQgbXVsdGlwbGUgdGltZXMuXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKTtcbiAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIHZpc2libGUgbm9kZXMgYW5kIGVkZ2VzIGxpc3Qgd2l0aCB0aGUgbW9zdCByZWNlbnQgbm9kZSBzdGF0ZS5cbiAqXG4gKiBWaXNpYmxlIG5vZGVzIGFyZSBzdG9yZWQgaW4gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLlxuICogVmlzaWJsZSBlZGdlcyBhcmUgc3RvcmVkIGluIHRoaXMuYm9keS5lZGdlSW5kaWNlcy5cbiAqIEEgbm9kZSBvciBlZGdlcyBpcyB2aXNpYmxlIGlmIGl0IGlzIG5vdCBoaWRkZW4gb3IgY2x1c3RlcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbk5ldHdvcmsucHJvdG90eXBlLl91cGRhdGVWaXNpYmxlSW5kaWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gIHRoaXMuYm9keS5ub2RlSW5kaWNlcyA9IFtdO1xuICB0aGlzLmJvZHkuZWRnZUluZGljZXMgPSBbXTtcbiAgZm9yICh2YXIgbm9kZUlkIGluIG5vZGVzKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2Rlcywgbm9kZUlkKSkge1xuICAgICAgaWYgKCF0aGlzLmNsdXN0ZXJpbmcuX2lzQ2x1c3RlcmVkTm9kZShub2RlSWQpICYmIG5vZGVzW25vZGVJZF0ub3B0aW9ucy5oaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5wdXNoKG5vZGVzW25vZGVJZF0uaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKHZhciBlZGdlSWQgaW4gZWRnZXMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVkZ2VzLCBlZGdlSWQpKSB7XG4gICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VkZ2VJZF07XG5cbiAgICAgIC8vIEl0IGNhbiBoYXBwZW4gdGhhdCB0aGlzIGlzIGV4ZWN1dGVkICphZnRlciogYSBub2RlIGVkZ2UgaGFzIGJlZW4gcmVtb3ZlZCxcbiAgICAgIC8vIGJ1dCAqYmVmb3JlKiB0aGUgZWRnZSBpdHNlbGYgaGFzIGJlZW4gcmVtb3ZlZC4gVGFraW5nIHRoaXMgaW50byBhY2NvdW50LlxuICAgICAgdmFyIGZyb21Ob2RlID0gbm9kZXNbZWRnZS5mcm9tSWRdO1xuICAgICAgdmFyIHRvTm9kZSA9IG5vZGVzW2VkZ2UudG9JZF07XG4gICAgICB2YXIgZWRnZU5vZGVzUHJlc2VudCA9IGZyb21Ob2RlICE9PSB1bmRlZmluZWQgJiYgdG9Ob2RlICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgaXNWaXNpYmxlID0gIXRoaXMuY2x1c3RlcmluZy5faXNDbHVzdGVyZWRFZGdlKGVkZ2VJZCkgJiYgZWRnZS5vcHRpb25zLmhpZGRlbiA9PT0gZmFsc2UgJiYgZWRnZU5vZGVzUHJlc2VudCAmJiBmcm9tTm9kZS5vcHRpb25zLmhpZGRlbiA9PT0gZmFsc2UgJiZcbiAgICAgIC8vIEFsc28gaGlkZGVuIGlmIGFueSBvZiBpdHMgY29ubmVjdGluZyBub2RlcyBhcmUgaGlkZGVuXG4gICAgICB0b05vZGUub3B0aW9ucy5oaWRkZW4gPT09IGZhbHNlOyAvLyBpZGVtXG5cbiAgICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLnB1c2goZWRnZS5pZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEJpbmQgYWxsIGV2ZW50c1xuICovXG5OZXR3b3JrLnByb3RvdHlwZS5iaW5kRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdGhpczMgPSB0aGlzO1xuICAvLyBUaGlzIGV2ZW50IHdpbGwgdHJpZ2dlciBhIHJlYnVpbGRpbmcgb2YgdGhlIGNhY2hlIGV2ZXJ5dGhpbmcuXG4gIC8vIFVzZWQgd2hlbiBub2RlcyBvciBlZGdlcyBoYXZlIGJlZW4gYWRkZWQgb3IgcmVtb3ZlZC5cbiAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZGF0YUNoYW5nZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgIF90aGlzMy5lZGdlc0hhbmRsZXIuX3VwZGF0ZVN0YXRlKCk7XG4gICAgX3RoaXMzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFVcGRhdGVkXCIpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIGNhbGxlZCB3aGVuIG9wdGlvbnMgb2YgRVhJU1RJTkcgbm9kZXMgb3IgZWRnZXMgaGF2ZSBjaGFuZ2VkLlxuICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhVXBkYXRlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgLy8gT3JkZXIgaW1wb3J0YW50IGluIGZvbGxvd2luZyBibG9ja1xuICAgIF90aGlzMy5jbHVzdGVyaW5nLl91cGRhdGVTdGF0ZSgpO1xuICAgIF90aGlzMy5fdXBkYXRlVmlzaWJsZUluZGljZXMoKTtcbiAgICBfdGhpczMuX3VwZGF0ZVZhbHVlUmFuZ2UoX3RoaXMzLmJvZHkubm9kZXMpO1xuICAgIF90aGlzMy5fdXBkYXRlVmFsdWVSYW5nZShfdGhpczMuYm9keS5lZGdlcyk7XG4gICAgLy8gc3RhcnQgc2ltdWxhdGlvbiAoY2FuIGJlIGNhbGxlZCBzYWZlbHksIGV2ZW4gaWYgYWxyZWFkeSBydW5uaW5nKVxuICAgIF90aGlzMy5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKTtcbiAgICBfdGhpczMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFNldCBub2RlcyBhbmQgZWRnZXMsIGFuZCBvcHRpb25hbGx5IG9wdGlvbnMgYXMgd2VsbC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGF0YSAgICAgICAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QXJyYXkgfCBEYXRhU2V0IHwgRGF0YVZpZXd9IFtub2Rlc10gQXJyYXkgd2l0aCBub2Rlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheSB8IERhdGFTZXQgfCBEYXRhVmlld30gW2VkZ2VzXSBBcnJheSB3aXRoIGVkZ2VzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gW2RvdF0gU3RyaW5nIGNvbnRhaW5pbmcgZGF0YSBpbiBET1QgZm9ybWF0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gW2dlcGhpXSBTdHJpbmcgY29udGFpbmluZyBkYXRhIGluIGdlcGhpIEpTT04gZm9ybWF0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09wdGlvbnN9IFtvcHRpb25zXSBPYmplY3Qgd2l0aCBvcHRpb25zXG4gKi9cbk5ldHdvcmsucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAvLyByZXNldCB0aGUgcGh5c2ljcyBlbmdpbmUuXG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJyZXNldFBoeXNpY3NcIik7XG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVzZXREYXRhXCIpO1xuXG4gIC8vIHVuc2VsZWN0IGFsbCB0byBlbnN1cmUgbm8gc2VsZWN0aW9ucyBmcm9tIG9sZCBkYXRhIGFyZSBjYXJyaWVkIG92ZXIuXG4gIHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuICBpZiAoZGF0YSAmJiBkYXRhLmRvdCAmJiAoZGF0YS5ub2RlcyB8fCBkYXRhLmVkZ2VzKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignRGF0YSBtdXN0IGNvbnRhaW4gZWl0aGVyIHBhcmFtZXRlciBcImRvdFwiIG9yICcgKyAnIHBhcmFtZXRlciBwYWlyIFwibm9kZXNcIiBhbmQgXCJlZGdlc1wiLCBidXQgbm90IGJvdGguJyk7XG4gIH1cblxuICAvLyBzZXQgb3B0aW9uc1xuICB0aGlzLnNldE9wdGlvbnMoZGF0YSAmJiBkYXRhLm9wdGlvbnMpO1xuICAvLyBzZXQgYWxsIGRhdGFcbiAgaWYgKGRhdGEgJiYgZGF0YS5kb3QpIHtcbiAgICBjb25zb2xlLndhcm4oXCJUaGUgZG90IHByb3BlcnR5IGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdGhlIHN0YXRpYyBjb252ZXJ0RG90IG1ldGhvZCB0byBjb252ZXJ0IERPVCBpbnRvIHZpcy5uZXR3b3JrIGZvcm1hdCBhbmQgdXNlIHRoZSBub3JtYWwgZGF0YSBmb3JtYXQgd2l0aCBub2RlcyBhbmQgZWRnZXMuIFRoaXMgY29udmVydGVyIGlzIHVzZWQgbGlrZSB0aGlzOiB2YXIgZGF0YSA9IHZpcy5uZXR3b3JrLmNvbnZlcnREb3QoZG90U3RyaW5nKTtcIik7XG4gICAgLy8gcGFyc2UgRE9UIGZpbGVcbiAgICB2YXIgZG90RGF0YSA9IERPVFRvR3JhcGgoZGF0YS5kb3QpO1xuICAgIHRoaXMuc2V0RGF0YShkb3REYXRhKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoZGF0YSAmJiBkYXRhLmdlcGhpKSB7XG4gICAgLy8gcGFyc2UgRE9UIGZpbGVcbiAgICBjb25zb2xlLndhcm4oXCJUaGUgZ2VwaGkgcHJvcGVydHkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0aGUgc3RhdGljIGNvbnZlcnRHZXBoaSBtZXRob2QgdG8gY29udmVydCBnZXBoaSBpbnRvIHZpcy5uZXR3b3JrIGZvcm1hdCBhbmQgdXNlIHRoZSBub3JtYWwgZGF0YSBmb3JtYXQgd2l0aCBub2RlcyBhbmQgZWRnZXMuIFRoaXMgY29udmVydGVyIGlzIHVzZWQgbGlrZSB0aGlzOiB2YXIgZGF0YSA9IHZpcy5uZXR3b3JrLmNvbnZlcnRHZXBoaShnZXBoaUpzb24pO1wiKTtcbiAgICB2YXIgZ2VwaGlEYXRhID0gcGFyc2VHZXBoaShkYXRhLmdlcGhpKTtcbiAgICB0aGlzLnNldERhdGEoZ2VwaGlEYXRhKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5ub2Rlc0hhbmRsZXIuc2V0RGF0YShkYXRhICYmIGRhdGEubm9kZXMsIHRydWUpO1xuICAgIHRoaXMuZWRnZXNIYW5kbGVyLnNldERhdGEoZGF0YSAmJiBkYXRhLmVkZ2VzLCB0cnVlKTtcbiAgfVxuXG4gIC8vIGVtaXQgY2hhbmdlIGluIGRhdGFcbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcblxuICAvLyBlbWl0IGRhdGEgbG9hZGVkXG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUxvYWRlZFwiKTtcblxuICAvLyBmaW5kIGEgc3RhYmxlIHBvc2l0aW9uIG9yIHN0YXJ0IGFuaW1hdGluZyB0byBhIHN0YWJsZSBwb3NpdGlvblxuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiaW5pdFBoeXNpY3NcIik7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBhbGwgYmluZGluZ3Mgb2YgdGhlIG5ldHdvcmssIHJlbW92aW5nIGl0IGZ1bGx5IGZyb20gdGhlIG1lbW9yeSBJRiB0aGUgdmFyaWFibGUgaXMgc2V0IHRvIG51bGwgYWZ0ZXIgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICogdmFyIG5ldHdvcmsgPSBuZXcgdmlzLk5ldHdvcmsoLi4pO1xuICogbmV0d29yay5kZXN0cm95KCk7XG4gKiBuZXR3b3JrID0gbnVsbDtcbiAqL1xuTmV0d29yay5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImRlc3Ryb3lcIik7XG4gIC8vIGNsZWFyIGV2ZW50c1xuICB0aGlzLmJvZHkuZW1pdHRlci5vZmYoKTtcbiAgdGhpcy5vZmYoKTtcblxuICAvLyBkZWxldGUgbW9kdWxlc1xuICBkZWxldGUgdGhpcy5ncm91cHM7XG4gIGRlbGV0ZSB0aGlzLmNhbnZhcztcbiAgZGVsZXRlIHRoaXMuc2VsZWN0aW9uSGFuZGxlcjtcbiAgZGVsZXRlIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyO1xuICBkZWxldGUgdGhpcy52aWV3O1xuICBkZWxldGUgdGhpcy5yZW5kZXJlcjtcbiAgZGVsZXRlIHRoaXMucGh5c2ljcztcbiAgZGVsZXRlIHRoaXMubGF5b3V0RW5naW5lO1xuICBkZWxldGUgdGhpcy5jbHVzdGVyaW5nO1xuICBkZWxldGUgdGhpcy5tYW5pcHVsYXRpb247XG4gIGRlbGV0ZSB0aGlzLm5vZGVzSGFuZGxlcjtcbiAgZGVsZXRlIHRoaXMuZWRnZXNIYW5kbGVyO1xuICBkZWxldGUgdGhpcy5jb25maWd1cmF0b3I7XG4gIGRlbGV0ZSB0aGlzLmltYWdlcztcbiAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5ub2Rlcywgbm9kZUlkKSkgY29udGludWU7XG4gICAgZGVsZXRlIHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICB9XG4gIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLmJvZHkuZWRnZXMpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkuZWRnZXMsIGVkZ2VJZCkpIGNvbnRpbnVlO1xuICAgIGRlbGV0ZSB0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXTtcbiAgfVxuXG4gIC8vIHJlbW92ZSB0aGUgY29udGFpbmVyIGFuZCBldmVyeXRoaW5nIGluc2lkZSBpdCByZWN1cnNpdmVseVxuICByZWN1cnNpdmVET01EZWxldGUodGhpcy5ib2R5LmNvbnRhaW5lcik7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgdmFsdWVzIG9mIGFsbCBvYmplY3QgaW4gdGhlIGdpdmVuIGFycmF5IGFjY29yZGluZyB0byB0aGUgY3VycmVudFxuICogdmFsdWUgcmFuZ2Ugb2YgdGhlIG9iamVjdHMgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmogICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXQgb2YgRWRnZXMgb3IgTm9kZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG9iamVjdHMgbXVzdCBoYXZlIGEgbWV0aG9kIGdldFZhbHVlKCkgYW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlUmFuZ2UobWluLCBtYXgpLlxuICogQHByaXZhdGVcbiAqL1xuTmV0d29yay5wcm90b3R5cGUuX3VwZGF0ZVZhbHVlUmFuZ2UgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBpZDtcblxuICAvLyBkZXRlcm1pbmUgdGhlIHJhbmdlIG9mIHRoZSBvYmplY3RzXG4gIHZhciB2YWx1ZU1pbiA9IHVuZGVmaW5lZDtcbiAgdmFyIHZhbHVlTWF4ID0gdW5kZWZpbmVkO1xuICB2YXIgdmFsdWVUb3RhbCA9IDA7XG4gIGZvciAoaWQgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGlkKSkge1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2lkXS5nZXRWYWx1ZSgpO1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWVNaW4gPSB2YWx1ZU1pbiA9PT0gdW5kZWZpbmVkID8gdmFsdWUgOiBNYXRoLm1pbih2YWx1ZSwgdmFsdWVNaW4pO1xuICAgICAgICB2YWx1ZU1heCA9IHZhbHVlTWF4ID09PSB1bmRlZmluZWQgPyB2YWx1ZSA6IE1hdGgubWF4KHZhbHVlLCB2YWx1ZU1heCk7XG4gICAgICAgIHZhbHVlVG90YWwgKz0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gYWRqdXN0IHRoZSByYW5nZSBvZiBhbGwgb2JqZWN0c1xuICBpZiAodmFsdWVNaW4gIT09IHVuZGVmaW5lZCAmJiB2YWx1ZU1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChpZCBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpZCkpIHtcbiAgICAgICAgb2JqW2lkXS5zZXRWYWx1ZVJhbmdlKHZhbHVlTWluLCB2YWx1ZU1heCwgdmFsdWVUb3RhbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBOZXR3b3JrIGlzIGFjdGl2ZS5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTmV0d29yay5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhdGhpcy5hY3RpdmF0b3IgfHwgdGhpcy5hY3RpdmF0b3IuYWN0aXZlO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNhbnZhcy5zZXRTaXplLmFwcGx5KHRoaXMuY2FudmFzLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmNhbnZhc1RvRE9NID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jYW52YXMuY2FudmFzVG9ET00uYXBwbHkodGhpcy5jYW52YXMsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuRE9NdG9DYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNhbnZhcy5ET010b0NhbnZhcy5hcHBseSh0aGlzLmNhbnZhcywgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogTm9kZXMgY2FuIGJlIGluIGNsdXN0ZXJzLiBDbHVzdGVycyBjYW4gYWxzbyBiZSBpbiBjbHVzdGVycy4gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuZCBhcnJheSBvZlxuICogbm9kZUlkcyBzaG93aW5nIHdoZXJlIHRoZSBub2RlIGlzLlxuICpcbiAqIElmIGFueSBub2RlSWQgaW4gdGhlIGNoYWluLCBlc3BlY2lhbGx5IHRoZSBmaXJzdCBwYXNzZWQgaW4gYXMgYSBwYXJhbWV0ZXIsIGlzIG5vdCBwcmVzZW50IGluXG4gKiB0aGUgY3VycmVudCBub2RlcyBsaXN0LCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZC5cbiAqXG4gKiBFeGFtcGxlOlxuICogY2x1c3RlciAnQScgY29udGFpbnMgY2x1c3RlciAnQicsXG4gKiBjbHVzdGVyICdCJyBjb250YWlucyBjbHVzdGVyICdDJyxcbiAqIGNsdXN0ZXIgJ0MnIGNvbnRhaW5zIG5vZGUgJ2ZyZWQnLlxuICogYGpzbmV0d29yay5jbHVzdGVyaW5nLmZpbmROb2RlKCdmcmVkJylgIHdpbGwgcmV0dXJuIGBbJ0EnLCdCJywnQycsJ2ZyZWQnXWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBub2RlSWRcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuTmV0d29yay5wcm90b3R5cGUuZmluZE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuZmluZE5vZGUuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmlzQ2x1c3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5pc0NsdXN0ZXIuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLm9wZW5DbHVzdGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLm9wZW5DbHVzdGVyLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5jbHVzdGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmNsdXN0ZXIuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmdldE5vZGVzSW5DbHVzdGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmdldE5vZGVzSW5DbHVzdGVyLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5jbHVzdGVyQnlDb25uZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmNsdXN0ZXJCeUNvbm5lY3Rpb24uYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmNsdXN0ZXJCeUh1YnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuY2x1c3RlckJ5SHVic2l6ZS5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUudXBkYXRlQ2x1c3RlcmVkTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy51cGRhdGVDbHVzdGVyZWROb2RlLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5nZXRDbHVzdGVyZWRFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5nZXRDbHVzdGVyZWRFZGdlcy5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZ2V0QmFzZUVkZ2UgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuZ2V0QmFzZUVkZ2UuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmdldEJhc2VFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5nZXRCYXNlRWRnZXMuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLnVwZGF0ZUVkZ2UgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcudXBkYXRlRWRnZS5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHdpbGwgY2x1c3RlciBhbGwgbm9kZXMgd2l0aCAxIGVkZ2Ugd2l0aCB0aGVpciByZXNwZWN0aXZlIGNvbm5lY3RlZCBub2RlLlxuICogVGhlIG9wdGlvbnMgb2JqZWN0IGlzIGV4cGxhaW5lZCBpbiBmdWxsIDxhIGRhdGEtc2Nyb2xsPVwiXCIgZGF0YS1vcHRpb25zPVwieyAmcXVvdDtlYXNpbmcmcXVvdDs6ICZxdW90O2Vhc2VJbkN1YmljJnF1b3Q7IH1cIiBocmVmPVwiI29wdGlvbnNPYmplY3RcIj5iZWxvdzwvYT4uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuTmV0d29yay5wcm90b3R5cGUuY2x1c3Rlck91dGxpZXJzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmNsdXN0ZXJPdXRsaWVycy5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZ2V0U2VlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGF5b3V0RW5naW5lLmdldFNlZWQuYXBwbHkodGhpcy5sYXlvdXRFbmdpbmUsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZW5hYmxlRWRpdE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5lbmFibGVFZGl0TW9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5kaXNhYmxlRWRpdE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5kaXNhYmxlRWRpdE1vZGUuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuYWRkTm9kZU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5hZGROb2RlTW9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5lZGl0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmVkaXROb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmVkaXROb2RlTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc29sZS53YXJuKFwiRGVwcmVjYXRlZDogUGxlYXNlIHVzZSBlZGl0Tm9kZSBpbnN0ZWFkIG9mIGVkaXROb2RlTW9kZS5cIik7XG4gIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5lZGl0Tm9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5hZGRFZGdlTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmFkZEVkZ2VNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmVkaXRFZGdlTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmVkaXRFZGdlTW9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5kZWxldGVTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmRlbGV0ZVNlbGVjdGVkLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmdldFBvc2l0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLmdldFBvc2l0aW9ucy5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLmdldFBvc2l0aW9uLmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLnN0b3JlUG9zaXRpb25zID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIuc3RvcmVQb3NpdGlvbnMuYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUubW92ZU5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVzSGFuZGxlci5tb3ZlTm9kZS5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLmdldEJvdW5kaW5nQm94LmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmdldENvbm5lY3RlZE5vZGVzID0gZnVuY3Rpb24gKG9iamVjdElkKSB7XG4gIGlmICh0aGlzLmJvZHkubm9kZXNbb2JqZWN0SWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIuZ2V0Q29ubmVjdGVkTm9kZXMuYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuZWRnZXNIYW5kbGVyLmdldENvbm5lY3RlZE5vZGVzLmFwcGx5KHRoaXMuZWRnZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xuICB9XG59O1xuTmV0d29yay5wcm90b3R5cGUuZ2V0Q29ubmVjdGVkRWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVzSGFuZGxlci5nZXRDb25uZWN0ZWRFZGdlcy5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5zdGFydFNpbXVsYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnBoeXNpY3Muc3RhcnRTaW11bGF0aW9uLmFwcGx5KHRoaXMucGh5c2ljcywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5zdG9wU2ltdWxhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGh5c2ljcy5zdG9wU2ltdWxhdGlvbi5hcHBseSh0aGlzLnBoeXNpY3MsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuc3RhYmlsaXplID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5waHlzaWNzLnN0YWJpbGl6ZS5hcHBseSh0aGlzLnBoeXNpY3MsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGlvbi5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuc2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNldFNlbGVjdGlvbi5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZ2V0U2VsZWN0ZWROb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZE5vZGVJZHMuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmdldFNlbGVjdGVkRWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWRFZGdlSWRzLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5nZXROb2RlQXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdC5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgbm9kZS5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5vZGUuaWQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZ2V0RWRnZUF0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZSA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRFZGdlQXQuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xuICBpZiAoZWRnZSAhPT0gdW5kZWZpbmVkICYmIGVkZ2UuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBlZGdlLmlkO1xuICB9XG4gIHJldHVybiBlZGdlO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLnNlbGVjdE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdE5vZGVzLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5zZWxlY3RFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RFZGdlcy5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUudW5zZWxlY3RBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbC5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5jb21taXRXaXRob3V0RW1pdHRpbmcuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyKTtcbiAgdGhpcy5yZWRyYXcoKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlbmRlcmVyLnJlZHJhdy5hcHBseSh0aGlzLnJlbmRlcmVyLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmdldFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy52aWV3LmdldFNjYWxlLmFwcGx5KHRoaXMudmlldywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5nZXRWaWV3UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnZpZXcuZ2V0Vmlld1Bvc2l0aW9uLmFwcGx5KHRoaXMudmlldywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5maXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnZpZXcuZml0LmFwcGx5KHRoaXMudmlldywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnZpZXcubW92ZVRvLmFwcGx5KHRoaXMudmlldywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudmlldy5mb2N1cy5hcHBseSh0aGlzLnZpZXcsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUucmVsZWFzZU5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnZpZXcucmVsZWFzZU5vZGUuYXBwbHkodGhpcy52aWV3LCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmdldE9wdGlvbnNGcm9tQ29uZmlndXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0aW9ucyA9IHt9O1xuICBpZiAodGhpcy5jb25maWd1cmF0b3IpIHtcbiAgICBvcHRpb25zID0gdGhpcy5jb25maWd1cmF0b3IuZ2V0T3B0aW9ucy5hcHBseSh0aGlzLmNvbmZpZ3VyYXRvcik7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG52YXIgcGFyc2VET1ROZXR3b3JrID0gRE9UVG9HcmFwaDtcbi8vIERhdGFTZXQsIHV0aWxzIGV0Yy4gY2FuJ3QgYmUgcmVleHBvcnRlZCBoZXJlIGJlY2F1c2UgdGhhdCB3b3VsZCBjYXVzZSBzdGFja1xuLy8gb3ZlcmZsb3cgaW4gVU1EIGJ1aWxkcy4gVGhleSBhbGwgZXhwb3J0IHZpcyBuYW1lc3BhY2UgdGhlcmVmb3JlIHJlZXhwb3J0aW5nXG4vLyBsZWFkcyB0byBsb2FkaW5nIHZpcyB0byBsb2FkIHZpcyB0byBsb2FkIHZpc+KAplxuXG5leHBvcnQgeyBOZXR3b3JrLCBJbWFnZXMgYXMgTmV0d29ya0ltYWdlcywgZG90cGFyc2VyIGFzIG5ldHdvcmtET1RQYXJzZXIsIGdlcGhpUGFyc2VyIGFzIG5ldHdvcmtHZXBoaVBhcnNlciwgb3B0aW9ucyBhcyBuZXR3b3JrT3B0aW9ucywgcGFyc2VET1ROZXR3b3JrLCBwYXJzZUdlcGhpIGFzIHBhcnNlR2VwaGlOZXR3b3JrIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD12aXMtbmV0d29yay5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/vis-network/peer/esm/vis-network.js\n");

/***/ })

};
;